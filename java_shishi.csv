,Unnamed: 0,sentences1,sentences2,is_similar
0,8927,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
 
 public class Problem1 {
 	public static final boolean FILE = true;
 	
 	public static boolean checkHor(char ch, char [][] arr, int m, int times){
 		int count = 0;
 		for(int i = 0; i < m; i++){
 			count = 0;
 			for(int j = 0; j < m; j++){
 				if(arr[i][j] == ch){
 					count++;
 					if(count >= times) return true;
 				}else count=0;
 			}
 		}
 		return false;
 	}
 	
 	public static boolean checkVer(char ch, char [][] arr, int m, int times){
 		int count = 0;
 		for(int i = 0; i < m; i++){
 			count = 0;
 			for(int j = 0; j < m; j++){
 				if(arr[j][i] == ch){
 					count++;
 					if(count >= times) return true;
 				}else count=0;
 			}
 		}
 		return false;
 	}
 	
 	public static boolean checkDia(char ch, char [][] arr, int m, int times){
 		int count = 0;
 		int i = m-1;
 		int j = 0;
 		while(j < m){
 			int a = i;
 			int b = j;
 			count=0;
 			while(a < m && b < m){
 				if(arr[a][b] == ch){
 					count++;
 					if(count >= times) return true;
 				}else count=0;
 				a++; b++;
 			}
 			
 			if(i > 0) i--;
 			else j++;
 		}
 		i = m-1;
 		j = m-1;
 		count=0;
 		while(j >= 0){
 			int a = i;
 			int b = j;
 			count=0;
 			while(a < m && b >= 0){
 				if(arr[a][b] == ch){
 					count++;
 					if(count >= times) return true;
 				}else count=0;
 				a++; b--;
 			}
 			if(i > 0) i--;
 			else j--;
 		}
 		return false;
 	}
 	
 	public static char[][] rotate90(char [][] input, int n){
 		char [][] tinput = new char[n][n];
 		int col = n-1;
 		for(int i = 0; i < n; i++){
 			for(int j = 0; j < n; j++){
 				tinput[j][col] = input[i][j];
 			}
 			col--;
 		}
 		//System.out.println(Arrays.deepToString(tinput).replaceAll(""\\], \\["", ""\n""));
 		for(int i = 0; i < n; i++){
 			for(int j = n-1; j>=0; j--){
 				if(tinput[j][i] != '.'){
 					int start = j+1;
 					while(start < n && tinput[start][i] == '.') start++;
 					start = start-1;
 					if(start < n && tinput[start][i] == '.'){
 						tinput[start][i] = tinput[j][i];
 						tinput[j][i] = '.';
 					}
 				}
 			}
 		}
 		return tinput;
 	}
 	
 	public static void main(String[] args) throws Exception{
 		BufferedReader reader = null;
 		PrintWriter writer  = null;
 		if(!FILE){
 			reader = new BufferedReader(new InputStreamReader(System.in));
 			writer = new PrintWriter(System.out);
 		}else{
 			reader = new BufferedReader(new FileReader(""A-small-attempt7.in""));
 			writer = new PrintWriter(""A-small-attempt7.in.out"");
 		}
 		int T = Integer.valueOf(reader.readLine());
 		String [] spl;
 		String line;
 		for(int i = 1; i <= T; i++){
 			writer.print(""Case #"" + i + "": "");
 			spl = reader.readLine().split("" "");
 			int m = Integer.parseInt(spl[0]);
 			int n = Integer.parseInt(spl[1]);
 			char [][] arr = new char[m][m];
 			for(int j = 0; j < m; j++){
 				line = reader.readLine();
 				arr[j] = line.toCharArray();
 			}
 			boolean R = false;
 			boolean B = false;
 			//System.out.println(Arrays.deepToString(arr).replaceAll(""\\], \\["", ""\n""));
 			arr = rotate90(arr, m);
 			//System.out.println(Arrays.deepToString(arr).replaceAll(""\\], \\["", ""\n""));
 
 			if(checkHor('R',arr, m, n)){
 				R = true;
 			}
 			if(!R && checkVer('R',arr, m, n)){
 				R = true;
 			}
 			if(!R && checkDia('R',arr, m, n)){
 				R = true;
 			}
 			if(checkHor('B',arr, m, n)){
 				B = true;
 			}
 			if(!B && checkVer('B',arr, m, n)){
 				B = true;
 			}
 			if(!B && checkDia('B',arr, m, n)){
 				B = true;
 			}
 /*				//System.out.println(Arrays.deepToString(arr).replaceAll(""\\], \\["", ""\n""));
 				arr = rotate90(arr, m);
 				//System.out.println(Arrays.deepToString(arr).replaceAll(""\\], \\["", ""\n""));
 				if(!R && checkHor('R',arr, m, n)){
 					R = true;
 				}
 				if(!R && checkVer('R',arr, m, n)){
 					R = true;
 				}
 				if(!R && checkDia('R',arr, m, n)){
 					R = true;
 				}
 				if(!B && checkHor('B',arr, m, n)){
 					B = true;
 				}
 				if(!B && checkVer('B',arr, m, n)){
 					B = true;
 				}
 				if(!B && checkDia('B',arr, m, n)){
 					B = true;
 				}*/
 			String result = ""Neither"";
 			if(R && B) result = ""Both"";
 			else if(R) result = ""Red"";
 			else if(B) result = ""Blue"";
 			writer.println(result);
 			System.out.println(""Case "" + i + "" complete."");
 		}
 		writer.flush();
 		writer.close();		
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 
 class Compare implements Comparator<int []>{
 
 	public int compare(int[] o1, int[] o2) {
 		return o1[0] - o2[0];
 	}
 	
 }
 
 public class Problem1 {
 	public static final boolean FILE = true;
 	
 	public static void main(String[] args) throws Exception{
 		BufferedReader reader = null;
 		PrintWriter writer  = null;
 		if(!FILE){
 			reader = new BufferedReader(new InputStreamReader(System.in));
 			writer = new PrintWriter(System.out);
 		}else{
 			reader = new BufferedReader(new FileReader(""A-large.in""));
 			writer = new PrintWriter(""A-large.in.out"");
 		}
 		int T = Integer.valueOf(reader.readLine());
 		String [] spl;
 		String line;
 		for(int i = 1; i <= T; i++){
 			writer.print(""Case #"" + i + "": "");
 			int wires = Integer.valueOf(reader.readLine());
 			int [][] A = new int[wires][2];
 			List<Integer> B = new ArrayList<Integer>();
 			for(int j = 0; j < wires; j++){
 				spl = reader.readLine().split("" "");
 				A[j][0] = Integer.parseInt(spl[0]);
 				A[j][1] = Integer.parseInt(spl[1]);
 				B.add(A[j][1]);
 			}
 			Arrays.sort(A, new Compare());
 			Collections.sort(B);
 			long ans = 0;
 			for(int j = 0; j < wires; j++){
 				int val = A[j][1];
 				int pos = Collections.binarySearch(B, val);
 				ans += pos;
 				B.remove(pos);
 			}
 			writer.println(ans);
 			System.out.println(""Case "" + i + "" complete."");
 		}
 		writer.flush();
 		writer.close();		
 	}
 }
",1
1,6772,"package Qualification_2013;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 public class Treasure {
 	InputReader in;
 
 	int[] availableKeys;
 	int N;
 	int MAX_KEY = 300;
 
 	int[] openedBy;
 
 	ArrayList<Integer> keyInside[];
 
 	int[] memo;
 	int[] chosen;
 
 	public int go(int mask, int[] curKeys) {
 		if (mask == (1 << N) - 1)
 			return 1;
 		if (memo[mask] != -1)
 			return memo[mask];
 
 		// try to open more chests
 		for (int i = 0; i < N; i++) {
 			if ((mask & (1 << i)) == 0 && curKeys[openedBy[i]] > 0) {
 
 				curKeys[openedBy[i]]--;
 				for(int q : keyInside[i])
 					curKeys[q]++;
 				
 				int x = go(mask | (1 << i), curKeys);
 				
 				curKeys[openedBy[i]]++;
 				for(int q : keyInside[i])
 					curKeys[q]--;
 				
 				if (x == 1) {
 					chosen[mask] = i;
 					return memo[mask] = 1;
 				}
 			}
 		}
 
 		return memo[mask] = 0;
 	}
 
 	public String solve() throws IOException {
 
 		int initialKeys = in.nextInt();
 		N = in.nextInt();
 		availableKeys = new int[MAX_KEY];
 		for (int i = 0; i < initialKeys; i++)
 			availableKeys[in.nextInt()]++;
 		openedBy = new int[N];
 		keyInside = new ArrayList[N];
 		chosen = new int[(1 << N) + 10];
 		for (int i = 0; i < N; i++) {
 			openedBy[i] = in.nextInt();
 			int typesinside = in.nextInt();
 			keyInside[i] = new ArrayList<Integer>();
 			for (int j = 0; j < typesinside; j++)
 				keyInside[i].add(in.nextInt());
 		}
 		
 		memo = new int[(1 << N) + 10];
 		Arrays.fill(memo, -1);
 		boolean answerExist = (go(0, availableKeys) == 1);
 		if (!answerExist)
 			return "" IMPOSSIBLE"";
 		StringBuffer ans = new StringBuffer();
 		int mask = 0;
 		while (mask != (1<<N)-1) {
 			ans.append("" "" + (chosen[mask] + 1));
 			mask |= (1 << chosen[mask]);
 		}
 		return ans.toString();
 	}
 
 	public void answer() throws Exception {
 		in = new InputReader(""in.in"");
 		FileWriter out = new FileWriter(""out.out"");
 		int t = in.nextInt();
 		for (int i = 1; i <= t; i++) {
 			out.write(""Case #"" + i + "":"" + solve() + ""\n"");
 		}
 		out.close();
 	}
 
 	public static void main(String[] args) throws Exception {
 		new Treasure().answer();
 	}
 
 	static class InputReader {
 		BufferedReader in;
 		StringTokenizer st;
 
 		public InputReader(String filename) throws IOException {
 			in = new BufferedReader(new FileReader(filename));
 			st = new StringTokenizer(in.readLine());
 
 		}
 
 		public String next() throws IOException {
 
 			while (!st.hasMoreElements())
 				st = new StringTokenizer(in.readLine());
 			return st.nextToken();
 		}
 
 		public int nextInt() throws NumberFormatException, IOException {
 			return Integer.parseInt(next());
 		}
 
 		public long nextLong() throws NumberFormatException, IOException {
 			return Long.parseLong(next());
 		}
 	}
 }
","import java.util.*;
 
 public class A {
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		int cases = in.nextInt();
 		for(int cc=1;cc<=cases;++cc) {
 			System.out.println(""Case #"" + cc + "": "");
 			int w = in.nextInt(); //width
 			int l = in.nextInt(); //lower points
 			int u = in.nextInt(); //upper points
 			int g = in.nextInt(); //guests
 			Point[] lower = new Point[l];
 			for(int i=0;i<l;++i) {
 				lower[i] = new Point(in.nextInt(), in.nextInt());
 			}
 			Point[] upper = new Point[u];
 			for(int i=0;i<u;++i) {
 				upper[i] = new Point(in.nextInt(), in.nextInt());
 			}
 			
 			
 			double totalArea = 0.0;
 			int curL = 1;
 			int curU = 1;
 			int lastX = 0;
 			double curHeight = 1.0*upper[0].y-lower[0].y;
 			while(curL < l && curU < u) {
 				int lowX = lower[curL].x;
 				int upX = upper[curU].x;
 				int curX = Math.min(lowX, upX);
 				if (curX == lowX && curX == upX) {
 					double thisHeight = upper[curU].y-lower[curL].y;
 					totalArea += (1.0*curHeight + thisHeight) / 2 * (curX-lastX);
 					
 					//System.err.println(""dist: "" + (curX-lastX));
 					//System.err.println(""newHeight: "" + thisHeight);
 					//System.err.println(""oldHeight: "" + curHeight);
 					curHeight = thisHeight;
 					lastX = curX;
 					++curL;
 					++curU;
 				}
 				else if (curX == lowX) {
 					double upHeight = upper[curU-1].y + (upper[curU].y-upper[curU-1].y) * (1.0*(curX-upper[curU-1].x)/(upper[curU].x-upper[curU-1].x));
 					upHeight -= lower[curL].y;
 					totalArea += ((1.0*curHeight)+upHeight)/2 * (curX-lastX);
 					
 					//System.err.println(""dist: "" + (curX-lastX));
 					//System.err.println(""newHeight: "" + upHeight);
 					//System.err.println(""oldHeight: "" + curHeight);
 					curHeight = upHeight;
 					lastX = curX;
 					++curL;
 				}
 				else {
 					double lowHeight = lower[curL-1].y + (lower[curL].y-lower[curL-1].y) * (1.0*(curX-lower[curL-1].x)/(lower[curL].x-lower[curL-1].x));
 					//System.err.println(""prevLowHeight: "" + lowHeight);
 					lowHeight = upper[curU].y-lowHeight;
 					totalArea += ((1.0*curHeight)+lowHeight)/2 * (curX-lastX);
 					
 					//System.err.println(""dist: "" + (curX-lastX));
 					//System.err.println(""newHeight: "" + lowHeight);
 					//System.err.println(""oldHeight: "" + curHeight);
 					curHeight = lowHeight;
 					lastX = curX;
 					++curU;
 				}
 				//System.err.println(totalArea);
 			}
 			//System.err.println(totalArea);
 			ArrayList<Point> upperPoints = new ArrayList<Point>();
 			for(Point p : upper) {
 				upperPoints.add(p);
 			}
 			ArrayList<Point> lowerPoints = new ArrayList<Point>();
 			for(Point p : lower) {
 				lowerPoints.add(p);
 			}
 			double prevX = 0.0;
 			double goal = totalArea/g;
 			double target = 0.0;
 			double ERR = 0.000001;
 			List<Double> answers = new LinkedList<Double>();
 			A: for(int i=0;i<g-1;++i) {
 				target += goal;
 				double minX = prevX;
 				double maxX = 1.0*w;
 				while(minX < maxX) {
 					double curX = (minX+maxX)/2;
 					double area = findArea(curX, prevX, lowerPoints, upperPoints);
 					//System.err.println(curX + "": "" + area);
 					if (Math.abs(area-target) < ERR) {
 						prevX = curX;
 						answers.add(curX);
 						continue A;
 					}
 					else if (area-target < 0) {
 						minX = curX;
 					}
 					else {
 						maxX = curX;
 					}
 					//find area between prevX and curX
 				}
 			}
 			for(Double d : answers) {
 				System.out.printf(""%.6f\n"", d);
 			}
 		}
 	}
 	
 	public static double findArea(double stopX, double prevX, ArrayList<Point> lower, ArrayList<Point> upper) {
 		double curHeight = 1.0*upper.get(0).y-lower.get(0).y;
 		int curU = 1;
 		int curL = 1;
 		int u = upper.size();
 		int l = lower.size();
 		double lastX = 0;
 		double totalArea = 0.0;
 		while(curL < l && curU < u && (lower.get(curL).x < stopX || upper.get(curU).x < stopX)) {
 			Point curUp = upper.get(curU);
 			Point curLow = lower.get(curL);
 			Point prevUp = upper.get(curU-1);
 			Point prevLow = lower.get(curL-1);
 			int lowX = curLow.x;
 			int upX = curUp.x;
 			int curX = Math.min(lowX, upX);
 			if (curX == lowX && curX == upX) {
 				double thisHeight = curUp.y-curLow.y;
 				totalArea += (1.0*curHeight + thisHeight) / 2 * (curX-lastX);
 				
 				////System.err.println(""dist: "" + (curX-lastX));
 				////System.err.println(""newHeight: "" + thisHeight);
 				////System.err.println(""oldHeight: "" + curHeight);
 				curHeight = thisHeight;
 				lastX = curX;
 				++curL;
 				++curU;
 			}
 			else if (curX == lowX) {
 				double upHeight = prevUp.y + (curUp.y-prevUp.y) * (1.0*(curX-prevUp.x)/(curUp.x-prevUp.x));
 				upHeight -= curLow.y;
 				totalArea += ((1.0*curHeight)+upHeight)/2 * (curX-lastX);
 				
 				////System.err.println(""dist: "" + (curX-lastX));
 				////System.err.println(""newHeight: "" + upHeight);
 				////System.err.println(""oldHeight: "" + curHeight);
 				curHeight = upHeight;
 				lastX = curX;
 				++curL;
 			}
 			else {
 				double lowHeight = prevLow.y + (curLow.y-prevLow.y) * (1.0*(curX-prevLow.x)/(curLow.x-prevLow.x));
 				lowHeight = curUp.y-lowHeight;
 				totalArea += ((1.0*curHeight)+lowHeight)/2 * (curX-lastX);
 				
 				////System.err.println(""dist: "" + (curX-lastX));
 				////System.err.println(""newHeight: "" + lowHeight);
 				////System.err.println(""oldHeight: "" + curHeight);
 				curHeight = lowHeight;
 				lastX = curX;
 				++curU;
 			}
 			////System.err.println(totalArea);
 		}
 		////System.err.println(""before last part: "" + totalArea);
 		//find area between last used x value and the end x value
 		double curX = stopX;
 		Point prevU = upper.get(curU-1);
 		Point nextU = upper.get(curU);
 		Point prevL = lower.get(curL-1);
 		Point nextL = lower.get(curL);
 		double upperHeight = prevU.y + (nextU.y-prevU.y) * 1.0*(curX-prevU.x)/(nextU.x-prevU.x);
 		double lowerHeight = prevL.y + (nextL.y-prevL.y) * 1.0*(curX-prevL.x)/(nextL.x-prevL.x);
 		double newHeight = upperHeight-lowerHeight;
 		totalArea += (upperHeight - lowerHeight + curHeight) / 2 * (curX-lastX);
 		////System.err.println(""dist: "" + (curX-lastX));
 		////System.err.println(""newHeight: "" + newHeight);
 		////System.err.println(""oldHeight: "" + curHeight);
 		return totalArea;
 	}
 }
 
 class Point {
 	int x;
 	double y;
 	public Point(int x, int y) {
 		this.x = x;
 		this.y = 1.0*y;
 	}
 
 }",0
2,2130,"package codejam.util;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class Parser {
 
     //Type 0 is simple, one testcase per line
     public static List<String> parseType0(List<String> lines) {
         lines.remove(0); //Remove number of testcases
         return lines;
     }
 
     //Type 1 is where there are several lines per test case ex
     //4
     //3
     //101
     //010
     //111
     //4
     //... ect.
     public static List<List<String>> parseType1(List<String> lines) {
 
         lines.remove(0); //Remove number of testcases
 
         List<List<String>> testCases = new ArrayList<List<String>>();
         int testCaseLines = 0;
         for (int i = 0; i < lines.size(); i += testCaseLines) {
             List<String> testCase = new ArrayList<String>();
             testCaseLines = Integer.parseInt(lines.get(i));
             i++;
             for (int j = 0; j < testCaseLines; j++) {
                 testCase.add(lines.get(i + j));
             }
             testCases.add(testCase);
         }
 
         return testCases;
     }
 
     //Similar to type 1, however
     //we want to save the first line of the test case
     //and only use the first number of the first row to determine
     public static List<List<String>> parseType2(List<String> lines) {
         lines.remove(0); //Remove number of testcases
 
         List<List<String>> testCases = new ArrayList<List<String>>();
         int testCaseLines = 0;
         for (int i = 0; i < lines.size(); i += testCaseLines) {
             List<String> testCase = new ArrayList<String>();
             testCaseLines = Integer.parseInt(lines.get(i).split("" "")[0]);
             testCase.add(lines.get(i));
             i++;
             for (int j = 0; j < testCaseLines; j++) {
                 testCase.add(lines.get(i + j));
             }
             testCases.add(testCase);
         }
 
         return testCases;
     }
 
     //Similar to type 1, however
     //The number of rows is static
     public static List<List<String>> parseType3(List<String> lines, int testCaseLines) {
         lines.remove(0); //Remove number of testcases
 
         List<List<String>> testCases = new ArrayList<List<String>>();
         for (int i = 0; i < lines.size(); i += testCaseLines) {
             List<String> testCase = new ArrayList<String>();
             for (int j = 0; j < testCaseLines; j++) {
                 testCase.add(lines.get(i + j));
             }
             testCases.add(testCase);
         }
 
         return testCases;
     }
 }
","package codejam.bottrust;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class BotTrustSchedule {
 
     public static class BotTrustSchedulePoint {
 
         private String color;
         private int button;
 
         public BotTrustSchedulePoint(String color, int button) {
             this.color = color;
             this.button = button;
         }
 
         public int getButton() {
             return button;
         }
 
         public String getColor() {
             return color;
         }
     }
     private int current = 0;
     private List<BotTrustSchedulePoint> points = new ArrayList<BotTrustSchedulePoint>();
 
     public BotTrustSchedule(String schedule) {
         String[] scheduleArray = schedule.split("" "");
 
         //NOTE: starts at 1, skip first entry
         for (int i = 1; i < scheduleArray.length - 1; i += 2) {
             points.add(new BotTrustSchedulePoint(
                     scheduleArray[i],
                     Integer.parseInt(scheduleArray[i + 1])));
         }
     }
 
     public void executeCurrent() {
         current++;
     }
 
     public BotTrustSchedulePoint current() {
         if(current > points.size() - 1) {
             return null;
         }
         return points.get(current);
     }
 
     public BotTrustSchedulePoint next(String color) {
         for (int i = current; i < points.size(); i++) {
             if (points.get(i).getColor().equals(color)) {
                 return points.get(i);
             }
         }
         return null;
     }
 
     public boolean done() {
         return current == points.size();
     }
 
     public void print() {
         for (BotTrustSchedulePoint point : points) {
             System.out.print(point.getColor() + point.getButton() + "", "");
         }
         System.out.println();
     }
 }
",1
3,14010,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class PROBLEMA {
 	class Point{
 		String value;
 		int pst;
 		
 		public boolean equals(Point point) {
 			// TODO Auto-generated method stub
 			//return super.equals(arg0);
 			if(value.equals(point.value)){
 				if(pst==point.pst){
 					return true;
 				}else{
 					return false;
 				}
 			}else{
 				return false;
 			}
 		}
 	}
 	void solve(Scanner sc, PrintWriter pw) {
 		long ans = 0;
 		String name = sc.next().toLowerCase();
 		int n = sc.nextInt();
 		ArrayList<Point> points=new ArrayList<PROBLEMA.Point>();
 		//System.out.println("" name "" + name + "" n "" + n);
 
 		for (int i = name.length(); i > 0; i--) {
 			for (int j = 0; (j < name.substring(0, i).length()); j++) {
 				if (name.substring(j, i).length() >= n) {
 					String newval=name.substring(j, i);
 					boolean flag=true;
 					Point newpoint=new Point(); 
 					newpoint.value=newval;
 					newpoint.pst=j;
 					for (Point point : points) {
 						if(point.equals(newpoint)){
 							flag=false;
 						}
 					}
 					if(flag){
 						points.add(newpoint);
 					}
 				}
 			}
 		}
 		for (Point point : points) {
 			String substrA = point.value;
 			int slider = 0;
 			for (int k = 0; k < substrA.length(); k++) {
 				if (substrA.charAt(k) != 'a' && substrA.charAt(k) != 'e'
 						&& substrA.charAt(k) != 'i' && substrA.charAt(k) != 'o'
 						&& substrA.charAt(k) != 'u') {
 					slider++;
 				} else {
 					slider = 0;
 				}
 				if (slider == n) {
 					ans++;
 					break;
 				}
 
 			}
 			//System.out.println(""anss ""+point.value);
 		}
 		System.out.println("" ans "" + ans +"" ""+points.size() );
 		pw.println(ans);
 	}
 
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new FileReader(""C:\\CJ13\\Input\\A-small-attempt1.in""));
 		PrintWriter pw = new PrintWriter(new FileWriter(
 				""C:\\CJ13\\Output\\A-small-attempt1.out""));
 		int caseCnt = sc.nextInt();
 		for (int caseNum = 0; caseNum < caseCnt; caseNum++) {
 			System.out.println(""test case number "" + (caseNum + 1));
 			pw.print(""Case #"" + (caseNum + 1) + "": "");
 			new PROBLEMA().solve(sc, pw);
 		}
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Consonants {
 
   public static void main(String[] args) throws IOException {
      BufferedReader br = new BufferedReader(new FileReader(new File(""A-small-attempt0.in"")));
     // BufferedReader br = new BufferedReader(new FileReader(new
     // File(""test.txt"")));
 //    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 
     String line = br.readLine();
     int t = Integer.parseInt(line);
     for (int i = 0; i < t; i++) {
       line = br.readLine();
       String[] arr = line.split("" "");
       int res = 0;
       String name = arr[0];
       int n = Integer.parseInt(arr[1]);
       char[] charArray = name.toCharArray();
 
       List<Integer> regionStartPoints = new ArrayList<>();
       List<Integer> regionEndPoints = new ArrayList<>();
 
       int idx = 0;
       int regionStartIdx = -1;
 
       for (char c : charArray) {
         boolean cons = isConsonant(c);
         if (!cons) {
           if (regionStartIdx != -1) {
             if (idx - regionStartIdx >= n) {
               regionStartPoints.add(regionStartIdx);
               regionEndPoints.add(idx);
             }
             regionStartIdx = -1;
           }
         }
         else {
           if (regionStartIdx == -1) {
             regionStartIdx = idx;
           }
         }
         idx++;
       }
 
       if (regionStartIdx != -1) {
         if (idx - regionStartIdx >= n) {
           regionStartPoints.add(regionStartIdx);
           regionEndPoints.add(idx);
         }
       }
 
 //      System.out.println(regionStartPoints);
 //      System.out.println(regionEndPoints);
 
       for (int j = 0; j < regionStartPoints.size(); j++) {
         Integer end = regionEndPoints.get(j);
         Integer start = regionStartPoints.get(j);
         int regionSize = end-start;
         int biggerThanN = regionSize-n+1;
         int tail = charArray.length-end;
         int subs = tail*biggerThanN + biggerThanN*(biggerThanN+1)/2;
         res+=subs;
           int head = j==0 ? start : (start-(regionEndPoints.get(j-1)-(n-1)));
           int subs2 = head*(tail+(biggerThanN));
           res+=subs2;
       }
 
       System.out.println(""Case #"" + (i + 1) + "": "" + res);
     }
 
   }
 
   private static boolean isConsonant(char c) {
     return c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u';
   }
 
 }
",0
4,6592,"import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.text.DecimalFormat;
 import java.util.Locale;
 import java.util.StringTokenizer;
 
 
 public class ProblemD {
 
 	public static void main(String[] args) throws IOException {
 		Locale.setDefault(Locale.ENGLISH);
 		DecimalFormat df = new DecimalFormat(""0.000000"");
 		BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
 		PrintWriter out = new PrintWriter(new BufferedOutputStream(
 	            System.out));
 		
 		int T = Integer.valueOf(stdin.readLine());
 		
 		for (int i = 0; i < T; i++) {
 			int N = Integer.valueOf(stdin.readLine());
 			int[] p = new int[N + 1];
 			StringTokenizer st = new StringTokenizer(stdin.readLine());
 			for (int j = 1; j <= N; j++) {
 				p[j] = Integer.valueOf(st.nextToken());
 			}
 			boolean[] used = new boolean[N+1];
 			int r = 0;
 			for (int j = 1; j <= N; j++) {
 				int x = j;
 				int c = 0;
 				while (!used[x]) {
 					c++;
 					used[x] = true;
 					x = p[x];
 				}
 				if (c > 1) {
 					r += c;
 				}
 			}
 			out.println(""Case #"" + (i + 1) + "": "" + df.format(r));
 		}
 		out.flush();
 		out.close();
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class Launcher {
 	static int t, n, tcount;
 	static int[] oarray = new int[101];
 	static int[] barray = new int[101];
 	static int opos, bpos;
 	static int onext, bnext;
 	static long count=0;
 	static int odiff, bdiff, odiffp, bdiffp;
 	static int oseq, bseq;
 	static boolean ofinished, bfinished;
 	
 	
 	public static void main(String[] args){
 		String c;
 		int i,j;
 
 		
 		
 		try {
 			FileInputStream fin = new FileInputStream (""c:\\siva\\A-large.in"");
 			System.out.println(""Input file stream created"");
 			Scanner sc = new Scanner(fin);
 			System.out.println(""Scanner created"");
 			
 			FileOutputStream fout = new FileOutputStream (""c:\\siva\\output2.txt"");
 			DataOutputStream dout = new DataOutputStream (fout);
 			
 			t=sc.nextInt();
 			tcount=0;
 			
 			
 			while (tcount<t){
 				tcount++;
 				n=sc.nextInt();
 				j=n;
 				i=0;
 				while (j>0){
 					ofinished=false;
 					bfinished=false;
 					j--;
 					c=sc.next();
 	//				System.out.println(c);
 					if (c.equals(""O"")){
 						oarray[i] = sc.nextInt();
 	//					System.out.println(oarray[i]);
 						barray[i] = 0;
 						i++;
 					}
 					else {
 						oarray[i] = 0;
 						barray[i] = sc.nextInt();
 	//					System.out.println(barray[i]);
 						i++;					
 					}
 				} //while buttons exist
 				
 //				for (int x:oarray)
 //					System.out.println(x);
 //				
 //				for (int x:barray)
 //					System.out.println(x);
 				
 				opos = 1;
 				bpos = 1;
 				count = 0;
 				
 				//find next o and b : first time
 				i=0;
 				while (oarray[i] == 0 && i<100){
 					i++;
 				}
 				if (i==100)
 					ofinished=true;
 				onext = oarray[i];
 				oseq = i;
 				
 				i=0;
 				while (barray[i] == 0 && i<100){
 					i++;
 				}
 				if (i==100)
 					ofinished=true;
 				bnext = barray[i];
 				bseq = i;
 				
 				System.out.println(""First positions O and B: "" + opos + "" "" + bpos);
 				System.out.println(""First targets O and B: "" + onext + "" "" + bnext);
 				
 				j=n; //no of positions
 				i=0;
 				while (j>0){
 					j--;
 					odiff = onext - opos;
 					bdiff = bnext - bpos;
 					
 					//convert to positive
 					if (odiff>=0)
 						odiffp=odiff;
 					else
 						odiffp=-(odiff);
 					
 					if (bdiff>=0)
 						bdiffp=bdiff;
 					else
 						bdiffp=-(bdiff);
 					
 					if (oseq<bseq && ofinished!=true){
 						count=count+odiffp+1;	
 						System.out.println(""In o. Count is: "" + count);
 						opos = onext;
 						if (bpos != bnext){
 							if (bdiffp <= (odiffp+1)){
 								bpos = bnext;
 							} else {
 								if (bdiff>=0)
 									bpos = bpos + odiffp + 1;
 								else
 									bpos = bpos - odiffp - 1;
 								
 							}
 						}
 						// o target acheived, find next o target
 						i=oseq+1; //start finding from next target + boundary condition
 						
 						while (oarray[i] == 0 && i<100){
 							i++;
 						}
 						if (i==100)
 							ofinished=true;
 						onext = oarray[i];
 						oseq = i;
 						
 					}
 					else if (bfinished!=true){   //oseq > bseq
 						count=count+bdiffp+1;	
 						System.out.println(""In b. Count is: "" + count);
 						bpos = bnext;
 						if (opos != onext){
 							if (odiffp <= (bdiffp+1)){
 								opos = onext;
 							} else {
 								if (odiff>=0)
 									opos = opos + bdiffp + 1;
 								else
 									opos = opos - bdiffp - 1;
 								
 							}
 						}
 						// b target acheived, find next b target
 						i=bseq+1;
 						while (barray[i] == 0 && i<100) {
 							i++;
 						}
 						if (i==100)
 							bfinished=true;
 						bnext = barray[i];
 						bseq = i;
 						
 					}
 					
 					System.out.println(""Positions O and B: "" + opos + "" "" + bpos);
 					System.out.println(""Targets O and B: "" + onext + "" "" + bnext);
 					
 				}
 				
 			
 			//Write output file
 			dout.writeBytes(""Case #"");
 			dout.writeBytes(Integer.toString(tcount));
 			dout.writeBytes("": "");
 			dout.writeBytes(Long.toString(count));
 			fout.write(13);
 			fout.write(10);
 
 			} //while test cases end
 			
 		
 			
 		} catch (Exception e){
 			System.out.println(e);
 		}
 	}//main
 	
 	
 } //class
",0
5,1788,"package onlineQualification;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 
 public class QualificationC {
 
 	
 
 	public static String getLine(int nbTours, int nbPlaces, String[] groupesTab, int nbGroups){
 		
 		int resulInt = 0;
 		ArrayList groups = new ArrayList();
 		for(int i = 0; i < groupesTab.length; i++){
 			groups.add(groupesTab[i]);
 		}
 
 		int indexGroup = 0;
 		int[] solutions = new int[nbGroups];
 		int[] indexGroupEnd = new int[nbGroups];
 		for(int i = 0; i < nbTours; i++){
 			boolean full = false;
 			int nbPersonnes = 0;
 			int nbGroupesInside = 0;
 			int indexGroupStart = indexGroup;
 			
 
 			if(solutions[indexGroupStart]!=0){
 				full = true;
 				resulInt+=solutions[indexGroupStart];
 				indexGroup = indexGroupEnd[indexGroupStart];
 			}
 			
 			while(!full){
 				int nextGroupe = Integer.parseInt(groups.get(indexGroup).toString());
 				if(nextGroupe + nbPersonnes <= nbPlaces && nbGroupesInside < nbGroups){
 					nbPersonnes+=nextGroupe;
 					nbGroupesInside++;
 					indexGroup = (indexGroup + 1) % nbGroups;
 				}
 				else{
 					full=true;
 					resulInt+=nbPersonnes;
 					solutions[indexGroupStart]=nbPersonnes;
 					indexGroupEnd[indexGroupStart]= indexGroup;
 				}
 			}
 			
 		}
 		
 		
 		return """" + resulInt;
 	}
 	
 	
 	
 	
 	public static void main(String[] args) throws IOException {
 		String fileName = ""C-large"";
 		
 		String inputFile=""D:\\googleCodeJam\\onlineQualification\\""+ fileName +"".in"";
 		File f = new File(inputFile);
 		FileReader fr = new FileReader(f);
 		BufferedReader br = new BufferedReader(fr);		
 		String outputFile=""D:\\googleCodeJam\\onlineQualification\\""+ fileName +"".out"";
 		FileWriter fw = new FileWriter(outputFile);
 		
 		
 		String line1 = br.readLine();
 		
 		//Extraction of number of cases
 		int nbCases = Integer.parseInt(line1);
 		
 		for(int i=1; i<=nbCases; i++){
 			System.out.println(""ligne "" + i + ""sur "" + nbCases);
 			String variables = br.readLine();
 			String[] variablesTab = variables.split("" "");
 			int nbTours = Integer.parseInt(variablesTab[0]);
 			int nbPlaces = Integer.parseInt(variablesTab[1]);
 			int nbGroups = Integer.parseInt(variablesTab[2]);
 			String groupes = br.readLine();
 			String[] groupesTab = groupes.split("" "");
 			
 			String lineResult = getLine(nbTours, nbPlaces, groupesTab, nbGroups);
 			Outils.writeLine(lineResult, i, fw);
 		}
 		fw.close();
 	}
 }
","import java.util.*;
 import java.io.*;
 
 public class one{
 	public static final String fileName = ""A-small-attempt0.in"";
 	public static PrintStream output; 
 	public static void main(String[] args) throws FileNotFoundException{
 		output = new PrintStream(new File(""OUTPUT_""+fileName));
 		Scanner input = new Scanner(new File(fileName));
 		
 		int T = Integer.parseInt(input.nextLine());
 		
 		for(int i=1; i<=T; i++){
 			output.print(""Case #""+i+"": "");
 			explore(input);
 			output.println();
 		}
 	}
 	
 	public static void explore(Scanner in){
 		Scanner o = new Scanner(in.nextLine());
 		int n = o.nextInt();
 		int m = o.nextInt();
 		//System.out.println(n+"" ""+m);
 		Tree root = new Tree(""root"");
 		for(int i=1; i<=n; i++){
 			String l = in.nextLine();
 			add(l, root);
 		}
 		int c = 0;
 		//output.println(""--------------"");
 		for(int i=1; i<=m; i++){
 			String l = in.nextLine();
 			c += add(l, root);
 		}
 		output.print(c);
 	}
 	
 	public static int add(String s, Tree r){
 		int count = 0;
 		String[] parts = s.split(""[/]"");
 		Tree place = r;
 		for(int i=0; i<parts.length; i++){
 			String cur = parts[i];
 			if(!cur.equals("""")){
 				if( !place.sub.contains(new Tree(cur)) ){
 					place.sub.add(new Tree(cur));
 					count++;
 					//System.out.println(""added ""+cur+"" ""+count);
 				}
 				for(Tree x : place.sub){
 					if(x.name.equals(cur)){
 						place = x;
 					}
 				}
 			}
 		}
 		return count;
 	}
 }
",0
6,721,"import java.io.*;
 import java.util.*;
 
 public class Main {
 	
 	Scanner in;
 	PrintWriter out;
 	
 	static final String problem = ""A-small"";
 	
 	static void asserT(boolean e) {
 		if (!e) {
 			throw new Error();
 		}
 	}
 	
 	class Cmd {
 		char executor;
 		int pos;
 		
 		Cmd(Scanner in) {
 			String s = in.next();
 			asserT(s.equals(""O"") || s.equals(""B""));
 			executor = s.charAt(0);
 			pos = in.nextInt();
 		}
 	}
 	
 	void solveOne() {
 		Cmd []cmd = new Cmd[in.nextInt()];
 		for (int i = 0; i < cmd.length; i++) {
 			cmd[i] = new Cmd(in);
 		}
 		int timeO = 0;
 		int posO = 1;
 		
 		int timeB = 0;
 		int posB = 1;
 		
 		int timeAll = 0;
 		for (int i = 0; i < cmd.length; i++) {
 			if (cmd[i].executor == 'O') {
 				int dist = Math.abs(cmd[i].pos - posO) + 1;
 				timeO += dist;
 				posO = cmd[i].pos;
 				if (timeAll >= timeO) {
 					timeAll++;
 					timeO = timeAll;
 				} else {
 					timeAll = timeO;
 				}
 			} else {
 				int dist = Math.abs(cmd[i].pos - posB) + 1;
 				timeB += dist;
 				posB = cmd[i].pos;
 				if (timeAll >= timeB) {
 					timeAll++;
 					timeB = timeAll;
 				} else {
 					timeAll = timeB;
 				}
 			}
 		}
 		out.println(timeAll);
 	}
 	
 	void solve() {
 		int nTests = in.nextInt();
 		for (int i = 0; i < nTests; i++) {
 			out.print(""Case #""+(i+1)+"": "");
 			solveOne();
 		}
 	}
 	
 	void run() {
 		try {
 			in = new Scanner(new FileReader(""C:\\"" + problem + "".in""));
 			out = new PrintWriter(new FileWriter(""C:\\"" + problem + "".out""));
 		} catch (IOException e) {
 			in = new Scanner(System.in);
 			out = new PrintWriter(System.out);
 		}
 		
 		try {
 			solve();
 		} finally {
 			out.close();
 		}
 	}
 
 	public static void main(String[] args) {
 		new Main().run();
 	}
 }","import java.io.*;
 import java.util.*;
 import java.math.*;
 
 public class Main extends Thread {
 	
 	Scanner in;
 	PrintWriter out;
 	
 	
 	int ans[] = new int[26];
 
 	int ar[] = new int[26];
 	boolean contains[] = new boolean[26];
 	int rank[] = new int[26];
 	
 	int cnt;
 	
 	boolean can(int val, int pos){
 		if (pos == 1) {
 			return true;
 		}
 		return contains[pos] && can(pos, rank[pos]);
 	}
 	
 	void gen(int i, int pos){
 		if (i == 26){
 			return;
 		}
 		//take
 		ar[pos] = i;
 		contains[i] = true;
 		rank[i] = pos;
 		if (can(i, pos)) {
 			ans[i] ++;
 		}
 			/*
 				for (int j = 1; j <= pos; j++){
 					out.print(ar[j] + "" "");
 				}
 				out.println();			
 			*/
 			gen(i + 1, pos + 1);
 		//}
 		
 		// not take
 		contains[i] = false;
 		rank[i] = 0;
 		gen(i + 1, pos);
 	}
 		
 	void solveOne(){
 		out.println(ans[in.nextInt()] % 100003);
 	}
 			
 	void solve(){
 		gen(2, 1);
 		/*for (int i = 2; i < 26; i++){
 			out.println(ans[i]);
 		}
 		*/
 		int t = in.nextInt();
 		for (int i = 1; i <= t; i++) {
 			out.print(""Case #""+i + "": "");
 			solveOne();
 		}
 	}
 	
 	public void run(){
 		
 		try {
 			in = new Scanner(new FileReader(""C:\\C.in""));
 			out = new PrintWriter(new FileWriter(""C:\\output.txt""));
 		} catch (IOException e)  {			
 			in = new Scanner(System.in);
 			out = new PrintWriter(System.out);
 		}
 		
 		try {
 			solve();
 		} finally {
 			out.close();
 		}
 	}
 	
 	void asserT(boolean e){
 		if (!e){
 			throw new Error();
 		}
 	}
 
 	public static void main(String[] args) {
 		new Thread(null, new Main(), ""M"", 164000000).run();
 	}
 }",1
7,3378,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package Round1C2011;
 
 import java.io.File;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  *
  * @author Thomas
  */
 public class ProblemC {
 	public static void main(String[] args) throws Exception {
 		Scanner in =
 //			new Scanner(System.in);
 			new Scanner(new File(""Round1C2011/C-small.in""));
 //			new Scanner(new File(""Round1C2011/C-large.in""));
 		PrintStream out =
 //			System.out;
 			new PrintStream(new File(""Round1C2011/C-small.out""));
 //			new PrintStream(new File(""Round1C2011/C-large.out""));
 
 		int T = in.nextInt();
 		for (int x = 1; x <= T; x++) {
 			int N = in.nextInt();
 			long L = in.nextLong();
 			long H = in.nextLong();
 			long[] fq = new long[N];
 			for (int i = 0; i < N; i++) {
 				fq[i] = in.nextLong();
 			}
 			String result = solve(L, H, fq);
 			out.println(""Case #"" + x + "": "" + result);
 		}
 		in.close();
 		out.close();
 	}
 
 	public static String solve(long L, long H, long[] fq) {
 		/*long gcf = fq[0];
 		for (int i = 1; i < fq.length; i++) {
 		gcf = gcf(gcf, fq[i]);
 		}
 		System.out.println(""GCF: "" + gcf);
 		if (gcf > H)
 		return ""NO"";
 		if (gcf >= L)
 		return gcf + """";
 		for (long i = L; i <= H; i++) {
 		if (gcf % i == 0) {
 		return i + """";
 		}
 		}*/
 		/*Arrays.sort(fq);
 		ArrayList<Long> fqs = new ArrayList<Long>();
 		ArrayList<Long> high = new ArrayList<Long>();
 		for (int i = 0; i < fq.length; i++) {
 		if (fq[i] > H) {
 		high.add(fq[i]);
 		continue;
 		}
 		boolean add = true;
 		for (int j = 0; j < fqs.size(); j++) {
 		if (fq[i] % fqs.get(j) == 0)
 		}
 		}*/
 		for (long i = L; i <= H; i++) {
 			boolean good = true;
 			for (int j = 0; j < fq.length; j++) {
 				if ((fq[j] > i && fq[j] % i != 0) || (fq[j] <= i & i % fq[j] != 0)) {
 					good = false;
 					break;
 				}
 			}
 			if (good) {
 				return i + """";
 			}
 		}
 		return ""NO"";
 	}
 
 	public static long gcf(long a, long b) {
 		if (b == 0) {
 			return a;
 		}
 		do {
 			long c = a % b;
 			a = b;
 			b = c;
 		} while (b != 0);
 		return a;
 	}
 
 }
","import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class ProblemB {
 	public static void main(String[] args) throws Exception {
 		System.setIn(new FileInputStream(""B-small-attempt0.in""));
 		System.setOut(new PrintStream(new FileOutputStream(""B-small-attempt0.out"")));
 		
 		Scanner in = new Scanner(System.in);
 		
 		int T = in.nextInt();
 		
 		for (int caseNum = 1; caseNum <= T; caseNum++) {
 			double C = in.nextDouble();
 			double F = in.nextDouble();
 			double X = in.nextDouble();
 			
 			double rate = 2.0;
 			
 			double t = 0;
 			while (true) {
 				double xt = X / rate;
 				double buyt = (C / rate);
 				double ft = (C / rate) + (X / (rate + F));
 				if (xt < ft) {
 					t += xt;
 					break;
 				} else {
 					t += (C / rate);
 					rate += F;
 				}
 			}
 			System.out.printf(""Case #%d: %.08f%n"", caseNum, t);
 		}
 	}
 }
",1
8,1083,"
 
 import java.util.*;
 import java.io.*;
 
 public class Park {
 
     public static String filename = ""C-small"";
 
     public static void main(String[] args) {
 
 
     	try {
 	    	Scanner filein = new Scanner(new File(filename+"".in""));
 	    	PrintWriter fileout = new PrintWriter(new FileWriter(filename+"".out""));
 	    	int totalCase = filein.nextInt();
 	    	filein.nextLine();
 	    	for(int item=1; item<=totalCase; item++) {
 
 
 				fileout.print(""Case #"" + (item) + "": "");
 
 				String str = filein.nextLine();
 				Long value[] = new Long[3];
 				String[] tokens = str.split(""\\s"");
 				int i=0;
 				for(String token : tokens)
 				{
 
 					value[i]= Long.parseLong(token);
 					i++;
 				}
 				long r = value[0];
 				long k= value[1];
 				int n = value[2].intValue();
 				Long gi[] = new Long[n];
 
 				 str = filein.nextLine();
 				 tokens = str.split(""\\s"");
 				 i=0;
 				 for(String token : tokens)
 				 {
 
 				 	gi[i]= Long.parseLong(token);
 
 				 	i++;
 				}
 				int gQueue =0;
 				long cash =0;
 				for(int round =0; round < r; round++)
 				{
 					long newRound=0;
 					int groupCount=0;
 
 					while(true)
 					{
 
 						if(newRound < k)
 						{
 							newRound=newRound+(gi[gQueue%n]);
 							groupCount++;
 							if(groupCount > n)
 							{
 								newRound=newRound-(gi[gQueue%n]);
 							//	System.out.println(newRound);
 								break;
 							}
 
 
 							if(newRound > k)
 							{
 								newRound=newRound-(gi[gQueue%n]);
 							//	System.out.println(newRound);
 								break;
 							}
 							gQueue ++;
 
 						}
 						else
 						break;
 
 					}
 					cash=cash+newRound;
 				}
 				fileout.println(cash);
 
 
 
 	    	}
 
 	    	filein.close();
 	    	fileout.close();
        	}
        	catch(IOException e) {
        		System.out.println(""Error loading input or output file"");
        	}
     }
 }
","package com.google.codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 
 public class MagicTrick {
 
 	public static ArrayList<String> readFromFile() 
 	{
 		ArrayList<String> inputList = new ArrayList<String>();
 		try
 		{
 			FileReader fr = new FileReader(""C:\\Users\\Home\\Downloads\\code\\A-small-attempt0.in"");
 			BufferedReader br = new BufferedReader(fr);
 			String readLine = null;
 			while((readLine=br.readLine())!=null)
 			{
 				inputList.add(readLine);
 			}
 		}
 		catch (IOException e) {
 			inputList = null;
 			e.printStackTrace();
 		}
 		return inputList;
 	}
 	
 	public static void writeToFile(ArrayList<String> outputList)
 	{
 		try
 		{
 			FileWriter fw = new FileWriter(""C:\\Users\\Home\\Downloads\\code\\A-small-attempt0.out"");
 			BufferedWriter br = new BufferedWriter(fw);
 			for(int i = 0; i < outputList.size(); i++)
 			{
 				br.write(""Case #"" + (i+1) + "": "" + outputList.get(i));
 				br.newLine();
 			}
 			br.close();
 		}
 		catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		ArrayList<String> inputList = readFromFile(); 
 		
 		String inputStr = null;
 		String finalString = null;
 		ArrayList<String> outputList = new ArrayList<String>();
 		
 		int firstAnswer, secondAnswer;
 		String[] arrange1, arrange2;
 		
 		int noOfTestCases = Integer.parseInt(inputList.get(0).toString());
 		for(int i = 1, x = 1; i < noOfTestCases + 1; i++)
 		{
 			firstAnswer = Integer.parseInt(inputList.get(x++).toString());			
 			inputStr = inputList.get(x + firstAnswer - 1);
 			arrange1 = inputStr.split("" "");
 			x += 4;
 			secondAnswer = Integer.parseInt(inputList.get(x++).toString());
 			inputStr = inputList.get(x + secondAnswer - 1);			
 			arrange2 = inputStr.split("" "");
 			x += 4;			
 			int answerNumber = 0;
 			int count = 0;
 			for(int j = 0; j < 4; j++)
 			{
 				for(int k = 0; k < 4; k++)
 				{
 					if (arrange1[j].equals(arrange2[k]))
 					{
 						count++;
 						answerNumber = Integer.parseInt(arrange1[j]);
 					}
 				}
 			}
 			if (count == 1)
 				finalString = """" + answerNumber;
 			else if (count > 1)
 				finalString = ""Bad magician!"";
 			else if (count == 0)
 				finalString = ""Volunteer cheated!"";
 			outputList.add(finalString.trim());
 		}
 		
 		writeToFile(outputList);
 		
 	}
 
 }
",0
9,6771,"/**
  * 
  */
 package com.gkishor.jam.snapper;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 
 
 /**
  * @author Kishor_Gandham
  *
  */
 public class SnapperMain {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args)  throws Exception{
 		File f = new File(""d:\\small.in"");
 		BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
 		String strLine;
 		int i = 0;
 		int t;
 		String tokens[];
 		OptimizedSnapperProcessor proc;
 		while((strLine = bReader.readLine()) != null) {
 			if(i == 0)
 				t = Integer.parseInt(strLine);
 			else {
 				tokens = strLine.split("" "");
 				proc = new OptimizedSnapperProcessor(Integer.parseInt(tokens[0]));
 				System.out.println(""Case #"" + i + "": "" + proc.snap(Long.parseLong(tokens[1])));
 			}
 			i++;
 		}
 	}
 
 }
","package de.johanneslauber.codejam;
 
 import java.io.IOException;
 
 /**
  * 
  * @author Johannes Lauber - joh.lauber@googlemail.com
  * 
  */
 public class Main {
 
 	/**
 	 * @author Johannes Lauber - joh.lauber@googlemail.com
 	 * @param Args
 	 */
 	public static void main(String[] Args) {
 		long millis = System.currentTimeMillis();
 
 		// solveProblem(""input/A-small-practice.in"", ""StoreCredit"");
 		// solveProblem(""input/A-large-practice.in"", ""StoreCredit"");
 		// solveProblem(""input/B-small-practice.in"", ""ReverseWords"");
 		// solveProblem(""input/B-large-practice.in"", ""ReverseWords"");
 		// solveProblem(""input/C-small-practice.in"", ""T9Spelling"");
 		// solveProblem(""input/C-large-practice.in"", ""T9Spelling"");
 		// solveProblem(""input/A-small-practice.in"", ""SpeakinginTongues"");
 		// solveProblem(""input/B-large.in"", ""DancingGooglers"");
 		solveProblem(""input/A-small-attempt0.in"", ""tictactoe.TicTacToe"");
 
 		System.out.println(System.currentTimeMillis() - millis);
 	}
 
 	/**
 	 * 
 	 * @author Johannes Lauber - joh.lauber@googlemail.com
 	 * @param fileName
 	 * @param problemName
 	 */
 	private static void solveProblem(String fileName, String problemName) {
 		CaseProvider caseProvider = new CaseProvider();
 		try {
 			try {
 				caseProvider.importFile(
 						fileName,
 						Class.forName(""de.johanneslauber.codejam.model.impl.""
 								+ problemName + ""Case""));
 
 				caseProvider.solveCases(Class
 						.forName(""de.johanneslauber.codejam.model.impl.""
 								+ problemName + ""Problem""));
 			} catch (ClassNotFoundException e) {
 				System.out.println(""Error finding implemented Case: ""
 						+ e.getMessage());
 			} catch (InstantiationException e) {
 				e.printStackTrace();
 			} catch (IllegalAccessException e) {
 				e.printStackTrace();
 			}
 		} catch (IOException e) {
 			System.out.println(""Error reading file: "" + e.getMessage());
 		}
 	}
 }",0
10,1779,"import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.Scanner;
 
 public class A {
 	static FileWriter out;
 	public static void main(String[] args) throws IOException {
 		Scanner sc=new Scanner(System.in);
 		out=new FileWriter(""out.txt"");
 		int T=sc.nextInt();
 		for(int t=1;t<=T;t++){
 			int a=sc.nextInt(),b=sc.nextInt();
 			double enter=b+2.0,kaku=1.0,ans=Double.MAX_VALUE;
 			for(int i=1;i<=a;i++){
 				kaku*=sc.nextDouble();
 				double tmp=kaku*((b-a+1)+(a-i)*2)+(1.0-kaku)*(((b-a+1)+(a-i)*2)+b+1);
 				ans=Math.min(ans, tmp);
 			}
 			DecimalFormat df=new DecimalFormat();
 			df.setMaximumFractionDigits(6);
 	        df.setMinimumFractionDigits(6);
 			output(""Case #""+t+"": ""+df.format(Math.min(ans, enter)));
 		}
 		out.close();
 	}
 	
 	static void output(String str) throws IOException{
 		out.write(str+""\n"");
 		System.out.println(str);
 	}
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 
 public class Dancing {
 	private static Map<String, String> knowledgeBase = new HashMap<String, String>();
 	
 	static
 	{
 		knowledgeBase.put(""our language is impossible to understand"", ""ejp mysljylc kd kxveddknmc re jsicpdrysi"");
 		knowledgeBase.put(""there are twenty six factorial possibilities"", ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"");
 		knowledgeBase.put(""so it is okay if you want to just give up"", ""de kr kd eoya kw aej tysr re ujdr lkgc jv"");
 		knowledgeBase.put(""aozq"", ""yeqz"");
 	}
 
 
     private BufferedReader reader;
     private BufferedWriter writer;
     
     /**
      * @param args
      */
     public static void main(String[] args)
     {
         Dancing dancing = new Dancing(args[0]);
         dancing.executeTests();
     }
     
 
     public Dancing(String filename)
     {
         // Open file
         File file = new File(filename);
         try
         {
             reader = new BufferedReader(new FileReader(file));
             writer = new BufferedWriter(new FileWriter(file+"".out""));
         }
         catch (IOException e)
         {
             // Failed to open new buffered reader
             System.err.println(""Failed to open FileReader"");
             e.printStackTrace();
             System.exit(-1);
         }
     }
     
     private void executeTests()
     {
         // Read number of test cases
         int numberOfTests = 0; 
         
         try
         {
             // Read number of tests (first line)
             numberOfTests = Integer.parseInt(reader.readLine());
         }
         catch (NumberFormatException | IOException e)
         {
             // Failed to read a line
             System.err.println(""Failed to read a line"");
             e.printStackTrace();
             System.exit(-1);
         }
 
         for (int testCase = 1; testCase <= numberOfTests; testCase++)
         {
             String[] input;
             
             try
             {
                 input = reader.readLine().split(""\\s"");
                 
                 int contestants = Integer.parseInt(input[0]);
                 int surprises = Integer.parseInt(input[1]);
                 int threshhold = Integer.parseInt(input[2]);
                 
                 List<Integer> scores = new ArrayList<Integer>();
                 
                 for (int i = 3; i < 3 + contestants; i++)
                 {
                 	scores.add(Integer.parseInt(input[i]));
                 }
                 
                 int answer = findWinners(surprises, threshhold, scores);
                 
                 writer.write(""Case #"" + testCase + "": "" + answer + '\n');
             }
             catch (IOException e)
             {
                 e.printStackTrace();
             }
         }
         
         try
         {
             reader.close();
             writer.flush();
             writer.close();
         }
         catch (IOException e)
         {
             e.printStackTrace();
         }
     }
 
 
 	private static int findWinners(int surprises, int threshhold, List<Integer> scores)
 	{
 		int totalPossible = 0;
 		int surprisesRemaining = surprises;
 		
 		for (Integer score : scores)
 		{
 			Map<String, Integer> maxScores = getMaxScores(score);
 			
 			if (maxScores.get(""normal"") >= threshhold)
 			{
 				totalPossible++;
 			}
 			else if (maxScores.get(""surprise"") >= threshhold && surprisesRemaining > 0)
 			{
 				totalPossible++;
 				surprisesRemaining--;
 			}
 		}
 	
 		return totalPossible;
 	}
 	
 	private static Map<String, Integer> getMaxScores(int totalScore)
 	{
 		int maxNormalScore = ((totalScore - 1) / 3) + 1;
 		int maxSurpriseScore = maxNormalScore;
 		
 		if (totalScore % 3 != 1)
 		{
 			maxSurpriseScore++;
 		}
 		
 		Map<String, Integer> maxScores = new HashMap<String, Integer>();
 		maxScores.put(""normal"", maxNormalScore);
 		maxScores.put(""surprise"", maxSurpriseScore);
 		
 		// Special case to continue using integer division
 		if (totalScore == 0)
 		{
 			maxScores.put(""normal"", 0);
 			maxScores.put(""surprise"", 0);
 		}
 		
 		return maxScores;
 	}
 }
",0
11,404,"package ru.guredd.codejam.y2014;
 
 import ru.guredd.codejam.Main;
 
 import java.util.StringTokenizer;
 
 /**
  * Created by guredd on 12.04.2014.
  */
 public class Qualification2014B {
 
     double C;
     double F;
     double X;
 
     public void solve() {
         int count = Integer.valueOf(Main.inputData.get(0));
         for (int i = 0; i < count; i++) {
             String data = Main.inputData.get(i + 1);
 
             StringTokenizer st = new StringTokenizer(data, "" "");
             C = Double.parseDouble(st.nextToken());
             F = Double.parseDouble(st.nextToken());
             X = Double.parseDouble(st.nextToken());
 
             double T;
             if(X < C) {
                 T = X/2;
             } else {
                 T = C/2 + getNextTime(2, (X - C) / 2);
             }
 
             Main.outputData.add(""Case #"" + (i + 1) + "": "" + T);
         }
     }
 
     private double getNextTime(double V, double T) {
         double T1 = X / (V + F);
         return T < T1 ? T : C/(V+F) + getNextTime(V + F, (X - C) / (V + F));
     }
 }
","import java.io.*;
 import java.util.*;
 
 public class C
 {
 	private static boolean isPerfectSquare(long i) {
 		long tst = (long)(Math.sqrt(i) + 0.5);
 		return tst*tst == i;
 	}
 	
 	private static boolean isPalindrome(long n) {
 		String s = """"+n;
 		int len = s.length();
 		for(int i = 0; i<len/2; i++) {
 			if(s.charAt(i) != s.charAt(len-1-i)) {
 				return false;
 			}
 		}
 		return true;
 	}
 	private static int[] solutions = new int[10000000];
 	
 	private static void solve(int casenum, long from, long to) {
 		long numsfound = 0;
 		/*
 		for(long i = from; i <= to; i++) {
 			if(isPalindrome(i) && isPerfectSquare(i) && isPalindrome((long)(Math.sqrt(i)+0.5))) {
 				numsfound++;
 			}
 		}
 		*/
 		for(long i = (long)Math.ceil(Math.sqrt(from)); i <= Math.floor(Math.sqrt(to)); i++) {
 			if (solutions[i] == -1) {
 				if(isPalindrome(i) && isPalindrome(i*i)) {
 					solutions[i]=1;
 				} else {
 					solutions[i]=0;
 				}
 			}
 			numsfound+=solutions[i];
 		}
 		System.out.println(""Case #""+casenum+"": ""+numsfound);
 	}
 
 	public static void main(String[] args) throws Exception {
 		for (long i = 0; i < solutions.length; i++) {
 			solutions[i] = -1;
 		}
 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		int numCases = Integer.parseInt(br.readLine());
 		for(int i = 0; i < numCases; i++) {
 			String line = br.readLine();
 			String[] parts = line.split("" "");
 			solve(i+1, Long.parseLong(parts[0]), Long.parseLong(parts[1]));
 		}
 	}
 
 }",0
12,1617,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.ArrayList;
 
 public class IntersectionFinder {
 	static FileRead fr = new FileRead();
 	static ArrayList<ArrayList<Double>> list;
 
 	public static void main(String[] args) {
 
 		fr.getContents(new File(""A-large.in""));
 		// Double largestN = Helper.findLargetN(list.get(0));
 		convertToOutput();
 	}
 
 	private static void convertToOutput() {
 		ArrayList<Inst> obj = fr.obj;
 		ArrayList<Integer> list_n = fr.list_wire_n;
 		Double sum = 0.0;
 		int index = 1;
 		for (int k = 0; k < obj.size(); k++) {
 			int[][] wires = obj.get(k).list_sorted;
 			for (int i = 0; i < obj.get(k).list_a.size(); i++) {
 				int a = wires[i][0];
 				int b = wires[i][1];
 				for (int j = 0; j < i; j++) {
 					if (b < wires[j][1]) {
 						sum++;
 					}
 				}
 
 			}
 			try {
 				fr.writeLine(""Case #""+ index + "": ""+sum.intValue());
 			} catch (FileNotFoundException e) {
 				e.printStackTrace();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			sum = 0.0;
 			index++;
 		}
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 
 
 public class BotTrust {
 	static FileRead fr = new FileRead();
 	static ArrayList<ArrayList<Double>> list;
 	public static void main(String[] args) {
 
 		fr.getContents(new File(
 				""A-large.in""));
 		//Double largestN = Helper.findLargetN(list.get(0));
 		fr.RunAlgo();
 		//convertToOutput();
 	}
 
 //	private static void convertToOutput() {
 //		Iterator<Double> enm = ns.iterator();
 //		Iterator<Double> knm = ks.iterator();
 //		int next,knext;
 //		boolean out;
 //		String res;
 //		int index=1;
 //		while (enm.hasNext()) {
 //			int newcc;
 //			if(index==20)
 //				newcc=0;
 //			next = enm.next().intValue();
 //			knext = knm.next().intValue();
 //			out = (knext+1) % Math.pow(2, next) == 0;
 //			res = out ? ""ON"" : ""OFF"";
 //			try {
 //				fr.writeLine(""Case #""+index+"": ""+res);
 //			} catch (FileNotFoundException e) {
 //				// TODO Auto-generated catch block
 //				e.printStackTrace();
 //			} catch (IOException e) {
 //				// TODO Auto-generated catch block
 //				e.printStackTrace();
 //			}
 //			index++;
 //	}
 //	}
 	
 }
",1
13,17938,"package codejam.codejam2014.round1B;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  * 
  * The Repeater
  * 
  */
 
 public class ProblemA {
     
 //    private static final String ID = ""gcj2014round1B\\A-small-attempt0"";
     private static final String ID = ""gcj2014round1B\\A-large"";
     
     private static Scanner input;
     private static PrintWriter output;
     
     private static void run() {
         long time = System.currentTimeMillis();
         solve();
         output.flush();
         output.close();
         input.close();
         time = System.currentTimeMillis() - time;
         System.out.printf(""[%s] finished in %d ms\n"", ID, time);
     }
     
     public static void main(String[] args) {
         try {
             input = new Scanner(new File(""codejam\\"" + ID + "".in""));
             output = new PrintWriter(new FileWriter(""codejam\\"" + ID + "".out""));
             run();
         } catch (Exception ex) {
             ex.printStackTrace(System.out);
         }
     }
     
     private static void solve() {
         final int T = input.nextInt();
         for (int t = 1; t <= T; t++) {
             final int N = input.nextInt();
             final String[] S = new String[N];
             final Sequence[] Q = new Sequence[N];
             input.nextLine();
             for (int i = 0; i < N; i++) {
                 S[i] = input.nextLine();
                 Q[i] = new Sequence(S[i]);
             }
             
             output.printf(""Case #%d: "", t);
             
             boolean possible = true;
             for (int i = 1; i < N && possible; i++) {
                 if (Q[i].sequence.size() != Q[i - 1].sequence.size()) {
                     possible = false;
                 }
             }
             if (!possible) {
                 output.println(""Fegla Won"");
                 continue;
             }
             
             possible = true;
             for (int segment = 0; segment < Q[0].sequence.size() && possible; segment++) {
                 for (int i = 1; i < N; i++) {
                     if (Q[i].sequence.get(segment).c != Q[i - 1].sequence.get(segment).c) {
                         possible = false;
                         i = N;
                     }
                 }
             }
             if (!possible) {
                 output.println(""Fegla Won"");
                 continue;
             }
             
 //            System.out.printf(""Case %d\n"", t);
             int operations = 0;
             final int segments = Q[0].sequence.size();
             for (int segment = 0; segment < segments; segment++) {
                 int[] counts = new int[101];
                 int maxCounts = 0, mode = 0, total = 0;
                 for (int i = 0; i < N; i++) {
                     Segment s = Q[i].sequence.get(segment);
                     total += s.length;
                     counts[s.length]++;
                     if (counts[s.length] > maxCounts) {
                         maxCounts = counts[s.length];
                         mode = s.length;
                     }
                 }
                 int mean = Math.round((float) total / N);
                 int target = mode;
                 int o = 0;
                 for (int i : counts)
                     if (i == maxCounts)
                         o++;
                 if (o > 1) {
                     target = mean;
                 }
 //                System.out.println(""Counts: "" + Arrays.toString(counts));
 //                System.out.printf(""Mode %d  Mean %d  Target %d\n"", mode, mean, target);
                 for (int i = 0; i < N; i++) {
                     Segment s = Q[i].sequence.get(segment);
                     operations += Math.abs(target - s.length);
                 }
             }
 //            System.out.println();
             output.println(operations);
         }
     }
     
     private static class Sequence {
         
         public ArrayList<Segment> sequence;
         
         public Sequence(String s) {
             if (s.isEmpty())
                 throw new IllegalArgumentException();
             
             sequence = new ArrayList();
             char current = s.charAt(0);
             int count = 1;
             for (int i = 1; i <= s.length(); i++) {
                 if (i == s.length()) {
                     sequence.add(new Segment(current, count));
                 } else if (s.charAt(i) == current) {
                     count++;
                 } else {
                     sequence.add(new Segment(current, count));
                     current = s.charAt(i);
                     count = 1;
                 }
             }
         }
         
         @Override
         public String toString() {
             StringBuilder sb = new StringBuilder();
             for (Segment seg : sequence) {
                 sb.append(seg.c);
                 sb.append('(');
                 sb.append(seg.length);
                 sb.append(')');
                 sb.append(' ');
             }
             return sb.toString();
         }
     }
     
     private static class Segment {
         public final char c;
         public final int length;
         public Segment(char c, int length) {
             this.c = c;
             this.length = length;
         }
     }
     
 }
","import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 
 public class C1A {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		
 		try{
 			Scanner myFile = new Scanner(new FileReader(""D://alon//programming//codejam2013//C1//A-small-attempt0.in"")); //check!!!
 			BufferedWriter out = new BufferedWriter(new FileWriter(""D://alon//programming//codejam2013//C1//A-small-answers.txt"")); //check!!!
 			int T = myFile.nextInt();
 			for(int t = 1; t<=T; t++){
 				String name = myFile.next();
 				int n = myFile.nextInt();
 				int count = 0;
 				for(int i = 0; i<name.length(); i++){
 					for(int j = name.length(); j>i; j--){
 						String st = name.substring(i, j);
 						if(cunsecutive(st, n))
 							count++;
 					}
 				}
 				out.write(""Case #""+t+"": ""+count+'\n');
 				System.out.println(""Case #""+t+"": ""+count);
 			}
 			out.close();
 			myFile.close();
 		}catch(FileNotFoundException e){
 			System.out.println(""file not found"");
 		}catch(Exception e){
 			e.printStackTrace();
 		}
 	}
 	
 	public static boolean cunsecutive(String n, int num){
 		int count = 0;
 		for(int k = 0; k<n.length(); k++){
 			char c = n.charAt(k);
 			if((c != 'a')&&(c != 'e')&&(c != 'i')&&(c != 'o')&&(c != 'u'))
 				count++;
 			else
 				count = 0;
 			if(count == num)
 				return true;
 		}
 		return false;
 	}
 
 }
",0
14,15166,"import java.util.List;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Scanner;
 import java.util.Locale;
 
 public class P4
 {
 	public static void main( String args[] )
 	{
 		List<Double> l1 = new ArrayList<Double>();
 		List<Double> l2 = new ArrayList<Double>();
 		List<Double> tmp1 = new ArrayList<Double>();
 		List<Double> tmp2 = new ArrayList<Double>();
 		Scanner in = new Scanner( System.in );
 		
 		in.useLocale( Locale.US );
 		int t = in.nextInt();
 		for( int i = 0; i < t; i++ )
 		{		
 			int n = in.nextInt();
 			l1.clear();
 			l2.clear();
 			tmp1.clear();
 			tmp2.clear();
 			
 			for( int j = 0; j < n; j++ )
 				l1.add( in.nextDouble() );
 			for( int j = 0; j < n; j++ )
 				l2.add( in.nextDouble() );
 				
 			Collections.sort( l1 );
 			Collections.sort( l2 );
 			
 			int p1 = 0;
 			tmp1.addAll( l1 );
 			tmp2.addAll( l2 );
 			while( !l1.isEmpty() )
 			{								
 				double s2 = l2.remove( l2.size() - 1 );
 				
 				if( l1.size() == 1 )
 				{
 					double s1 = l1.remove( l1.size() - 1 );
 					if( s1 > s2 )
 						p1++;
 				} // fim de if
 				else
 				{
 					double s1 = l1.get( l1.size() - 1 );
 					
 					if( s1 < s2 )
 						l1.remove( 0 );
 					else if( s1 > s2 )
 					{
 						int index = l1.size() - 1;
 						while( index >= 0 && l1.get( index ) > s2 )
 							index--;							
 						l1.remove( index + 1 );
 							
 						p1++;
 					} // fim de else
 				} // fim de else
 			} // fim de while
 			
 			int p2 = 0;
 			l1.addAll( tmp1 );
 			l2.addAll( tmp2 );
 			while( !l1.isEmpty() )
 			{
 				double s1 = l1.remove( 0 );
 				
 				if( s1 > l2.get( l2.size() - 1 ) )
 				{
 					p2++;
 					l2.remove( 0 );
 				} // fim de if
 				else
 				{
 					int index = l2.size() - 1;
 					while( index >= 0 && l2.get( index ) > s1 )
 						index--;							
 					l2.remove( index + 1 );
 				} // fim de else
 			} // fim de while
 			
 			System.out.printf( Locale.US, ""Case #%d: %d %d\n"", i + 1, p1, p2 );			
 		} // fim de for
 		
 		
 	} // fim de main
 } // fim de classe","package google.codejam2014;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.Arrays;
 
 public class MagicTrick {
 
 	private static final String OUTPUT = ""Case #%d: %s"";
 	private static final String BAD_MAGICIAN = ""Bad magician!"";
 	private static final String VOLUNTEER_CHEATED = ""Volunteer cheated!"";
 
 	public static void main(String[] args) throws IOException {
 		if (args.length < 1) {
 			System.out.println(""Usage: MagicTrick <input-file>"");
 			System.exit(0);
 		}
 		BufferedReader in = new BufferedReader(new FileReader(args[0]));
 		int T = Integer.parseInt(in.readLine());
 
 		for (int c = 0; c < T; c++) {
 			int[] answers = new int[2];
 			int[][][] grids = new int[2][4][4];
 			for (int a = 0; a < 2; a++) {
 				answers[a] = Integer.parseInt(in.readLine());
 				grids[a] = new int[4][4];
 				for (int i = 0; i < 4; i++) {
 					grids[a][i] = new int[4];
 					String[] line = in.readLine().split("" "");
 					for (int j = 0; j < 4; j++) {
 						grids[a][i][j] = Integer.parseInt(line[j]);
 					}
 				}
 			}
 
 			solveCase(c + 1, grids[0][answers[0] - 1], grids[1][answers[1] - 1]);
 		}
 
 		in.close();
 	}
 
 	private static void solveCase(int caseNum, int[] rowOne, int[] rowTwo) {
 		int card = -1;
 		int count = 0;
 
 		out: for (int i = 0; i < 4; i++) {
 			for (int j = 0; j < 4; j++) {
 				if (rowOne[i] == rowTwo[j]) {
 					card = rowOne[i];
 					count++;
 					if (count > 1) {
 						break out;
 					}
 				}
 			}
 		}
 
 		if (count < 1) {
 			System.out.println(String.format(OUTPUT, caseNum, VOLUNTEER_CHEATED));
 		}
 		else if (count == 1) {
 			System.out.println(String.format(OUTPUT, caseNum, card));
 		}
 		else {
 			System.out.println(String.format(OUTPUT, caseNum, BAD_MAGICIAN));
 		}
 	}
 }",0
15,15367,"import java.awt.Point;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.List;
 
 
 
 public class Intranet {
     private int testCasesCount;
     private BufferedReader input;
     private BufferedWriter output;
     
     public static void main(String[] args) {
         Intranet intra = new Intranet();
         try {
             intra.mainAlgo();
         } catch (Exception e1) {
             // TODO Auto-generated catch block
             e1.printStackTrace();
         }
         
         
     }
     
     public void mainAlgo() throws Exception {
         readInputs();
         output = new BufferedWriter(new FileWriter(""intersections.txt""));
         
         for(int i = 0; i < testCasesCount; i++) {
             
             int intersections = 0;
             int n = Integer.parseInt(input.readLine());
             
             Point []left_right = new Point[n];
             for(int j = 0; j < n; j++) {
                 String line = input.readLine();
                 List<Integer> LR = getSplittedIntegers(line);
                 Point p = new Point(LR.get(0), LR.get(1));
                 left_right[j] = p;
             }
             
             for(int j = 0; j < n-1; j++) {
                 Point reference = left_right[j];
                 for(int k = j; k < n; k++) {
                     Point compareWith = left_right[k];
                     if((reference.x > compareWith.x && reference.y < compareWith.y) ||
                             (reference.x < compareWith.x && reference.y > compareWith.y))
                         intersections++;
                 }
             }
             
             output.write(""Case #"" + (i+1) + "": "" + intersections + ""\n"");
         }
         output.close();
 
     }
     
     
 
     private void readInputs() {
         input = new BufferedReader(new InputStreamReader(System.in));
             
         try {
             testCasesCount = Integer.parseInt(input.readLine());
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
     
 
     private List<Integer> getSplittedIntegers(String oneLine) {
         String[] splittedItems = oneLine.split("" "");
         List<Integer> toReturn = new ArrayList<Integer>();
         for(String splitted : splittedItems)
             toReturn.add(Integer.parseInt(splitted));
         
         return toReturn;
     }
 }
","
 package Cookie;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 
 
 public class CookieCutter{
     public CookieCutter(){    
     }
     public void CookieCutter(String filename) throws NumberFormatException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException{
    	 BufferedReader greyparse = new BufferedReader(new FileReader(filename));
    	 greyparse.readLine();
    	 PrintWriter writer = new PrintWriter(""output.txt"", ""UTF-8"");
    	 int thiscase = 1;
    	 String thisString;
    	 Double cps;
    	 Double cpf;
    	 Double fp;
    	 Double goal;
    	 Double timetaken;
    	 Double timenofarm;
    	 Double timefarm;
    	 while(greyparse.ready()){
    		 thisString = ""Case #"" + thiscase + "": "";
    		 String[] curr = greyparse.readLine().split("" "");
    		 fp = Double.valueOf(curr[0]);
    		 cpf = Double.valueOf(curr[1]);
    		 goal = Double.valueOf(curr[2]);
    		 timetaken = 0.0;
    		 cps = 2.0;
    		 
    		 timenofarm = goal/cps + timetaken;
    		 timefarm = goal/(cps + cpf) + fp/cps + timetaken;
    		 while(timefarm < timenofarm){
    			 timetaken += fp/cps;
    			 cps += cpf;
    			 timenofarm = goal/cps + timetaken;
    			 timefarm = goal/(cps + cpf) + fp/cps + timetaken;
    		 }
    		 thisString += timenofarm;
    		 thiscase++;
    		 writer.println(thisString);
    	 }
    	 writer.close();
     }
     /**
     public static void main(String[] args) throws NumberFormatException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException{
    	 CookieCutter c = new CookieCutter();
    	 c.CookieCutter(""src/CookieCutter/B-large.in"");
     }
     */
     
 }",0
16,12681,"
 public class Main {
     public static void main(String[] args) {
          try {
             java.util.Scanner s = new java.util.Scanner( new java.io.File(""B-Large.in"") );
             java.io.FileWriter fw = new java.io.FileWriter( new java.io.File(""output.out"") );
             String result = """";
             String listMod = """";
             int c = 0;
             int d = 0;
             int cases = s.nextInt();
             for(int k = 1; k <= cases; k++){
                 String aux = """";
                      listMod = """";
                 c = s.nextInt();
                 String combinations[][] = new String[2][c];
                 for(int yaya = 0; yaya < c; yaya++){
                         aux = s.next();
                         combinations[0][yaya] = aux.substring(0,2);
                         combinations[1][yaya] = aux.substring(2,3);
                 }
                 d = s.nextInt();
                 String replacements[][] = new String[2][d];
                  for(int dada = 0; dada < d; dada++){
                     aux = s.next();
                     replacements[0][dada] = aux.substring(0,1);
                     replacements[1][dada] = aux.substring(1,2);
                 }
                 int n = s.nextInt();
                 String list = s.next();
                  for(int i = 1; i <= n; i++){
                     listMod += list.substring(i-1,i);
                     for(int lplp = 0; lplp < c; lplp++){
                         if((c != 0) && (listMod.endsWith(combinations[0][lplp]) || listMod.endsWith(combinations[0][lplp].substring(1,2) + combinations[0][lplp].substring(0,1)))){
                              listMod = listMod.substring(0, listMod.length()-2);
                              listMod += combinations[1][lplp];
                          }
                     }
                    for(int lplp = 0; lplp < d; lplp++){
                      if( d == 1 && (listMod.contains(replacements[0][lplp]) && listMod.contains(replacements[1][lplp])))
                          listMod = """";
                      }
             }
             result += ""Case #"" + k + "": ["";
             for(int coco=1; coco<=listMod.length();coco++){
                 if(coco == 1)
                    result +=  listMod.substring(coco-1, coco) ;
                 else
                     result += "", "" + listMod.substring(coco-1, coco) ;
             }
             result+= ""]\n"";
              }
             fw.write("""" + result);
             fw.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 }
 
","
 import java.util.ArrayList;
 import java.util.Collections;
 
 
 
 public class Main {
     public static long factorial(int n )
     {
         if( n <= 1 )     // base case
             return 1;
         else
             return n * factorial( n - 1 );
     }
 
     public static void main(String[] args) {
          try {
             java.util.Scanner s = new java.util.Scanner( new java.io.File(""D-small-attempt4.in"") );
             java.io.FileWriter fw = new java.io.FileWriter( new java.io.File(""output.out"") );
             ArrayList list1 = new ArrayList();
             ArrayList list2 = new ArrayList();
             int cases = s.nextInt();
  
             String result = """";
             for(int k = 1; k <= cases; k++){
                 int pitufina = 0;
                 list1.clear();
                 list2.clear();
                 int n = s.nextInt();
                 for(int j = 1; j <= n; j++){
                     int aux = s.nextInt();
                     list1.add(aux);
                     list2.add(aux);
                  }
                 Collections.sort(list2);
                 for(int p = list2.size()-1; p >= 0; p--){
                    if(list1.get(p)==list2.get(p)){
                        list1.remove(p);
                        list2.remove(p);
                    }
                 }
                result += ""Case #"" + k + "": "" + list2.size() + "".000000"" + ""\n"";
 
                 }
 
 
             fw.write("""" + result);
             fw.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 }
 
",1
17,15190,"package codejam.qualification2014;
 
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  *
  * @author isakrabin
  */
 public class DeceitfulWar {
 
     private Scanner scanner;
     private PrintWriter writer;
 
     public DeceitfulWar(InputStream in, OutputStream os) {
         scanner = new Scanner(in);
         writer = new PrintWriter(os);
     }
 
     public void solve() {
         Integer n = Integer.parseInt(scanner.nextLine());
         for (int i = 1; i <= n; i++) {
 
             int N = scanner.nextInt();
 
             int[] flag = new int[N];
             for (int x = 0; x < N; x++) {
                 flag[x] = 0;
             }
 
             double[] naomi = new double[N];
             double[] ken = new double[N];
 
             //read Naomi block
             for (int a = 0; a < N; a++) {
                 naomi[a] = scanner.nextDouble();
             }
 
             //read Ken block 
             for (int b = 0; b < N; b++) {
                 ken[b] = scanner.nextDouble();
             }
 
 
             //sort
             Arrays.sort(naomi);
             Arrays.sort(ken);
 
             //DeceitfulWar
             double[] blocks = new double[2 * N];
             System.arraycopy(naomi, 0, blocks, 0, N);
             System.arraycopy(ken, 0, blocks, N, N);
             Arrays.sort(blocks);
 
             int[] naomiBlock = new int[N];
             for (int a = 0; a < N; a++) {
                 naomiBlock[a] = 0;
             }
 
             int count = 0;
             int[] naomiBlockIndex = new int[N];
             for (int c = 0; c < 2 * N; c++) {
                 for (int d = 0; d < N; d++) {
                     if (blocks[c] == naomi[d]) {
                         naomiBlockIndex[count] = c;
                         count = count + 1;
                         break;
                     }
                 }
             }
 
             int [] kenBlock = new int[N];
             for (int a = 0; a < N; a++) {
                 kenBlock[a] = 0;
             }
 
 
             count = 0;
             int[] kenBlockIndex = new int[N];
             for (int c = 0; c < 2 * N; c++) {
                 for (int d = 0; d < N; d++) {
                     if (blocks[c] == ken[d]) {
                         kenBlockIndex[count] = c;
                         count = count + 1;
                         break;
                     }
                 }
             }
 
 
             int totalWinDecitfulWar = N;
 
             //sure Lose
             int index = 0;
             while (index < N && naomiBlockIndex[index] < kenBlockIndex[0]) {
                 totalWinDecitfulWar = totalWinDecitfulWar - 1;
                 naomiBlock[index] = 1;
                 kenBlock[N - index -1] = 1;
                 index = index + 1;
             }
 
             //play
             double chosenNaomi = 0;
             double chosenKen = 0;
             for (int a = 0; a < N; a++) {
                 if (naomiBlock[a] == 1) {
                     continue;
                 }
                 chosenNaomi = blocks[naomiBlockIndex[a]];
                 naomiBlock[a]=1;
                 for (int b = 0; b < N; b++) {
                     if (kenBlock[b] == 1) {
                         continue;
                     }
                     chosenKen = blocks[kenBlockIndex[b]];
                     kenBlock[b]=1;
                     break;
                 }
                 if (chosenKen>chosenNaomi) {
                     totalWinDecitfulWar = totalWinDecitfulWar - 1;
                 }
             }
 
 
             //WAR Game         
             int totalWinWar = N;
             for (int e = 0; e < N; e++) {
                 for (int f = 0; f < N; f++) {
                     if (flag[f] == 1) {
                         continue;
                     }
                     if (ken[f] > naomi[e]) {
                         totalWinWar = totalWinWar - 1;
                         flag[f] = 1;
                         break;
                     }
                 }
 
             }
 
 
             writer.print(""Case #"" + i + "": "");
             writer.println(totalWinDecitfulWar + "" "" + totalWinWar);
             writer.flush();
         }
         writer.close();
     }
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         InputStream input = DeceitfulWar.class.getResourceAsStream(args[0]);
 
         OutputStream output = null;
         try {
             output = new FileOutputStream(args[1]);
         } catch (FileNotFoundException e) {
             System.err.print(e.getMessage());
         }
 
         DeceitfulWar solution = new DeceitfulWar(input, output);
         solution.solve();
     }
 }
","package codejam.qualification2013;
 
 import codejam.template.CodeJam;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author isakrabin
  */
 public class TicTacToe {
 
     private Scanner scanner;
     private PrintWriter writer;
 
     public TicTacToe(InputStream in, OutputStream os) {
         scanner = new Scanner(in);
         writer = new PrintWriter(os);
     }
 
     public void solve() {
         Integer n = Integer.parseInt(scanner.nextLine());
         for (int i = 1; i <= n; i++) {
 
             char[][] board = new char[4][4];
             char result = '.';
             boolean unfinished = false;
 
             String line = """";
             for (int j = 0; j < 4; j++) {
                 line = scanner.nextLine();
                 for (int k = 0; k < 4; k++) {
                     board[j][k] = line.charAt(k);
                     if (board[j][k] == result) {
                         unfinished = true;
                     }
                 }
             }
             line = scanner.nextLine();
 
             //check row
             if (result == '.') {
                 //4 same character in the row, or 3 same character + T
                 int j = 0;
                 while (j < 4 && result == '.') {
                     if ((board[j][0] == board[j][1] && board[j][0] == board[j][2] && board[j][0] == board[j][3])
                             || (board[j][0] == 'T' && board[j][1] == board[j][2] && board[j][1] == board[j][3])
                             || (board[j][0] == board[j][1] && board[j][0] == board[j][2] && board[j][3] == 'T')) {
                         result = board[j][1];
                     }
                     j++;
                 }
             }
 
 
             //check column
             if (result == '.') {
                 //4 same character in the row, or 3 same character + T
                 int j = 0;
                 while (j < 4 && result == '.') {
                     if ((board[0][j] == board[1][j] && board[0][j] == board[2][j] && board[0][j] == board[3][j])
                             || (board[0][j] == 'T' && board[1][j] == board[2][j] && board[1][j] == board[3][j])
                             || (board[0][j] == board[1][j] && board[0][j] == board[2][j] && board[3][j] == 'T')) {
                         result = board[1][j];
                     }
                     j++;
                 }
             }
 
 
             //check diagonal
             if (result == '.') {
 
                 //top left to bottom right
                 if (((board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[0][0] == board[3][3])
                         || (board[0][0] == 'T' && board[1][1] == board[2][2] && board[1][1] == board[3][3])
                         || (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[3][3] == 'T')) &&(board[1][1]!='.')){
                     result = board[1][1];
                 }
 
                 //top right to bottom left
                 if (((board[0][3] == board[1][2] && board[0][3] == board[2][1] && board[0][3] == board[3][0])
                         || (board[0][3] == 'T' && board[1][2] == board[2][1] && board[1][2] == board[3][0])
                         || (board[0][3] == board[1][2] && board[0][3] == board[2][1] && board[3][0] == 'T')) &&(board[2][1]!='.')) {
                     result = board[2][1];
                 }
             }
 
 
             writer.print(""Case #"" + i + "": "");
             if (unfinished && result == '.') {
                 writer.println(""Game has not completed"");
 
             } else {
                 if (result == '.') {
                     writer.println(""Draw"");
                 } else {
                     writer.println(result + "" won"");
                 }
             }
             writer.flush();
         }
         writer.close();
     }
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         InputStream input = TicTacToe.class.getResourceAsStream(args[0]);
 
         OutputStream output = null;
         try {
             output = new FileOutputStream(args[1]);
         } catch (FileNotFoundException e) {
             System.err.print(e.getMessage());
         }
 
         TicTacToe solution = new TicTacToe(input, output);
         solution.solve();
     }
 }
",1
18,2039,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class p1
 {
 	public static int getOrbs1(int mySize, ArrayList<Integer> orbs)
 	{
 		for (int i = 0; i < orbs.size(); i++)
 		{
 			int currentOrb = orbs.get(i);
 			if (currentOrb < mySize)
 			{
 				mySize += currentOrb;
 				orbs.remove(i);
 			}
 		}
 		return mySize;
 	}
 
 	public static int getOrbs2(int mySize, ArrayList<Integer> orbs)
 	{
 		int currentSize = orbs.size();
 		mySize = getOrbs1(mySize, orbs);
 		while (currentSize != orbs.size())
 		{
 			currentSize = orbs.size();
 			mySize = getOrbs1(mySize, orbs);
 		}
 		return mySize;
 	}
 
 	public static int add(int mySize, ArrayList<Integer> orbs)
 	{
 		mySize += mySize - 1;
 		mySize = getOrbs2(mySize, orbs);
 		return mySize;
 	}
 
 	public static int findMoves(int mySize, ArrayList<Integer> orbs)
 	{
 		int minMoves = orbs.size();
 		int carry=mySize;
 		for (int i = 0;  orbs.size()>0;i++)
 		{
 			mySize = add(mySize, orbs);
 			int currentMoves = i+1 + orbs.size();
 			if (currentMoves < minMoves)
 				minMoves = currentMoves;
 		}
 		return minMoves;
 	}
 
 	/**
 	 * @param args
 	 * @throws FileNotFoundException
 	 */
 	public static void main(String[] args) throws FileNotFoundException
 	{
 		// ///////////////////////////////////////////////////////////////////
 		long start = System.nanoTime();
 		// ///////////////////////////////////////////////////////////////////
 	//	Scanner inFile = new Scanner(new File(""p1.txt""));
 		 Scanner inFile = new Scanner(new File(""A-small-attempt0.in""));
 		// Scanner inFile = new Scanner(new File(""A-Large.in""));
 		PrintWriter out = new PrintWriter(""p1out.txt"");
 		int numberOfTimes = inFile.nextInt();
 
 		for (int times = 1; times <= numberOfTimes; times++)
 		{
 			int mySize = inFile.nextInt();
 			int orbNum = inFile.nextInt();
 			ArrayList<Integer> orbs = new ArrayList<Integer>(orbNum);
 			for (int i = 0; i < orbNum; i++)
 			{
 				orbs.add(inFile.nextInt());
 			}
 			if (mySize <= 1)
 			{
 				//System.out.println(""Case #"" + times + "": "" + orbs.size());
 				out.println(""Case #"" + times + "": "" + orbs.size());
 			}
 			else
 			{
 				mySize = getOrbs2(mySize, orbs);
 
 				if (orbs.size() == 0)
 				{
 					//System.out.println(""Case #"" + times + "": 0"");
 					out.println(""Case #"" + times + "": 0"");
 				}
 				else
 				{
 					int moves = findMoves(mySize, orbs);
 					//System.out.println(""Case #"" + times + "": "" + moves);
 					out.println(""Case #"" + times + "": "" + moves);
 
 				}
 			}
 		}
 		inFile.close();
 		out.close();
 		// ///////////////////////////////////////////////////////////////////
 		long stop = System.nanoTime();
 		System.out.printf(""Run time: %.1f ms%n"", (stop - start) / 1000000.0);
 		System.out.println(""End of Program"");
 		// ///////////////////////////////////////////////////////////////////
 
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.LinkedList;
 
 
 public class one {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		// TODO Auto-generated method stub
 		BufferedReader r= new BufferedReader(new FileReader(""A-large.in""));
 		
 		FileWriter write=new FileWriter(new File(""output.txt""));
 		int testCases=Integer.parseInt(r.readLine());
 		
 		int k=1;
 		while(k<=testCases){
 			int result=0;
 			LinkedList<Integer> o=new LinkedList<Integer>();
 			LinkedList<Integer> b=new LinkedList<Integer>();
 			
 			String input=r.readLine();
 			if(input.split("" "")[0].equals(""1"")){
 				result=Integer.parseInt(input.split("" "")[2]);
 			}else{
 				
 				
 				String [] input2=input.split("" "");
 				int length=input2.length;
 
 				String prese="""";
 				for (int i = 1; i < length; i+=2) {
 					prese+=input2[i];
 					if(input2[i].equals(""O"")){
 						int s=Integer.parseInt(input2[i+1]);
 						o.addLast(s);
 					}else{
 						int  s=Integer.parseInt(input2[i+1]);
 						b.addLast(s);
 					}
 				}
 				int starto=1;
 				int startb=1;
 				int i=0;
 				String main=""""+prese.charAt(i);
 				while(!o.isEmpty() || !b.isEmpty()){
 					boolean once=false;
 					
 					if(!o.isEmpty()&&starto==o.getFirst() && main.equals(""O"")){
 						o.removeFirst();
 						once=true;
 						i++;
 						if(i!=prese.length())main=""""+prese.charAt(i);
 						
 					}
 					else{
 						if(!o.isEmpty()&&starto<o.getFirst()){
 							starto++;
 						}else if(!o.isEmpty()&&starto>o.getFirst()){
 							starto--;
 						}
 					}
 					if(!b.isEmpty()&&startb==b.getFirst() && !once && main.equals(""B"")){
 						
 						b.removeFirst();
 						i++;
 						if(i!=prese.length())main=""""+prese.charAt(i);
 					}
 					else{
 						if(!b.isEmpty()&&startb<b.getFirst()){
 							startb++;
 						}else if(!b.isEmpty()&&startb>b.getFirst()){
 							startb--;
 						}
 					}
 					result++;
 				}
 			}
 			
 			write.write(""Case #""+k+"": ""+result+""\n"");
 			k++;
 		}
 		write.close();
 
 	}
 
 }
",0
19,2127,"package codejam;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class Cookie
 {
   // static final String FILENAME = ""/Users/chaoren/Downloads/A-small-attempt0.in"";
   static final String FILENAME = ""/Users/chaoren/Downloads/B-small-attempt0.in"";
   static final String IN = FILENAME;
   static final String OUT = FILENAME + "".out"";
 
   static Scanner sc = null;
   static PrintStream out = System.out;
 
   private void solve ()
   {
     double t_old = 0;
     double t = 0;
     double start = 2.0;
     double c = sc.nextDouble ();
     double f = sc.nextDouble ();
     double x = sc.nextDouble ();
     int n = 0;
 
     t_old = x / start;
 
     if (c > x) {
       out.println (t_old);
       return;
     }
 
     while (true) {
       double sum = 0.0;
 
       for (int i = 0; i < n; i++) {
         sum += (c / (f * i + 2));
       }
 
       sum += x / (f * n + 2);
 
       t = sum;
 
       if (t_old < t) {
         out.println (t_old);
         return;
       }
       else {
         t_old = t;
       }
 
       n++;
     }
   }
 
   private void run () throws Exception
   {
     out = new PrintStream (new FileOutputStream (OUT));
     int t = sc.nextInt ();
     for (int i = 1; i <= t; i++) {
       out.print (""Case #"" + i + "": "");
       solve ();
     }
     sc.close ();
     out.close ();
   }
 
   public static void main (String args[]) throws Exception
   {
     Cookie.sc = new Scanner (new FileInputStream (new File (IN)));
     new Cookie ().run ();
   }
 }
","import java.util.Scanner;
 
 public class Dance {
 
 	public static void main(String[] args) {
 		Scanner cin = new Scanner(System.in);
 		int linenum = cin.nextInt();
 		
 		for(int idx = 1; idx < linenum+1; idx++)
 		{
 			System.out.print(""Case #"" + idx + "": "");
 			int n = cin.nextInt();
 			int s = cin.nextInt();
 			int p = cin.nextInt();
 			
 			int ans = 0;
 			
 			for(int i=0; i < n; i++)
 			{
 				int score = cin.nextInt();
 				
 				if(score == 0)
 				{
 					if(p == 0)
 						ans++;
 					else
 						continue;
 				}
 				else if(score == p*3 || score == p*3 - 1 ||score == p*3 - 2 || score > p*3)
 				{
 					ans++;
 				}
 				else if(score == p*3 - 3 || score == p*3 - 4)
 				{
 					if(s > 0)
 					{
 						s--;
 						ans++;
 					}
 					else
 					{
 						continue;
 					}
 				}
 				else
 				{
 					continue;
 				}
 			}
 			System.out.println(ans);
 		}
 	}
 
 }
",1
20,15505,"import java.io.*;
 import java.util.Arrays;
 import java.lang.Math;
 public class Task1 {
 	public static void main(String[] args) {
 		int TotalMovement = 0, Dist=0,posO=1, posB=1, MoveTo=0;
 		char Current;
 		try {
 			BufferedReader reader = new BufferedReader(new FileReader (""A-small-attempt0.in""));
 			BufferedWriter writer = new BufferedWriter(new FileWriter(""Output1.txt""));
 			int T = Integer.parseInt(reader.readLine());
 			for (int i=0; i<T;i++) {
 				String[] Orders = reader.readLine().split("" "");
 				//int N = Integer.parseInt(Orders[0]);
 				Current = Orders[1].charAt(0);
 				MoveTo = Integer.parseInt(Orders[2]);
 				if (Current == 'B') {
 					posB = MoveTo; posO++; }
 				else  {
 					posO = MoveTo; posB++; }
 				TotalMovement +=MoveTo;
 				Dist += MoveTo;
 				for (int j=3; j < (Orders.length-1); j++) {
 					MoveTo = Integer.parseInt(Orders[j+1]);
 					if (Current == Orders[j].charAt(0)) {
 						if (Current == 'B') {
 							TotalMovement += Math.abs(MoveTo - posB) + 1;
 							Dist += Math.abs(MoveTo - posB) + 1;
 							posB = MoveTo;
 						}
 						else {
 							TotalMovement += Math.abs(MoveTo - posO) + 1;
 							Dist += Math.abs(MoveTo - posO) + 1;
 							posO = MoveTo;
 						}											
 					}
 					else {
 						Current = Orders[j].charAt(0);
 						if (Current =='B') {
 							if ((Math.abs(MoveTo - posB) - Dist) > 0) {
 								TotalMovement+= Math.abs(MoveTo - posB) - Dist;
 								Dist = Math.abs(MoveTo - posB) - Dist + 1; 
 								}
 							else Dist = 1;
 							posB = MoveTo;
 							TotalMovement++;
 						}
 						else {
 							if ((Math.abs(MoveTo - posO) - Dist ) > 0) {
 								TotalMovement+= Math.abs(MoveTo - posO) - Dist ;
 								Dist = Math.abs(MoveTo - posO) - Dist +1 ; 
 								}
 							else Dist = 1;
 							posO = MoveTo;
 							TotalMovement++;
 						}
 					}
 				j++;
 				}
 				writer.write(""Case #""+(i+1)+"": ""+TotalMovement);
 				writer.newLine();
 				TotalMovement = 0; Dist = 0; posO =0; posB=0;
 			}
 			writer.close();
 		} catch (Exception Ex) {Ex.printStackTrace(); }
 
 	}
 
 }
","
 
 public class Space {
 
 	/**
 	 * @param args
 	 */
 
 	public static boolean isdiv(int a, int b)
 	{
 		if (a%b==0 || b%a==0)
 			return true;
 		return false;
 		
 	}
 	public static int[] String2arr(String ln)
 	{
 		String[] res= ln.split("" "");
 		
 		int[] ret=new int[res.length];
 		for (int i=0; i<res.length; i++)
 		{
 			ret[i]=Integer.parseInt(res[i]);
 		}
 		return ret;
 		
 	}
 
     public static void main(String[] args)
     {
 		EasyFile a=new EasyFile(""C:\\Users\\Ido\\Downloads\\space.in"");
 		EasyWrite out= new EasyWrite(""C:\\Users\\Ido\\Downloads\\space.out"");
 		
 		int T= Integer.parseInt(a.getline());
 		
 		for (int m=1; m<=T; m++)
 		{
 			int[] prop=String2arr(a.getline());
 			int[] numbers=String2arr(a.getline());
 			int low=prop[1];
 			int high=prop[2];
 			boolean found=false;
 			int i;
 			for (i=low; i<=high && !found;  i++)
 			{
 				found=true;
 				for (int j : numbers)
 				{
 					if(!isdiv(j, i))
 						found=false;
 						
 				}
 				
 			}
 			String number= """";
 			if (found)
 				number=String.valueOf(i-1);
 			else
 				number=""NO"";
 			out.writeline(""Case #""+m+"": ""+number);
 			
 		}
 		out.end();
     }
 
 }
",0
21,6253,"import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  * Author: dened
  * Date: 07.05.11
  */
 public class A {
     static Scanner in;
     static PrintWriter out;
 
     public static void main(String[] args) throws FileNotFoundException {
         in = new Scanner(new BufferedInputStream(new FileInputStream(""A.in"")));
         out = new PrintWriter(""A.out"");
 
         int t = in.nextInt();
         for (int i = 1; i <= t; ++i) {
             int ans = solve();
             out.println(""Case #"" + i + "": "" + ans);
         }
 
         out.close();
     }
 
     private static int solve() {
         int n = in.nextInt();
         int[] t = {0, 0};
         int[] p = {0, 0};
         for (int i = 0; i < n; ++i) {
             int r = in.next().equals(""O"") ? 0 : 1;
             int b = in.nextInt() - 1;
             t[r] = Math.max(t[r] + Math.abs(b - p[r]), t[1-r]) + 1;
             p[r] = b;
         }
         return Math.max(t[0], t[1]);
     }
 }
","import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.FileInputStream;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class B {
 
   public static int gao(int s, int p , int[] ss) {
     int p1 = p + Math.max(0,p-1) * 2;
     int p2 = p + Math.max(0,p-2) * 2;
     
     Arrays.sort(ss);
     int ret = 0;
     for (int i = ss.length - 1; i >=0; --i) {
       int n = ss[i];
       if (n >= p1) {
         ret ++;
       } else  if (n >= p2 && s > 0) {
         ret ++;
         s--;
       }
     }
     
     
     return ret;
     
   
   }
   
   public static void main(String[] args) throws Exception {
     
     
     //InputStream in = System.in;
     InputStream in = new FileInputStream(""c:\\B-large.in"");
     
     Scanner scanner = new Scanner(in);
     //BufferedReader r = new BufferedReader(new InputStreamReader(in));
     /*
     for (;;) {
       String l = r.readLine();
       if (l == null) {
         break;
       }
     }
     */
     
     int n;
     n = scanner.nextInt();
     for (int i = 1; i <= n; ++i) {
       int m = scanner.nextInt();
       int s = scanner.nextInt();
       int p = scanner.nextInt();
       int[] ss = new int[m];
       for (int j = 0; j < m; ++j) {
         ss[j] = scanner.nextInt();
       }
       System.out.println(""Case #"" + i + "": "" + gao(s, p, ss));
     }
     
     
     
   }
 
 }
",0
22,982,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 
 public class DancingGooglers 
 {
 	String line=""Code Jam"";
 	static int noOfTCs;
 	
 	public static void main(String[] args)
 	{
 		//initialize();
 		new DancingGooglers().calculate();
 		//generateOPFile();
 	}
 	
 	private void calculate() 
 	{
 		try
 		{
 			BufferedReader br = new BufferedReader(new FileReader(""C:/CodeJam/B-small-attempt1.in""));
 			FileWriter fw = new FileWriter(""C:/CodeJam/B-small-output.txt"");
 			BufferedWriter bw = new BufferedWriter(fw);
 			line = br.readLine().trim();
 			noOfTCs = Integer.parseInt(line);
 			int dancers,surprises,maxScore;
 			for(int testCase=0;testCase<noOfTCs;testCase++)
 			{
 				line = br.readLine().trim();
 				String[] input = line.split("" "");
 				dancers = Integer.parseInt(input[0]);
 				surprises = Integer.parseInt(input[1]);
 				maxScore = Integer.parseInt(input[2]);
 				int sum,maxDancers=0;
 				
 				for(int i=3; i<input.length;i++)
 				{
 					sum =  Integer.parseInt(input[i]);
 					int rem = sum%3;
 					int result = sum/3;
 					if(rem <= 1) 
 					{
 						if((result+rem)>=maxScore)
 							maxDancers++;
 						else if(rem == 0 && result > 0 && (result+1)>=maxScore && surprises > 0)
 						{
 							maxDancers++;
 							surprises--;
 						}
 					}
 					else
 					{
 						if((1+result) >= maxScore)
 						{
 							maxDancers++;
 						}
 						else
 						{
 							if(surprises > 0 && (rem+result) >= maxScore)
 							{
 								maxDancers++;
 								surprises--;
 							}
 						}
 					}
 					
 				}
 				
 				line = ""Case #""+(testCase+1)+"": ""+maxDancers;
 				System.out.println(line);
 				bw.write(line);
 				bw.newLine();
 			}
 			br.close();
 			bw.close();
 			System.out.println(""Done !"");
 		}
 		catch(Exception e)
 		{
 			e.printStackTrace();
 		}
 	}
 	
 	/*static void generateOPFile()
 	{
 		try
 		{
 			FileWriter fw = new FileWriter(""C:/CodeJam/output.txt"");
 			BufferedWriter bw = new BufferedWriter(fw);
 			for(int i=1;i<=noOfTCs;i++)
 			{
 				line = ""Case #""+i+"": ""+1;
 				bw.write(line);
 				bw.newLine();
 			}			
 			bw.close();
 		}
 		catch(Exception e)
 		{
 			e.printStackTrace();
 		}
 	}*/
 
 	/*static void initialize()
 	{
 		try
 		{
 			BufferedReader br = new BufferedReader(new FileReader(""C:/CodeJam/C-small.in""));
 			line = br.readLine().trim();
 			noOfTCs = Integer.parseInt(line);
 			br.close();
 			
 		}
 		catch(Exception e)
 		{
 			e.printStackTrace();
 		}
 	}*/
 }
","import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
 
 public class A {
 
   public static void main(String[] args) throws IOException {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
 
 
     String ss = reader.readLine();
     int n = Integer.parseInt(ss);
 
     for (int i = 0; i < n; i++) {
       Map<String, Integer> map = new HashMap<String, Integer>();
       ss = reader.readLine();
 
       int N = Integer.parseInt(ss);
       int[][] x = new int[N][N];
       for (int k = 0; k < N; k++) {
 
         ss = reader.readLine();
         String[] p = ss.split("" "");
         for (int j = 1; j < p.length; j++) {
           int z = Integer.parseInt(p[j]);
           if (z > 0) {
             x[k][z - 1] = 1;
           }
         }
       }
       boolean found = false;
       for (int j = 0; j < N; j++) {
 
         List<Integer> queue = new LinkedList<Integer>();
         queue.add(j);
         int[] v = new int[N];
         v[j] = 1;
         while (!queue.isEmpty()){
           Integer m = queue.remove(0);
           for (int k = 0; k < N; k++) {
             if (k == m) {
               continue;
             }
             if (x[m][k] == 1) {
               if (v[k] == 1) {
                 found = true;
               } else {
                 v[k] = 1;
                 queue.add(k);
               }
             }
           }
         }
         
       }
 
       
       String res = ""No"";
       if (found) {
         res = ""Yes"";
       }
       String sss = ""Case #"" + (i + 1) + "": "" + res;
       System.out.println(sss);
 
 
     }
   }
 }
",0
23,2796,"import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.HashSet;
 import java.util.Map.Entry;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.TreeMap;
 
 
 public class GCJ_2013_C3 {
 
 	public static class Attack {
 		long day;
 		long beg;
 		long end;
 		long strength;
 	}
 	
 	public static int simday(TreeMap<Long,Long> wall, Set<Attack> attacks) {
 	
 		int attackSuccess = 0;
 		HashSet<Attack> succ = new HashSet<Attack>();
 		
 		
 		for (Attack a : attacks)
 		{
 
 			long ib = a.beg;
 			long ie = a.end;
 			boolean broke = false;
 			while (ib < ie)
 			{
 				long jb = wall.floorKey(ib);
 				long wh = wall.get(jb);
 				if (wh < a.strength)
 					broke = true;
 				ib = wall.higherKey(ib);
 			}
 			if (broke)
 			{
 				attackSuccess ++;
 				succ.add(a);
 			}
 		}
 		
 		for (Attack a : succ)
 			{
 
 				long ib = a.beg;
 				long ie = a.end;
 
 				while (ib<ie)
 				{
 					long ivs = wall.floorKey(ib);
 					if (ivs != ib)
 						wall.put(ib, wall.get(ivs));
 					else if (wall.higherKey(ivs) > ie)
 					{
 						wall.put(ie, wall.get(ivs));
 					}
 					else
 					{
 						if (wall.get(ivs) < a.strength)
 						{
 							wall.put(ivs, a.strength);
 							if (wall.get(wall.lowerKey(ivs)) == a.strength)
 							{
 								wall.remove(ivs);
 							}
 						}
 						ib = wall.higherKey(ib);
 					}
 				}
 /*				for(Entry<Long, Long> entry : wall.entrySet()) {
 					  System.out.printf("" %d:%d "",entry.getKey(),entry.getValue());
 				}
 				System.out.println();*/
 		}
 		
 		return attackSuccess;
 	}
 	
 	public static void main(String[] args) throws Exception {
 //		String fname = ""C_example"";
 		String fname = ""C_small"";
 //		String fname = ""C_large"";
 		
 		File file = new File(fname+""_in.txt"");
 		Scanner scanner = new Scanner(file);
 
 		FileWriter outFile = new FileWriter(fname+""_out.txt"");
 		PrintWriter outp = new PrintWriter(outFile);
 	
 	
 		int T = scanner.nextInt();
 			
 		for (int i=1;i<=T;i++)
 		{
 			System.out.printf("" *** %d\n"",i);
 			TreeMap<Long, HashSet<Attack> > attacks = new TreeMap<Long, HashSet<Attack> >();
 			
 			int tribeNum = scanner.nextInt();
 			
 			for (int j=0;j<tribeNum;j++)
 			{
 				int d0 = scanner.nextInt();
 				int n = scanner.nextInt();
 				long beg0 = scanner.nextLong();
 				long end0 = scanner.nextLong();
 				long s0 = scanner.nextLong();
 				long dd = scanner.nextLong();
 				long dp = scanner.nextLong();
 				long ds = scanner.nextLong();
 				for (int k=0;k<n;k++)
 				{
 					Attack a = new Attack();
 					a.beg = beg0 + k*dp;
 					a.end = end0 + k*dp;
 					a.strength = s0 + k*ds;
 					long d = d0 + k*dd;
 					HashSet<Attack> aset = attacks.get(d);
 					if (aset == null)
 					{
 						attacks.put(d, new HashSet<Attack>());
 						aset = attacks.get(d);
 					}
 					aset.add(a);
 				}
 			}
 			
 			long res = 0;
 			
 			TreeMap<Long,Long> wall = new TreeMap<Long,Long>();
 			wall.put(-99999999999999999l, 0l);
 			wall.put(99999999999999999l, 0l);
 			
 			long d = attacks.firstKey();
 			while (attacks.containsKey(d))
 			{
 //				System.out.printf(""simday: %d\n"",d);
 				res += simday(wall, attacks.get(d));
 				if (attacks.higherKey(d) != null)
 					d = attacks.higherKey(d);
 				else
 					d = d+1;
 			}
 			
 			outp.printf(""Case #%d: %s\n"",i,res);
 		}
 		
 		outp.close();
 
 	}
 
 }","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Stack;
 
 public class name{
 	public static String out="""";
 	
 	public static boolean isv(char c){
 		if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u')
 			return true;
 		else
 			return false;
 	}
 	public static int count(String s, int n){
 		int i,j,co=0,res=0,t;
 		int m=s.length();
 		Stack<Integer> store= new Stack<Integer>();
 		char[] arr=new char[m];
 		for(i=0;i<m;i++){
 			arr[i]=s.charAt(i);
 		}
 		for(i=0;i<m;i++){
 			if(!isv(arr[i])){
 				co++;
 				if(co>=n)
 					store.push(i);
 			}else
 				co=0;
 		}
 		t=m;
 		while(!store.isEmpty()){
 			j=store.pop();
 			res+=(t-j)*(j-n+2);
 			t=j;
 		}
 		return res;
 	}
 	
 	public static void main(String[] args) {
 		BufferedReader br = null;
 		BufferedWriter writer = null;
 		try {
 
 			br = new BufferedReader(new FileReader(""C:/codejam/A-small-attempt1.in""));
 			int T, N, X, Y, j, i,n;
 			String s;
 			int res;
 			String result;
 			String tmpd;
 			T = Integer.parseInt(br.readLine());
 			for (i = 1; i < T + 1; i++) {
 				out += ""Case #"" + i + "": "";
 				tmpd = br.readLine();
 				String[] d = tmpd.split("" "");
 				s = d[0];
 				n = Integer.parseInt(d[1]);
 				res=count(s,n);
 				System.out.println(""Case #""+ i+ "": ""+ res);
 				out += res;
 				out += ""\n"";
 			}
 
 			writer = new BufferedWriter(new FileWriter(""C:/codejam/output.out""));
 			System.out.println(out);
 			writer.write(out);
 
 
 		} catch (IOException e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (writer != null)
 					writer.close();
 			} catch (IOException e) {
 			}
 		}
 
 	}
 }",0
24,13293,"import java.util.Map;
 import java.util.Scanner;
 import java.util.TreeMap;
 
 
 public class A {
 	
 	String cipher=""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv y qeez"";
 	String plain= ""our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up a zooq"";
 	Map<Character,Character> M=new TreeMap<Character,Character>();
 	
 	A() {
 		for (int i=0; i<cipher.length(); ++i)
 			M.put(cipher.charAt(i), plain.charAt(i));
 		
 		Scanner in=new Scanner(System.in);
 		for (int T=new Integer(in.nextLine().trim()),TC=1; T-->0; ++TC) {
 			String line=in.nextLine();
 			System.out.printf(""Case #%d: "", TC);
 			for (char c : line.toCharArray())
 				System.out.print(M.get(c));
 			System.out.println();
 		}
 	}
 	
 	public static void main(String[] args) {
 		new A();
 	}
 
 }
","package round1c;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 /**
  * Created by alemar on 11.05.2014.
  */
 public class P1 {
     //private static final String inputFileName = ""input/round1c/p1/test.in"";
     private static final String inputFileName = ""input/round1c/p1/A-large.in"";
     private static final String outputFileName = ""answer.out"";
 
     public static void main(String[] args) throws Exception {
         File inputFile = new File(inputFileName);
         Scanner scanner = new Scanner(inputFile);
 
         File outputFile = new File(outputFileName);
         outputFile.delete();
         outputFile.createNewFile();
         FileWriter fw = new FileWriter(outputFile);
         BufferedWriter bw = new BufferedWriter(fw);
 
         int numOfTestCases = scanner.nextInt();
         scanner.nextLine();
 
         for (int i = 1; i <= numOfTestCases; i++) {
             String[] s = scanner.nextLine().split(""/"");
             long p = Long.parseLong(s[0]);
             long q = Long.parseLong(s[1]);
 
             Problem1 problem = new Problem1();
 
             String testCase = ""Case #"" + i + "": "" + problem.solve(p, q);
             bw.append(testCase + ""\n"");
             System.out.println(testCase);
         }
 
         bw.flush();
         fw.flush();
 
         bw.close();
         fw.close();
     }
 }
 
 
 class Problem1 {
     public String solve(long p, long q) {
 
         long gcd = gcd(p,q);
 
         p = p / gcd;
         q = q / gcd;
 
         if (Long.bitCount(q) == 1) {
             return String.valueOf(Long.toBinaryString(q).length() - Long.toBinaryString(p).length());
         }
 
         return ""impossible"";
     }
 
     public long gcd(long a, long b) {
         if (b == 0) return a;
         long x = (long)(a % b);
         return gcd(b, x);
     }
 }",0
25,2038,"package qualifierFun;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 public class Round1BQ1 {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			PrintWriter out = new PrintWriter(new FileWriter(""output1.txt"")); 
 			BufferedReader in  = new BufferedReader(new FileReader(""input.txt""));
 			int answer =1;
 			String strLine = in.readLine();
 			int totalCases = Integer.parseInt(strLine);
 			for(int i = 0; i < totalCases; i++) {
 				strLine = in.readLine();
 				String inputs[] = strLine.split("" "");
 				long startSize = Long.parseLong(inputs[0]);
 				int numMotes = Integer.parseInt(inputs[1]);
 				strLine = in.readLine();
 				List<Long> motes = new ArrayList<Long>();
 				for(String mote : strLine.split("" "")) {
 					motes.add(Long.parseLong(mote));
 				}
 				Collections.sort(motes);
 				long changes = getChanges(startSize, 0, motes);
 				
 				System.out.print(String.format(""Case #%s: %s\n"", answer, changes));
 				out.write(String.format(""Case #%s: %s\n"", answer, changes));
 				answer++;
 			}
 			out.close();
 			in.close();
 		} catch (FileNotFoundException e) {
 			System.out.println(""I'd want to know"");
 		} catch (IOException e) {
 			System.out.println(""I'd want to know io"");
 		}
 		System.out.println(""done"");
 	}
 
 	private static long getChanges(long size, int index, List<Long> motes) {
 		Long newMote = motes.get(index);
 		if (index == motes.size() -1) {
 			if(newMote < size) {
 				return 0;
 			} else {
 				return 1;
 			}
 		}
 		if (newMote < size) {
 			return getChanges(newMote + size, index + 1, motes);
 		}
 		if(size <= 1) {
 			return 1 + getChanges(size, index + 1, motes);
 		}
 		long choice1 = 1 + getChanges(size + size - 1, index, motes);
 		long choice2 = 1 + getChanges(size, index + 1, motes);
 		return choice1 < choice2 ? choice1 : choice2;
 	}
 
 }
","package qualifierFun;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.HashSet;
 import java.util.Set;
 
 
 public class Round1CQ1 {
 
 	private static Set<Character> vowels;
 	
 	static {
 		vowels = new HashSet<Character>();
 		vowels.add('a');
 		vowels.add('e');
 		vowels.add('i');
 		vowels.add('o');
 		vowels.add('u');
 	}
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			PrintWriter out = new PrintWriter(new FileWriter(""output1c1.txt"")); 
 			BufferedReader in  = new BufferedReader(new FileReader(""input.txt""));
 			int answer =1;
 			String strLine = in.readLine();
 			int totalCases = Integer.parseInt(strLine);
 			for(int i = 0; i < totalCases; i++) {
 				strLine = in.readLine();
 				String inputs[] = strLine.split("" "");
 				String name = inputs[0];
 				int n = Integer.parseInt(inputs[1]);
 				long score = getScore(name, n);
 				System.out.print(String.format(""Case #%s: %s\n"", answer, score));
 				out.write(String.format(""Case #%s: %s\n"", answer, score));
 				answer++;
 			}
 			out.close();
 			in.close();
 		} catch (FileNotFoundException e) {
 			System.out.println(""I'd want to know"");
 		} catch (IOException e) {
 			System.out.println(""I'd want to know io"");
 		}
 		System.out.println(""done"");
 	}
 
 	private static long getScore(String name, int n) {
 		long score = 0;
 		int streakSize = 0;
 		int lastStreakIndex = -1;
 		for(int i = 0; i < name.length(); i++) {
 			if (isVowel(name.charAt(i))) {
 				streakSize = 0;
 			} else {
 				streakSize++;
 			}
 			if (streakSize >= n) {
 				int behind = 1 + (i-lastStreakIndex - n);
 				int ahead = name.length() - i;
 				score += behind * ahead;
 				lastStreakIndex = i - n + 1;
 			} 
 		}
 		return score;
 	}
 
 	private static boolean isVowel(char test) {
 		return vowels.contains(test);
 	}
 
 }
",1
26,20635,"
 import java.util.ArrayList;
 import java.util.Collections;
 
 
 
 public class Main {
     public static long factorial(int n )
     {
         if( n <= 1 )     // base case
             return 1;
         else
             return n * factorial( n - 1 );
     }
 
     public static void main(String[] args) {
          try {
             java.util.Scanner s = new java.util.Scanner( new java.io.File(""D-large.in"") );
             java.io.FileWriter fw = new java.io.FileWriter( new java.io.File(""output.out"") );
             ArrayList list1 = new ArrayList();
             ArrayList list2 = new ArrayList();
             int cases = s.nextInt();
  
             String result = """";
             for(int k = 1; k <= cases; k++){
                 int pitufina = 0;
                 list1.clear();
                 list2.clear();
                 int n = s.nextInt();
                 for(int j = 1; j <= n; j++){
                     int aux = s.nextInt();
                     list1.add(aux);
                     list2.add(aux);
                  }
                 Collections.sort(list2);
                 for(int p = list2.size()-1; p >= 0; p--){
                    if(list1.get(p)==list2.get(p)){
                        list1.remove(p);
                        list2.remove(p);
                    }
                 }
                result += ""Case #"" + k + "": "" + list2.size() + "".000000"" + ""\n"";
 
                 }
 
 
             fw.write("""" + result);
             fw.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 }
 
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 
 public class Keys {
 
 	static int[] can;
 	static int[] nextOpen;
 	static int[] lock;
 	static int[][] keysIn;
 	static int[] iniKeys;
 	static int n;
 	
 	static int dp(int x){
 		if(can[x]!=-1){
 			return can[x];
 		}
 		
 		boolean allOpened = true;
 		
 		for(int i =0; i<n; i++){
 			boolean isClosed = (x&(1<<i))==0;
 			
 			if(isClosed)
 				allOpened = false;
 			
 			if (isClosed && canOpen(i,x) ){ // Is closed
 				if(dp(x | 1<<i) == 1){
 					can[x] = 1;
 					nextOpen[x] = i;
 					return can[x];
 				}
 			}
 		}
 		
 		if(allOpened) {
 			can[x] = 1;
 		} else {
 			can[x] = -2;
 		}
 		
 		return can[x];
 	}
 	
 	
 	
 	static boolean canOpen(int chest, int conf){
 		
 		int needed = lock[chest];
 		int keysAv = iniKeys[needed];
 				
 		for(int i =0; i<n; i++){
 			if ((conf&(1<<i))!=0){ // Is open
 				if(lock[i]==needed){ // Subtract the lock if the same key
 					keysAv--;
 				}
 				keysAv+=keysIn[i][needed]; // Add the keys needed from the chest
 			}
 		}
 		
 		if (keysAv>0) 
 			return true;
 		else 
 			return false;
 	}
 	
 	static int[] build(){
 		
 		int mask = 0;
 		
 		int[] res = new int[n];
 		
 		for(int i=0; i<n; i++){
 			res[i] = nextOpen[mask];
 			mask |= 1<<nextOpen[mask];
 		}
 		
 		return res;
 	}
 	
 	public static void main(String[] args) {
 		FastScanner sc = new FastScanner(System.in);
 		
 		int cases = sc.nextInt();
 		
 		for(int c = 0; c<cases; c++){
 			
 			int k = sc.nextInt();
 			n = sc.nextInt();
 			
 			iniKeys  = new int[201];
 			for(int i=0; i<k; i++){
 				iniKeys[sc.nextInt()-1]++;
 			}
 			
 			lock = new int[n];
 			keysIn = new int[n][201];
 			
 			for(int i=0; i<n; i++){
 				lock[i] = sc.nextInt()-1;
 				int in = sc.nextInt();
 				for(int j=0; j<in; j++){
 					keysIn[i][sc.nextInt()-1]++;
 				}
 			}
 			
 			can = new int[1<<n];
 			nextOpen = new int[1<<n];
 			Arrays.fill(can, -1);
 			Arrays.fill(nextOpen, -1);
 			
 				
 			if(dp(0)==1){
 				int res[] = build();
 				String r = """";
 				
 				for (int i = 0; i < n; i++) {
 					if (i != 0)
 						r+="" "";
 					r+=(res[i]+1);
 				}
 				
 				System.out.printf(""Case #%d: %s\n"", c+1,r);
 			} else{
 				System.out.printf(""Case #%d: IMPOSSIBLE\n"", c+1);
 			}
 			
 		}
 
 	}
 
 	static class FastScanner {
 		BufferedReader br;
 		StringTokenizer st;
 
 		public FastScanner(File f) {
 			try {
 				br = new BufferedReader(new FileReader(f));
 			} catch (FileNotFoundException e) {
 				e.printStackTrace();
 			}
 		}
 
 		public FastScanner(InputStream f) {
 			br = new BufferedReader(new InputStreamReader(f));
 		}
 
 		String next() {
 			while (st == null || !st.hasMoreTokens()) {
 				String s = null;
 				try {
 					s = br.readLine();
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 				if (s == null)
 					return null;
 				st = new StringTokenizer(s);
 			}
 			return st.nextToken();
 		}
 
 		boolean hasMoreTokens() {
 			while (st == null || !st.hasMoreTokens()) {
 				String s = null;
 				try {
 					s = br.readLine();
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 				if (s == null)
 					return false;
 				st = new StringTokenizer(s);
 			}
 			return true;
 		}
 
 		int nextInt() {
 			return Integer.parseInt(next());
 		}
 
 		long nextLong() {
 			return Long.parseLong(next());
 		}
 		
 		double nextDouble(){
 			return Double.parseDouble(next());
 		}
 	}
 }
",0
27,17857,"package pd.codejam.qr.problem_b;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 public class Main {
 
 	static String input_filename = ""B-large.in"";
 	static BufferedReader in;
 	
 	static int matrix_width, matrix_height;
 	static int[][] matrix;
 	
 	
 	static String getMessage(int code)
 	{
 		switch (code)
 		{
 		case 0:
 			return ""NO"";
 		case 1:
 			return ""YES"";
 		default :
 			return ""NA"";
 		}
 	}
 	
 	
 	public static void main(String args[]) throws NumberFormatException, IOException
 	{
 		int numOfCase = readFirstLine();
 //		System.out.println(""numOfCase="" + numOfCase);
 		
 //		char data[] = new char[16];
 		for (int i = 0; i < numOfCase; ++i)
 		{
 			readMatrixDimension();
 			readMatrix();
 			System.out.println(String.format(""Case #%d: %s"", i + 1, getMessage(analysis())));
 		}
 	}
 
 
 	private static int analysis() {
 		
 		for (int y = 0; y < matrix_height; ++y)
 		{
 			for (int x = 0; x < matrix_width; ++x)
 			{
 				if (scanVertical(x, y) == 0 && scanHorizontal(x, y) == 0)
 					return 0;
 			}
 		}
 		
 		return 1;
 	}
 
 
 	private static int scanHorizontal(int x, int y) {
 		for (int xx = 0; xx < matrix_width; ++xx)
 		{
 			if (matrix[y][xx] > matrix[y][x])
 				return 0;
 		}
 		return 1;
 	}
 
 
 	private static int scanVertical(int x, int y) {
 		for (int yy = 0; yy < matrix_height; ++yy)
 		{
 			if (matrix[yy][x] > matrix[y][x])
 				return 0;
 		}
 		return 1;
 	}
 
 
 	private static void readMatrix() throws IOException {
 		
 		for (int y = 0; y < matrix_height; ++y)
 		{
 			String[] line = in.readLine().trim().split("" "");
 			if (line.length != matrix_width)
 				throw new IOException(""matrix exception"");
 			
 			for (int x = 0; x < matrix_width; ++x)
 			{
 				matrix[y][x] = Integer.parseInt(line[x]);
 //				System.out.println(String.format(""[%d][%d]=%d"", y, x, matrix[y][x]));
 			}
 		}
 	}
 
 
 	private static void readMatrixDimension() throws IOException {
 		String[] line = in.readLine().trim().split("" "");
 		if (line.length != 2)
 			throw new IOException(""dimension exception"");
 		
 		matrix_height = Integer.parseInt(line[0]);
 		matrix_width = Integer.parseInt(line[1]);
 		
 //		System.out.println(""matrix_width="" + matrix_width);
 //		System.out.println(""matrix_height="" + matrix_height);
 		
 		matrix = new int[matrix_height][matrix_width];
 	}
 
 
 	private static int readFirstLine() throws NumberFormatException, IOException {
 		in = new BufferedReader(new InputStreamReader(Main.class.getResourceAsStream(input_filename)));
 		return Integer.parseInt(in.readLine());
 	}
 }
","package com.gzroger.codejam2010.qualification;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.ObjectInputStream.GetField;
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.StringTokenizer;
 
 public class BFairWarning {
 
 	int N;
 	BigDecimal[] t;
 	
 	public BFairWarning(int n, BigDecimal[] t) {
 		this.N = n;
 		this.t = t;
 	}
 
 
 	private BigDecimal getOptAnn() {
 		HashSet<BigDecimal> set = new HashSet<BigDecimal>(); 
 		for (int i=0; i<N; i++) {
 			//System.out.println(t[i]);
 			for (int j=i+1; j<N; j++) {
 				if (!t[i].equals(t[j])) {
 					set.add(t[i].subtract(t[j]).abs());
 				}
 			}
 		}
 		
 		BigDecimal gcd = getGCD(set);
 		System.out.println(""gcd: ""+gcd); 
 		
 		
 		BigDecimal max = new BigDecimal(0);
 		for (int i=0; i<N; i++) {
 /*			System.out.println(t[i].divide(gcd, RoundingMode.CEILING));
 			System.out.println(t[i].divide(gcd, RoundingMode.CEILING).multiply(gcd));
 			System.out.println(t[i]);*/
 			BigDecimal count = t[i].divide(gcd, RoundingMode.CEILING).multiply(gcd).subtract(t[i]);
 //			System.out.println(max+"", ""+count);
 			if (count.compareTo(max)>0) {
 				max = count;
 			}
 		}
 		
 		return max;
 	}
 	
 	private static BigDecimal getGCD(HashSet<BigDecimal> set) {
 		//System.out.println(set);
 		Iterator<BigDecimal> it = set.iterator(); 
 		BigDecimal result = it.next();
 		while (it.hasNext()) {
 			result = getGCD(result, it.next());
 		}
 		
 		return result;
 	}
 
 	private static BigDecimal getGCD(BigDecimal bd1, BigDecimal bd2) {
 		BigDecimal d1;
 		BigDecimal d2;
 		if (bd1.compareTo(bd2)>=0) {
 			d1 = bd1;
 			d2 = bd2;
 		} else {
 			d1 = bd2;
 			d2 = bd1;
 		}
 		while (!d2.equals(BigDecimal.ZERO)) {
 			BigDecimal remainder = d1.remainder(d2);
 			d1 = d2;
 			d2 = remainder;
 		}
 		//System.out.println(bd1+"", ""+bd2+"": ""+d1);
 		return d1;
 	}
 
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 /*		
 		BigDecimal bd84 = new BigDecimal(84);
 		BigDecimal bd18 = new BigDecimal(18);
 		BigDecimal bd27 = new BigDecimal(27);
 		HashSet<BigDecimal> hs = new HashSet<BigDecimal>();
 		hs.add(bd84);
 		hs.add(bd18);
 		hs.add(bd27);
 		
 		System.out.println(getGCD(bd84, bd18));
 		System.out.println(getGCD(bd84, bd27));
 		System.out.println(getGCD(bd18, bd27));
 		System.out.println(getGCD(hs));
 		{
 				int N = 1000;
 				BigDecimal add = new BigDecimal(10).pow(30);
 				BigDecimal mul = new BigDecimal(999);
 				BigDecimal[] t = new BigDecimal[N];
 				for (int j = 0; j<N; j++) {
 					BigDecimal jdec = new BigDecimal(j);
 					t[j] = add.add(jdec).multiply(mul);
 					mul = mul.add(jdec);
 				}
 
 				BFairWarning fw = new BFairWarning(N, t);
 				Date d = new Date();
 				BigDecimal optAnn = fw.getOptAnn();
 				System.out.println( ""Case #""+ "": "" + optAnn );
 		}
 		if (true) return;
 */
 		
 		
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(args[0]));
 			
 			PrintStream ps;
 			if (args.length>1) {
 				ps = new PrintStream(args[1]);
 			} else {
 				ps = System.out;
 			}
 			int C;
 			String firstLine = br.readLine();
 			C = Integer.parseInt(firstLine);
 			Date dStart = new Date();
 			for (int i=0;i<C;i++) {
 				StringTokenizer st = new StringTokenizer(br.readLine());
 				int N = Integer.parseInt( st.nextToken() );
 				BigDecimal[] t = new BigDecimal[N];
 				for (int j = 0; j<N; j++) {
 					t[j] = new BigDecimal(st.nextToken());
 				}
 
 				BFairWarning fw = new BFairWarning(N, t);
 				Date d = new Date();
 				BigDecimal optAnn = fw.getOptAnn();
 				ps.println( ""Case #""+ (i+1) + "": "" + optAnn );
 				System.out.println(""Case #""+ (i+1) +"" time in ms: ""+(new Date().getTime()-d.getTime()));
 			}
 			Date dEnd = new Date();
 			System.out.println(""Runtime in ms: ""+(dEnd.getTime() - dStart.getTime()));
 
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
",0
28,8022,"package cookieClicker;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 
 public class CookieClicker {
 
 	public static void main(String[] args) {
 		try{
 		String fileName = ""C:\\Users\\Beez\\CodeJam2014\\B-small-attempt0.in"";
 		String outName = ""C:\\Users\\Beez\\CodeJam2014\\B-Small-out.txt"";
 		BufferedReader in = new BufferedReader(new FileReader(fileName));
 		int t = Integer.parseInt(in.readLine());
 		String answer[] = new String[t];
 		for(int i = 0; i < t; i++){
 			String line = in.readLine();
 			double c = Double.parseDouble(line.split("" "")[0]);
 			double f = Double.parseDouble(line.split("" "")[1]);
 			double x = Double.parseDouble(line.split("" "")[2]);
 			double time = 0;
 			double cookiePerSecond = 2;
 			while((x - c) / cookiePerSecond > x / (cookiePerSecond + f)){
 				time += c / cookiePerSecond;
 				cookiePerSecond += f;
 			}
 			time += x / cookiePerSecond;
 			answer[i] = ""Case #"" + (i + 1) + "": "" + time;
 		}
 		in.close();
 		PrintWriter out = new PrintWriter(new FileWriter(outName));
 		for(int i = 0; i < t; i++){
 			out.println(answer[i]);
 		}
 		out.close();
 		}catch(Exception e){
 			System.out.println(""Error running program"");
 			e.printStackTrace();
 		}
 
 	}
 
 }
","package cookieClicker;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 
 public class CookieClicker {
 
 	public static void main(String[] args) {
 		try{
 		String fileName = ""C:\\Users\\Beez\\CodeJam2014\\B-large.in"";
 		String outName = ""C:\\Users\\Beez\\CodeJam2014\\B-Small-out.txt"";
 		BufferedReader in = new BufferedReader(new FileReader(fileName));
 		int t = Integer.parseInt(in.readLine());
 		String answer[] = new String[t];
 		for(int i = 0; i < t; i++){
 			String line = in.readLine();
 			double c = Double.parseDouble(line.split("" "")[0]);
 			double f = Double.parseDouble(line.split("" "")[1]);
 			double x = Double.parseDouble(line.split("" "")[2]);
 			double time = 0;
 			double cookiePerSecond = 2;
 			while((x - c) / cookiePerSecond > x / (cookiePerSecond + f)){
 				time += c / cookiePerSecond;
 				cookiePerSecond += f;
 			}
 			time += x / cookiePerSecond;
 			answer[i] = ""Case #"" + (i + 1) + "": "" + time;
 		}
 		in.close();
 		PrintWriter out = new PrintWriter(new FileWriter(outName));
 		for(int i = 0; i < t; i++){
 			out.println(answer[i]);
 		}
 		out.close();
 		}catch(Exception e){
 			System.out.println(""Error running program"");
 			e.printStackTrace();
 		}
 
 	}
 
 }
",1
29,16209,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.File;
 
 public class Consonants {
 	String personName;
 	long howManyConsonants;
 	long howManySubs;
 
 	public Consonants() {
 		
 		//Data Structure
 //		char[][] matrix;
 		
 		//other variables
 		boolean isFirst = true;
 		BufferedReader br = null;
 		String[] currentLine;
 		char[] currentLineChar;
 		
 		long numberTestCases= 0;
 		long testCase = 1;
 		
 		try {
  
 			String sCurrentLine;
  
 			File file = new File(""C:\\Users\\Utente\\Downloads\\Google JAM\\Consonants\\A-small-attempt3.out"");
 			FileWriter fw = new FileWriter(file.getAbsoluteFile());
 			BufferedWriter bw = new BufferedWriter(fw);
 
 			// if file doesnt exists, then create it
 			if (!file.exists()) {
 				file.createNewFile();
 			}
 
 			br = new BufferedReader(new FileReader(""C:\\Users\\Utente\\Downloads\\Google JAM\\Consonants\\A-small-attempt3.in""));
  
 			while ((sCurrentLine = br.readLine()) != null) {
 				
 				if(isFirst){
 					currentLine = sCurrentLine.split("" "");
 					numberTestCases = Long.parseLong(currentLine[0],10);
 					isFirst = false;
 					
 				}else{
 					currentLine = sCurrentLine.split("" "");
 					personName = currentLine[0];					
 					howManyConsonants = Integer.parseInt(currentLine[1]);
 										
 					//Solve the problem
 					long result = evaluate();
 					
 					bw.write(""Case #"" + testCase++ + "": "" + result + ""\n"");
 //					bw.write(""Case #"" + testCase++ + ""\n"");
 					
 					
 				}
 			}
 			bw.close();
  
 		} catch (IOException e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (br != null)br.close();
 			} catch (IOException ex) {
 				ex.printStackTrace();
 			}
 		}
  
 	};
 	
 	
 	private long evaluate(){
 		long evaluation = 0;
 		howManySubs =0;
 		
 		//for all substrings in personName
 		suffixGen(personName);
 		
 		return howManySubs;
 	}
 	
 	
 	public void generate(String word) 
 	{
 
 	    if (word.length() == 1 || word.length() <= howManyConsonants)
 	    {
 //	        System.out.println(word);
 	    	boolean hasEnough = scanWord(word);
 	    	if(hasEnough){
 	    		howManySubs++;
 	    	}
 	    	
 	        return;
 	    }
 
 	    if (word.length() != 0)
 	    {
 //	        System.out.println(word);
 	    	//use word!
 	    	boolean hasEnough = scanWord(word);
 	    	if(hasEnough){
 	    		howManySubs++;
 	    	}
 	    		
 	        generate(word.substring(0, word.length()-1)); 
 	    }
 	}
 	
 	public void suffixGen(String word)
 	{
 	    if (word.length() >= 1 && word.length() >= howManyConsonants)
 	    {
 	        generate(word);
 	        suffixGen(word.substring(1));
 	    }
 
 	}
 	
 	private boolean scanWord(String word){
 		int tempCount = 0;
 		//		howManyConsonants
 //        System.out.println(word);
 		char[] wordSplit = word.toCharArray();
 		
 		for(int i=0; i< wordSplit.length; i++){
 			if(wordSplit[i] != 'a' && wordSplit[i] != 'e' && wordSplit[i] != 'i' && wordSplit[i] != 'o' && wordSplit[i] != 'u'){
 				tempCount++;
 				if(tempCount >= howManyConsonants){
 					return true;
 				}
 			}else{
 				tempCount=0;
 			}
 		}
 		return false;
 	}
 	
 	/*Main class*/
 	public static void main(String[] args)
 	{
 		new Consonants();	           
 	}
 }
 
 
","package round1A2013;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Locale;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class Main {
 	
 	private boolean isValid(int n) {
 		while (n != 0) {
 			int m = n % 10;
 			if (m < 2 || m > 5) {
 				return false;
 			}
 			n /= 10;
 		}
 		
 		return true;
 	}
 	
 	private int getProduct(int n, int mask) {
 		int res = 1;
 		while (n != 0) {
 			int m = n % 10;
 			if (mask % 2 == 1) {
 				res *= m;
 			}
 			
 			n /= 10;
 			mask /= 2;
 		}
 		
 		return res;
 	}
 
 	private void solve() throws IOException {
 		
 		Set<Integer>[] a = new Set[600];
 		for (int i = 222; i <= 555; i++) {
 			a[i] = new HashSet<>();
 			
 			if (isValid(i)) {
 				for (int mask = 0; mask < 8; mask++) {
 					a[i].add(getProduct(i, mask));
 				}
 			}
 		}
 		
 		int tests = nextInt();
 		for (int t = 1; t <= tests; t++) {
 			println(""Case #"" + t + "":"");
 
 			int r = nextInt();
 			int n = nextInt();
 			int m = nextInt();
 			int k = nextInt();
 			
 			for (int i = 0; i < r; i++) {
 				int[] b = new int[k];
 				for (int j = 0; j < k; j++) {
 					b[j] = nextInt();
 				}
 				
 				ArrayList<Integer> res = new ArrayList<>();
 				for (int p = 222; p <= 555; p++) {
 					boolean f = true;
 					for (int j = 0; j < k; j++) {
 						if (!a[p].contains(b[j])) {
 							f = false;
 							break;
 						}
 					}
 					
 					if (f) {
 						res.add(p);
 					}
 				}
 				
 				Collections.shuffle(res);
 				println(res.get(0));
 			}
 		}
 	}
 
 	private String nextToken() throws IOException {
 		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
 			tokenizer = new StringTokenizer(reader.readLine());
 		}
 		return tokenizer.nextToken();
 	}
 
 	private int nextInt() throws NumberFormatException, IOException {
 		return Integer.parseInt(nextToken());
 	}
 
 	private double nextDouble() throws NumberFormatException, IOException {
 		return Double.parseDouble(nextToken());
 	}
 
 	private long nextLong() throws IOException {
 		return Long.parseLong(nextToken());
 	}
 
 	private void print(Object o) {
 		writer.print(o);
 	}
 
 	private void println(Object o) {
 		writer.println(o);
 	}
 
 	private void printf(String format, Object... o) {
 		writer.printf(format, o);
 	}
 
 	public static void main(String[] args) {
 		long time = System.currentTimeMillis();
 		Locale.setDefault(Locale.US);
 		new Main().run();
 		System.err.printf(""%.3f\n"", 1e-3 * (System.currentTimeMillis() - time));
 	}
 
 	BufferedReader reader;
 	StringTokenizer tokenizer;
 	PrintWriter writer;
 
 	private void run() {
 		try {
 			reader = new BufferedReader(new FileReader(new File(""input.in"")));
 			writer = new PrintWriter(new File(""output.out""));
 			solve();
 			reader.close();
 			writer.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.exit(13);
 		}
 	}
 }",0
30,8532,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package googlecodejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Formatter;
 import java.util.Scanner;
 
 /**
  *
  * @author pavlos
  */
 public class ReadFile {
     private static Scanner input;
     public static void OpenFile(String name) throws FileNotFoundException
     {
         input = new Scanner(new File(name));
     }
     public static String ReadFromFile()
     {
        return input.next();
     }
     public static void CloseFile()
     {
         input.close();
     }
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package googlecodejammag;
 
 import java.io.FileNotFoundException;
 import java.util.Formatter;
 
 /**
  *
  * @author pavlos
  */
 public class WriteFile {
 private static Formatter output;
 public static void OpenFile(String name) throws FileNotFoundException
 {
     output = new Formatter(name);
 }
 public static void WriteToFile(String x)
 {
     output.format(x);
 }
 public static void CloseFile()
 {
     output.close();
 }
 }
",1
31,536,"import java.util.*;
 
 public class CodeJam3
 {
 	public static void main(String[] args)
 	{
 		Scanner sc= new Scanner(System.in);
 		int tt = sc.nextInt();
 		int[] n = new int[1001];
 		n[1] = 1;
 		// ArrayList<Long> arr = new ArrayList<Long>();
 		long[] arr = {1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,100020001,102030201,104060401,121242121,
 						123454321,125686521,400080004,404090404,10000200001l,10221412201l,12102420121l,12345654321l,40000800004l,
 						1000002000001l,1002003002001l,1004006004001l,1020304030201l,1022325232201l,1024348434201l,1210024200121l,
 						1212225222121l,1214428244121l,1232346432321l,1234567654321l,4000008000004l,4004009004004l};
 		// for(long i=1;i<10000001;i++)
 		// {
 			// if(pal(i))
 			// {
 				// long a = i*i;
 				// if(pal(a))
 				// {
 					// arr.add(a);
 					// System.out.println(a);
 				// }
 			// }
 		// }
 		for(int kk=1;kk<=tt;kk++)
 		{
 			long a = Long.parseLong(sc.next());
 			long b = Long.parseLong(sc.next());
 			int c = binarySearch(arr,a-1,0,38);
 			int d = binarySearch(arr,b,0,38);
 			System.out.printf(""Case #%d: %d\n"",kk,d-c);
 		}
 	}
 	public static boolean square(long n)
 	{
 		long tst = (long)(Math.sqrt(n) + 0.5);
 		return tst*tst == n;
 	}
 	public static boolean pal(long n)
 	{
 		String a = n+"""";
 		String b = new StringBuffer(a).reverse().toString();
 		return (a.equals(b));
 	}
 	private static int binarySearch(long[] arr, long searchValue, int left, int right) 
 	{
 		if (right < left) {
 				return left - 1;
 		}
 		int mid = (left + right) >>> 1;
 		if (searchValue > arr[mid]) {
 				return binarySearch(arr, searchValue, mid + 1, right);
 		} else if (searchValue < arr[mid]) {
 				return binarySearch(arr, searchValue, left, mid - 1);
 		} else {
 				return mid;
 		}               
     }
 }","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class SnapperChain
 {
 	int[] minSnaps;
 	public SnapperChain()
 	throws Exception
 	{
 		BufferedReader reader = new BufferedReader(new FileReader(""A-small-attempt3.in""));
 		PrintWriter out = new PrintWriter(""output"");
 		
 		fillMinSnaps();
 		
 		int testCases = Integer.parseInt(reader.readLine());
 		
 		for(int x=1;x<=testCases;x++)
 		{
 			StringTokenizer line = new StringTokenizer(reader.readLine(),"" "");
 			int devices = Integer.parseInt(line.nextToken());		//N
 			int snaps = Integer.parseInt(line.nextToken());			//K
 			
 			boolean on = solveProblem(devices,snaps);
 			if(on)
 				out.write(""Case #""+x+"": ON\n"");
 			else
 				out.write(""Case #""+x+"": OFF\n"");
 		}
 		out.close();
 	}
 	
 	public boolean solveProblem(int devices, int snaps)
 	{
 		if(devices==1)
 		{
 			if(snaps%2==0)
 				return false;
 			return true;
 		}
 		while(snaps>minSnaps[devices])
 		{
 			snaps-=minSnaps[devices];
 			snaps--;
 		}
 		if(minSnaps[devices]>snaps)
 			return false;
 		else if (minSnaps[devices]==snaps)
 			return true;
 		return false;
 	}
 	
 	public void fillMinSnaps()
 	{
 		minSnaps = new int[32];
 		minSnaps[1]=1;
 		for(int x=2;x<minSnaps.length;x++)
 		{
 			minSnaps[x] = minSnaps[x-1]*2+1;
 		}
 	}
 	
 	public static void main(String args[])
 	{
 		try {
 			new SnapperChain();
 		} catch (Exception e) {e.printStackTrace();}
 	}
 }
",0
32,3320,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.LinkedList;
 import java.util.Vector;
 
 
 public class Round2ProblemA {
 
 	private Vector<Case> cases;
 	
 	public Round2ProblemA(){
 		cases=new Vector<Case>();
 	}
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		String inputName;
 		String outputName;
 		
 		if(args.length<1) {
 			inputName=""testA.in"";
 			outputName=""testA.out"";
 		} else {
 		    inputName=args[0];
 		    outputName=inputName+"".out"";
 		}
 		
 		Round2ProblemA slover=new Round2ProblemA();
         try {
 			if(!slover.readInputFile(inputName))
 				return;
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.err.println(""Input file ""+inputName+"" read failed"");
 			return;
 		}
 		//slover.slove();
 		try {
 			slover.writeResult(outputName);
 		} catch (IOException e) {
 			System.err.println(""Output file ""+outputName+"" write failed"");
 			return;
 		}
 
 	}
 	
 	class Directory {
 		String name;
 		Vector<Directory> subDirectories;
 		
 		public Directory(String name) {
 			this.name=name;
 			subDirectories=new Vector<Directory>();
 		}
 	}
 	
 	class Case {
         int N;
         int M;
         //Vector<String> existPaths;
         //Vector<String> toAddPaths;
         Directory root;
         int counter;
         
         public Case() {
         	root=new Directory(""""); 
             counter=0;
         }
         
         private boolean findNode(Directory node, LinkedList<String> subs) {
         	
         	String first=subs.getFirst();
         	
         	for(int i=0; i<node.subDirectories.size(); i++) {
         		Directory sub=node.subDirectories.get(i);
         		if(first.equals(sub.name)) {
         		   subs.removeFirst();
         		   if(subs.isEmpty()) {
         			   return true;
         		   } else {
         			   return findNode(sub, subs);
         		   }
         	    }
         	}
         	
 			return false;
         }
         
         
         private int addNode(Directory node, LinkedList<String> subs) {
         	
         	String first=subs.getFirst();
         	
         	for(int i=0; i<node.subDirectories.size(); i++) {
         		Directory sub=node.subDirectories.get(i);
         		if(first.equals(sub.name)) {
         		   subs.removeFirst();
         		   if(subs.isEmpty()) {
         			   return 0;
         		   } else {
         			   return addNode(sub, subs);
         		   }
         	    }
         	}
         	
         	int addCount=0;
         	Directory currDirectory=node;
         	
         	for(String sub : subs) {
         		Directory subDirectory=new Directory(sub);
         		currDirectory.subDirectories.add(subDirectory);
         		currDirectory=subDirectory;
         		addCount++;
         	}
         	
 			return addCount;
         }
         
         public void addDirectoryNew(String path) {
         	
         	String [] directories=path.split(""/"");
             LinkedList<String> pathList=new LinkedList<String>();
             for(int i=1; i<directories.length; i++) {
                pathList.addLast(directories[i]);
             }
             counter+=addNode(root, pathList);
         }
         
         public void addDirectoryExist(String path) {
         
         	String [] directories=path.split(""/"");
             LinkedList<String> pathList=new LinkedList<String>();
             for(int i=1; i<directories.length; i++) {
                pathList.addLast(directories[i]);
             }
             addNode(root, pathList);
         }
 	}
 	
 	
 	public boolean readInputFile(String file_name) throws IOException
 	{
 		
 		BufferedReader br=new BufferedReader(new FileReader(file_name));
 		String firstLine=br.readLine();
 		if(firstLine==null||"""".equals(firstLine)) {
 			System.err.printf(""First line of input file %s read failed\n"", file_name);
 			return false;
 		}
 
 		int caseNumber=Integer.parseInt(firstLine);
 		
 		for(int i=0; i<caseNumber; i++) {
 		   String line1=br.readLine();
 			
 		   Case jamCase=new Case();
 		   try {
 		       String [] jamCaseParams=line1.split("" "");
 		       jamCase.N=Integer.parseInt(jamCaseParams[0]);
 		       jamCase.M=Integer.parseInt(jamCaseParams[1]);
 		       
 		       if(jamCase.N<0||jamCase.M<0) 
 		       {
 		    	   System.err.printf(""Input line1 error at %d %d %d\n"", jamCase.N, jamCase.M);
 		    	   return false;
 		       }
 		   } catch(Exception e) {
 			   System.err.printf(""Input line1 %s parse failed\n"", line1);
 			   return false;  
 		   }
 		
 		   for(int n=0; n<jamCase.N; n++) {
 			   String path=br.readLine();
 			   jamCase.addDirectoryExist(path);
 		   }
 		   
 		   
 		   for(int m=0; m<jamCase.M; m++) {
 			   String path=br.readLine();
 			   jamCase.addDirectoryNew(path);
 		   }
 		   
            cases.add(jamCase);
 		}
 		return true;
 	}
 	
 	
 	/*
 	public boolean slove() {
 		  for(int i=0; i<cases.size(); i++) {
 			  Case jamCase=cases.get(i);
 			  individualSlove(jamCase);
 		  }	
 		  return true;
     }
 	*/
 	
 	public boolean writeResult(String outputFile) throws IOException {
 		  FileWriter fw=new FileWriter(outputFile);
 		  for(int i=0; i<cases.size(); i++) {
 			Case jamCase=cases.get(i);
 			fw.write(""Case #""+(i+1)+"": ""+jamCase.counter+""\n"");
 		  }
 		  fw.flush();
 		  fw.close();
 		  return true;
 		  
 	}
 	
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Hashtable;
 import java.util.Vector;
 
 
 public class ProblemB {
 
 	private Vector<Case> cases;
 	
 	public ProblemB(){
 		cases=new Vector<Case>();
 	}
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		String inputName;
 		String outputName;
 		
 		if(args.length<1) {
 			inputName=""testB.in"";
 			outputName=""testB.out"";
 		} else {
 		    inputName=args[0];
 		    outputName=inputName+"".out"";
 		}
 		
 		ProblemB slover=new ProblemB();
         try {
 			if(!slover.readInputFile(inputName))
 				return;
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.err.println(""Input file ""+inputName+"" read failed"");
 			return;
 		}
 		slover.slove();
 		try {
 			slover.writeResult(outputName);
 		} catch (IOException e) {
 			System.err.println(""Output file ""+outputName+"" write failed"");
 			return;
 		}
 
 	}
 
 	class CombineRelation {
 		char K2;
 		char V;
 	}
 	
 	class OppositeRelation {
 		char K2;
 	}
 	
 	class Case {
 		
         Hashtable<Character, Vector<CombineRelation>> combineTable;
         Hashtable<Character, Vector<OppositeRelation>> oppositeTable;
         String input;
         char [] result;
         int ptr;
         
         public Case() {
         	result = new char[100];
         	ptr = 0;
         	combineTable = new Hashtable<Character, Vector<CombineRelation>>(); 
         	oppositeTable = new Hashtable<Character, Vector<OppositeRelation>>();
         }
         
         public void solve() {
         	char [] inputChars = input.toCharArray();
         	result[ptr]=inputChars[0];
         	ptr++;
         	
 MAIN_LOOP:    for(int i=1; i<inputChars.length; i++) {
         		
 				Vector<CombineRelation> combineList = combineTable.get(inputChars[i]);
         		if(combineList !=null && ptr>0) {
         			for(int c=0; c<combineList.size(); c++){
         				CombineRelation combine = combineList.get(c);
         				if(combine.K2 == result[ptr-1]){
 		        			result[ptr-1]=combine.V;
 		        			continue MAIN_LOOP;
         				}
         			}
         		}
         		
         		Vector<OppositeRelation> oppositeList = oppositeTable.get(inputChars[i]);
         		if(oppositeList !=null && ptr>0) {
         			for(int o=0; o<oppositeList.size(); o++){
         				OppositeRelation opposite = oppositeList.get(o);
 	        			for(int k=ptr-1; k>=0; k--) {
 	        				if(result[k]==opposite.K2) {
 	        					ptr=0;
 	        					continue MAIN_LOOP;
 	        				}
 	        			}
         			}
         		}
         		        		
         		result[ptr]=inputChars[i];
         		ptr++;
         	}
         	
         }
         
 	}
 	
 	
 	public boolean readInputFile(String file_name) throws IOException
 	{
 		
 		BufferedReader br=new BufferedReader(new FileReader(file_name));
 		String firstLine=br.readLine();
 		if(firstLine==null||"""".equals(firstLine)) {
 			System.err.printf(""First line of input file %s read failed\n"", file_name);
 			return false;
 		}
 
 		int caseNumber=Integer.parseInt(firstLine);
 		
 		for(int i=0; i<caseNumber; i++) {
 		   String line1=br.readLine();
 		   String [] elements=line1.split("" "");
 		   Case jamCase=new Case();
 		   
 		   try {
 			   int index=0;
 		       int combine=Integer.parseInt(elements[index]);
 		       index++;
 		       if(combine!=0) {
 		    	   for(int c =0; c<combine; c++){
 			    	   char [] chars=elements[index].toCharArray();
 			    	   
 			    	   Vector<CombineRelation> relationList1 =  jamCase.combineTable.get(chars[0]);
 			    	   if(relationList1 == null){
 			    		   relationList1 = new Vector<CombineRelation>();
 			    		   jamCase.combineTable.put(chars[0], relationList1);
 			    	   }
 			    	   
 			    	   CombineRelation relation1=new CombineRelation();
 			    	   relation1.K2=chars[1];
 			    	   relation1.V=chars[2];
 			    	   relationList1.add(relation1);
 			    	   
 			    	   if(chars[1] != chars[0]){
 				    	   Vector<CombineRelation> relationList2 =  jamCase.combineTable.get(chars[1]);
 				    	   if(relationList2 == null){
 				    		   relationList2 = new Vector<CombineRelation>();
 				    		   jamCase.combineTable.put(chars[1], relationList2);
 				    	   }
 				    	   
 				    	   CombineRelation relation2=new CombineRelation();
 				    	   relation2.K2=chars[0];
 				    	   relation2.V=chars[2];
 				    	   relationList2.add( relation2);
 			    	   }
 			    	   
 			    	   index++;
 		    	   }
 		       }
 		       
 		       int opposite=Integer.parseInt(elements[index]);
 		       index++;
 		       if(opposite!=0) {
 		    	   for(int o=0; o<opposite; o++){
 			    	   char [] chars=elements[index].toCharArray();
 			    	   
 			    	   Vector<OppositeRelation> relationList1 =  jamCase.oppositeTable.get(chars[0]);
 			    	   if(relationList1 == null){
 			    		   relationList1 = new Vector<OppositeRelation>();
 			    		   jamCase.oppositeTable.put(chars[0], relationList1);
 			    	   }
 			    	   
 			    	   OppositeRelation relation1=new OppositeRelation();
 			    	   relation1.K2=chars[1];
 			    	   relationList1.add(relation1);
 			    	   
 			    	   if(chars[1] != chars[0]){
 			    		   Vector<OppositeRelation> relationList2 =  jamCase.oppositeTable.get(chars[1]);
 				    	   if(relationList2 == null){
 				    		   relationList2 = new Vector<OppositeRelation>();
 				    		   jamCase.oppositeTable.put(chars[1], relationList2);
 				    	   }
 			    		   
 			    		   OppositeRelation relation2=new OppositeRelation();
 				    	   relation2.K2=chars[0];
 				    	   relationList2.add(relation2);
 			    	   }
 			    	   
 			    	   index++;
 		    	   }
 		       }
 		       
 		       int length=Integer.parseInt(elements[index]);
 		       index++;
 		       jamCase.input=elements[index];
 		       
 		       cases.add(jamCase);
 		   } catch(Exception e) {
 			   e.printStackTrace();
 			   System.err.printf(""Input case %d parse failed\n"", i);
 			   return false;  
 		   }
 		}
 		
 		return true;
 	}
 	
 	
 	public boolean slove() {
 		  for(int i=0; i<cases.size(); i++) {
 			  Case jamCase=cases.get(i);
 			  jamCase.solve();
 		  }	
 		  return true;
     }
 	
 	
 	public boolean writeResult(String outputFile) throws IOException {
 		  FileWriter fw=new FileWriter(outputFile);
 		  for(int i=0; i<cases.size(); i++) {
 			Case jamCase=cases.get(i);
 			String result=""["";
 			for(int k=0; k<jamCase.ptr; k++) {
 				if(k==jamCase.ptr-1) {
 					result+=jamCase.result[k];
 				} else {
 					result+=jamCase.result[k]+"", "";
 				}
 			}
 			result+=""]"";
 			fw.write(""Case #""+(i+1)+"": ""+result+""\n"");
 		  }
 		  fw.flush();
 		  fw.close();
 		  return true;
 		  
 	}
 	
 }
 
",1
33,18631,"package com.google.codejam.roundC2013.consonants;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class Consonants {
 
     public static void main(String[] args) {
         String inputFile = args[0];
         String outputFile = args[1];
         readAndSolve(inputFile, outputFile);
     }
 
     private static int getResult(String name, int n) {
         int n_value = 0;
         for(int i = 0; i <= name.length()-n; i++){
             for(int j=i+n; j <= name.length(); j++){
                 if(isConsecutiveConsonants(name, i, j, n)){
                     n_value += name.length()-j+1;
                     break;
                 }
             }
         }
         return n_value;
     }
     
     private static boolean isConsecutiveConsonants(String name, int startIndex, int endIndex, int n){
         int consecutiveNumber=0;
         
         for(int i=startIndex; i < endIndex; i++){
             if(!isVowel(name.charAt(i))){
                 consecutiveNumber++;
                 if(consecutiveNumber>=n){
                     return true;
                 }
             }
             else{
                 consecutiveNumber=0;
             }
         }
         return false;
     }
     
     private static boolean isVowel(char c){
         if(c!='\0'){
             if(c=='a' || c=='e'|| c=='i'|| c=='o'|| c=='u'){
                 return true;
             }
         }
         return false;
     }
 
     public static String readAndSolve(String inFileName, String outFileName) {
         File file = new File(inFileName);
         BufferedReader bufferedReader = null;
         try {
             bufferedReader = new BufferedReader(new FileReader(file));
             FileWriter fileWriter = new FileWriter(outFileName, true);
             String readLine = null;
             int currentTestCaseIndex = 1;
             int line = 0;
 
             while ((readLine = bufferedReader.readLine()) != null) {
                 if (readLine.trim().length() <= 0) {
                     continue;
                 }
                 if (line == 0) {
                     line++;
                     continue;
                 }
                 String[] interval = readLine.split("" "");
                 String name = interval[0];
                 int n = Integer.valueOf(interval[1]);
                 int result = getResult(name, n);
                 fileWriter.append(""Case #"" + currentTestCaseIndex + "": "" + result);
                 fileWriter.append(""\n"");
                 currentTestCaseIndex++;
             }
             fileWriter.flush();
             fileWriter.close();
             bufferedReader.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
         return null;
     }
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.*;
 import java.util.Scanner;
 public class SpeakingInTongues
 {
 	public static void main(String[] args)throws Exception
 	{
 		File f = new File(""speakingintongues.txt"");
 		File outp = new File(""speakingintongues.out"");
 		if(!f.exists())
 			return;
 		String translate = new String(""yhesocvxduiglbkrztnwjpfmaq"");
 		Scanner sc = new Scanner(new FileReader(f));
 		Writer wr = new BufferedWriter(new FileWriter(outp));
 		int t = sc.nextInt();
 		sc.nextLine();
 		for(int i=1; i<=t; i++)
 		{
 			char[] g = sc.nextLine().toCharArray();
 			char[] e = new char[g.length];
 			for(int j=0; j<g.length; j++)
 			{
 				int index =  g[j] - 'a';
 				e[j] = (g[j]==32)? ' ' : translate.charAt(index);
 				System.out.print(e[j]);
 			}
 			System.out.println();
 			wr.write(""Case #""+i+"": ""+new String(e)+""\n""); //\r\n for windows
 		}
 		sc.close();
 		wr.close();
 		return;
 	}
 }",0
34,1056,"package round1A_2014;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class A {
 	InputReader in;
 
 	public char swap(char c) {
 		return (c == '0') ? '1' : '0';
 	}
 
 	public String solve() throws Exception {
 
 		int N = in.nextInt();
 		int L = in.nextInt();
 
 		char[][] cur = new char[N][L];
 		for (int i = 0; i < N; i++) {
 			cur[i] = in.next().toCharArray();
 		}
 		Set<String> target = new HashSet<String>();
 		for (int i = 0; i < N; i++) {
 			target.add(in.next());
 		}
 
 		int ans = 1 << 25;
 		for (int mask = 0; mask < (1 << L); mask++) {
 
 			int cnt = 0;
 
 			for (int col = 0; col < L; col++) {
 				if ((mask & (1 << col)) != 0) {
 					cnt++;
 					for (int i = 0; i < N; i++)
 						cur[i][col] = swap(cur[i][col]);
 				}
 			}
 			Set<String> mine = new HashSet<String>();
 			for (int i = 0; i < N; i++)
 				mine.add(new String(cur[i]));
 
 			for (int col = 0; col < L; col++) {
 				if ((mask & (1 << col)) != 0) {
 					for (int i = 0; i < N; i++)
 						cur[i][col] = swap(cur[i][col]);
 				}
 			}
 			
 			if (mine.size() != N)
 				continue;
 			Iterator<String> iter = mine.iterator();
 			boolean valid = true;
 			while (iter.hasNext()) {
 				if (!target.contains(iter.next())) {
 					valid = false;
 					break;
 				}
 			}
 			if (!valid)
 				continue;
 			ans = Math.min(ans, cnt);
 		}
 
 		return (ans == 1 << 25) ? ""NOT POSSIBLE"" : (ans + """");
 	}
 
 	public void answer() throws Exception {
 		in = new InputReader(""in.in"");
 		FileWriter out = new FileWriter(""out.out"");
 		int t = in.nextInt();
 		for (int i = 1; i <= t; i++) {
 			out.write(""Case #"" + i + "": "" + solve() + ""\n"");
 		}
 		out.close();
 	}
 
 	public static void main(String[] args) throws Exception {
 		new A().answer();
 	}
 
 	static class InputReader {
 		BufferedReader in;
 		StringTokenizer st;
 
 		public InputReader(String filename) throws IOException {
 			in = new BufferedReader(new FileReader(filename));
 			st = new StringTokenizer(in.readLine());
 
 		}
 
 		public String next() throws IOException {
 
 			while (!st.hasMoreElements())
 				st = new StringTokenizer(in.readLine());
 			return st.nextToken();
 		}
 
 		public int nextInt() throws NumberFormatException, IOException {
 			return Integer.parseInt(next());
 		}
 
 		public long nextLong() throws NumberFormatException, IOException {
 			return Long.parseLong(next());
 		}
 	}
 }
","package RoundB_2012;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.Scanner;
 
 public class ProbC2 {
 
 	static Scanner in;
 	static int N;
 	static int[] a;
 
 	public static String solve() {
 		N = in.nextInt();
 		a = new int[N];
 		for (int i = 0; i < N; i++)
 			a[i] = in.nextInt();
 
 		Hashtable<Integer, Integer> hash = new Hashtable<Integer, Integer>();
 
 		for (int i = 1; i < (1 << N) - 1; i++) {
 			int sum = 0;
 			for (int k = 0; k < N; k++) {
 				if (((1 << k) & i) != 0) {
 					sum += a[k];
 				}
 			}
 			Integer map = hash.get(sum);
 			if (map != null) {
 				ArrayList<Integer> s1 = new ArrayList<Integer>();
 				ArrayList<Integer> s2 = new ArrayList<Integer>();
 				for (int k = 0; k < N; k++) {
 					boolean x = (((1 << k) & i) != 0);
 					boolean y = (((1 << k) & map) != 0);
 					if (!(x && y)) {
 						if (x)
 							s1.add(a[k]);
 						if (y)
 							s2.add(a[k]);
 					}
 				}
 
 				StringBuffer s = new StringBuffer(""\n"");
 				s.append(s1.get(0));
 				for (int k = 1; k < s1.size(); k++)
 					s.append("" "" + s1.get(k));
 				s.append(""\n"" + s2.get(0));
 				for (int k = 1; k < s2.size(); k++)
 					s.append("" "" + s2.get(k));
 				return s.toString();
 
 			} else
 				hash.put(sum, i);
 
 		}
 		return ""\nImpossible"";
 	}
 
 	public static void main(String[] args) throws IOException {
 		in = new Scanner(new File(""in.in""));
 
 		FileWriter out = new FileWriter(""out.out"");
 
 		int t = in.nextInt();
 
 		for (int i = 1; i <= t; i++) {
 			out.write(""Case #"" + i + "":"" + solve() + ""\n"");
 		}
 		in.close();
 		out.close();
 	}
 
 }
",1
35,14097,"package fairAndSquare;
 
 import java.math.BigInteger;
 import java.util.Scanner;
 
 public class FairAndSquare {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 //		System.out.println(getNumberFairAndSquare(""100""));
 //		System.out.println(getNumberFairAndSquare(""1024348434201""));
 		
 		
 		
 		Scanner sc = new Scanner(FairAndSquare.class.getResourceAsStream(""C-large-2.in""));
 		
 		int count = sc.nextInt();
 		for(int i=0;i<count;i++) {
 			String minS = sc.next();
 			String maxS = sc.next();
 			
 			String minsS = new BigInteger(minS).subtract(BigInteger.ONE).toString();
 		
 			BigInteger result = getNumberFairAndSquare(maxS).subtract(getNumberFairAndSquare(minsS));
 			System.out.println(""Case #""+(i+1)+"": ""+ result.toString());
 		}
 		sc.close();
 
 	}
 	
 	
 	private static String genNumber(int i) {
 		StringBuilder b = new StringBuilder(""1"");
 		for(int j=0;j<i;j++) {
 			b.append(""0"");
 		}
 		System.out.println(b);
 		return b.toString();
 	}
 
 
 	private static BigInteger getNumberFairAndSquare(String number)
 	{
 		if(number.length() <=3) { // hard coded
 			int value = Integer.parseInt(number);
 			if(value==0) {
 				return BigInteger.ZERO;
 			}
 			if(value<=3) {
 				return BigInteger.ONE;
 			}
 			if(value<=8) {
 				return BigInteger.valueOf(2L);
 			}
 			if(value<=120) {
 				return BigInteger.valueOf(3L);
 			}
 			if(value<=483) {
 				return BigInteger.valueOf(4L);
 			}
 			if(value<=1000) {
 				return BigInteger.valueOf(5L);
 			}
 		}
 		BigInteger result = BigInteger.valueOf(5L);
 		for(int i=4;i<number.length();i++) {
 			result = result.add(getWholeCount(i));
 		}
 		
 		result =result.add(getPartCount(number));
 		
 		
 		return result;
 	}
 
 	private static BigInteger getWholeCount(int i) {
 		if(((i-1) % 2) !=0) {
 			return BigInteger.ZERO;
 		}
 		int n = ((i-1)/ 2) +1;
 		
 		boolean even = n % 2 == 0;
 		
 		BigInteger result = BigInteger.ZERO;
 		result = result.add(even ? BigInteger.ONE : BigInteger.valueOf(2L)) ; // 200...0...002 or also 200...100...2 
 		BigInteger ones = BigInteger.valueOf(2L).pow(even ? n / 2 -1 : ((n-1) / 2)-1).multiply(even ? BigInteger.ONE : BigInteger.valueOf(3));
 		result = result.add(ones);
 		
 		return result;
 	}
 	
 	private static BigInteger getPartCount(String number) {
 		int i= number.length();
 		
 		if(((i-1) % 2) !=0) {
 			return BigInteger.ZERO;
 		}
 		
 		int n = ((i-1)/ 2) + 1;
 		
 		boolean even = n % 2 == 0;
 		
 		BigInteger numberInteger = new BigInteger(number);
 		
 		if(square(build2(n,true)).compareTo(numberInteger) <= 0) {
 			return getWholeCount(i);
 		}
 		
 		if(!even && square(build2(n,false)).compareTo(numberInteger) <= 0) {
 			return getWholeCount(i).subtract(BigInteger.ONE);
 		}
 		
 
 		int range = even ? n / 2 -1 : ((n-1) / 2)-1;
 		int subpartWidth = even ? n / 2 -1 : ((n-1) / 2)-1;
 		return findSmallerOrEqual(numberInteger, BigInteger.ZERO, range , even, subpartWidth);
 	}
 
 	private static BigInteger findSmallerOrEqual(BigInteger numberInteger, BigInteger position, int range, boolean even, int subpartWidth)
 	{
 		if(range ==0) {
 			return BigInteger.valueOf(evaluatePosition(numberInteger, position, even,subpartWidth));
 		}
 		
 		BigInteger middlePosition = position.add(BigInteger.valueOf(2).pow(range-1));
 		BigInteger lastFromHalfRange = middlePosition.subtract(BigInteger.ONE);
 		int middle = evaluatePosition(numberInteger, lastFromHalfRange, even,subpartWidth);
 		if(middle == (even ? 1 : 3)) {
 			// je v druhej polke
 			return BigInteger.valueOf(2).pow(range-1).multiply(even ? BigInteger.ONE : BigInteger.valueOf(3)).add(findSmallerOrEqual(numberInteger, middlePosition, range-1, even,subpartWidth));
 		} else {
 			return findSmallerOrEqual(numberInteger, position, range-1, even,subpartWidth); 
 		}
 		
 	}
 	
 	private static int evaluatePosition(BigInteger numberInteger,
 			BigInteger position, boolean even, int subpartWidth) {
 
 		
 		if(even) {
 			if(square(build1(even, position,2,subpartWidth)).compareTo(numberInteger) <= 0) {
 				return 1;
 			}
 		} else {
 			for(int i=2;i>=0;i--) {
 				if(square(build1(even, position,i,subpartWidth)).compareTo(numberInteger) <= 0) {
 					return i+1;
 				}
 			}
 		}
 		return 0;
 	}
 
 
 	private static boolean isFair(long sq) {
 		String s = String.valueOf(sq);
 		StringBuffer buf = new StringBuffer(s);
 		return buf.reverse().toString().equals(s);
 	}
 	
 	private static BigInteger build2(int n, boolean second)
 	{
 		boolean even= n % 2 ==0;
 		if(even || !second) {
 			return new BigInteger(""2"" + repeat(""0"", n-2) + ""2"");
 		} else {
 			String middle = repeat(""0"", (n-3)/2);
 			return new BigInteger(""2"" +  middle + ""1"" + middle + ""2"");
 		}
 	}
 
 	private static BigInteger build1(boolean even, BigInteger order, int suborder, int subpartWidth)
 	{
 		String orderS = addZeroes(order.toString(2), subpartWidth);
 		
 		String orderSR = new StringBuilder(orderS).reverse().toString();
 		
 		return new BigInteger(""1"" + orderS + (even ? """" : suborder) + orderSR + ""1"");
 	}
 	
 	private static String addZeroes(String string, int subpartWidth) {
 		if(subpartWidth == 0) {
 			return """";
 		} 
 		return repeat(""0"", subpartWidth-string.length())+string;
 	}
 
 
 	private static String repeat(String s, int count)
 	{
 		StringBuilder b=  new StringBuilder();
 		for(int i=0;i<count;i++) {
 			b.append(s);
 		}
 		return b.toString();
 	}
 	
 	private static BigInteger square(BigInteger integer)
 	{
 		return integer.multiply(integer);
 	}
 
 	private static void generate()
 	{
 //		int j=0;
 //		for(long i=1;i<10000000;i++) {
 //			if(isFair(i)) {
 //				long sq = i*i;
 //				boolean sqAndF = isFair(sq);
 //				if(sqAndF) {
 //					System.out.println(j+ "".  ""+ i+ "" fair => "" +sq + "" - "" + (sqAndF));
 //					j++;
 //				}
 //				
 //			}
 //		}
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class Mountain {
 
 	final int MAX = 1000000000 + 1;
 	final int MAX_IT = 100000000;
 
 	void solve() throws Exception {
 		int n = nextInt();
 		int[] x = new int[n - 1];
 		for (int i = 0; i < n - 1; i++) {
 			x[i] = nextInt() - 1;
 		}
 		int[] h = new int[n];
 		Random rnd = new Random();
 		for (int IT = 0; IT < MAX_IT; IT++) {
 			for (int i = 0; i < n; i++) {
 				h[i] = rnd.nextInt(MAX);
 			}
 			boolean ok = true;
 			for (int i = 0; i < n - 1; i++) {
 				for (int j = i + 1; j < n; j++) {
 					long left = (long) (h[j] - h[i]) * (x[i] - i);
 					long right = (long) (h[x[i]] - h[i]) * (j - i);
 					if (j < x[i]) {
 						if (left >= right) {
 							ok = false;
 							break;
 						}
 					}
 					if (j > x[i]) {
 						if (left > right) {
 							ok = false;
 							break;
 						}
 					}
 				}
 				if (ok == false) {
 					break;
 				}
 			}
 			if (ok) {
 				for (int i = 0; i < n; i++) {
 					out.print(h[i] + "" "");
 				}
 				out.println();
 				return;
 			}
 		}
 		out.println(""Impossible"");
 	}
 
 	void run() {
 		try {
 			in = new BufferedReader(new FileReader(""input.txt""));
 			out = new PrintWriter(""output.txt"");
 			int tests = nextInt();
 
 			for (int i = 0; i < tests; i++) {
 				long time = System.currentTimeMillis();
 				out.print(""Case #"" + (i + 1) + "": "");
 				solve();
 				System.err.println(""Solved case #"" + (i + 1) + "" in ""
 						+ (System.currentTimeMillis() - time) + "" ms"");
 			}
 
 			out.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 
 	BufferedReader in;
 	StringTokenizer st;
 	PrintWriter out;
 	final String filename = new String(""Mountain"").toLowerCase();
 
 	String nextToken() throws Exception {
 		while (st == null || !st.hasMoreTokens())
 			st = new StringTokenizer(in.readLine());
 		return st.nextToken();
 	}
 
 	int nextInt() throws Exception {
 		return Integer.parseInt(nextToken());
 	}
 
 	long nextLong() throws Exception {
 		return Long.parseLong(nextToken());
 	}
 
 	double nextDouble() throws Exception {
 		return Double.parseDouble(nextToken());
 	}
 
 	public static void main(String[] args) {
 		new Mountain().run();
 	}
 
 }
",0
36,8498,"/**
  * 
  */
 package problem;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 /**
  * @author michael
  *
  */
 public class Problem {
 
 	/**
 	 * Metodo main que corre el programa.
 	 * @param args Argumentos con los que es llamado el programa.
 	 * @throws Exception Si hubo excepcion.
 	 */
 	public static void main(String args[]) throws Exception {
 
 		String file = ""A-small-attempt0"";
 		//String file = ""test"";
 
 		Object[] pairIO = openIO(file);
 		BufferedReader red = (BufferedReader) pairIO[0];
 		PrintWriter wr = (PrintWriter) pairIO[1];
 
 
 		int problemas = Integer.parseInt(red.readLine());
 		outer: for (int w = 0 ; w < problemas ; w++) {
 			String p1 [] = red.readLine().split("" "");
 			int N = Integer.parseInt(p1[0]);
 			int L = Integer.parseInt(p1[1]);
 
 			long[] init = new long[N];
 			long[] need = new long[N];
 			int min = Integer.MAX_VALUE;
 
 			String[] temp = red.readLine().split("" "");
 			for (int i = 0 ; i < N; i++) {
 				init[i] = Long.parseLong(temp[i], 2);
 			}
 			temp = red.readLine().split("" "");
 			for (int i = 0 ; i < N; i++) {
 				need[i] = Long.parseLong(temp[i], 2);
 			}
 
 			otherConf: for (int i = 0 ; i < N; i++) {
 				// Tratar de casar el switch i al primer equipo
 				long switches = init[i]^need[0];
 				otherDev: for (int j = 1 ; j < N ; j++) {
 					for (int k = 0 ; k < N ; k++) {
 						if ((init[k]^need[j]) == switches) {
 							continue otherDev;
 						}
 					}
 					continue otherConf;
 				}
 
 				int thisCase = 0;
 				for (int j = 0 ; j < L ; j++) {
 					if ((switches&1) == 1)
 						thisCase++;
 					switches = switches>>1;
 				}
 
 				min = Math.min(min, thisCase);
 			}
 
 			if (min == Integer.MAX_VALUE) {
 				wr.println(""Case #"" + (w+1) + "": NOT POSSIBLE"" );
 			}
 			else {
 				wr.println(""Case #"" + (w+1) + "": "" + min);
 			}
 		}
 	}
 
 
 	/////////////////////////////////////////////
 	//// Methods for IO operations
 	/////////////////////////////////////////////
 
 	public static BufferedReader loadFile(String fileName) throws FileNotFoundException {
 		File file = new File(""./data/"" + fileName + "".in"");
 		FileInputStream fis = new FileInputStream(file);
 		BufferedReader red = new BufferedReader(new InputStreamReader(fis));
 		return red;
 	}
 
 	public static PrintWriter openFile(String fileName) throws FileNotFoundException {
 		File file = new File(""./data/"" + fileName + "".out"");
 		if (file.exists()) file.delete();
 		FileOutputStream fos = new FileOutputStream(file);
 		PrintWriter wr = new PrintWriter(fos, true);
 		return wr;
 	}
 
 	public static Object[] openIO(String fileName) throws IOException {
 		return new Object[] { loadFile(fileName) , openFile(fileName)};
 	}
 }
 
","/**
  * 
  */
 package general;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 /**
  * @author michael
  *
  */
 public class IO {
 
 	public static BufferedReader loadFile(String fileName) throws FileNotFoundException {
 		File file = new File(""./data/"" + fileName + "".in"");
 		FileInputStream fis = new FileInputStream(file);
 		BufferedReader red = new BufferedReader(new InputStreamReader(fis));
 		return red;
 	}
 
 	public static PrintWriter openFile(String fileName) throws FileNotFoundException {
 		File file = new File(""./data/"" + fileName + "".out"");
 		if (file.exists()) file.delete();
 		FileOutputStream fos = new FileOutputStream(file);
 		PrintWriter wr = new PrintWriter(fos, true);
 		return wr;
 	}
 
 	public static Object[] openIO(String fileName) throws IOException {
 
 		
 		return new Object[] { loadFile(fileName) , openFile(fileName)};
 	}
 }
",1
37,1978,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 public class CookieClickerAlphaBig {
 
 	static final String inputPath = ""/home/bertrand/Desktop/B-large.in"";
 	static final String outputPath = ""/home/bertrand/Desktop/B-large.out"";
 
 	static final Map<Integer, String> answers = new ConcurrentHashMap<>();
 
 	public static void main(String[] args) throws IOException, InterruptedException {
 		long beginning = System.currentTimeMillis();
 
 		FileReader fr = new FileReader(inputPath);
 		final BufferedReader br = new BufferedReader(fr);
 
 		FileWriter fw = new FileWriter(outputPath);
 		BufferedWriter bw = new BufferedWriter(fw);
 
 		String nbCaseString = br.readLine();
 		int nbCase = Integer.parseInt(nbCaseString);
 
 		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
 
 		for (int i = 1; i <= nbCase; i++) {
 			String readLine = br.readLine();
 			newCachedThreadPool.submit(new Task(i, readLine));
 		}
 
 		newCachedThreadPool.shutdown();
 		newCachedThreadPool.awaitTermination(1, TimeUnit.MINUTES);
 
 		for (int i = 1; i <= nbCase; i++) {
 			System.out.println(""Case "" + i);
 			bw.write(String.format(""Case #%s: "", i));
 
 			String answer = answers.get(i);
 			bw.write(answer);
 
 			bw.write(""\n"");
 		}
 
 		bw.close();
 		br.close();
 
 		long end = System.currentTimeMillis();
 		System.out.println((end - beginning) / 1000 + "" s"");
 	}
 
 	static class Task implements Callable<Object> {
 
 		int indice;
 		String line;
 
 		public Task(int i, String line) {
 			this.indice = i;
 			this.line = line;
 		}
 
 		@Override
 		public Object call() throws Exception {
 			System.out.println(""Run du cas "" + indice);
 			try {
 				String answer = solve(line);
 				answers.put(indice, answer);
 				System.out.println(""Fin du cas "" + indice);
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			return null;
 		}
 
 	}
 
 	static final double initialCookiesPerSecond = 2;
 	static final DecimalFormat df = new DecimalFormat(""#.0000000"");
 
 	private static String solve(String line) throws IOException {
 		String[] args = line.split("" "");
 		double costForFarmC = Double.parseDouble(args[0]);
 		double extraCookiesPerSecondF = Double.parseDouble(args[1]);
 		double cookiesGoalX = Double.parseDouble(args[2]);
 
 		double bestcostWithoutFarm = costWithNbFarm(0, costForFarmC, extraCookiesPerSecondF, cookiesGoalX);
 		for (int nbFarm = 1; true; nbFarm++) {
 			double cost = costWithNbFarm(nbFarm, costForFarmC, extraCookiesPerSecondF, cookiesGoalX);
 			if (cost > bestcostWithoutFarm) {
 				break;
 			} else {
 				bestcostWithoutFarm = cost;
 			}
 		}
 
 		return df.format(bestcostWithoutFarm);
 	}
 
 	static double costWithNbFarm(int nbFarm, double costForFarmC, double extraCookiesPerSecondF, double cookiesGoalX) {
 		if (nbFarm == 0) {
 			return cookiesGoalX / initialCookiesPerSecond;
 		}
 		double time = 0;
 
 		for (int i = 0; i < nbFarm; i++) {
 			time += costForFarmC / (initialCookiesPerSecond + i * extraCookiesPerSecondF);
 		}
 
 		time += cookiesGoalX / (initialCookiesPerSecond + nbFarm * extraCookiesPerSecondF);
 
 		return time;
 	}
 
 }
","package fr.pabeke.round1;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
 public class B {
 
 	static final String INPUT_PATH = ""/home/bertrand/Desktop/B-small-attempt0.in"";
 	static final String OUTPUT_PATH = ""/home/bertrand/Desktop/B-small-attempt0.out"";
 
 	static final ExecutorService POOL = Executors.newCachedThreadPool();
 
 	static final int LINE_PER_CASE = 1;
 
 	public static void main(String[] args) throws IOException, InterruptedException, ExecutionException {
 		try (final BufferedReader br = new BufferedReader(new FileReader(INPUT_PATH)); final BufferedWriter bw = new BufferedWriter(new FileWriter(OUTPUT_PATH));) {
 			long beginningTime = System.currentTimeMillis();
 			int nbCase = Integer.parseInt(br.readLine());
 			Map<Integer, Future<String>> answers = new HashMap<>();
 
 			for (int i = 1; i <= nbCase; i++) {
 				List<String> lines = new ArrayList<>();
 				for (int j = 0; j < LINE_PER_CASE; j++) {
 					lines.add(br.readLine());
 				}
 				TestCase task = new TestCase(i, lines);
 				Future<String> future = POOL.submit(task);
 				answers.put(i, future);
 			}
 
 			POOL.shutdown();
 			POOL.awaitTermination(1, TimeUnit.DAYS);
 
 			for (int i = 1; i <= nbCase; i++) {
 				System.out.print(String.format(""Case #%s: "", i));
 				bw.write(String.format(""Case #%s: "", i));
 
 				Future<String> future = answers.get(i);
 				String answer = future.get();
 				System.out.println(answer);
 				bw.write(answer);
 				bw.write(""\n"");
 			}
 
 			long end = System.currentTimeMillis();
 			System.out.println(""Solved everything in "" + (end - beginningTime) / 1000 + "" s"");
 		}
 	}
 
 	static class TestCase implements Callable<String> {
 
 		int indice;
 		List<String> lines;
 
 		public TestCase(int i, List<String> lines) {
 			this.indice = i;
 			this.lines = lines;
 		}
 
 		@Override
 		public String call() throws Exception {
 			long beginningTime = System.currentTimeMillis();
 			System.out.println(""Beginning solving of test case "" + indice);
 			String answer = solve(lines);
 			long end = System.currentTimeMillis();
 			System.out.println(""Finished solving of test case "" + indice + "" in "" + (end - beginningTime) / 1000 + "" s"");
 			return answer;
 		}
 
 		private String solve(List<String> lines) {
 			String line = lines.get(0);
 			String[] split = line.split("" "");
 			int A = Integer.parseInt(split[0]);
 			int B = Integer.parseInt(split[1]);
 			int K = Integer.parseInt(split[2]);
 
 			int nbCas = 0;
 			for (int i = 0; i < A; i++) {
 				for (int j = 0; j < B; j++) {
 					int res = i & j;
 					if (res < K) {
 						nbCas++;
 					}
 				}
 			}
 
 			return """" + nbCas;
 		}
 
 	}
 
 }
",1
38,5492,"package com.codejam.cookieclicker;
 
 import java.text.DecimalFormat;
 
 public class Executor {
 
 	public static String execute(TestCase testCase) {
 		double productionCapability = 2;
 		double newFarmCost = testCase.newFarmCost;
 		double targetProduction = testCase.targetProduction;
 		double timeTakenForExpansion = 0;
 		double attempt1Time = 0;
 		double attempt2Time = 0;
 		
 		do{			
 			attempt1Time = calculateProductionTime(targetProduction, productionCapability) + timeTakenForExpansion;
 			//sell
 			timeTakenForExpansion += testCase.newFarmCost/productionCapability;
 			productionCapability += testCase.productionGain;
 			attempt2Time = calculateProductionTime(targetProduction, productionCapability) + timeTakenForExpansion;
 		} while(attempt1Time > attempt2Time);
 		DecimalFormat df = new DecimalFormat();
 		df.setMinimumFractionDigits(7);
 		df.setMaximumFractionDigits(7);
 		return df.format(attempt1Time);
 	}
 
 	private static double calculateProductionTime(double targetProduction, double productionCapability) {
 		return targetProduction/productionCapability;
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 
 
 public class TicTacTomek {
 
 	public static void main(String[] args) throws IOException {
 
 		FileReader r = new FileReader(""/Users/nikhilgahlot/Programs/TicTacTomek/src/A-small-attempt1.in"");
 
 		BufferedReader reader = new BufferedReader(r);
 		String line; 
 		line=reader.readLine(); 
 		int total=Integer.valueOf(line);
 		String[][] board= new String [4][4];
 		int row=0;
 		int win=0;
 		int check=0;
 
 		for(int q=1; q<=total;q++){	
 
 			row=0;
 			while (((line=reader.readLine())!=null) && (!((line).equals("""")))) {
 				if(row<4){
 					for(int i=0; i<4; i++){
 						board[row][i]=line.substring(i,i+1);
 					}
 				}
 				row++;
 			}
 
 
 			
 			if(	((board[0][0].equals(""X"")) || (board[0][0].equals(""T""))) && ((board[0][1].equals(""X"")) || (board[0][1].equals(""T""))) && ((board[0][2].equals(""X"")) || (board[0][2].equals(""T""))) && ((board[0][3].equals(""X"")) || (board[0][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}
 			else if(	((board[1][0].equals(""X"")) || (board[1][0].equals(""T""))) && ((board[1][1].equals(""X"")) || (board[1][1].equals(""T""))) && ((board[1][2].equals(""X"")) || (board[1][2].equals(""T""))) && ((board[1][3].equals(""X"")) || (board[1][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			else if(	((board[2][0].equals(""X"")) || (board[2][0].equals(""T""))) && ((board[2][1].equals(""X"")) || (board[2][1].equals(""T""))) && ((board[2][2].equals(""X"")) || (board[2][2].equals(""T""))) && ((board[2][3].equals(""X"")) || (board[2][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			else if(	((board[3][0].equals(""X"")) || (board[3][0].equals(""T""))) && ((board[3][1].equals(""X"")) || (board[3][1].equals(""T""))) && ((board[3][2].equals(""X"")) || (board[3][2].equals(""T""))) && ((board[3][3].equals(""X"")) || (board[3][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			
 			else if(	((board[0][0].equals(""O"")) || (board[0][0].equals(""T""))) && ((board[0][1].equals(""O"")) || (board[0][1].equals(""T""))) && ((board[0][2].equals(""O"")) || (board[0][2].equals(""T""))) && ((board[0][3].equals(""O"")) || (board[0][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}
 			else if(	((board[1][0].equals(""O"")) || (board[1][0].equals(""T""))) && ((board[1][1].equals(""O"")) || (board[1][1].equals(""T""))) && ((board[1][2].equals(""O"")) || (board[1][2].equals(""T""))) && ((board[1][3].equals(""O"")) || (board[1][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}	
 			else if(	((board[2][0].equals(""O"")) || (board[2][0].equals(""T""))) && ((board[2][1].equals(""O"")) || (board[2][1].equals(""T""))) && ((board[2][2].equals(""O"")) || (board[2][2].equals(""T""))) && ((board[2][3].equals(""O"")) || (board[2][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}	
 			else if(	((board[3][0].equals(""O"")) || (board[3][0].equals(""T""))) && ((board[3][1].equals(""O"")) || (board[3][1].equals(""T""))) && ((board[3][2].equals(""O"")) || (board[3][2].equals(""T""))) && ((board[3][3].equals(""O"")) || (board[3][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}	
 
 			//Verticals
 			else if(	((board[0][0].equals(""X"")) || (board[0][0].equals(""T""))) && ((board[1][0].equals(""X"")) || (board[1][0].equals(""T""))) && ((board[2][0].equals(""X"")) || (board[2][0].equals(""T""))) && ((board[03][0].equals(""X"")) || (board[03][0].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}
 			else if(	((board[0][1].equals(""X"")) || (board[0][1].equals(""T""))) && ((board[1][1].equals(""X"")) || (board[1][1].equals(""T""))) && ((board[2][1].equals(""X"")) || (board[2][1].equals(""T""))) && ((board[3][1].equals(""X"")) || (board[3][1].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			else if(	((board[0][2].equals(""X"")) || (board[0][2].equals(""T""))) && ((board[1][2].equals(""X"")) || (board[1][2].equals(""T""))) && ((board[2][2].equals(""X"")) || (board[2][2].equals(""T""))) && ((board[3][2].equals(""X"")) || (board[3][2].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			else if(	((board[0][3].equals(""X"")) || (board[0][3].equals(""T""))) && ((board[1][3].equals(""X"")) || (board[1][3].equals(""T""))) && ((board[2][3].equals(""X"")) || (board[2][3].equals(""T""))) && ((board[3][3].equals(""X"")) || (board[3][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}	
 			
 			else if(	((board[0][0].equals(""O"")) || (board[0][0].equals(""T""))) && ((board[1][0].equals(""O"")) || (board[1][0].equals(""T""))) && ((board[2][0].equals(""O"")) || (board[2][0].equals(""T""))) && ((board[03][0].equals(""O"")) || (board[03][0].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}
 			else if(	((board[0][1].equals(""O"")) || (board[0][1].equals(""T""))) && ((board[1][1].equals(""O"")) || (board[1][1].equals(""T""))) && ((board[2][1].equals(""O"")) || (board[2][1].equals(""T""))) && ((board[3][1].equals(""O"")) || (board[3][1].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}	
 			else if(	((board[0][2].equals(""O"")) || (board[0][2].equals(""T""))) && ((board[1][2].equals(""O"")) || (board[1][2].equals(""T""))) && ((board[2][2].equals(""O"")) || (board[2][2].equals(""T""))) && ((board[3][2].equals(""O"")) || (board[3][2].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}	
 			else if(	((board[0][3].equals(""O"")) || (board[0][3].equals(""T""))) && ((board[1][3].equals(""O"")) || (board[1][3].equals(""T""))) && ((board[2][3].equals(""O"")) || (board[2][3].equals(""T""))) && ((board[3][3].equals(""O"")) || (board[3][3].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}
 
 			//Diagonals 
 			else if(	((board[0][0].equals(""O"")) || (board[0][0].equals(""T""))) && ((board[1][1].equals(""O"")) || (board[1][1].equals(""T""))) && ((board[2][2].equals(""O"")) || (board[2][2].equals(""T""))) && ((board[03][03].equals(""O"")) || (board[03][03].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}
 			else if(	((board[0][0].equals(""X"")) || (board[0][0].equals(""T""))) && ((board[1][1].equals(""X"")) || (board[1][1].equals(""T""))) && ((board[2][2].equals(""X"")) || (board[2][2].equals(""T""))) && ((board[03][03].equals(""X"")) || (board[03][03].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}
 			else if(	((board[0][3].equals(""X"")) || (board[0][3].equals(""T""))) && ((board[1][2].equals(""X"")) || (board[1][2].equals(""T""))) && ((board[2][1].equals(""X"")) || (board[2][1].equals(""T""))) && ((board[03][0].equals(""X"")) || (board[03][0].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": X won"");check=1;}
 			else if(	((board[0][3].equals(""O"")) || (board[0][3].equals(""T""))) && ((board[1][2].equals(""O"")) || (board[1][2].equals(""T""))) && ((board[2][1].equals(""O"")) || (board[2][1].equals(""T""))) && ((board[03][0].equals(""O"")) || (board[03][0].equals(""T""))))
 			{System.out.println(""Case #"" +q +"": O won"");check=1;}
 			else {
 				check=0;
 			}
 
 
 			//Game Still Going
 			//System.out.println(check);
 			if(check==0){
 				for(int u=0; u<4; u++){
 					for(int g=0; g<4; g++){
 						if(board[u][g].equals(""."")){
 							System.out.println(""Case #"" +q +"": Game has not completed""); 
 							check=1;
 							break;
 						}
 					}
 					if(check==1){
 						break;
 					}
 				}
 			}
 			if(check==0){
 				System.out.println(""Case #"" +q +"": Draw""); 
 
 			}
 
 		}
 
 
 	}
 }
 
",0
39,8894,"package com.google.jam14.qualification.cookie;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.Locale;
 
 import static com.google.jam14.qualification.cookie.JamUtils.*;
 
 /**
  * Created with IntelliJ IDEA.
  * User: Alisa
  * Date: 12.04.14
  * Time: 14:26
  * To change this template use File | Settings | File Templates.
  */
 public class CookieClicker extends JamTask {
 
     private final int startCookiesPerSec;
 
     public CookieClicker(int cookiesPerSec) {
         this.startCookiesPerSec = cookiesPerSec;
     }
 
     public static void main(String ... args) {
 
         CookieClicker taskA = new CookieClicker(2);
         taskA.start();
     }
 
     @Override
     public void solve(int testCaseNum, BufferedReader bufferedReader, BufferedWriter bufferedWriter) throws IOException {
         String[] lines = getNextString(bufferedReader).split("" "");
         double farmCostInCookies = parseDouble(lines[0]);
         double farmSalaryInCookies = parseDouble(lines[1]);
         double winCookies = parseDouble(lines[2]);
         System.out.println(String.format("" testCase = %d; c = %f; f = %f;  x = %f"", testCaseNum, farmCostInCookies, farmSalaryInCookies, winCookies));
         boolean useFormulaSolution = true;
         //first solution with ""how people think approach""
         if (!useFormulaSolution) {
             Game game = new Game(startCookiesPerSec, farmCostInCookies, farmSalaryInCookies, winCookies);
 
             processAnotherStep(testCaseNum, game, 0, bufferedWriter);
 
         }  else {
             // second solution using formulas
             int numOfFarmBuys = 0;
             if (winCookies / startCookiesPerSec <= farmCostInCookies / startCookiesPerSec) {
                 format(bufferedWriter, testCaseNum, winCookies / startCookiesPerSec);
                 return;
             }
             double secWithNBuys = getSecondsOfGameWithNBuys(numOfFarmBuys, farmSalaryInCookies, farmCostInCookies, winCookies, startCookiesPerSec);
             double secWithOneMoreBuy = getSecondsOfGameWithNBuys(numOfFarmBuys + 1, farmSalaryInCookies, farmCostInCookies, winCookies, startCookiesPerSec);
             double err = Math.pow(10, -7);
             while (secWithOneMoreBuy < secWithNBuys && Math.abs(secWithNBuys - secWithOneMoreBuy) > err) {
                 numOfFarmBuys++;
                 secWithNBuys = getSecondsOfGameWithNBuys(numOfFarmBuys, farmSalaryInCookies, farmCostInCookies, winCookies, startCookiesPerSec);
                 secWithOneMoreBuy = getSecondsOfGameWithNBuys(numOfFarmBuys + 1, farmSalaryInCookies, farmCostInCookies, winCookies, startCookiesPerSec);
 
             }
             format(bufferedWriter, testCaseNum, secWithNBuys);
         }
 
     }
 
     /**
      *
      * @param numberOfBuys - amount of buys of farm during whole game
      * @param f - cookies farm earn for u
      * @param c - cost of farm in cookies
      * @param w - cookies to win and finish game
      * @param x - start amount of cookies u earn per second
      * @return
      */
     private double getSecondsOfGameWithNBuys(int numberOfBuys, double f, double c, double w, double x) {
         double sum = 0;
         for(int i = 0; i <= numberOfBuys - 1; i++) {
             sum += 1.0 / (x + i * f);
         }
         return c * sum + w / (x + (numberOfBuys * f));
     }
 
     private void processAnotherStep(int testCaseNum, Game game, int iteration, BufferedWriter bufferedWriter) throws IOException {
          if (game.getSecondsElapsed() > game.getStartSecondsToWin()) {
              format(bufferedWriter, testCaseNum, game.getStartSecondsToWin());
              return;
          }
 
         // if it's obvious to win without buying a farm
         if (game.weCanFinish()) {
             game.finish();
             format(bufferedWriter, testCaseNum, game.getSecondsElapsed());
         } else {
             //else we buy a farm and repeat iteration
             game.buyNewFarm();
 
             Game gameWithOneMoreBuy = game.clone();
             gameWithOneMoreBuy.buyNewFarm();
 
 
             System.out.println(String.format(""        timeToWin=%f (%f) ; timeToWinWithOneBuy=%f (%f)"",
                     game.getCurrentSecondsToWinWithoutBuyingFarm(),
                     game.getSecondsElapsed() + game.getCurrentSecondsToWinWithoutBuyingFarm(),
                     gameWithOneMoreBuy.getCurrentSecondsToWinWithoutBuyingFarm(),
                     gameWithOneMoreBuy.getSecondsElapsed() + gameWithOneMoreBuy.getCurrentSecondsToWinWithoutBuyingFarm()));
 
             if (gameWithOneMoreBuy.getSecondsElapsed() + gameWithOneMoreBuy.getCurrentSecondsToWinWithoutBuyingFarm() < game.getSecondsElapsed() + game.getCurrentSecondsToWinWithoutBuyingFarm()) {
                 System.out.println(String.format(""        the game is on.....""));
                 processAnotherStep(testCaseNum, game, iteration + 1, bufferedWriter);
             } else {
                 format(bufferedWriter, testCaseNum, game.getSecondsElapsed() + game.getCurrentSecondsToWinWithoutBuyingFarm());
                 return;
             }
 
         }
 
     }
 
     private void format(BufferedWriter bufferedWriter, int testCaseNum, double value) throws IOException {
         formatOutput(bufferedWriter, testCaseNum, String.format(Locale.US, ""%.6f"", value));
 
     }
 
     public class Game {
         private double secondsElapsed;
         private final double startCookiesWeEarnPerSec;
         private int farmsWeOwn;
         private final double farmSalaryPerSec;
         private final double farmCostInCookies;
         private double cookiesWeOwn;
         private double cookiesToWin;
 
         public Game clone() {
             Game g = new Game(startCookiesPerSec, farmCostInCookies, farmSalaryPerSec, cookiesToWin);
             g.cookiesWeOwn = cookiesWeOwn;
             g.secondsElapsed = secondsElapsed;
             g.farmsWeOwn = farmsWeOwn;
             return g;
         }
 
 
         @Override
         public String toString() {
             return ""Game{"" +
                     ""secondsElapsed="" + secondsElapsed +
                     "", startCookiesWeEarnPerSec="" + startCookiesWeEarnPerSec +
                     "", cookiesWeEarnPerSec="" + getCookiesWeEarnPerSec() +
                     "", farmsWeOwn="" + farmsWeOwn +
                     "", farmSalaryPerSec="" + farmSalaryPerSec +
                     "", farmCostInCookies="" + farmCostInCookies +
                     "", cookiesWeOwn="" + cookiesWeOwn +
                     "", cookiesToWin="" + cookiesToWin +
                     '}';
         }
 
         public Game(double startCookiesWeEarnPerSec, double farmCostInCookies , double farmSalaryPerSec, double cookiesToWin) {
             this.startCookiesWeEarnPerSec = startCookiesWeEarnPerSec;
             this.farmCostInCookies = farmCostInCookies;
             this.farmSalaryPerSec = farmSalaryPerSec;
             this.cookiesToWin = cookiesToWin;
         }
 
         public double getSecondsElapsed() {
             return secondsElapsed;
         }
 
         public double getCookiesWeEarnPerSec() {
             return startCookiesPerSec + farmsWeOwn * farmSalaryPerSec;
         }
 
         public int getFarmsWeOwn() {
             return farmsWeOwn;
         }
         public double getCookiesWeOwn() {
             return cookiesWeOwn;
         }
 
         public void setCookiesWeOwn(double cookiesWeOwn) {
             this.cookiesWeOwn = cookiesWeOwn;
         }
 
         public double getCookiesToWin() {
             return cookiesToWin;
         }
 
         public double getCurrentSecondsToWinWithoutBuyingFarm() {
             return cookiesWeOwn >= cookiesToWin ? 0 : cookiesToWin  / getCookiesWeEarnPerSec();
         }
 
         public double getStartSecondsToWin() {
             return cookiesToWin  / startCookiesWeEarnPerSec;
         }
 
         public double getCurrentSecondsToGetNewFarm() {
             return (farmCostInCookies <= getCookiesWeOwn()) ? 0 : (farmCostInCookies - getCookiesWeOwn()) /getCookiesWeEarnPerSec() ;
         }
 
         public boolean weCanFinish() {
             return getCurrentSecondsToWinWithoutBuyingFarm() <= getCurrentSecondsToGetNewFarm();
         }
 
         public void finish() {
             secondsElapsed += getCurrentSecondsToWinWithoutBuyingFarm();
         }
 
         public void buyNewFarm() {
             double timeToBuy = getCurrentSecondsToGetNewFarm();
             secondsElapsed += timeToBuy;
             cookiesWeOwn += timeToBuy * getCookiesWeEarnPerSec() - farmCostInCookies;
             farmsWeOwn++;
         }
     }
 
 
     @Override
     public String getInputFileName() {
         return ""B-large.in"";
     }
 }
","package round_1a;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.Scanner;
 
 public class Q2 {
 
 	/**
 	 * @param args
 	 * @throws Exception 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, Exception {
 		int cases,e,r,n;
 		int ans[][]=new int[11][5];
 		int v[]=new int[10];
 		FileReader buf = new FileReader(""C:\\Users\\bond\\Desktop\\input.in"");
 		BufferedReader br = new BufferedReader(buf);
 		cases=Integer.parseInt(br.readLine());
 		
 		//Scanner sc=new Scanner(""C:\\Users\\bond\\Desktop\\input.in"");
 		
 		//cases=sc.nextInt();
 		String[] outputs = new String[cases];
 		ans[0][0]=0;
 		ans[0][1]=0;
 		ans[0][2]=0;
 		ans[0][3]=0;
 		ans[0][4]=0;
 		for (int i = 1; i <=cases; i++)
 		{
 			String[] inp=br.readLine().split("" "");
 			e=Integer.parseInt(inp[0]);
 			r=Integer.parseInt(inp[1]);
 			n=Integer.parseInt(inp[2]);
 				
 			
 			String[] inp1=br.readLine().split("" "");	
 			for(int j=0;j<n;j++)
 			{
 		
 			v[j]=Integer.parseInt(inp1[j]);
 			}
 			
 			for(int j=1;j<=n;j++)
 			{
 				
 				
 //				v[j-1]=sc.nextInt();
 				for(int k=0;k<=e-r;k++)
 				{
 					ans[j][k]=0;
 					int l=0;
 					if(k>r)
 						l=k-r;
 					for(;l<=e-r;l++)
 					{
 						if(ans[j-1][l]+v[j-1]*(l+r-k)>ans[j][k])
 							ans[j][k]=ans[j-1][l]+v[j-1]*(l+r-k);
 					}
 				}
 			}
 			
 			/*for(int j=1;j<=n;j++)
 			{
 				
 				
 				v[j-1]=sc.nextInt();
 				for(int k=0;k<=e-r;k++)
 				{
 					ans[j][k]=0;
 					int l=0;
 					if(k>r)
 						l=k-r;
 					for(;l<=e-r;l++)
 					{
 						if(ans[j-1][l]+v[j-1]*(l+r-k)>ans[j][k])
 							ans[j][k]=ans[j-1][l]+v[j-1]*(l+r-k);
 					}
 				}
 			}
 */
 			//outputs[i]""Case #""+i+"": ""<<ans[n][0]<<endl;
 			outputs[i-1]=""Case #"" + i + "": "" + ans[n][0]+""\n"";
 		}
 		br.close();
 		buf.close();
 		FileWriter buf1 = new FileWriter(new File(""C:\\Users\\bond\\Desktop\\OutputDance.txt""), true);
 		BufferedWriter bw1 = new BufferedWriter(buf1);
 		for (int i = 0; i < cases; i++) {
 			bw1.write(outputs[i]);
 		}
 		bw1.close();
 		buf1.close();
 	}
 
 }
",0
40,19580,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.StringTokenizer;
 
 
 public class dancing {
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		String input="""";
 		StringTokenizer strtok;
 		
 		int googlers, surprises, p, count=0;
 		
 		int line = 0;
 		int totalscore, base, residual;
 		try {
 			BufferedReader inputStream = new BufferedReader(new FileReader(""B-large.in""));
 			BufferedWriter writer = new BufferedWriter(new FileWriter(""output.txt""));
 			
 			line = Integer.parseInt(inputStream.readLine());
 			for(int i=0; i< line; i++){
 				input = inputStream.readLine(); 
 				strtok = new StringTokenizer(input,"" "");
 				
 				googlers = Integer.parseInt(strtok.nextToken());
 				surprises = Integer.parseInt(strtok.nextToken());
 				p = Integer.parseInt(strtok.nextToken());
 				for(int j=0 ; j< googlers; j++){
 					totalscore = Integer.parseInt(strtok.nextToken());
 					base = totalscore/3;
 					residual = totalscore % 3;
 					
 					triplet normal,surprise;
 					
 					if(residual==0){
 						//normal
 						normal = new triplet(base,base,base);
 						//surprising
 						surprise = new triplet(base-1,base,base+1);
 						
 						if(normal.score()>=p)
 							count++;
 						else if(surprise.status!=""invalid"" && surprise.score()>=p && surprises > 0){
 							count++;
 							surprises--;
 						}
 					}
 					else if(residual==1){
 						//normal
 						normal = new triplet(base,base,base+1);
 						//surprising but not helpful
 						//new triplet(base-1,base+1,base+1);
 						if(normal.score()>=p)
 							count++;
 					}
 					else if(residual==2){
 						//normal
 						normal = new triplet(base,base+1,base+1);
 						//surprising
 						surprise = new triplet(base,base,base+2);
 						if(normal.score()>=p)
 							count++;
 						else if(surprise.status!=""invalid"" && surprise.score()>=p && surprises > 0){
 							count++;
 							surprises--;
 						}
 					}
 				}//for each googler
 				
 				//System.out.println(""Case #""+(i+1)+"": ""+count);
 				
 				if(i!=line-1)
 					writer.write(""Case #""+(i+1)+"": ""+count+""\r\n"");
 				else
 					writer.write(""Case #""+(i+1)+"": ""+count);
 				count = 0;
 				
 				
 				
 			}//read new line
 			writer.close();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 	}//main
 }
 
 
 
 
 
 
 
 
 
 
 
 
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package bot;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.util.ArrayList;
 
 /**
  *
  * @author tom
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String arg[])
 	{
 		final int NUM_BOTS = 2;
 		int numTests = 0;
 
 		BufferedReader inBuffer = null;
 
 		try
 		{
 			inBuffer = new BufferedReader(new FileReader(new File(""bots.in"")));
 			numTests = Integer.parseInt(inBuffer.readLine());
 		}
 		catch (Exception e)
 		{
 		}
 
 		for (int test = 0; test < numTests; test++)
 		{
 			Bot activeBot;
 			Bot waitingBot;
 			Bot[] bots = new Bot[NUM_BOTS];
 			ArrayList<Bot> nextBot = new ArrayList<Bot>();
 
 			for (int i = 0; i < NUM_BOTS; i++)
 			{
 				bots[i] = new Bot(0);
 			}
 
 			String[] input;
 			int numCommands = 0;
 
 			try
 			{
 				input = inBuffer.readLine().split("" "");
 				numCommands = Integer.parseInt(input[0]);
 
 				for (int i = 0; i < numCommands; i++)
 				{
 					char botChar = input[2 * i + 1].charAt(0);
 					int position = Integer.parseInt(input[2 * i + 2]);
 					if (botChar == 'O')
 					{
 						nextBot.add(bots[0]);
 						bots[0].addCommand(position);
 					}
 					else
 					{
 						nextBot.add(bots[1]);
 						bots[1].addCommand(position);
 					}
 				}
 			}
 			catch(Exception e)
 			{
 			}
 
 			for (int i = 0; i < NUM_BOTS; i++)
 			{
 				bots[i].getNextCommand();
 			}
 
 			int numSteps = 0;
 
 			for (int b = 0; b < nextBot.size(); b++)
 			{
 				activeBot = nextBot.get(b);
 				waitingBot = getOtherBot(activeBot, bots);
 
 				boolean activeFinished = false;
 				
 				do
 				{
 					numSteps++;
 
 					waitingBot.move();
 					activeFinished = activeBot.move();
 
 				} while (!activeFinished);
 
 				activeBot.getNextCommand();
 			}
 
 			System.out.println(
 					""Case #"" +
 					String.valueOf(test + 1) + "" "" +
 					String.valueOf(numSteps - 1));
 		}
     }
 
 	static Bot getOtherBot(Bot aBot, Bot[] bots)
 	{
 		for (int i = 0; i < bots.length; i++)
 		{
 			if (bots[i] != aBot)
 			{
 				return bots[i];
 			}
 		}
 
 		return null;
 	}
 }
 
 class Bot
 {
 	private int position;
 	private int direction;
 	private int target;
 	private ArrayList<Integer> commands;
 	private int commandIndex;
 	
 	public boolean move()
 	{
 		if (position == target)
 		{
 			return true;
 		}
 		else
 		{
 			position += direction;
 			return false;
 		}
 	}
 
 	public void getNextCommand()
 	{
 		if (commandIndex < commands.size())
 		{
 			setTarget(commands.get(commandIndex).intValue());
 			commandIndex++;
 		}
 	}
 
 	public void addCommand(int aPosition)
 	{
 		commands.add(aPosition);
 	}
 	
 	private void setTarget(int newTarget)
 	{
 		target = newTarget;
 		direction = (int)Math.signum(target - position);
 	}
 	
 	public Bot(int newPosition)
 	{
 		position = newPosition;
 		commandIndex = 0;
 		commands = new ArrayList<Integer>();
 	}
 
 	public Bot()
 	{
 	}
 }
",0
41,19337,"package questions_2014;
 
 import java.util.Arrays;
 
 public class MagicTrickTestCase {
 	//Private fields and constants: testBoards, answers to rows, and number of rows and columns;
 	private String[][] testBoard1, testBoard2;
 	private String answer1, answer2;
 	private final static int NUM_ROWS = 4, NUM_COLS = 4; 
 	
 	//Constructor for MagicTrickTestCase
 	public MagicTrickTestCase(String testCase){
 		String[] splitTestCase = testCase.split(""\n"");
 		answer1 = splitTestCase[0];
 		answer2 = splitTestCase[5];
 		testBoard1 = splitTestBoard(Arrays.copyOfRange(splitTestCase, 1, 5));
 		testBoard2 = splitTestBoard(Arrays.copyOfRange(splitTestCase, 6, 10));
 	}
 	//MagicTrickTestCase constructor helper method to form 2D Array for test boards
 	private static String[][] splitTestBoard(String[] tB){
 		String[][] testBoard = new String[NUM_ROWS][NUM_COLS]; 
 		for(int i = 0; i < tB.length; i++){
 			String testRow = tB[i];
 			testBoard[i] = testRow.split("" "");
 		}
 		return testBoard;
 	}
 	
 	//Public instance field accessor methods
 	public String[][] getTestBoard1(){return testBoard1;}
 	public String[][] getTestBoard2(){return testBoard2;}
 	public String getAnswer1(){return answer1;}
 	public String getAnswer2(){return answer2;}
 	
 	//getPossibleCard method returns the outcome of the search for the card.
 	public String getPossibleCard(){
 		String possibleCard = """";
 		String[] board1Cards = testBoard1[Integer.parseInt(answer1)-1];
 		String[] board2Cards = testBoard2[Integer.parseInt(answer2)-1];
 		for(String s1 : board1Cards)
 			for(String s2 : board2Cards){
 				if(s1.equals(s2) && possibleCard.equals("""")) possibleCard = s1;
 				else if(s1.equals(s2) && !possibleCard.equals("""")) return ""Bad magician!"";
 			}
 		if(!possibleCard.equals("""")) return possibleCard;
 		else return ""Volunteer cheated!"";
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.StringTokenizer;
 
 public class B {
 
     private void solve() throws Exception {
         int n = nextInt();
         int[] a = new int[n];
         for (int i = 0; i < n; ++i) {
             a[i] = nextInt();
         }
         boolean[] used = new boolean[n];
         int ans = 0;
         for (int i = 0; i < n; ++i) {
             int minVal = Integer.MAX_VALUE, minValInd = -1;
             for (int j = 0; j < n; ++j) {
                 if (!used[j] && a[j] < minVal) {
                     minVal = a[j];
                     minValInd = j;
                 }
             }
             used[minValInd] = true;
             int countBefore = 0, countAfter = 0;
             for (int j = 0; j < n; ++j) {
                 if (!used[j] && j < minValInd) {
                     ++countBefore;
                 } else if (!used[j] && j > minValInd) {
                     ++countAfter;
                 }
             }
             ans += Math.min(countBefore, countAfter);
         }
         out.println(ans);
     }
 
     public void run() {
         try {
             int tc = nextInt();
             for (int it = 1; it <= tc; ++it) {
                 System.err.println(it);
                 out.print(""Case #"" + it + "": "");
                 solve();
             }
         } catch (Exception e) {
             NOO(e);
         } finally {
             out.close();
         }
     }
 
     PrintWriter out;
     BufferedReader in;
     StringTokenizer St;
 
     void NOO(Exception e) {
         e.printStackTrace();
         System.exit(42);
     }
 
     int nextInt() {
         return Integer.parseInt(nextToken());
     }
 
     long nextLong() {
         return Long.parseLong(nextToken());
     }
 
     double nextDouble() {
         return Double.parseDouble(nextToken());
     }
 
     String nextToken() {
         while (!St.hasMoreTokens()) {
             try {
                 String line = in.readLine();
                 if (line == null)
                     return null;
                 St = new StringTokenizer(line);
             } catch (Exception e) {
                 NOO(e);
             }
         }
         return St.nextToken();
     }
 
     private B(String name) {
         try {
             in = new BufferedReader(new FileReader(""input.txt""));
             St = new StringTokenizer("""");
             out = new PrintWriter(new FileWriter(""output.txt""));
         } catch (Exception e) {
             NOO(e);
         }
     }
 
     public static void main(String[] args) {
         Locale.setDefault(Locale.US);
         new B(""a"").run();
     }
 }
",0
42,20229,"package cdj2013;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 /**
  * 
  * Problem
 
 Tic-Tac-Toe-Tomek is a game played on a 4 x 4 square board. 
 The board starts empty, except that a single 'T' symbol may appear in one of the 16 squares. 
 There are two players: X and O. 
 They take turns to make moves, with X starting. 
 In each move a player puts her symbol in one of the empty squares. 
 Player X's symbol is 'X', and player O's symbol is 'O'.
 
 After a player's move, if there is a row, column or a diagonal containing 4 of that player's symbols, 
 or containing 3 of her symbols and the 'T' symbol, 
 she wins and the game ends. 
 Otherwise the game continues with the other player's move. 
 
 If all of the fields are filled with symbols and nobody won, the game ends in a draw. 
 
 See the sample input for examples of various winning positions.
 
 
 
 Given a 4 x 4 board description containing 'X', 'O', 'T' and '.' characters (where '.' represents an empty square), 
 describing the current state of a game, determine the status of the Tic-Tac-Toe-Tomek game going on. 
 
 The statuses to choose from are:
 
 ""X won"" (the game is over, and X won)
 ""O won"" (the game is over, and O won)
 ""Draw"" (the game is over, and it ended in a draw)
 ""Game has not completed"" (the game is not over yet)
 If there are empty cells, and the game is not over, you should output ""Game has not completed"", even if the outcome of the game is inevitable.
 Input
 
 The first line of the input gives the number of test cases, T. T test cases follow. Each test case consists of 4 lines with 4 characters each, with each character being 'X', 'O', '.' or 'T' (quotes for clarity only). Each test case is followed by an empty line.
 
 Output
 
 For each test case, output one line containing ""Case #x: y"", where x is the case number (starting from 1) and y is one of the statuses given above. Make sure to get the statuses exactly right. When you run your code on the sample input, it should create the sample output exactly, including the ""Case #1: "", the capital letter ""O"" rather than the number ""0"", and so on.
 
 Limits
 
 The game board provided will represent a valid state that was reached through play of the game Tic-Tac-Toe-Tomek as described above.
 
 Small dataset
 
 1  T  10.
 
 Large dataset
 
 1  T  1000.
 
 Sample
 
 
 Input 
  	
 Output 
  
 6
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 
 XOX.
 OX..
 ....
 ....
 
 OOXX
 OXXX
 OX.T
 O..O
 
 XXXO
 ..O.
 .O..
 T...
 
 OXXX
 XO..
 ..O.
 ...O
 
 Case #1: X won
 Case #2: Draw
 Case #3: Game has not completed
 Case #4: O won
 Case #5: O won
 Case #6: O won
 
 Note
 
 Although your browser might not render an empty line after the last test case in the sample input, in a real input file there would be one.
  * @author chmin
  *
  */
 public class Problem01 {
 	static String FILE_NAME = ""A-small-attempt0.in"";
 	
 	static char x = 'X';
 	static char o = 'O';
 	static char t = 'T';
 	static char empty = '.';
 	
 	static char draw = 'D';
 	
 	static int not_completed = 0;
 	
 	static StringBuilder sb = new StringBuilder();
 	
 	static void fillMatrix(char [][] mx) throws FileNotFoundException {
 		
 		Scanner scanner = new Scanner(new FileInputStream(new File(FILE_NAME)));
 		
 		int line = Integer.parseInt(scanner.nextLine());
 		
 		for( int i = 0 ; i < line ; i++ ) {
 			checkMatrix((i+1), scanner);
 			
 		}
 	}
 	
 	static void checkMatrix(int caseNum, Scanner scanner ) {
 		char [][] mx = new char [4][4];
 		char [] line  = null;
 		
 		not_completed = 0; // reset
 		int cnt_draw = 0;
 		char winner = '\0';
 		
 		boolean winner_found = false;
 		
 		for( int r = 0 ; r < 4 ; r ++ ) {
 			String row = scanner.next();
 			if ( row.length() != 4) throw new RuntimeException (""4 chars expected, but not : "" + row.length());
 			for( int c = 0 ; c < row.length() ; c++ ) {
 				mx[r][c] = row.charAt(c);
 			}
 		}
 		
 //		System.out.println( ""--"");
 //		printMatrix(mx);
 		
 		
 		// horizontal direction 
 		for( int r = 0 ; r < 4 ; r ++ ) {
 			line = new char[]{ mx[r][0], mx[r][1], mx[r][2], mx[r][3] };
 			winner = checkLine(line);
 			if ( winner == x) {
 				System.out.println(""Case #"" + caseNum + "": X won"");
 				winner_found = true;
 				break;
 			} else if ( winner == o ) {
 				System.out.println(""Case #"" + caseNum + "": O won"");
 				winner_found = true;
 				break;
 			} else if ( winner == draw ) {
 				cnt_draw ++ ;
 			}
 		}
 		
 		if( winner_found ) {
 			return;
 		}
 		
 		// vertical direction 
 		for( int c= 0 ; c < 4 ; c ++ ) {
 			line = new char[]{ mx[0][c], mx[1][c], mx[2][c], mx[3][c] };
 			winner = checkLine(line);
 			if ( winner == x) {
 				System.out.println(""Case #"" + caseNum + "": X won"");
 				winner_found = true;
 				break;
 			} else if ( winner == o ) {
 				System.out.println(""Case #"" + caseNum + "": O won"");
 				winner_found = true;
 				break;
 			}  else if ( winner == draw ) {
 				cnt_draw ++ ;
 			}
 		}
 		if( winner_found) {
 			return;
 		}
 		
 		// diagonal direction 
 		
 		line = new char[] {mx[0][0], mx[1][1], mx[2][2], mx[3][3]};
 		winner = checkLine(line);
 		if ( winner == x) {
 			System.out.println(""Case #"" + caseNum + "": X won"");
 			winner_found = true;
 		
 		} else if ( winner == o ) {
 			System.out.println(""Case #"" + caseNum + "": O won"");
 			winner_found = true;
 		}  else if ( winner == draw ) {
 			cnt_draw ++ ;
 		}
 		
 		if ( winner_found) return;
 		
 		line = new char[]{mx[0][3], mx[1][2], mx[2][1], mx[3][0]};
 		winner = checkLine(line);
 		if ( winner == x) {
 			System.out.println(""Case #"" + caseNum + "": X won"");
 			winner_found = true;
 		
 		} else if ( winner == o ) {
 			System.out.println(""Case #"" + caseNum + "": O won"");
 			winner_found = true;
 		}  else if ( winner == draw ) {
 			cnt_draw ++ ;
 		}
 		if ( winner_found) return;
 		
 		
 		if ( not_completed > 0) { // no empty square
 			System.out.println(""Case #"" + caseNum + "": Game has not completed"");
 		} else {
 			System.out.println(""Case #"" + caseNum + "": Draw"");
 		}
 		
 	}
 	
 	static char checkLine(char [] line) {
 		char winner = '\0';
 		
 		int nx = 0, no = 0, nt = 0;
 		for( int i = 0 ; i < line.length ; i++ ) {
 			if ( line[i] == empty){
 				not_completed++ ;
 			}
 			else if ( line[i] == o ) no ++;
 			else if ( line[i] == x) nx ++;
 			else if ( line[i] == t ) nt ++;
 		}
 		
 		
 		if ( nt <= 1) {
 			if ( nx + nt == 4 ) {
 				winner = x;
 			} else if ( no + nt == 4) {
 				winner = o;
 			} else {
 				winner = draw;
 			}
 		}
 		
 		return winner;
 		
 	}
 
 	
 	static void printMatrix(char [][] mx) {
 		for ( int i = 0 ; i < 4 ; i++) {
 			for( int j = 0 ; j < 4 ; j++) {
 				System.out.print(mx[i][j]);
 			}
 			System.out.println();
 		}
 	}
 	public static void main(String[] args) throws FileNotFoundException {
 		char [][] matrix = new char[4][4];
 		
 		fillMatrix(matrix);
 		
 	}
 }
","package bot.trust;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 
 public class BotTrust {
 
 	
 	public static void main(String args[]) throws IOException{
 		File file = new File(args[0]);
 		if(!file.exists()){
 			System.err.println(""Wrong file path supplied"");
 			return;
 		}
 		
 		BufferedReader br = new BufferedReader(new FileReader(file));
 		String line;
 		//ignore first line
 		br.readLine();
 		File output = new File(""BotTrust.txt"" );
 		if(output.exists()){
 			output.delete();
 			output.createNewFile();
 		}
 		BufferedWriter bw = new BufferedWriter(new FileWriter(output));
 		int caseNum = 1; 
 		StringBuilder sb = new StringBuilder();
 		while((line = br.readLine()) != null){
 			line = line.replaceAll("" "", """");
 			sb.append(""Case #"").append(caseNum).append("": "").append(performTicks(line)).append(""\n"");
 			caseNum++;
 		}
 		bw.write(sb.toString());
 		bw.flush();
 	}
 	
 	public static int readToChar(String line, int start){
 		int j = start;
 		while(j< line.length() && Character.isDigit(line.charAt(j))){
 			j++;
 		}
 		return j;
 		
 	}
 	public static int performTicks(String line){
 		int next = readToChar(line, 0);
 		int numberOfMoves = Integer.parseInt(line.substring(0, next));
 		
 		Move[] moves = new Move[numberOfMoves];
 		ArrayList<Move> orangeList = new ArrayList<Move>();
 		ArrayList<Move> blueList = new ArrayList<Move>();
 		char id;
 		int j =0;
 		int i = next;
 		while(i < line.length()){
 			id = line.charAt(i);
 			next = readToChar(line, i+1);
 			moves[j] = new Move(id, Integer.parseInt(line.substring(i + 1, next)));
 			if(id == 'O'){
 				orangeList.add(moves[j]);
 			}
 			else{
 				blueList.add(moves[j]);
 			}
 			i = next;
 			j++;
 			
 		}
 		
 		
 		int currentMove = 0;
 		int orangeCount =1;
 		int blueCount = 1;
 		int blueMove = 0;
 		int orangeMove = 0;
 		int seconds = 0;
 		while(blueMove < blueList.size() && orangeMove < orangeList.size()){
 			if(moves[currentMove].id=='O'){
 				if(moves[currentMove].button == orangeCount){
 					currentMove++;
 					orangeMove++;
 				}
 				else{
 					if(orangeCount < orangeList.get(orangeMove).button){
 						orangeCount++;
 					}
 					else{
 						orangeCount--;
 					}
 				}
 				if(blueCount < blueList.get(blueMove).button){
 					blueCount++;
 				}
 				else if(blueCount > blueList.get(blueMove).button){
 					blueCount--;
 				}
 			}
 			else{
 				if(moves[currentMove].button == blueCount){
 					currentMove++;
 					blueMove++;
 
 				}
 				else{
 					if(blueCount < blueList.get(blueMove).button){
 						blueCount++;
 					}
 					else{
 						blueCount--;
 					}
 				}
 				if(orangeCount < orangeList.get(orangeMove).button){
 					orangeCount++;
 				}
 				else if (orangeCount > orangeList.get(orangeMove).button){
 					orangeCount--;
 				}
 			}
 			seconds++;
 		}
 		while(blueMove < blueList.size()){
 			if(blueCount < blueList.get(blueMove).button){
 				seconds += blueList.get(blueMove).button - blueCount + 1;	
 			}
 			else{
 				seconds +=  blueCount - blueList.get(blueMove).button + 1;	
 			}
 			
 			blueCount = blueList.get(blueMove).button;
 			blueMove++;
 		}
 		while(orangeMove < orangeList.size()){
 			if(orangeCount < orangeList.get(orangeMove).button){
 				seconds += orangeList.get(orangeMove).button - orangeCount + 1;	
 			}
 			else{
 				seconds += orangeCount - orangeList.get(orangeMove).button + 1;	
 			}
 			
 			orangeCount = orangeList.get(orangeMove).button;
 			orangeMove++;
 		}
 		return seconds;
 	}
 	
 	private static class Move{
 		char id;
 		int button;
 		public Move(char i, int b){
 			this.id = i;
 			this.button = b;
 		}
 	}
 }
",0
43,1712,"import java.util.Scanner;
 
 
 public class problem2 {
 	
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int numCases = scan.nextInt();
 		for(int i = 0; i < numCases; i++) {
 			solve(scan.nextInt(), scan.nextInt(), scan.nextInt(), i);
 			
 			
 			
 		}
 	}
 	
 	/*public static int solve(int a, int b, int c) {
 		if(a*c >= b) return 0;
 		//otherwise, I test a*c. If fails, 
 	}*/
 	
 	public static void solve(int a, int b, int c, int i) {
 		int windows = 1;
 		while(a*c<b) {
 			windows++;
 			a*=c;
 			//a--;
 		}
 		//System.out.println(windows);
 		int result = (int)Math.ceil((Math.log(windows))/Math.log(2));
 		if(windows == 0) result = 0;
 		System.out.println(""Case #"" + (i+1) + "": "" + result);
 	}
 
 }
","import java.util.*;
 
 
 public class Round1A {
 	
 	static Scanner scan;
 	static int N, L;
 	static ArrayList<String> goal;
 	
 	public static void main(String[] args) {
 		scan = new Scanner(System.in);
 		int cases = scan.nextInt();
 		for(int i = 1; i <= cases; ++i) {
 			System.out.print(""Case #"" + i + "": "");
 			doCase();
 		}
 	}
 	
 	static void doCase() {
 		N = scan.nextInt();
 		L = scan.nextInt();
 		ArrayList<String> initial = new ArrayList<String>();
 		goal = new ArrayList<String>();
 		for(int i = 0; i < N; ++i) {
 			initial.add(scan.next());
 		}
 		for(int i = 0; i < N; ++i) {
 			goal.add(scan.next());
 		}
 		int r = findClosest(0, 0, initial);
 		if(r == -1) {
 			System.out.println(""NOT POSSIBLE"");
 		} else {
 			System.out.println(r);
 		}
 	}
 	
 	static int findClosest(int index, int changed, ArrayList<String> start) {
 		if(index == L) {
 			if(correct(start, goal)) {
 				return changed;
 			}
 			return -1;
 		}
 		int result = findClosest(index+1, changed, start);
 		ArrayList<String> switched = new ArrayList<String>();
 		for(String s : start) {
 			switched.add(useSwitch(s,index));
 		}
 		int result2 = findClosest(index+1, changed+1, switched);
 		if(result == -1) return result2;
 		if(result2 == -1) return result;
 		return Math.min(result, result2);
 	}
 	
 	static String useSwitch(String s, int i) {
 		char c = s.charAt(i);
 		char[] r = s.toCharArray();
 		if(c=='0') {
 			r[i] = '1';
 		} else {
 			r[i] = '0';
 		}
 		return String.valueOf(r);
 	}
 	
 	static boolean correct(ArrayList<String> candidate, ArrayList<String> goal) {
 		return candidate.containsAll(goal);
 	}
 
 }
",1
44,2780,"import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 
 /**
  * @author Thomas Dybdahl Ahle
  */
 public class B2 implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 	private static final int INF = 1000000000;
 
 	public static void main(String[] args) {
 		new Thread(new B2()).start();
 	}
 
 	public B2() {
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 	
 	double E = 10e-7;
 	int MAXV = 1000000;
 	int P;
 	int[] ps = new int[MAXV];
 	int D;
 	
 	private boolean g(double l) {
 		double last = ps[0]-l;
 		for (int i = 1; i < P; i++) {
 			if (ps[i] - l >= last + D)
 				last = ps[i] - l;
 			else if (Math.abs(last + D - ps[i]) <= l) {
 				last = last + D;
 			}
 			else return false;
 		}
 		return true;
 	}
 	
 	public void run() {
         int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
         	out.print(String.format(""Case #%d: "", testNumber + 1));
         	
         	int C = in.readInt();
         	D = in.readInt();
         	P = 0;
         	for (int i = 0; i < C; i++) {
         		int c = in.readInt();
         		int v = in.readInt();
         		for (int j = 0; j < v; j++) {
         			ps[P] = c;
         			P++;
         		}
         	}
         	
         	if (g(0)) {
         		out.println(0.0);
         		continue;
         	}
         	double a = 0; // not possible
         	double b = 1; // possible
         	while (!g(b))
         		b *= 2;
         	
         	while (b-a > E) {
         		double c = (a+b)/2.;
         		if (!g(c))
         			a = c;
         		else b = c;
         	}
         	
         	out.println(b);
         }
 		out.close();
 	}
 	
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
","import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 
 /**
  * @author Thomas Dybdahl Ahle (thomas@ahle.dk)
  *         Created on 07.05.2011
  */
 public class CandySplitting implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 	private static final int INF = 1000000000;
 
 	public static void main(String[] args) {
 		new Thread(new CandySplitting()).start();
 	}
 
 	public CandySplitting() {
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 	
 	final static int MAX = 0x100000+5;
 	final static int MAXN = 1000+5;
 	boolean[] canget = new boolean[MAX];
 	int[] values = new int[MAXN];
 	
 	public void run() {
         int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
         	out.print(String.format(""Case #%d: "", testNumber + 1));
         	
         	// Load
         	int N = in.readInt();
         	for (int i = 0; i < N; i++)
         		values[i] = in.readInt();
         	
         	// Test possible
         	int patSum = 0;
         	for (int i = 0; i < N; i++)
         		patSum ^= values[i];
         	if (patSum != 0 || N < 2) {
         		out.println(""NO"");
         		continue;
         	}
         	
         	// Give Patrick the least, Sean the most
         	int patrick = INF;
         	int sean = 0;
         	for (int i = 0; i < N; i++) {
         		patrick = Math.min(patrick, values[i]);
         		sean += values[i];
         	}
         	sean -= patrick;
         	
         	out.println(sean);
         }
 		out.close();
 	}
 	
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
",1
45,7397,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.Stack;
 
 
 public class SnapperSimulate {
 
 	public static void main(String[] args) {
 		try {
 //			Scanner scanner = new Scanner(new File(""A-large-practice.in""));
 			Scanner scanner = new Scanner(new File(""small.in""));
 			
 			int T = scanner.nextInt();
 //			System.out.println(caseNum);
 			int caseCount=1;
 			
 			for(int i=0;i<T;i++)
 			{
 				int N = scanner.nextInt();
 				int K = scanner.nextInt();
 				
 				List<Snapper> snapperList = new ArrayList<Snapper>(N);
 				
 				//first snapper is connected to electricity
 				Snapper firstSnapper = new Snapper();
 				firstSnapper.setHasElectric(true);
 				snapperList.add(firstSnapper);
 				
 				//initialize the rest of the snapper
 				for(int j=0;j<N-1;j++)
 				{
 					snapperList.add(new Snapper());
 				}
 				
 				//start to flip finger
 				for(int j=0;j<K;j++)
 				{
 					for(int m=0;m<snapperList.size();m++)
 					{
 						Snapper currentSnapper = snapperList.get(m);
 						
 						if(currentSnapper.hasElectric())
 						{
 							currentSnapper.toggle();
 						}
 						else
 						{
 							break;
 						}
 					}
 					
 					for(int m=0;m<snapperList.size();m++)
 					{
 						Snapper currentSnapper = snapperList.get(m);
 						
 						if(currentSnapper.isOn())
 						{
 							try
 							{
 								Snapper nextSnapper = snapperList.get(m+1);
 								nextSnapper.setHasElectric(true);
 								snapperList.set(m+1, nextSnapper);
 							}
 							catch(IndexOutOfBoundsException e)
 							{
 								break;
 							}
 						}
 						else
 						{
 							for(int g=m+1;g<snapperList.size();g++)
 							{
 								Snapper snapper1 = snapperList.get(g);
 								snapper1.setHasElectric(false);
 								snapperList.set(g, snapper1);
 							}
 							
 							break;
 						}
 					}
 //					System.out.println(snapperList);
 				}
 				
 				boolean result = true;
 				for(Snapper eachSnapper : snapperList)
 				{
 					if(!eachSnapper.isOn())
 					{
 						result=false;
 						break;
 					}
 				}
 //				System.out.println(""final ""+snapperList);
 				System.out.println(""Case #""+caseCount+"": ""+(result?""ON"":""OFF""));
 				caseCount++;
 			}
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
","package wc.magicka;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 
 public class Magicka {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			Scanner scanner = new Scanner(new File(""C:/B-small-attempt0.in""));
 			int T = scanner.nextInt();
 //			System.out.println(""T:""+T);
 			
 			for(int i=0;i<T;i++)
 			{
 				Map<String,Character> combineMap = new HashMap<String, Character>();
 //				Map<Character,Set<Character>> combineCharMap = new HashMap<Character, Set<Character>>();
 				Map<Character,Set<Character>> deductMap = new HashMap<Character, Set<Character>>();
 				
 				int C=scanner.nextInt();
 //				System.out.println(""C:""+C);
 				for(int j=0;j<C;j++)
 				{
 					String value = scanner.next();
 					combineMap.put(""""+value.charAt(0)+value.charAt(1), value.charAt(2));
 					combineMap.put(""""+value.charAt(1)+value.charAt(0), value.charAt(2));
 					
 //					char theChar = value.charAt(0);
 //					char anotherChar = value.charAt(1);
 //					
 //					addToMap(theChar, anotherChar, combineCharMap);
 //					addToMap(anotherChar, theChar, combineCharMap);
 //					
 //					System.out.println(""combineCharMap:""+combineCharMap);
 				}
 //				System.out.println(""combineMap:""+combineMap);
 				
 				int D=scanner.nextInt();
 //				System.out.println(""D:""+D);
 				for(int j=0;j<D;j++)
 				{
 					String value = scanner.next();
 					char theChar = value.charAt(0);
 					char anotherChar = value.charAt(1);
 					
 					addToMap(theChar, anotherChar, deductMap);
 					addToMap(anotherChar, theChar, deductMap);
 				}
 //				System.out.println(""deductMap:""+deductMap);
 				
 				int N=scanner.nextInt();
 //				System.out.println(""N:""+N);
 				String value = scanner.next();
 //				System.out.println(""value:""+value);
 				char[] valueChar = value.toCharArray();
 				
 				Deque<Character> stack = new ArrayDeque<Character>();
 				for(int j=0;j<N;j++)
 				{
 					if(stack.isEmpty())
 					{
 						stack.push(valueChar[j]);
 					}
 					else
 					{
 						//check combine
 						char lastChar = stack.pop();
 						String combineTest = """"+lastChar+valueChar[j];
 						if(combineMap.containsKey(combineTest))
 						{
 							stack.push(combineMap.get(combineTest));
 						}
 						else
 						{
 							stack.push(lastChar);
 							stack.push(valueChar[j]);
 							
 							//check deduct char
 							if(deductMap.containsKey(valueChar[j]))
 							{
 								Set<Character> deductSet = deductMap.get(valueChar[j]);
 								for(char eachChar:deductSet)
 								{
 									if(stack.contains(eachChar))
 									{
 										stack.clear();
 										break;
 									}
 								}
 							}
 						}
 					}
 				}
 //				StringBuilder result = new StringBuilder();
 //				for(int m=0;m<stack.size();m++)
 //				{
 //					result.append(stack.remove()+"", "");
 //				}
 //				result.subSequence(0, result.length())
 				
 				Deque<Character> stack2 = new ArrayDeque<Character>();
 				for(char c:stack)
 				{
 					stack2.push(c);
 				}
 				System.out.println(""Case #""+(i+1)+"": ""+stack2);
 			}
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 	}
 
 	private static void addToMap(char theChar,char anotherChar, Map<Character, Set<Character>> combineCharMap)
 	{
 		Set<Character> theList;
 		if(combineCharMap.containsKey(theChar))
 		{
 			theList = combineCharMap.get(theChar);
 		}
 		else
 		{
 			theList = new HashSet<Character>();
 		}
 		theList.add(anotherChar);
 		combineCharMap.put(theChar, theList);
 	}
 }
",1
46,15236,"import java.util.*;
 
 public class FreeCellStatistics {
   private String run(Scanner line) {
     long N = line.nextLong();
     int P_D = line.nextInt();
     int P_G = line.nextInt();
 
     int pd_mod = P_D % 100;
     int num_2 = 0;
     int num_5 = 0;
     for(int i = 0; i < 2; ++i) {
       if(pd_mod % 2 == 0) {
         num_2 += 1;
         pd_mod /= 2;
       }
       if(pd_mod % 5 == 0) {
         num_5 += 1;
         pd_mod /= 5;
       }
     }
 
     int min_x = 1;
     for(int i = num_2; i < 2; ++i) {
       min_x *= 2;
     }
     for(int i = num_5; i < 2; ++i) {
       min_x *= 5;
     }
     if(min_x > N) {
       return ""Broken"";
     }
     if(P_G == 0 && P_D > 0) {
       return ""Broken"";
     }
     if(P_G == 100 && P_D != 100) {
       return ""Broken"";
     }
     return ""Possible"";
   }
 
   public static void main(String[] args) {
     Scanner in = new Scanner(System.in);
     int numTestCases = in.nextInt();
     in.nextLine();
     for(int i = 1; i <= numTestCases; ++i) {
       String line = in.nextLine();
       String result = (new FreeCellStatistics()).run(new Scanner(line));
       System.out.println(""Case #"" + i + "": "" + result);
     }
   }
 }
","import java.util.*;
 
 public class ReventOfTheHotDogs {
   private class Struct {
     public double position;
     public double left;
     public double right;
     public long num_stands;
     public double time_needed;
   }
   private int min_distance;
   private Struct consolidate(ArrayList<Struct> groups, int start, int end) {
 //System.out.println(""Consolidate "" + start + "" "" + end);
     Struct s = new Struct();
     double sum = 0;
     for(int i = start; i <= end; ++i) {
       sum += groups.get(i).position;
       Struct ss = groups.get(i);
 //System.out.println("""" + ss.num_stands + "" "" + ss.position + "" "" + ss.left + "" "" + ss.right + "" "" + ss.time_needed);
     }
     s.position = sum / (end-start+1);
 
     sum = 0;
     for(int i = start; i <= end; ++i) {
       Struct c = groups.get(i);
       sum += (c.right - c.left);
     }
     double total_length = sum + (end-start)*min_distance;
     s.left = s.position - total_length / 2.0;
     s.right = s.position + total_length / 2.0;
 
     long isum = 0;
     for(int i = start; i <= end; ++i) {
       isum += groups.get(i).num_stands;
     }
     s.num_stands = isum;
 
     double cur_left = s.left;
     double new_time = 0.0;
     for(int i = start; i <= end; ++i) {
       Struct c = groups.get(i);
       double t = Math.abs(c.left-cur_left) + c.time_needed;
 //System.out.println(t);
       if(t > new_time) {
         new_time = t;
       }
       cur_left = cur_left + (c.right - c.left) + min_distance;
     }
     s.time_needed = new_time;
 //System.out.println("""" + s.num_stands + "" "" + s.position + "" "" + s.left + "" "" + s.right + "" "" + s.time_needed);
     return s;
   }
   private double run(Scanner in) {
     int num_groups = in.nextInt();
     min_distance = in.nextInt();
     ArrayList<Struct> groups = new ArrayList<Struct>(num_groups);
     for(int i = 0; i < num_groups; ++i) {
       Struct s = new Struct();
       s.position = (double)in.nextLong();
       s.num_stands = in.nextLong();
       s.left = s.position - ((s.num_stands-1) * min_distance) / 2.0;
       s.right = s.position + ((s.num_stands-1) * min_distance) / 2.0;
       s.time_needed = ((s.num_stands-1) * min_distance) / 2.0;
 //System.out.println("""" + s.num_stands + "" "" + s.position + "" "" + s.left + "" "" + s.right + "" "" + s.time_needed);
       groups.add(s);
     }
     int previous_num_group = -1;
     while(previous_num_group != num_groups) {
       if(num_groups == 1) {
         return groups.get(0).time_needed;
       }
       ArrayList<Struct> new_groups = new ArrayList<Struct>(num_groups);
       int left = 0;
       for(int i = 1; i < groups.size(); ++i) {
         if((groups.get(i-1).right + min_distance < groups.get(i).left)) {
           new_groups.add(consolidate(groups, left, i-1));
           left = i;
         }
         if(i == groups.size()-1) {
           new_groups.add(consolidate(groups, left, i));
         }
       }
       groups = new_groups;
       previous_num_group = num_groups;
       num_groups = groups.size();
     }
     double time = groups.get(0).time_needed;
     for(int i = 1; i < groups.size(); ++i) {
       if(groups.get(i).time_needed < time) {
         time = groups.get(i).time_needed;
       }
     }
     return time;
   }
 
   public static void main(String[] args) {
     Scanner in = new Scanner(System.in);
     int numTestCases = in.nextInt();
     in.nextLine();
     for(int i = 1; i <= numTestCases; ++i) {
       System.out.println(""Case #"" + i + "": "" + (new ReventOfTheHotDogs()).run(in));
     }
   }
 }
",1
47,4791,"import static java.util.Arrays.deepToString;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 
 
 public class A {
 	public BufferedReader in;
 	public PrintWriter out;
 
 	void debug(Object...os) {
 		System.err.println(deepToString(os));
 	}
 	void pl(Object s)	{
 		System.out.println(s);
 	}
 	void p(Object s)	{
 		System.out.print(s);
 	}
 
 	public void run() throws Exception	{
 		int T,N;long K;
 		String line;String[] tok;		
 		in = new BufferedReader(new FileReader(new File(""A-large.in"" ) ) );
 		out = new PrintWriter(new File(""A-large.out""));
 		
 		long test = 0;int mul = 0;String onoff;
 		T = new Integer(in.readLine());
 		for(int t=1;t<=T;++t)	{
 			line = in.readLine();
 			tok = line.split("" "");
 			N = new Integer(tok[0]);
 			K = new Long(tok[1]);
 //			p(N+"" "");pl(K+"" "");
 			
 			mul = (int)Math.pow(2, N);
 			test = mul - 1;
 			onoff = ""OFF"";
 			if (K != 0){
 				while (test <= K)	{
 					if (test == K)	{
 						onoff = ""ON"";
 						break;
 					}
 					test += mul;
 				}
 			}
 			pl(""Case #"" + t + "": "" + onoff);
 			out.println(""Case #"" + t + "": "" + onoff);
 		}
 		in.close();out.close();		
 	}
 	public static void main(String[] args) {
 		try {
 			java.util.Date t1 = new java.util.Date();
 			new A().run();
 			java.util.Date t2 = new java.util.Date();
 			long diff = (t2.getTime() - t1.getTime());
 			System.out.println(""Time: ""+(((float)diff)/1000));
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 }
","import static java.util.Arrays.deepToString;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 
 
 public class A {
 	public BufferedReader in;
 	public PrintWriter out;
 
 	void debug(Object...os) {
 		System.err.println(deepToString(os));
 	}
 	void pl(Object s)	{
 		System.out.println(s);
 	}
 	void p(Object s)	{
 		System.out.print(s);
 	}
 
 	public void run() throws Exception	{
 		int T,N;long K;
 		String line;String[] tok;		
 		in = new BufferedReader(new FileReader(new File(""A-large.in"" ) ) );
 		out = new PrintWriter(new File(""A-large.out""));
 		
 		long test = 0;int mul = 0;String onoff;
 		T = new Integer(in.readLine());
 		for(int t=1;t<=T;++t)	{
 			line = in.readLine();
 			tok = line.split("" "");
 			N = new Integer(tok[0]);
 			K = new Long(tok[1]);
 //			p(N+"" "");pl(K+"" "");
 			
 			mul = (int)Math.pow(2, N);
 			test = mul - 1;
 			onoff = ""OFF"";
 			if (K != 0){
 				while (test <= K)	{
 					if (test == K)	{
 						onoff = ""ON"";
 						break;
 					}
 					test += mul;
 				}
 			}
 			pl(""Case #"" + t + "": "" + onoff);
 			out.println(""Case #"" + t + "": "" + onoff);
 		}
 		in.close();out.close();		
 	}
 	public static void main(String[] args) {
 		try {
 			java.util.Date t1 = new java.util.Date();
 			new A().run();
 			java.util.Date t2 = new java.util.Date();
 			long diff = (t2.getTime() - t1.getTime());
 			System.out.println(""Time: ""+(((float)diff)/1000));
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 }
",1
48,13355,"import java.util.Scanner;
 
 public class B {
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int t = scan.nextInt();
 		for (int i = 1; i <= t; ++ i) {
 			int n = scan.nextInt();
 			int s = scan.nextInt();
 			int p = scan.nextInt();
 			int[] max = new int[n];
 			for (int j = 0; j < n; ++ j) {
 				max[j] = scan.nextInt();
 			}
 			boolean[] surprising = new boolean[n];
 			for (int j = 0; j < s; ++ j) {
 				surprising[j] = true;
 			}
 			int out = 0;
 			do {
 				out = Math.max(out, solve(max, surprising, p));
 				surprising = next(surprising, surprising.length);
 			} while (surprising != null);
 			System.out.printf(""Case #%d: %d\n"", i, out);
 		}
 	}
 
 	private static boolean[] next(boolean[] old, int end) {
 		int index = 0;
 		for (index = end - 1; index >= 0; -- index) {
 			if (old[index]) {
 				break;
 			}
 		}
 		if (index == -1) {
 			return null;
 		}
 		if (index == end - 1) {
 			boolean[] ret = next(old, index);
 			if (ret == null) {
 				return null;
 			}
 			ret[index] = false;
 			for (index = index - 1; index >= 0; -- index) {
 				if (ret[index]) {
 					break;
 				}
 			}
 			ret[index + 1] = true;
 			return ret;
 		}
 		old[index] = false;
 		old[index + 1] = true;
 		return old;
 	}
 
 	public static int solve(int[] max, boolean[] surprising, int p) {
 		int ret = 0;
 		for (int i = 0; i < max.length; ++ i) {
 			if (surprising[i]) {
 				if (max[i] < 2) {
 					return 0;	// impossible
 				}
 				if (max[i] % 3 <= 1) {
 					if (max[i] / 3 + 1 >= p) {
 						ret ++;
 					}
 				} else {
 					if (max[i] / 3 + 2 >= p) {
 						ret ++;
 					}
 				}
 			} else {
 				if ((int)Math.ceil(max[i] / 3.0) >= p) {
 					ret ++;
 				}
 			}
 		}
 		return ret;
 	}
 }
","import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 
 public class A {
 	
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int t = scan.nextInt();
 		for (int no = 1; no <= t; ++ no) {
 			int n = scan.nextInt();
 			char[][] wins = new char[n][n];
 			for (int i = 0; i < n; ++ i) {
 				String line = scan.next();
 				wins[i] = line.toCharArray();
 			}
 			
 			System.out.printf(""Case #%d:\n"", no);
 			Double[] owps = new Double[n];
 			for (int i = 0; i < n; ++ i) {
 				int won = 0;
 				Set<Integer> opp = new HashSet<Integer>();
 				for (int j = 0; j < n; ++ j) {
 					if (wins[i][j] == '1') ++ won;
 					if (wins[i][j] != '.') opp.add(j);
 				}
 				double wp = 1.0 * won / opp.size();
 
 				if (owps[i] == null) {
 					owps[i] = owp(i, opp, wins);
 				}
 				double owp = owps[i];
 
 				double oowpsum = 0;
 				for (int o : opp) {
 					if (owps[o] == null) {
 						Set<Integer> opp2 = new HashSet<Integer>();
 						for (int j = 0; j < n; ++ j) {
 							if (wins[o][j] != '.') opp2.add(j);
 						}
 						owps[o] = owp(o, opp2, wins);
 					}
 					oowpsum += owps[o];
 				}
 				double oowp = oowpsum / opp.size();
 
 
 				double rpi = 0.25 * wp + 0.50 * owp + 0.25 * oowp;
 				System.out.println(rpi);
 			}
 		}
 	}
 	
 	static double owp(int i, Set<Integer> opp, char[][] wins) {
 		double owpsum = 0;
 		for (int o : opp) {
 			int oppwon = 0;
 			int sum = 0;
 			for (int j = 0; j < wins.length; ++ j) {
 				if (j == i) continue;
 				if (wins[o][j] == '1') ++ oppwon;
 				if (wins[o][j] != '.') sum ++;
 			}
 			owpsum += 1.0 * oppwon / sum;
 		}
 		return owpsum / opp.size();
 	}
 
 }
",1
49,12656,"package adi.code.jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class Q1 {
 	public static void main (String[] args) {
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(""A-small-attempt0.in""));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(""output.txt""));
 
 			int cases = Integer.parseInt(br.readLine());
 			for (int x = 0; x < cases; x++) {
 				char[][] map = new char [4][4];
 				for (int y = 0; y < 4; y++) {
 					String line = br.readLine();
 					map[y] = line.toCharArray();
 				}
 				bw.write(""Case #"" + (x+1) + "": "" + solve(map)+""\r\n"");
 				String line = br.readLine();
 			}
 			bw.close();
 			br.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (NumberFormatException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 
 		
 	}
 	
 	public static String solve (char[][] map) {
 		//hor		
 		for (int x = 0; x < 4; x++) {
 			int countx = 0;
 			int counto = 0;
 			int countt = 0;
 			for (int y = 0; y < 4; y++) {
 				if (map[x][y] == 'X')
 					countx++;
 				if (map[x][y] == 'O')
 					counto++;
 				if (map[x][y] == 'T')
 					countt++;
 			}
 			if (countx == 4) return ""X won"";
 			if (counto == 4) return ""O won"";
 			if (countx == 3 && countt == 1) return ""X won"";
 			if (counto == 3 && countt == 1) return ""O won"";
 		}
 		
 		// ver
 		for (int x = 0; x < 4; x++) {
 			int countx = 0;
 			int counto = 0;
 			int countt = 0;
 			
 			for (int y = 0; y < 4; y++) {
 				if (map [y][x] == 'X')
 					countx++;
 				if (map[y][x] == 'O')
 					counto++;
 				if (map[y][x] == 'T')
 					countt++;
 			}
 			if (countx == 4) return ""X won"";
 			if (counto == 4) return ""O won"";
 			if (countx == 3 && countt == 1) return ""X won"";
 			if (counto == 3 && countt == 1) return ""O won"";
 		}
 		
 		// dia
 		int countx = 0;
 		int counto = 0;
 		int countt = 0;
 		for (int x = 0; x < 4; x++) {
 		
 			if (map[x][x] == 'X')
 				countx++;
 			if (map[x][x] == 'O')
 				counto++;
 			if (map[x][x] == 'T')
 				countt++;
 			
 			if (countx == 4) return ""X won"";
 			if (counto == 4) return ""O won"";
 			if (countx == 3 && countt == 1) return ""X won"";
 			if (counto == 3 && countt == 1) return ""O won"";
 		}
 		
 		countx = 0;
 		counto = 0;
 		countt = 0;
 		
 		for (int x = 3; x >= 0; x--) {
 			
 			if (map[x][3-x] == 'X')
 				countx++;
 			if (map[x][3-x] == 'O')
 				counto++;
 			if (map[x][3-x] == 'T')
 				countt++;
 			
 			if (countx == 4) return ""X won"";
 			if (counto == 4) return ""O won"";
 			if (countx == 3 && countt == 1) return ""X won"";
 			if (counto == 3 && countt == 1) return ""O won"";
 		}
 		
 		for (int x = 0; x < 4; x++) {
 			for (int y = 0; y < 4; y++) {
 				if (map[x][y] == '.')
 					return ""Game has not completed"";
 			}
 		}
 		return ""Draw"";
 	}
 }
","package adi.code.jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class Q3 {
 	public static void main (String[] args) {
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(""C-small-attempt0.in""));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(""output.txt""));
 
 			int cases = Integer.parseInt(br.readLine());
 			for (int x = 0; x < cases; x++) {
 				String[] lh = br.readLine().split("" "");
 				int low = Integer.parseInt(lh[0]);
 				int high = Integer.parseInt(lh[1]);
 				int count = 0;
 				for (int i = low; i <= high; i++) {
 					if (isPal(i)) {
 						if (isSq(i))
 							if (isPal((int)Math.sqrt(i)))
 								count++;
 					}
 				}
 				bw.write(""Case #"" + (x+1) + "": "" + count + ""\r\n"");
 			}
 			bw.close();
 			br.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (NumberFormatException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 
 		
 	}
 	
 	public static boolean isSq(int n)
 	{
 	    int z = n & 0xF; 
 	    if (z > 9)
 	        return false; 
 
 	    if ( z != 2 && z != 3 && z != 5 && z != 6 && z != 7 && z != 8 )
 	    {
 	        int t = (int) Math.floor( Math.sqrt((double) n) + 0.5 );
 	            return t*t == n;
 	    }
 	    return false;
 	}
 	
     public static boolean isPal(int n) {
         int pali = n; // copied number into variable
         int reverse = 0;
 
         while (pali != 0) {
             int remainder = pali % 10;
             reverse = reverse * 10 + remainder;
             pali /= 10;
         }
 
         // if original and reverse of number is equal means
         // number is palindrome in Java
         if (n == reverse) {
             return true;
         }
         return false;
     }
 
 }
 
",1
50,4741,"package qualification2010;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 
 public class SnapperChain
 {
 	public static void main(String[] args) throws Exception
 	{
 		BufferedReader reader = new BufferedReader(new FileReader(""A-large.in""));
 		int len = Integer.parseInt(reader.readLine());
 		PrintWriter writer = new PrintWriter((new BufferedWriter(new FileWriter(""result.txt""))));
 
 		String[] s;
 		String res;
 		int n, k, x;
 		for(int i = 0; i < len; i++)
 		{
 			s = reader.readLine().split("" "");
 			n = Integer.parseInt(s[0]);
 			k = Integer.parseInt(s[1]);
 
 			x = (1 << n);
 
 			res = ((k+1)%x == 0) ? ""ON"" : ""OFF"";
 
 			writer.print(""Case #""+(i+1)+"": "" + res + ""\n"");
 			writer.flush();
 		}
 	}
 }
","import java.io.*;
 import java.util.*;
 import static java.lang.Math.*;
 
 @SuppressWarnings(""unused"")
 public class C1B
 {
 	public static void main(String[] args) throws Exception
 	{
 		String file = args.length > 0 ?  args[0] : ""1C/B-small-attempt1.in"";
 		Scanner in = new Scanner(new BufferedReader(new FileReader(file)));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file.split(""\\."")[0]+"".out"")));
 
 		int t = in.nextInt();
 		for(int i = 0; i < t; i++)
 		{
 			int l = in.nextInt();
 			long _t = in.nextLong();
 			int n = in.nextInt();
 			int c = in.nextInt();
 			int[] a = new int[c];
 			for(int j = 0; j < c; j++)
 				a[j] = in.nextInt();
 
 			int[] dist = new int[n];
 			for(int j = 0; j < n; j++)
 				dist[j] = a[j%c];
 
 			int result = 0;
 			for(int j = 0; j < n; j++)
 				result += dist[j]*2;
 
 			int[] adv = new int [n];
 			for(int j = 0; j < n; j++)
 			{
 				int build = 0;
 				for(int k = 0; k < j; k++)
 					build += dist[k]*2;
 
 				if(build >= _t)
 					adv[j] = dist[j];
 				else
 				{
 					long _adv = dist[j] - (_t-build)/2;
 					if(_adv > 0)
 						adv[j] = (int)_adv;
 					else
 						adv[j] = 0;
 				}
 			}
 			Arrays.sort(adv);
 			for(int j = 0; j < l; j++)
 				result -= adv[n-1-j];
 
 			out.format(""Case #%d: %d\n"", i+1, result);
 			out.flush();
 		}
 	}
 }
",1
51,16712,"
 import java.io.*;
 
 public class Round1A1 {
 
 public static void main(String args[]) throws Exception
 {
     BufferedReader br=new BufferedReader(new FileReader(""C:/in.txt""));
     BufferedWriter bw=new BufferedWriter(new FileWriter(""C:/out.txt""));
     int t=Integer.parseInt(br.readLine());
     String s2[] = new String[4];
     String s;
     int oc=0,xc=0,tc=0,doc,dxc,dtc,dot,doc2,dxc2,dtc2;
     for(int i=0;i<t;i++)
     {   
         for(int j=0;j<4;j++)
         {
             s2[j]=br.readLine();
  
         }
  
         int flag=0;
        //row check
             dot=0;
             doc=0;
             dxc=0;
             dtc=0;
             doc2=0;
             dxc2=0;
             dtc2=0;
         for(int r=0;r<4;r++)
         {   oc =0;
             xc=0;
             tc=0;
             if(s2[r].charAt(3-r)=='X')
                    dxc2++;
             else if(s2[r].charAt(3-r)=='O')
                    doc2++;
             else if(s2[r].charAt(3-r)=='T')
                    dtc2++;  
            if(s2[r].charAt(r)=='X')
                    dxc++;
            else if(s2[r].charAt(r)=='O')
                    doc++;
            else if(s2[r].charAt(r)=='T')
                    dtc++;   
             for(int c=0;c<4;c++)
             {  
   //              System.out.println(r+"" ""+c+"" ""+s2[r]);
                 if(s2[r].charAt(c)=='.')
                    dot=1;
 
 
 
                if(s2[r].charAt(c)=='X')
                    xc++;
                else if(s2[r].charAt(c)=='O')
                    oc++;
                else if(s2[r].charAt(c)=='T')
                    tc++;
             }
             if(xc==4||(xc==3&&tc==1))
             {
               flag=1;
               break;
             }
             else if(oc==4||(oc==3&&tc==1))
             {
                 flag=2;
                 break;
             }
              if(dxc==4||(dxc==3&&dtc==1))
             {
               flag=1;
               break;
             }
             else if(doc==4||(doc==3&&dtc==1))
             {
                 flag=2;
                 break;
             }
             else if(doc2==4||(doc2==3&&dtc2==1))
             {
                 flag=2;
                 break;
             }
             else if(dxc2==4||(dxc2==3&&dtc2==1))
             {
                 flag=1;
                 break;
             }
        }
        if(flag==1)
        {  
            bw.write(""CASE #""+(i+1)+"": X won\n"");
             s=br.readLine();
            continue;
        }
        if(flag==2)
        {
            bw.write(""CASE #""+(i+1)+"": O won\n"");
             s=br.readLine();
            continue;
        }
         //column check
         for(int c=0;c<4;c++)
         {   oc =0;
             xc=0;
             tc=0;
             for(int r=0;r<4;r++)
             {
                if(s2[r].charAt(c)=='X')
                    xc++;
                else if(s2[r].charAt(c)=='O')
                    oc++;
                else if(s2[r].charAt(c)=='T')
                    tc++;
             }
             if(xc==4||(xc==3&&tc==1))
             {
               flag=1;
               break;
             }
             else if(oc==4||(oc==3&&tc==1))
             {
                 flag=2;
                 break;
             }
             
        }
        if(flag==1)
        {  
            bw.write(""CASE #""+(i+1)+"": X won\n"");
             s=br.readLine();
            continue;
        }
        if(flag==2)
        {
            bw.write(""CASE #""+(i+1)+"": O won\n"");
             s=br.readLine();
            continue;
        }
        if(dot==1)
        bw.write(""CASE #""+(i+1)+"": Game has not completed\n"");
        else
        bw.write(""CASE #""+(i+1)+"": Draw\n"");    
         s=br.readLine();
     }
     bw.close();
 }
 }
","import java.util.*;
 import java.io.*;
 import java.lang.*;
 
 public class Main {
   public static void main(String[] args) throws Exception {
     Main p = new Main();
     p.run(args[0]);
   }
 
   private void run(String inputFileName) throws Exception {
     Scanner fin = new Scanner(new BufferedInputStream(
           new FileInputStream(inputFileName)));
     PrintWriter fout = new PrintWriter(new BufferedWriter(
           new FileWriter(inputFileName + "".out"")));
 
     //pre
     int[] count = new int[10000001];
     for (long i = 1; i <= 10000000; ++i) {
       long sqr = i * i;
       count[(int) i] = count[(int) i - 1];
       if (palin(i) && palin(sqr)) ++count[(int) i];
     }
 
     T = fin.nextInt();
     fin.nextLine();
     for (int tt = 1; tt <= T; ++tt) {
       int result = 0;
 
       //input
       long A = fin.nextInt();
       long B = fin.nextInt();
 
       //run
       result = count[(int) Math.sqrt((double) B)];
       if (A != 0) {
         result -= count[(int) Math.sqrt((double) (A - 1))];
       }
 
       //output
       fout.printf(""Case #%d: %d\n"", tt, result);
     }
 
     fin.close();
     fout.close();
   }
 
   private boolean palin(long x) {
     String str = Long.toString(x);
     int l = str.length();
     for (int i = 0, j = l - 1; i < j; ++i, --j) {
       if (str.charAt(i) != str.charAt(j)) return false;
     }
     return true;
   }
 
   private int T;
   private int N, M;
 }
",0
52,14583,"import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.BufferedWriter;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.io.FileInputStream;
 import java.io.Writer;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  * @author Mahmoud Aladdin <aladdin3>
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""input.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""output.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		InputReader in = new InputReader(inputStream);
 		OutputWriter out = new OutputWriter(outputStream);
 		TaskB solver = new TaskB();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class TaskB {
     double EPS = 1e-9;
     public void solve(int testNumber, InputReader jin, OutputWriter jout) {
         double c = jin.float64();
         double f = jin.float64();
         double x = jin.float64();
 
         double factor = 2.0;
         double bestTime = x / factor;
         double timePassed = 0.0;
         while(true) {
             double timeToNextFarm = c / factor;
             double tempFactor = factor + f;
             double remaining = x / tempFactor;
             //System.err.println(bestTime + "" "" + (remaining + timeToNextFarm + timePassed) + "" "" + (remaining + timeToNextFarm + timePassed > (bestTime + EPS)));
             if(remaining + timeToNextFarm + timePassed > (bestTime + EPS)) break;
             timePassed += timeToNextFarm;
             factor = tempFactor;
             bestTime = remaining + timePassed;
             //break;
         }
         jout.println(String.format(""Case #%d: %.7f"", testNumber, bestTime));
     }
 }
 
 class InputReader {
     private static final int bufferMaxLength = 1024;
     private InputStream in;
     private byte[] buffer;
     private int currentBufferSize;
     private int currentBufferTop;
     private static final String tokenizers = "" \t\r\f\n"";
     
     public InputReader(InputStream stream) {
         this.in = stream;
         buffer = new byte[bufferMaxLength];
         currentBufferSize = 0;
         currentBufferTop = 0;
     }
     
     private boolean refill() {
         try {
             this.currentBufferSize = this.in.read(this.buffer);
             this.currentBufferTop = 0;
         } catch(Exception e) {}
         return this.currentBufferSize > 0;
     }
     
     
     private Byte readChar() {
         if(currentBufferTop < currentBufferSize) {
             return this.buffer[this.currentBufferTop++];
         } else {
             if(!this.refill()) {
                 return null;
             } else {
                 return readChar();
             }
         }
     }
 
     public String next() {
         return token();
     }
     
     public String token()  {
         StringBuffer tok = new StringBuffer();
         Byte first;
         while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) != -1));
         if(first == null) return null;
         tok.append((char)first.byteValue());
         while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) == -1)) {
             tok.append((char)first.byteValue());
         }
         return tok.toString();
     }
     
     public Double float64() throws NumberFormatException {
         String tok = token();
         return tok == null? null: Double.parseDouble(tok);
     }
 
     }
 
 class OutputWriter {
     private final int bufferMaxOut = 1024;
     private PrintWriter out;
     private StringBuilder output;
     private boolean forceFlush = false;
 
     public OutputWriter(OutputStream outStream) {
         out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream)));
         output = new StringBuilder(2 * bufferMaxOut);
     }
 
     public OutputWriter(Writer writer) {
         forceFlush = true;
         out = new PrintWriter(writer);
         output = new StringBuilder(2 * bufferMaxOut);
     }
 
     private void autoFlush() {
         if(forceFlush || output.length() >= bufferMaxOut) {
             flush();
         }
     }
 
     public void print(Object... tokens) {
         for(int i = 0; i < tokens.length; i++) {
             if(i != 0) output.append(' ');
             output.append(tokens[i]);
         }
         autoFlush();
     }
 
     public void println(Object... tokens) {
         print(tokens);
         output.append('\n');
         autoFlush();
     }
 
     public void flush() {
         out.print(output);
         output.setLength(0);
     }
 
     public void close() {
         flush();
         out.close();
     }
 }
 
","package round1C;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 
 public class SquareTiles {
 
 	public static void main(String[] args) throws IOException {
 		BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
 		String line = input.readLine(); 
 		int i = Integer.parseInt(line);
 		for (int cnt = 1; cnt<=i; cnt++) {
 			line = input.readLine();
 			StringTokenizer tok = new StringTokenizer(line);
 			int R=Integer.parseInt(tok.nextToken());
 			int C=Integer.parseInt(tok.nextToken());
 			char[][] pic = new char[R][];
 			for (int j=0; j<R; j++) {
 				line = input.readLine();
 				pic[j] = line.toCharArray();
 			}
 			boolean success=true;
 			for (int j=0; success && j<R; j++) {
 				for (int k=0; success && k<C; k++) {
 					if (pic[j][k]=='#') {
 						if (j<R-1 && k<C-1 && pic[j+1][k]=='#' && pic[j][k+1]=='#' && pic[j+1][k+1]=='#') {
 							pic[j][k]=pic[j+1][k+1]='/';
 							pic[j+1][k]=pic[j][k+1]='\\';
 						}
 						else {
 							success=false;
 						}
 					}
 				}
 			}
 			System.out.printf(""Case #%d:\n"", cnt);
 			if (success) {
 				for (int j=0; j<R; j++) {
 					System.out.println(String.valueOf(pic[j]));
 				}
 			}
 			else {
 				System.out.println(""Impossible"");
 			}
 		}		
 	}
 }
",0
53,17831,"
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class RecycledNo {
 
     Scanner in;
     BufferedWriter out;
 
     RecycledNo(String input, String output) throws Exception {
         in = new Scanner(new File(input));
         FileWriter fstream = new FileWriter(output);
         out = new BufferedWriter(fstream);
     }
 
     private void solveAll() throws IOException {
         int T = in.nextInt();
         int A, B;
 
         for (int test = 1; test <= T; test++) {
             A = in.nextInt();
             B = in.nextInt();
             out.write(""Case #"" + test + "": "" + solve(A, B));
             out.newLine();
         }
 
     }
 
     private int solve(int A, int B) {
         int count = 0, dig, pow10, lastPart, firstPart, exp10, newNo;
         int noDig = 1 + (int) Math.log10(A);
         Set<Integer> set = new HashSet<Integer>();
 
         for (int n = A; n < B; n++) {
             set.clear();
             pow10 = 1;
             lastPart = 0;
             firstPart = n;
             exp10 = (int) Math.pow(10, noDig - 1);
             
             for (dig = 1; dig < noDig; dig++) {
                 lastPart = (firstPart % 10) * pow10 + lastPart;
                 firstPart = firstPart / 10;
                 pow10 *= 10;
 
                 newNo = lastPart * exp10 + firstPart;
                 exp10 /= 10;
                 if ((int) Math.log10(newNo) != noDig - 1) {
                     continue;
                 }
 
                 if (newNo > n && newNo <= B &&
                         !set.contains(newNo)) {
                     set.add(newNo);
                     count++;
                 }
             }
         }
 
         return count;
     }
 
     public void close() throws IOException {
         in.close();
         out.close();
     }
 
     public static void main(String[] args) throws Exception {
         RecycledNo pb = new RecycledNo(""input.txt"", ""output.txt"");
 
         pb.solveAll();
 
         pb.close();
     }
 }
","import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 import java.util.StringTokenizer;
 
 
 /**
  * Google Code Jam 2013
  * Qualification Round: Problem C. Fair and Square
  * @author Jose Toro (@Wynkth)
  */
 
 public class QualificationRoundC {
 	public static void main (String[] args) throws IOException {	
 		FileReader fr = new FileReader(""in.txt"");
 		Scanner sc = new Scanner(fr);
 		BufferedWriter bw = new BufferedWriter(new FileWriter(""out.txt""));
 		int cases = Integer.parseInt(sc.nextLine());
 		
 		for(int i = 1; i<=cases; i++) {
 			System.out.println(""Processing Case #"" + i);
 			StringTokenizer st = new StringTokenizer(sc.nextLine());
 			
 			bw.write(""Case #"" + i + "": "" + solve(st.nextToken(),st.nextToken()) + ""\n"");
 		}
 		
 		sc.close();
 		fr.close();
 		bw.close();
 	}
 	
 	public static String solve(String a, String b) {
 		int res = 0;
 		int aa = Integer.parseInt(a);
 		int bb = Integer.parseInt(b);
 		
 		for (int i = aa ; i <= bb; i++) {
 			double c = Math.sqrt(i);
 			if ((int)c == c && isPalindrome(i) && isPalindrome((int)c)) res++;
 		}
 		
 		return String.valueOf(res);
 	}
 	
 	public static boolean isPalindrome(int a) {
 		String aa = String.valueOf(a);
 		int len = aa.length();
 		for (int i = 0; i<=len/2; i++) {
 			if(aa.charAt(i) != aa.charAt(len-1-i)) return false;
 		}
 		
 		return true;
 	}
 }
",0
54,5496,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.math.BigInteger;
 
 
 public class Fair_and_Square_2 {
 	
 	static boolean palendrum(String s) {
 		for (int i = 0; i < s.length() / 2; i++)
 			if (s.charAt(i) != s.charAt(s.length() - 1 - i))
 				return false;
 		
 		return true;
 	}
 	
 	public static void main(String[] args) throws Exception {
 		BufferedReader in = new BufferedReader(new InputStreamReader(
 				new FileInputStream(""C-large-2.in"")));
 		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
 				new FileOutputStream(""C.out"")));
 		
 		int T = Integer.parseInt(in.readLine());
 		BigInteger a, b, start;
 		String[] line;
 		int counter;
 		boolean finished;
 		BigInteger cur;
 		
 		for (int t = 1; t <= T; t++) {
 			counter = 0;
 			finished = false;
 			out.write(""Case #"" + t + "": "");
 			line = in.readLine().trim().split(""\\s+"");
 			a = new BigInteger(line[0]);
 			b = new BigInteger(line[1]);
 			
 			start = new BigInteger(""1"");
 			for (int i = 0; i < line[0].length() / 2; i++)
 				start = start.multiply(new BigInteger(""10""));
 			
 			if (!start.equals(BigInteger.ONE))
 				start = start.add(BigInteger.ONE);
 			
 			while (!finished) {
 				StringBuilder s = new StringBuilder(start.toString());
 				int l = s.length();
 				
 				cur = new BigInteger(s.toString()).multiply(new BigInteger(s.toString()));
 				
 				if (cur.compareTo(b) > 0) {
 					finished = true;
 					break;
 				}
 				
 				else if (cur.compareTo(a) >= 0 && palendrum(cur.toString()))
 					counter++;
 				
 				for (int i = l / 2; i >= 0; i--) {
 					while (s.charAt(i) - '0' != 9) {
 						s.replace(i, i + 1, String.valueOf(s.charAt(i) + 1 - '0'));
 						if (l % 2 != 1)
 							s.replace(l - 1 - i, l - i, String.valueOf(s.charAt(l - 1 - i) + 1 - '0'));
 						
 						cur = new BigInteger(s.toString()).multiply(new BigInteger(s.toString()));
 						
 						if (cur.compareTo(b) > 0) {
 							finished = true;
 							break;
 						}
 						
 						else if (cur.compareTo(a) >= 0 && palendrum(cur.toString()))
 							counter++;
 					}
 					
 					if (finished)
 						break;
 				}
 				
 				start = new BigInteger(""1"");
 				for (int i = 0; i < l; i++)
 					start = start.multiply(new BigInteger(""10""));
 				start = start.add(BigInteger.ONE);
 			}
 			
 			out.write(counter + ""\n"");
 		}
 		
 		in.close();
 		out.close();
 	}
 }
","import java.util.Scanner;
 
 
 public class a {
 
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		
 		int n = in.nextInt();
 		char[][] board;
 		
 		for(int t=1; t<=n; ++t) {
 			board = new char[4][4];
 			
 			boolean finished = true;
 			for(int i=0; i<4; ++i) {
 				String line = in.next();
 				for(int j=0; j<4; ++j) {
 					board[i][j] = line.charAt(j);
 					if(board[i][j] == '.') finished = false;
 				}
 			}
 			
 			boolean xWon=false, oWon=false;
 			int oCount=0, tCount=0, xCount=0;
 			for(int i=0; i<4; ++i) {
 				oCount=0; tCount=0; xCount=0;
 				for(int j=0; j<4; ++j) {
 					if(board[i][j] == 'X') ++xCount;
 					else if(board[i][j] == 'O') ++oCount;
 					else if(board[i][j] == 'T') ++tCount;
 				}
 				if(xCount == 4 || (xCount == 3 && tCount == 1)) xWon = true;
 				if(oCount == 4 || (oCount == 3 && tCount == 1)) oWon = true;
 
 				
 				oCount=0; tCount=0; xCount=0;
 				for(int j=0; j<4; ++j) {
 					if(board[j][i] == 'X') ++xCount;
 					else if(board[j][i] == 'O') ++oCount;
 					else if(board[j][i] == 'T') ++tCount;
 				}
 				if(xCount == 4 || (xCount == 3 && tCount == 1)) xWon = true;
 				if(oCount == 4 || (oCount == 3 && tCount == 1)) oWon = true;
 			}
 			oCount=0; tCount=0; xCount=0;
 			for(int i=0; i<4; ++i) {
 				if(board[i][i] == 'X') ++xCount;
 				else if(board[i][i] == 'O') ++oCount;
 				else if(board[i][i] == 'T') ++tCount;
 			}
 			if(xCount == 4 || (xCount == 3 && tCount == 1)) xWon = true;
 			if(oCount == 4 || (oCount == 3 && tCount == 1)) oWon = true;
 			
 			oCount=0; tCount=0; xCount=0;
 			for(int i=0; i<4; ++i) {
 				if(board[3-i][i] == 'X') ++xCount;
 				else if(board[3-i][i] == 'O') ++oCount;
 				else if(board[3-i][i] == 'T') ++tCount;
 			}
 			if(xCount == 4 || (xCount == 3 && tCount == 1)) xWon = true;
 			if(oCount == 4 || (oCount == 3 && tCount == 1)) oWon = true;
 			
 			
 			System.out.print(""Case #""+t+"": "");
 			if(xWon) {
 				System.out.println(""X won"");
 			}
 			else if(oWon) {
 				System.out.println(""O won"");
 			}
 			else if(!finished) {
 				System.out.println(""Game has not completed"");
 			}
 			else {
 				System.out.println(""Draw"");
 			}
 		}
 
 	}
 
 }
",0
55,3277,"package TaskA;
 
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.InputMismatchException;
 import java.util.Vector;
 
 /**
  * Thank you to Egor Kulikov for Java Template
  * Built using CHelper plug-in
  * @author Richard Hua (rich@rkhua.com)
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""input.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""output.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		InputReader in = new InputReader(inputStream);
 		OutputWriter out = new OutputWriter(outputStream);
 		TaskA solver = new TaskA();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class TaskA {
 	public void solve(int testNumber, InputReader in, OutputWriter out) {
 		out.print(""Case #"" + testNumber + "": "");
 		if (testNumber == 4) {
 			assert Boolean.TRUE;
 		}
 		int totalNumbers = in.readInt();
 		int totalBits = in.readInt();
 		
 		long[] numbers = new long[totalNumbers];
 
 		for (int i = 0; i < numbers.length; i++) {
 			numbers[i] = Long.parseLong(in.readString(), 2);
 		}
 		
 		int[] onBits = new int[totalBits];
 		for (int i = 0; i < onBits.length; i++) {
 			onBits[i] = 0;
 			for (int j = 0; j < numbers.length; j++) {
 				onBits[i] += numbers[j] >> i & 1;
 			}
 		}
 		
 		long[] flows = new long[totalNumbers];
 		for (int i = 0; i < numbers.length; i++) {
 			flows[i] = Long.parseLong(in.readString(), 2);
 		}
 		
 		int numFlips = 0;
 		Vector<Integer> ambiguousBits = new Vector<Integer>();
 		for (int i = 0; i < onBits.length; i++) {
 			int flowOnBits = 0;
 			for (int j = 0; j < numbers.length; j++) {
 				flowOnBits += flows[j] >> i & 1;
 			}
 			if (flowOnBits != onBits[i]) {
 				if (totalNumbers - flowOnBits != onBits[i]) {
 					out.printLine(""NOT POSSIBLE"");
 					return;
 				}
 				numFlips++;
 				// Flip all bits
 				for (int j = 0; j < flows.length; j++) {
 					flows[j] = flows[j] ^ (1 << i);
 				}
 			} else if (totalNumbers - flowOnBits == flowOnBits) {
 				ambiguousBits.add(i);
 			}
 		}
 		
 		if (ambiguousBits.size() == 0 && isMatching(numbers, flows, new Vector<Integer>())) {
 			out.printLine(numFlips);
 			return;
 		}
 		for (int i = 0; i <= ambiguousBits.size(); i++) {
 			Vector<Integer> flipped = new Vector<Integer>();
 			if (canMatch(i, ambiguousBits, numbers, flows, flipped, 0)) {
 				out.printLine(numFlips + i);
 				return;
 			}
 		}
 		out.printLine(""NOT POSSIBLE"");
 	}
 	
 	boolean canMatch(int numFlips, Vector<Integer> bits, long[] numbers, long[] flows, Vector<Integer> flipped, int startingBit) {
 		if (numFlips == 0) return isMatching(numbers, flows, flipped);
 		if (numFlips > bits.size() - startingBit) return false;
 		
 		for (int i = startingBit; i < bits.size(); i++) {
 			flipped.add(bits.get(i));
 			if (canMatch(numFlips - 1, bits, numbers, flows, flipped, i + 1)) {
 				return true;
 			}
 			flipped.remove(flipped.size() - 1);
 		}
 		
 		
 		return false;
 	}
 	
 	boolean isMatching(long[] numbers, long[] flows, Vector<Integer> flipped) {
 		long flipper = 0;
 		for (int i = 0; i < flipped.size(); i++) {
 			flipper = flipper | 1 << flipped.get(i);
 		}
 		
 		HashSet<Long> hashSet = new HashSet<Long>();
 		for (int i = 0; i < flows.length; i++) {
 			long flow = flows[i] ^ flipper;
 			if (hashSet.contains(flow)) {
 				return false;
 			}
 			hashSet.add(flow);
 		}
 		
 		for (int i = 0; i < numbers.length; i++) {
 			if (!hashSet.contains(numbers[i])) {
 				return false;
 			}
 		}
 		
 		return true;
 	}
 }
 
 class InputReader {
 
 	private InputStream stream;
 	private byte[] buf = new byte[1024];
 	private int curChar;
 	private int numChars;
 
 	public InputReader(InputStream stream) {
 		this.stream = stream;
 	}
 
 	public int read() {
 		if (numChars == -1)
 			throw new InputMismatchException();
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				throw new InputMismatchException();
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar++];
 	}
 	
 	public char readChar() {
 		int c;
 		do {
 			c = read();
 		} while (isSpaceChar(c));
 		
 		return (char) c;
 	}
 
 	public int readInt() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		int res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 	
 	public float readFloat() {
 		return Float.parseFloat(readString());
 	}
 	
 	public double readDouble() {
 		return Double.parseDouble(readString());
 	}
 
 	public String readString() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		StringBuffer res = new StringBuffer();
 		do {
 			res.appendCodePoint(c);
 			c = read();
 		} while (!isSpaceChar(c));
 		return res.toString();
 	}
 	
 	public void readArray(char[] array) {
 		for (int i = 0; i < array.length; i++) {
 				array[i] = readChar();
 		}
 	}
 	
 	public void readArray(int[] array) {
 		for (int i = 0; i < array.length; i++) {
 				array[i] = readInt();
 		}
 	}
 
 	public void readArray(char[][] array) {
 		for (int i = 0; i < array.length; i++) {
 			for (int j = 0; j < array[i].length; j++)
 				array[i][j] = readChar();
 		}
 	}
 
 	public void readArray(int[][] array) {
 		for (int i = 0; i < array.length; i++) {
 			for (int j = 0; j < array[i].length; j++)
 				array[i][j] = readInt();
 		}
 	}
 
 	public void readVerticalArrays(int[]... arrays) {
 		for (int i = 0; i < arrays[0].length; i++) {
 			for (int j = 0; j < arrays.length; j++)
 				arrays[j][i] = readInt();
 		}
 	}
 
 	public static boolean isSpaceChar(int c) {
 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 	}
 
 	public String next() {
 		return readString();
 	}
 }
 
 class OutputWriter {
 	private final PrintWriter writer;
 
 	public OutputWriter(OutputStream outputStream) {
 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
 	}
 
 	public OutputWriter(Writer writer) {
 		this.writer = new PrintWriter(writer);
 	}
 
 	public void print(Object...objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(Object...objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void close() {
 		writer.close();
 	}
 
 }
 
 class MiscUtils {
 
 	public static void decreaseByOne(int[]...arrays) {
 		for (int[] array : arrays) {
 			for (int i = 0; i < array.length; i++)
 				array[i]--;
 		}
 	}
 
 }
 
 class ArrayUtils {
 
 	public static void fill(int[][] array, int value) {
 		for (int[] row : array)
 			Arrays.fill(row, value);
 	}
 }
 
 	
 	
 	","package TaskB;
 
 import java.io.OutputStreamWriter;
 import java.io.BufferedWriter;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.util.List;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 import java.util.ArrayList;
 import java.io.FileOutputStream;
 import java.io.FileInputStream;
 import java.math.BigInteger;
 import java.util.Collections;
 import java.io.InputStream;
 
 /**
  * Thank you to Egor Kulikov for Java Template
  * Built using CHelper plug-in
  * @author Richard Hua (rich@rkhua.com)
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""input.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""output.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		InputReader in = new InputReader(inputStream);
 		OutputWriter out = new OutputWriter(outputStream);
 		TaskB solver = new TaskB();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class TaskB {
 	public void solve(int testNumber, InputReader in, OutputWriter out) {
 		out.print(""Case #"" + testNumber + "": "");
 
 		double C = Double.parseDouble(in.readString());
 		double F = Double.parseDouble(in.readString());
 		double X = Double.parseDouble(in.readString());
 		
 		double time = Double.MAX_VALUE;
 		double farmTime = 0;
 		for (int i = 0; ; i++) {
 			double newTime = X / (2 + i * F);
 			if (i > 0) {
 				farmTime += C / (2 + (i - 1) * F);
 			}
 			newTime += farmTime;
 			
 			if (newTime < time) {
 				time = newTime;
 			} else {
 				break;	
 			}
 		}
 		
 		out.printLine(String.format(""%.7f"", time));
 	}
 }
 
 class InputReader {
 
 	private InputStream stream;
 	private byte[] buf = new byte[1024];
 	private int curChar;
 	private int numChars;
 
 	public InputReader(InputStream stream) {
 		this.stream = stream;
 	}
 
 	public int read() {
 		if (numChars == -1)
 			throw new InputMismatchException();
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				throw new InputMismatchException();
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar++];
 	}
 	
 	public char readChar() {
 		int c;
 		do {
 			c = read();
 		} while (isSpaceChar(c));
 		
 		return (char) c;
 	}
 
 	public int readInt() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		int res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 
 	public String readString() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		StringBuffer res = new StringBuffer();
 		do {
 			res.appendCodePoint(c);
 			c = read();
 		} while (!isSpaceChar(c));
 		return res.toString();
 	}
 
 	public static boolean isSpaceChar(int c) {
 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 	}
 
 	public String next() {
 		return readString();
 	}
 }
 
 class OutputWriter {
 	private final PrintWriter writer;
 
 	public OutputWriter(OutputStream outputStream) {
 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
 	}
 
 	public OutputWriter(Writer writer) {
 		this.writer = new PrintWriter(writer);
 	}
 
 	public void print(Object...objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(Object...objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void close() {
 		writer.close();
 	}
 
 	}
 
 class IOUtils {
 
 	public static void readIntArrays(InputReader in, int[]... arrays) {
 		for (int i = 0; i < arrays[0].length; i++) {
 			for (int j = 0; j < arrays.length; j++)
 				arrays[j][i] = in.readInt();
 		}
 	}
 
 	public static void readBoard(InputReader in, char[][] board) {
 		for (int i = 0; i < board.length; i++) {
 			for (int j = 0; j < board[i].length; j++)
 				board[i][j] = in.readChar();
 		}
 	}
 
 	}
 
 class MiscUtils {
 
 	public static void decreaseByOne(int[]...arrays) {
 		for (int[] array : arrays) {
 			for (int i = 0; i < array.length; i++)
 				array[i]--;
 		}
 	}
 
 	}
 
 class ArrayUtils {
 
 	public static void fill(int[][] array, int value) {
 		for (int[] row : array)
 			Arrays.fill(row, value);
 	}
 }
 
 	
 	
 	",1
56,18772,"import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.Scanner;
 
 public class TicTac {
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         int T = sc.nextInt();
 
 
         char matrix[][][] = new char[T][4][4];
         for (int i = 0; i < T; i++) {
             for (int j = 0; j < 4; j++) {
                 for (int k = 0; k < 4; k++) {
                     try {
                         char x = (char) br.read();
 
                         if (x != 10) {
                             matrix[i][j][k] = x;
                             //System.out.println(matrix[i][j][k]);
                         }
                         if (x == 10) {
                             k--;
                         }
 
                     } catch (IOException ex) {
                     }
                 }
             }
         }
 
         for (int i = 0; i < T; i++) {
             int countX = 0, countO = 0, colX = 0, colO = 0, digX = 0, digO = 0, dig2X = 0, dig2O = 0;
             int flagX = 0, flagO = 0;
             for (int j = 0; j < 4; j++) {
                 for (int k = 0; k < 4; k++) {
 
 
                     if (matrix[i][j][k] == 'X' || matrix[i][j][k] == 'T') {
                         countX++;
                     }
                     if (matrix[i][j][k] == 'O' || matrix[i][j][k] == 'T') {
                         countO++;
                     }
                     if (matrix[i][k][j] == 'X' || matrix[i][k][j] == 'T') {
                         colX++;
                     }
                     if (matrix[i][k][j] == 'O' || matrix[i][k][j] == 'T') {
                         colO++;
                     }
                     if (j == k) {
                         if (matrix[i][j][j] == 'X' || matrix[i][j][j] == 'T') {
 
 
                             digX++;
                         }
                         if (matrix[i][j][k] == 'O' || matrix[i][j][k] == 'T') {
 
                             digO++;
                         }
                     }
                     if (k + j == 3) { 
                         if (matrix[i][j][k] == 'X' || matrix[i][j][k] == 'T') {
                             dig2X++;
                         }
                         if (matrix[i][j][k] == 'O' || matrix[i][j][k] == 'T') {
                             dig2O++;
                         }
                     }
                 }
                 if (countX == 4 || colX == 4) {
                     System.out.println(""Case #""+(int)(i+1)+"": ""+""X won"");
                     flagX = 1;
                     break;
                 }
 
                 if (countO == 4 || colO == 4) {
                     System.out.println(""Case #""+(int)(i+1)+"": ""+""O won"");
                     flagO = 1;
                     break;
                 }
                 countX = 0;
                 colX = 0;
                 countO = 0;
                 colO = 0;
             }
             if (digX == 4 || dig2X == 4) {
                 System.out.println(""Case #""+(int)(i+1)+"": ""+""X won"");
                 flagX = 1;
                 continue;
             }
             if (digO == 4 || dig2O == 4) {
                 System.out.println(""Case #""+(int)(i+1)+"": ""+""O won"");
                 flagO = 1;
                 continue;
             }
             int flag = 0;
             if (flagX == 0 && flagO == 0) {
                 for (int j = 0; j < 4; j++) {
                     for (int k = 0; k < 4; k++) {
                         if (matrix[i][j][k] == '.') {
                             flag = 1;
                             break;
                         }
                     }
                 }
                 if (flag == 1) {
                     System.out.println(""Case #""+(int)(i+1)+"": ""+""Game has not completed"");
                 } else {
                     System.out.println(""Case #""+(int)(i+1)+"": ""+""Draw"");
                 }
 
             }
 
         }
 
     }
 }
","import java.util.ArrayList;
 import java.util.LinkedList;
 
 public class RecycledNumbers {
 	static String[] zeros = { ""0"", ""00"", ""000"", ""0000"", ""00000"", ""000000"" };
 
 	public static void solve(String fname) {
 		Read r = new Read();
 		r.Read(fname);
 		int numOfTestCases = r.noOfTestCases;
 		int[] numbers = r.nums;
 		String finalAnser = """";
 		for (int i = 0; i < numOfTestCases; i++) {
 			String answer = """";
 			int firstNum = numbers[2 * i];
 			int secondNum = numbers[2 * i + 1];
 			
 			int lastNumIndex = (int) (secondNum / Math.pow(10, ((secondNum+"""").length())-1));
 			lastNumIndex++;
 			String large="""";
 			for (int k = 9; k >=lastNumIndex; k--) {
 				//check large number
 				
 					large=large+"" ""+k;
 				
 				
 			}
 			// int mid = ((secondNum-firstNum)/2)+1;
 			int noOfans = 0;
 			for (int j = firstNum; j < secondNum; j++) {
 				String numb = j + """";
 				int firstIndex = -1;
 				int lastIndex = -1;
 
 				for (int k = zeros.length - 1; k >= 0; k--) {
 					// check zeros 
 					if (numb.contains(zeros[k])) {
 						firstIndex = numb.indexOf(zeros[k]);
 						//first index of 0 eg in 201000 it will be 3
 						lastIndex = firstIndex + zeros[k].length() - 1;
 						//last index = 3+(3-1) = 5 
 					}
 				}
 			
 			
 
 				// /LinkedList<Integer> number = new LinkedList<Integer>();
 				for (int k = 0; (k < numb.length()) ; k++) {
 					if(k>=firstIndex&& (k <= lastIndex)&&(!large.contains(numb.charAt(k)+""""))){
 					//	System.out.println(k);
 					}else{
 					String first = numb.substring(0, k);
 					String last = numb.substring(k, numb.length());
 				//	int la = Integer.parseInt(last);
 					String newNumb = last + first;
 				//	int biggest = (int) (la * Math.pow(10, numb.length()- last.length()));
 		
 						int numbC = Integer.parseInt(newNumb);
 						if ((numbC <= secondNum) && (numbC > j)) {
 							noOfans++;
 						}
 					
 				}
 				}
 				int x = 0;
 				// int k=0;
 				// while(!number.isEmpty()){
 				// x=(int) (x+number.removeLast()*Math.pow(10, k));
 				// k++;
 				// }
 
 			}
 			
 			answer = ""Case #"" + (i + 1) + "": "" + noOfans;
 		//	System.out.println(answer);
 			finalAnser = finalAnser + answer + ""\n"";
 
 		}
 		r.write(""out"", finalAnser);
 		System.out.println(finalAnser);
 	}
 	public static void main(String[] args) {
 
 		solve(""test"");
 		// String n = ""10002"";
 		// System.out.println(n.lastIndexOf('0'));
 	}
 }
",0
57,6971,"package jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 
 public class Password {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] x)throws IOException{
 	
 		  File file=new File(""A.in"");
 	        Writer output = null;
 	        File out=new File(""A.out"");
 	        output = new BufferedWriter(new FileWriter(out));
 	        BufferedReader fileIn = new BufferedReader(new FileReader(file));
 	        String fileLine,delims,outs;
 	        String[] tokens;
 	        int cases,num,total,goal,indA,indB,i,j;
 	        float [] items;
 	        float ans;
 	        
 	        fileLine=fileIn.readLine();
 	        cases = Integer.parseInt(fileLine);
 	        delims = ""[ ]+"";
 	        System.out.println(""Cases = ""+cases);
 	        for	(i=0;i<cases;++i)
 	        {
 	        output.write(""Case #"");
 	        output.write(Integer.toString(i+1));
 	        output.write("": "");
 	    	fileLine=fileIn.readLine();
 	    	tokens = fileLine.split(delims);
 	        num = Integer.parseInt(tokens[0]);
 	        total= Integer.parseInt(tokens[1]);
 	        fileLine=fileIn.readLine();
 	        tokens = fileLine.split(delims);
 	        items = new float[num];
 	        for(j = 0;j<num;++j)
 	        {
 	        	items[j]=Float.parseFloat(tokens[j]);
 	        }
 	        ans = solve(total,items);
 	        output.write(Float.toString(ans));
 	        output.write(""\r\n"");
 	        System.out.println(ans);
 	        }
 	        output.close();
 
 	}
 
 	private static float solve(int total, float[] items) {
 		int n = items.length;
 		int x,y,row,col,tmp,strval,i;
 		String str;
 		x = (int) Math.pow(2, n);
 		y = n+2;
 		float temp;
 		float [] prob = new float [x];
 		float [][] strokes = new float [y] [x];
 		for(col = 0;col<x;++col)
 		{
 			str = Integer.toBinaryString(col);
 			while(str.length()<n)
 			{
 				str = ""0""+str;
 			}
 			tmp = 0;
 			temp = 1;
 			while(tmp<n)
 			{
 				temp = temp *( (Integer.parseInt(Character.toString(str.charAt(tmp)))-1)*(-1)*items[tmp] + Integer.parseInt(Character.toString(str.charAt(tmp)))*(1-items[tmp]));
 				++tmp;
 			}
 			prob[col]=temp;
 			//System.out.println(prob[col]);
 		}
 		
 		for (row = 0; row<y;++row)
 		{
 			for(col = 0;col<x;++col)
 			{
 				strval = 0;
 				str = Integer.toBinaryString(col);
 				while(str.length()<n)
 				{
 					str = ""0""+str;
 				}
 				
 				if(row ==0)
 				{
 					if(col ==0)
 					{strokes[row][col]=total-n+1;}
 					else
 					{strokes[row][col]=total+total-n+2;}	
 				}
 				else if(row == y-1)
 				{
 					if(n!=total)
 					{
 						strokes[row][col] = total+1+1;
 					}
 					else
 					{
 						if(col==0)
 						{
 							strokes[row][col] = 1;
 						}
 						else
 						{
 							strokes[row][col] = total+1+1;
 						}
 					}
 				}
 				else
 				{
 					for(i=0;i<row;++i)
 					{
 						++strval;
 						++strval;
 						
 					}
 					str = str.substring(0, n-row);
 					while(str.length()<n)
 					{
 						str = ""0""+str;
 					}
 					if(str.contains(""1""))
 					{
 						strval=strval+total-n;
 						++strval;
 						strval =strval + total;
 						++strval;
 					}
 					else
 					{
 						strval=strval+total-n;
 						++strval;
 					}
 					strokes[row][col]=strval;
 				}
 			}
 		}
 		
 		float min= 1000000000;
 		for (row = 0; row<y;++row)
 		{
 			temp = 0;
 			for(col = 0;col<x;++col)
 			{
 				temp =  temp+prob[col]*strokes[row][col];
 			}
 			if(temp<min)
 			{
 				min = temp;
 			}
 		}
 		for (row = 0; row<y;++row)
 		{
 			temp = 0;
 			str="""";
 			for(col = 0;col<x;++col)
 			{
 				str=str+strokes[row][col]+"" "";
 			}
 			System.out.println(str);
 		}
 		
 		return min;
 	}
 }
","import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.HashMap;
 import java.util.Map;
 
 
 public class ProblemC {
 
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
 		int T = Integer.parseInt(reader.readLine());
 		
 		String[] split;
 		StringBuilder number;
 		int A, B, count, nAux;
 		char first;
 		//Map<Integer, Boolean> counted;
 		Map<Integer, Boolean> countedAux;
 		
 		for(int t = 0; t < T; t++){
 			//counted = new HashMap<Integer, Boolean>();
 			count = 0;
 			split = reader.readLine().split("" "");
 			A = Integer.parseInt(split[0]);
 			B = Integer.parseInt(split[1]);
 			
 			extern:for(int n = A; n < B; n++){
 				number = new StringBuilder(String.valueOf(n));
 				if(sameNumbers(number)){
 					continue;
 				}
 				//if(counted.get(n) != null) continue;
 				//counted.put(n, true);
 				countedAux = new HashMap<Integer, Boolean>();
 				countedAux.put(n, true);
 				
 				for(int i = 0; i < number.length()-1; i++){
 					first = number.charAt(0);
 					number.deleteCharAt(0);
 					number.append(first);
 					if(number.charAt(0) == '0') {
 						continue;
 					}
 					nAux = Integer.parseInt(number.toString());
 					if(nAux > B) {
 						continue;
 					}
 					if(nAux < A) {
 						continue;
 					}
 					if(nAux < n) continue extern;
 					//counted.put(nAux, true);
 					countedAux.put(nAux, true);
 				}
 				if(countedAux.size() > 1){
 					count += (countedAux.size() * (countedAux.size()-1))/2;
 				}
 			}
 			System.out.println(""Case #""+(t+1)+"": ""+count);
 		}
 	}
 	
 	private static boolean sameNumbers(StringBuilder number){
 		for(int i = 1; i < number.length(); i++){
 			if(number.charAt(i-1) != number.charAt(i)) return false;
 		}
 		return true;
 	}
 }
",0
58,15796,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package magiqka;
 
 import java.util.List;
 
 /**
  *
  * @author hpadmin
  */
 public class Opposition {
 
     private char opposedCharA;
     private char opposedCharB;
 
     public Opposition( char A, char B ){
 
         opposedCharA = A;
         opposedCharB = B;
 
     }
 
     public void check( List<Character> invokedList ){
 
         if( invokedList.contains(opposedCharA) &&
                 invokedList.contains(opposedCharB)){
 
             invokedList.clear();
 
         }
 
     }
 
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package magiqka;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  *
  * @author hpadmin
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         // TODO code application logic here
 
          try {
             BufferedReader reader = new BufferedReader(new FileReader(""B-large.in""));
             // TODO code application logic here
             BufferedWriter writer = new BufferedWriter( new FileWriter(""output.txt"") );
 
 
             String line;
 
             line = reader.readLine();
 
             int N = Integer.parseInt(line);
 
             System.out.println( ""number of sequences: ""+N );
 
             int count = 1;
 
             while(( line = reader.readLine())!=null ){
 
             
 
                 Game game = new Game(line);
 
                 String result = game.invoke();
 
                 writer.write( ""Case #""+count+"": ""+result +""\r\n"");
                 System.out.println( result );
 
                 count++;
 
             }
 
             writer.close();
 
 
         } catch (FileNotFoundException ex) {
             Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
         } catch (IOException ex) {
             Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
         }
 
 
     }
 
 }
",1
59,8472,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 
 
 public class FairAndSquare implements Comparator<String>{
 
 	String [] decisions;
 	ArrayList<String[]> testCases;
 	public FairAndSquare() {
 		this.testCases = new ArrayList<String[]>();
 	}
 	
 	
 	public void checkAllTestCases(String filePath) throws Exception{
 		readFile(filePath);
 		for (int i = 0; i < testCases.size(); i++) {
 			String d = checkTestCase(this.testCases.get(i));
 			this.decisions[i] = d;
 		}
 		writeFile(""output.txt"");
 	}
 
 	public String checkTestCase(String [] testCase){
 		String A = testCase[0];
 		String B = testCase[1];
 		int count = 0;
 		ArrayList<String> palindromsToB = allPalindromic(B);
 		Collections.sort(palindromsToB, new FairAndSquare());
 		
 		for (int i = 0; i < palindromsToB.size(); i++) {
 			String palindrom = palindromsToB.get(i);
 			String multiplied = multiply(palindrom, palindrom);
 			int comparisonToB = compareTwoNumbers(multiplied, B) ;
 			if(compareTwoNumbers(multiplied, A) >=0 &&  comparisonToB <=0){
 				if(isPalindrom(multiplied)){
 					count++;
 				}
 			}else if (comparisonToB > 0){
 				return String.valueOf(count);
 			}
 		}
 		return String.valueOf(count);
 	}
 	
 	
 	public ArrayList<String> allPalindromic(String limit) {
 	    ArrayList<String> result = new ArrayList<String>();
 	    for (int i = 0; i <= 9 ; i++)
 	        result.add(String.valueOf(i));
 	    boolean cont = true;
 	    for (int i = 1; cont; i++) {
 	        StringBuffer rev = new StringBuffer("""" + i).reverse();
 	        cont = false;
 	        for (String d : ""0123456789"".split("""")) {
 	            String n = ("""" + i + d + rev);
 	            int comparison = compareTwoNumbers(n, limit);
 	            if(comparison <=0){
 	                cont = true;
 	                result.add(n);
 	           }
 	        }
 	    }
 	    return result;
 	}
 	
 	private void writeFile(String filePath) throws IOException{
 		FileWriter fstream = new FileWriter(filePath);
 		BufferedWriter out = new BufferedWriter(fstream);
 		for (int i = 0; i < this.decisions.length; i++) {
 			out.write(""Case #""+(i+1)+"": ""+this.decisions[i] +""\n"");	
 		}
 		out.close();
 	}
 
 	
 	
 	public void readFile(String filePath) throws IOException{
 		FileInputStream fstream = new FileInputStream(filePath);
 		DataInputStream in = new DataInputStream(fstream);
 		BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		int numberOfCases = Integer.parseInt(br.readLine());
 		this.decisions = new String[numberOfCases];
 		for (int i = 0; i < numberOfCases; i++) {
 			String[] nm = br.readLine().split("" "");
 			String [] testCase = new String[2];
 			testCase[0] = nm[0];
 			testCase[1] = nm[1];
 			this.testCases.add(testCase);
 		}
 	}
 	
 	
 	
 	public int compareTwoNumbers(String num1, String num2){
 		if(num1.length() > num2.length()){
 			return 1; // num1 is bigger
 		}else if (num2.length() > num1.length()){
 			return -1; //num2 is bigger
 		} 	
 		char [] array1 = num1.toCharArray();
 		char [] array2 = num2.toCharArray();
 		for (int i = 0; i < array1.length; i++) {
 			if(array1[i] > array2[i]){
 				return 1;
 			}else if(array2[i] > array1[i]){
 				return -1;
 			}
 		}
 		return 0;
 	}
 	
 	public boolean isPalindrom(String str){
 		 int n = str.length();
 		  for (int i=0;i<(n / 2) + 1;++i) {
 		     if (str.charAt(i) != str.charAt(n - i - 1)) {
 		         return false;
 		     }
 		  }
 		  return true;
 	}
 	
 	public String square(String str){
 		  String number1 = str;
 		  String number2 = str;
 		  char[] n1 = number1.toCharArray();
 		  char[] n2 = number2.toCharArray();
 		  int result = 0;
 		  for (int i = 0; i < n1.length; i++) {
 	        for (int j = 0; j < n2.length; j++) {
 	            result += (n1[i] - '0') * (n2[j] - '0')* (int) Math.pow(10, n1.length * 2 - (i + j + 2));
 	        }
 		  }
 		    System.out.println(result);
 		
 		
 		return """";
 	}
 	
 	
 	private int[] toIntArray(String str){
 		int [] intArray = new int [str.length()];
 		char[] charArray = str.toCharArray();
 		for (int i = 0; i < charArray.length; i++) {
 			intArray[i] = Character.getNumericValue(charArray[i]);
 		}
 		return intArray;
 	}
 	
 	
 	public String multiply(String a, String b) {
 		  int[] ca = toIntArray(a); // please write toIntArray() yourself.
 		  int[] cb = toIntArray(b);
 		  int[] result = new int[ca.length + cb.length + 1];
 		  int[] line = new int[ca.length + cb.length + 1];
 		  for (int i=0;i<cb.length;i++) {
 		    for (int k=0;k<line.length;k++) line[k] = 0;
 		    int residue = 0;
 		    for (int k=0;k<ca.length;k++) {
 		      int digit = cb[cb.length-1-i] * ca[ca.length-1-k] + residue;
 		      residue = digit/10;
 		      digit = digit%10;
 		      line[k+i] = digit;
 		    }
 		    line[ca.length+i] = residue;
 		    residue = 0;
 		    for (int k=0;k<result.length;k++) {
 		      int digit = result[k] + line[k] + residue;
 		      residue = digit/10;
 		      digit = digit%10;
 		      result[k] = digit;
 		    } 
 		  }
 		  StringBuffer sb = new StringBuffer();
 		  boolean matter = false;
 		  for (int i=0;i<result.length;i++) {
 		    if (matter == true || result[result.length-1-i] > 0) {
 		      sb.append(result[result.length-1-i]);
 		      matter = true;
 		    }
 		  }
 		  return sb.toString();
 		}	
 	
 	
 	public static void main(String[] args) throws Exception {
 		FairAndSquare fair = new FairAndSquare();
 		fair.checkAllTestCases(""C-small-attempt0.in"");
 		
 	}
 
 
 	@Override
 	 public int compare(String o1, String o2) {  
 	      if (o1.length() > o2.length()) {
 	         return 1;
 	      } else if (o1.length() < o2.length()) {
 	         return -1;
 	      }
 	      return o1.compareTo(o2);
 	  }
 
 	
 	
 }
","package c2012;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 
 public class Dance {
 
 	ArrayList<DanceTestCase> testCases = new ArrayList<DanceTestCase>();
 	
 	public void perform(String path) throws IOException{
 		readInput(path);
 		for (int i = 0; i < this.testCases.size(); i++) {
 			DanceTestCase t = this.testCases.get(i);
 			t.outPut = caluclateMaxNumber(t);
 		}
 		writeOutput();
 	}
 	
 	public int caluclateMaxNumber(DanceTestCase t){
 		int count = 0;
 		int surpriseCount = t.surprisingCount;
 		for (int i = 0; i < t.totalScore.length; i++) {
 			int score = t.totalScore[i];
 			if(t.p==0){
 				count++;
 				continue;
 			}
 			int div = score/t.p;
 			if(div==2){
 				int rem = score%t.p;
 				if(Math.abs(t.p-rem)>=3){
 					if(surpriseCount>0){
 						count++;
 						surpriseCount--;
 					}
 				}else{
 					count++;
 				}
 			}else if (div>2){
 				count++;
 			}
 		}
 		return count;
 	}
 	
 	
 	
 	public void readInput(String path) throws IOException{
 		FileInputStream fstream = new FileInputStream(path);
 		DataInputStream in = new DataInputStream(fstream);
 		BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		int numberOfTestCases = Integer.parseInt(br.readLine());
 		for (int i = 0; i < numberOfTestCases; i++) {
 			testCases.add(new DanceTestCase(br.readLine().split("" "")));
 		}
 
 	}
 	
 	private void writeOutput() throws IOException{
 		 FileWriter fstream = new FileWriter(""output_files/out.txt"");
 		 BufferedWriter out = new BufferedWriter(fstream);
 		for (int i = 0; i < this.testCases.size(); i++) {;
 			String output = ""Case #""+(i+1)+ "": "" + this.testCases.get(i).outPut+""\n"";
 			out.write(output);
 		}
 		 out.close();
 	}
 
 	public static void main(String[] args) throws IOException {
 		Dance d = new Dance();
 		d.perform(""input_files/B-small-attempt1.in"");
 	}
 	
 }
",1
60,5380,"
 import java.util.Arrays;
 
 public class Game {
 	Integer sNo;
 	char winner;
 	char [][] scoreBord=new char[4][4];
 	String statusMsg;
 	Boolean won;
 	
 	
 	public Game(Integer sNo, char[][] scoreBord) {
 		super();
 		this.sNo = sNo;
 		this.scoreBord = scoreBord;
 	}
 	
 	public Game() {
 		super();
 	}
 
 	public char getWinner() {
 		return winner;
 	}
 	public void setWinner(char winner) {
 		this.winner = winner;
 	}
 	public char[][] getScoreBord() {
 		return scoreBord;
 	}
 	public void setScoreBord(char[][] scoreBord) {
 		this.scoreBord = scoreBord;
 	}
 	public String getStatusMsg() {
 		return statusMsg;
 	}
 	public void setStatusMsg(String statusMsg) {
 		this.statusMsg = statusMsg;
 	}
 	public Integer getsNo() {
 		return sNo;
 	}
 	public void setsNo(Integer sNo) {
 		this.sNo = sNo;
 	}
 	
 	public Boolean getWon() {
 		return won;
 	}
 
 	public void setWon(Boolean won) {
 		this.won = won;
 	}
 
 	public String printArray(char[][] scoreBord){
 		StringBuilder sbBuilder=new StringBuilder();
 		for(int i=0;i<4;i++){
 			for(int j=0;j<4;j++){
 				sbBuilder.append(scoreBord[i][j]);
 			}
 			sbBuilder.append(',');
 		}
 		return sbBuilder.toString();
 	}
 	@Override
 	public String toString() {
 		return ""Game [sNo="" + sNo + "", winner="" + winner + "", scoreBord=""
 				+ printArray(scoreBord) + "", statusMsg="" + statusMsg + "" won= ""+won +""]"";
 	}
 
 
 }
","
 import java.util.Arrays;
 
 public class Game {
 	Integer sNo;
 	char winner;
 	char [][] scoreBord=new char[4][4];
 	String statusMsg;
 	Boolean won;
 	
 	
 	public Game(Integer sNo, char[][] scoreBord) {
 		super();
 		this.sNo = sNo;
 		this.scoreBord = scoreBord;
 	}
 	
 	public Game() {
 		super();
 	}
 
 	public char getWinner() {
 		return winner;
 	}
 	public void setWinner(char winner) {
 		this.winner = winner;
 	}
 	public char[][] getScoreBord() {
 		return scoreBord;
 	}
 	public void setScoreBord(char[][] scoreBord) {
 		this.scoreBord = scoreBord;
 	}
 	public String getStatusMsg() {
 		return statusMsg;
 	}
 	public void setStatusMsg(String statusMsg) {
 		this.statusMsg = statusMsg;
 	}
 	public Integer getsNo() {
 		return sNo;
 	}
 	public void setsNo(Integer sNo) {
 		this.sNo = sNo;
 	}
 	
 	public Boolean getWon() {
 		return won;
 	}
 
 	public void setWon(Boolean won) {
 		this.won = won;
 	}
 
 	public String printArray(char[][] scoreBord){
 		StringBuilder sbBuilder=new StringBuilder();
 		for(int i=0;i<4;i++){
 			for(int j=0;j<4;j++){
 				sbBuilder.append(scoreBord[i][j]);
 			}
 			sbBuilder.append(',');
 		}
 		return sbBuilder.toString();
 	}
 	@Override
 	public String toString() {
 		return ""Game [sNo="" + sNo + "", winner="" + winner + "", scoreBord=""
 				+ printArray(scoreBord) + "", statusMsg="" + statusMsg + "" won= ""+won +""]"";
 	}
 
 
 }
",1
61,3754,"import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 
 public class C {
 
 	public static void main(String[] args) {
 		try {
 			// so eclipse can read file from system in
 			System.setIn(new FileInputStream(new File(""small.in"")));
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 		Scanner scanner = new Scanner(System.in);
 		long T = scanner.nextLong();
 		scanner.nextLine();
 		for (int i = 0; i < T; i++) {
 			long A = scanner.nextLong();
 			long B = scanner.nextLong();
 			long count = 0;
 			for (long number = A; number <= B; number++) {
 				String numberS = String.valueOf(number);
 				Set<String> newNumbers = new HashSet<String>();
 				for (int k = 1; k < numberS.length(); k++) {
 					String newNumberS = numberS.substring(numberS.length() - k) + numberS.substring(0, numberS.length() - k);
 					if (newNumbers.contains(newNumberS)) {
 						continue;
 					}
 					newNumbers.add(newNumberS);
 					long newNumber = Long.parseLong(newNumberS);
 					if (newNumber != number && newNumber > number && newNumber >= A && newNumber <= B) {
 						count++;
 					}
 				}
 			}
 			System.out.printf(""Case #%d: %d%n"", i + 1, count);
 		}
 	}
 }
","import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 
 public class C {
 
 	public static void main(String[] args) {
 		try {
 			// so eclipse can read file from system in
 			System.setIn(new FileInputStream(new File(""small.in"")));
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 		Scanner scanner = new Scanner(System.in);
 		long T = scanner.nextLong();
 		scanner.nextLine();
 		for (int i = 0; i < T; i++) {
 			long A = scanner.nextLong();
 			long B = scanner.nextLong();
 			long count = 0;
 			for (long number = A; number <= B; number++) {
 				String numberS = String.valueOf(number);
 				Set<String> newNumbers = new HashSet<String>();
 				for (int k = 1; k < numberS.length(); k++) {
 					String newNumberS = numberS.substring(numberS.length() - k) + numberS.substring(0, numberS.length() - k);
 					if (newNumbers.contains(newNumberS)) {
 						continue;
 					}
 					newNumbers.add(newNumberS);
 					long newNumber = Long.parseLong(newNumberS);
 					if (newNumber != number && newNumber > number && newNumber >= A && newNumber <= B) {
 						count++;
 					}
 				}
 			}
 			System.out.printf(""Case #%d: %d%n"", i + 1, count);
 		}
 	}
 }
",1
62,9763,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class SnapperDone {
 
 	private static BufferedReader br;
 
 	private static BufferedWriter bw;
 
 	public static void main(String[] args) throws Exception {
 		br = new BufferedReader(new FileReader(args[0]));
 		bw = new BufferedWriter(new FileWriter(args[1]));
 
 		int T = Integer.parseInt(br.readLine());
 
 		for (int l = 1; l <= T; l++) {
 
 			String line2 = br.readLine();
 			String[] arr = line2.split("" "");
 			int N = Integer.parseInt(arr[0]);
 			long K = Long.parseLong(arr[1]);
 
 			long i = (1 << N);
 
 			boolean result = false;
 
 			if (N == 1)
 				result = (K % 2) == 1;
 			else{
 				result = (K % i) == (i-1);
 			}
 
 			bw.write(""Case #"" + l + "": "" + (result ? ""ON"" : ""OFF"") + ""\n"");
 
 		}
 		bw.flush();
 		bw.close();
 	}
 }
","import java.util.*;
 import java.math.*;
 import java.io.*;
 import java.awt.*;
 import java.lang.*;
 import java.text.*;
 import java.util.regex.*;
 import javax.swing.*;
 
 public class C {
 
 	static Scanner sc;
 	static String filein = ""C-small-attempt0.in"";
 	static String fileout = ""out"";
 	static String correctout = ""testout"";
 	static PrintWriter out;
 
 	public static int cut(String[] arr,boolean[][] used,int dim)
 	{
 		int count=0;
 		for(int x=0;x+dim<=arr.length;x++)
 			for(int y=0;y+dim<=arr[0].length();y++)
 			{
 				boolean good=true;
 				String chk="""";
 				f:for(int xx=x;xx<x+dim;xx++)
 				{
 					String a=arr[xx].substring(y,y+dim);
 					for(int yy=y;yy<y+dim;yy++)
 						if(used[xx][yy])
 						{
 							good=false;
 							break f;
 						}
 					if(dim%2==0)
 					{
 						if(a.endsWith(""0""))a+=""1"";
 						else a+=""0"";
 					}
 					else
 					{
 						//System.out.println(a+"" ""+x+"" ""+y+"" ""+dim);
 					}
 					chk+=a;
 				}
 				if(good)
 				if(good(chk))
 				{
 					//System.out.println(chk+"" ""+x+"" ""+y+"" ""+dim);
 					count++;
 					for(int xx=x;xx<x+dim;xx++)
 					{
 						for(int yy=y;yy<y+dim;yy++)
 							used[xx][yy]=true;
 					}
 				}
 			}
 		return count;
 	}
 	public static boolean good(String str)
 	{
 		for(int x=0;x<str.length()-1;x++)
 			if(str.charAt(x)==str.charAt(x+1))
 				return false;
 		return true;
 	}
 	public static void main(String[] args) throws Exception {
 		sc = new Scanner(new File(filein));
 		out = new PrintWriter(new FileWriter(fileout));
 		int ff = sc.nextInt();
 		sc.nextLine();
 		for (int www = 1; www <= ff; www++) {
 			int r=sc.nextInt();
 			int c=sc.nextInt();
 			String[] mat=new String[r];
 			boolean[][] used=new boolean[r][c];
 			for(int x=0;x<r;x++)
 			{
 				String cons="""";
 				String str=sc.next();
 				for(char ch:str.toCharArray())
 				{
 					String s=Integer.toBinaryString(Integer.parseInt(ch+"""",16));
 					while(s.length()<4)s=""0""+s;
 					cons+=s;
 					
 				}
 				//System.out.println(cons);
 				mat[x]=cons;
 			}
 			int num=0;
 			ArrayList<String> answer=new ArrayList<String>();
 			for(int x=r;x>0;x--)
 			{
 				int ans=cut(mat,used,x);
 				if(ans!=0)
 				{
 					num++;
 					answer.add(x+"" ""+ans);	
 				}
 			}
 			print(www,num+"""");
 			for(String s:answer)
 				out.println(s);
 			
 		}
 		out.close();
 		prints(""DONE"");
 		/*
 		Scanner kb = new Scanner(System.in);
 		System.out.println(""Check Answers?(y/n)"");
 		char c = kb.next().toLowerCase().charAt(0);
 		if (c == 'y')
 			check();
 		//*/
 	}
 
 	public static void print(int num, String ans) {
 		out.println(""Case #"" + num + "": "" + ans);
 	}
 
 	public static void prints(String ans) {
 		System.out.println(ans);
 	}
 
 	public static void printe(String ans) {
 		System.err.println(ans);
 	}
 
 	public static void check() throws Exception {
 		Scanner a = new Scanner(new File(fileout));
 		Scanner b = new Scanner(new File(correctout));
 		while (a.hasNext()) {
 			System.out.println(a.nextLine().equals(b.nextLine()));
 		}
 	}
 }
",0
63,7782,"import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 
 public class CookieClicker {
 	
 	static final String filename = ""B-small-attempt0"";
 	
 	static final int VARS = 3;
 	
 	static InputStream in;
 	static OutputStream out;
 	
 	public static void main(String[] args){
 		try {
 			in = new FileInputStream(filename + "".in"");
 			out =  new FileOutputStream(filename + "".out"");
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 //		in = System.in;
 //		out = System.out;
 		
 		
 		IO.init(in, out);
 		
 		int cases = IO.nextInt();
 		for(int i = 1; i <= cases; i++){
 			//read vars
 			double[] vars = IO.readDoubleArray(VARS);
 			
 			//read data
 			
 			//solve
 			double d = solve(vars[0], vars[1], vars[2]);
 			//
 			IO.writeStringln(""Case #"" + i + "": "" + d);
 		}
 		IO.finish();
 
 	}
 
 	private static double solve(double cost, double farm, double goal) {
 		double rate = 2.0;
 		double time = 0, current = 0;
 		
 		while(cost/rate + (goal/(rate + farm)) < goal/rate) {
 			time += cost/rate;
 			rate += farm;
 		}
 		time += goal/rate;
 		return time;
 	}
 }
","import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 
 
 public class DeceitfulWar {
 	
 	static final String filename = ""D-small-attempt0"";
 	
 	static final int VARS = 2;
 	
 	static InputStream in;
 	static OutputStream out;
 	
 	public static void main(String[] args){
 		try {
 			in = new FileInputStream(filename + "".in"");
 			out =  new FileOutputStream(filename + "".out"");
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 //		in = System.in;
 //		out = System.out;
 //		
 		
 		IO.init(in, out);
 		
 		int cases = IO.nextInt();
 		for(int i = 1; i <= cases; i++){
 			int size = IO.nextInt();
 			//read vars
 			double[] a = IO.readDoubleArray(size);
 			double[] b = IO.readDoubleArray(size);
 			
 			//read data
 			
 			//solve
 			int[] ans = solve(size, a, b);
 			//
 			IO.writeStringln(""Case #"" + i + "": "" + ans[0] + "" "" + ans[1]);
 		}
 		IO.finish();
 
 	}
 
 	private static int[] solve(int size, double[] a, double[] b) {
 		int cheat = 0;
 		int fair = 0;
 		Arrays.sort(a);
 		Arrays.sort(b);
 		
 		ArrayList<Double> aa = new ArrayList<Double>(size);
 		ArrayList<Double> bb = new ArrayList<Double>(size);
 //		System.out.println(Arrays.toString(a));
 //		System.out.println(Arrays.toString(b));
 		for(double d:a)
 			aa.add(d);
 		for(double d:b)
 			bb.add(d);
 		
 		for (int i = 0; i < b.length; i++) {
 			int j = Collections.binarySearch(bb, a[i]);
 			if(j < 0)
 				j = -j - 1 ;
 			int k = bSearchIdx(bb, a[i]);
 			if(j != k){
 				System.out.println(""=========="");
 				System.out.println(""j "" + j + "" k "" + k);
 			}
 			if(bb.size() == k)
 				k--;
 			
 			if(bb.get(k) < a[i])
 				fair++;
 			bb.remove(k);
 		}
 		
 		for (int j = size - 1; j >= 0; j--) {
 			if(a[j] > b[j]) {
 				cheat++;
 			} else {
 				if(j > 0) {
 					for (int k = 0; k < j; k++) {
 						a[k] = a[k+1];
 					}
 				}
 			}
 		}
 		
 		
 		return new int[]{cheat, fair};
 	}
 	
 	private static int bSearchIdx(ArrayList<Double> a, Double key) {
 		int lo = 0;
 		int hi = a.size();
 		while(lo < hi) {
 			int mid = lo + (hi - lo)/2;
 			Double m = a.get(mid);
 			if(m.equals(key))
 				return mid;
 			if(key < m)
 				hi = mid;
 			else
 				lo = mid + 1;
 			
 		}
 		return lo;
 		
 	}
 }
",1
64,101,"import static java.lang.Double.parseDouble;
 import static java.lang.Integer.parseInt;
 import static java.lang.Long.parseLong;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 import static java.lang.System.exit;
 import static java.util.Arrays.fill;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 public class C {
 	
 	static BufferedReader in;
 	static PrintWriter out;
 	static StringTokenizer tok;
 	static int test;
 	
 	static class Edge {
 		final int to;
 		Edge pair;
 		int capacity;
 		
 		Edge(int to, int capacity) {
 			this.to = to;
 			this.capacity = capacity;
 		}
 		
 		void addFlow(int flow) {
 			if ((capacity -= flow) < 0 || (pair.capacity += flow) < 0) {
 //				throw new AssertionError();
 			}
 		}
 		
 		void addNonreversibleFlow(int flow) {
 			if ((capacity -= flow) < 0) {
 //				throw new AssertionError();
 			}
 		}
 	}
 	
 	static Edge createEdge(List<Edge> net[], int a, int b, int forwardCapacity, int reverseCapacity) {
 		Edge ea = new Edge(b, forwardCapacity);
 		Edge eb = new Edge(a, reverseCapacity);
 		ea.pair = eb;
 		eb.pair = ea;
 		net[a].add(ea);
 		net[b].add(eb);
 		return ea;
 	}
 	
 	static int pushFlow(List<Edge> net[], boolean seen[], boolean terminal[], int cur, int flow) {
 		if (seen[cur]) {
 			return 0;
 		}
 		seen[cur] = true;
 		if (terminal[cur]) {
 			return flow;
 		}
 		for (Edge e: net[cur]) {
 			int newFlow;
 			if (flow < 0) {
 				newFlow = max(flow, -e.pair.capacity);
 			} else {
 				newFlow = min(flow, e.capacity);
 			}
 			if (newFlow == 0) {
 				continue;
 			}
 			newFlow = pushFlow(net, seen, terminal, e.to, newFlow);
 			if (newFlow != 0) {
 				e.addFlow(newFlow);
 				return newFlow;
 			}
 		}
 		return 0;
 	}
 	
 	static void solve() throws Exception {
 		int n = nextInt();
 		boolean leaves[] = new boolean[n];
 		int ids[] = new int[n];
 		int idcnt = 0;
 		int freecnt = 0;
 		Map<Integer, Integer> idmap = new HashMap<>();
 		for (int i = 0; i < n; i++) {
 			boolean leave = next().charAt(0) != 'E';
 			leaves[i] = leave;
 			int id = nextInt();
 			if (id == 0) {
 				ids[i] = -1;
 				++freecnt;
 			} else {
 				if (idmap.containsKey(id)) {
 					ids[i] = idmap.get(id);
 				} else {
 					idmap.put(id, ids[i] = idcnt++);
 				}
 			}
 		}
 		final int eventI = 0;
 		final int freeI = eventI + n;
 		final int personI = freeI + freecnt;
 		final int sourceI = personI + idcnt * freecnt;
 		final int sinkI = sourceI + 1;
 		List<Edge> net[] = new List[sinkI + 1];
 		for (int i = 0; i < net.length; i++) {
 			net[i] = new ArrayList<>();
 		}
 		int lastEvent[] = new int[idcnt];
 		int lastFree = sourceI;
 		fill(lastEvent, sourceI);
 		Edge eventEdges[] = new Edge[n];
 		for (int i = 0, j = 0; i < n; i++) {
 			if (ids[i] < 0) {
 				for (int id = 0; id < idcnt; id++) {
 					int peid = personI + id * freecnt + j;
 					createEdge(net, lastEvent[id], peid, 1, 0);
 					lastEvent[id] = peid;
 					createEdge(net, eventI + i, peid, leaves[i] ? 0 : 1, leaves[i] ? 1 : 0);
 				}
 				createEdge(net, lastFree, freeI + j, n, 0);
 				lastFree = freeI + j;
 				createEdge(net, eventI + i, freeI + j, leaves[i] ? 0 : 1, leaves[i] ? 1 : 0);
 				++j;
 			} else {
 				createEdge(net, lastEvent[ids[i]], eventI + i, 1, 0);
 				lastEvent[ids[i]] = eventI + i;
 			}
 			if (leaves[i]) {
 				eventEdges[i] = createEdge(net, eventI + i, sinkI, 1, 0);
 			} else {
 				eventEdges[i] = createEdge(net, sourceI, eventI + i, 1, 0);
 			}
 		}
 		Edge peopleEdges[] = new Edge[idcnt];
 		for (int id = 0; id < idcnt; id++) {
 			peopleEdges[id] = createEdge(net, lastEvent[id], sinkI, 1, 0);
 		}
 		Edge freeEdge = createEdge(net, lastFree, sinkI, n, 0);
 		boolean terminal[] = new boolean[net.length];
 		boolean seen[] = new boolean[net.length];
 		terminal[sourceI] = true;
 		terminal[sinkI] = true;
 		for (int i = 0; i < n; i++) {
 			if (eventEdges[i].capacity > 0) {
 				seen[sourceI] = false;
 				seen[sinkI] = false;
 				if (pushFlow(net, seen, terminal, eventI + i, leaves[i] ? -1 : 1) == 0) {
 					fill(seen, false);
 					if (pushFlow(net, seen, terminal, eventI + i, leaves[i] ? -1 : 1) == 0) {
 						printCase();
 						out.println(""CRIME TIME"");
 						return;
 					}
 				}
 				eventEdges[i].addNonreversibleFlow(1);
 			} else {
 				eventEdges[i].pair.addNonreversibleFlow(1);
 			}
 		}
 		terminal[sinkI] = false;
 		while (true) {
 			seen[sourceI] = false;
 			seen[sinkI] = false;
 			if (pushFlow(net, seen, terminal, sinkI, n) == 0) {
 				fill(seen, false);
 				if (pushFlow(net, seen, terminal, sinkI, n) == 0) {
 					break;
 				}
 			}
 		}
 		int ans = n - freeEdge.capacity;
 		for (Edge e: peopleEdges) {
 			if (e.capacity == 0) {
 				++ans;
 			}
 		}
 		printCase();
 		out.println(ans);
 	}
 	
 	static void printCase() {
 		out.print(""Case #"" + test + "": "");
 	}
 	
 	static void printlnCase() {
 		out.println(""Case #"" + test + "":"");
 	}
 	
 	static int nextInt() throws IOException {
 		return parseInt(next());
 	}
 
 	static long nextLong() throws IOException {
 		return parseLong(next());
 	}
 
 	static double nextDouble() throws IOException {
 		return parseDouble(next());
 	}
 
 	static String next() throws IOException {
 		while (tok == null || !tok.hasMoreTokens()) {
 			tok = new StringTokenizer(in.readLine());
 		}
 		return tok.nextToken();
 	}
 
 	public static void main(String[] args) {
 		try {
 			in = new BufferedReader(new InputStreamReader(System.in));
 			out = new PrintWriter(new OutputStreamWriter(System.out));
 			int tests = nextInt();
 			for (test = 1; test <= tests; test++) {
 				solve();
 				System.err.println(""Test "" + test + "" done"");
 			}
 			in.close();
 			out.close();
 		} catch (Throwable e) {
 			e.printStackTrace();
 			exit(1);
 		}
 	}
 }","import static java.lang.Integer.parseInt;
 import static java.lang.Math.min;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.StringTokenizer;
 
 public class B {
 	
 	static BufferedReader in;
 	static PrintWriter out;
 	static StringTokenizer tok;
 	
 	static void solveTest() throws Exception {
 		int p = nextInt();
 		int n = 1 << p;
 		int s[] = new int[n];
 		for (int i = 0; i < n; i++) {
 			s[i] = p - nextInt();
 		}
 		int price[] = new int[n];
 		for (int i = p - 1; i >= 0; i--) {
 			for (int j = 0; j < 1 << i; j++) {
 				price[(1 << i) + j] = nextInt();
 			}
 		}
 		// First index: number of matches seen
 		// Second index: ID
 		int cur[][] = new int[p + 1][n];
 		for (int i = 0; i <= p; i++) {
 			for (int j = 0; j < n; j++) {
 				cur[i][j] = (i >= s[j]) ? 0 : Integer.MAX_VALUE;
 			}
 		}
 		for (int level = p - 1; level >= 0; --level) {
 			int next[][] = new int[level + 1][1 << level];
 			for (int i = 0; i <= level; i++) {
 				for (int j = 0; j < 1 << level; j++) {
 					next[i][j] = trim(min(
 						(long) cur[i][j << 1] + cur[i][(j << 1) + 1],
 						(long) cur[i + 1][j << 1] + cur[i + 1][(j << 1) + 1] + price[(1 << level) + j]
 					));
 				}
 			}
 			cur = next;
 		}
 		out.println(cur[0][0]);
 	}
 	
 	private static int trim(long val) {
 		return (int) min(val, Integer.MAX_VALUE);
 	}
 
 	static void solve() throws Exception {
 		int tests = nextInt();
 		for (int test = 1; test <= tests; test++) {
 			out.print(""Case #"" + test + "": "");
 			solveTest();
 		}
 	}
 
 	public static void main(String[] args) throws Exception {
 		System.out.print(""Enter filename: "");
 		System.out.flush();
 		String filename = new BufferedReader(new InputStreamReader(System.in)).readLine();
 		in = new BufferedReader(new InputStreamReader(
 			new FileInputStream(new File(filename + "".in""))));
 		out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
 			new FileOutputStream(new File(filename + "".out"")))));
 		solve();
 		in.close();
 		out.close();
 	}
 	
 	static String next() throws IOException {
 		while (tok == null || !tok.hasMoreTokens()) {
 			tok = new StringTokenizer(in.readLine());
 		}
 		return tok.nextToken();
 	}
 	
 	static int nextInt() throws IOException {
 		return parseInt(next());
 	}
 	
 	static BigInteger nextBigInt() throws IOException {
 		return new BigInteger(next());
 	}
 }",1
65,12160,"package codejam2014;
 import java.io.*;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.*;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class B {	
 	private static final int ThreadCheckTime = 2000;
 	private static final int TreadCount = 100;
 	//private String inFileName = ""H:\\Codejam\\src\\codejam2014\\inputB.in"";
 	//private String inFileName = ""H:\\Codejam\\src\\codejam2014\\B-small-attempt0.in"";
 	private String inFileName = ""H:\\Codejam\\src\\codejam2014\\B-large.in"";
 	private String outFileNeme = ""H:\\Codejam\\src\\codejam2014\\output.txt"";	
 	public int testCaseCount=0;	
 	public List<TestCase> cases;
 	public class TestCase implements Runnable{		
 		public String result;	
 		long A,B,K;
 		public TestCase(){
 			A = getLong();
 			B = getLong();
 			K = getLong();			
 		}		
 		public void run(){
 			if(A==K && B==K){
 				Long l = new Long(K);
 				BigInteger count = new BigInteger(l.toString());
 				count = count.multiply(new BigInteger(new Long(K).toString()));
 				result = count.toString();
 			}
 			if(K>A || K>B){
 				Long l = new Long(A);
 				BigInteger count = new BigInteger(l.toString());
 				count = count.multiply(new BigInteger(new Long(B).toString()));
 				result = count.toString();
 			}else{
 				Long l = new Long((A*B)-((A-K)*(B-K)));				
 				BigInteger count = new BigInteger(l.toString());
 				for (long i = K; i < A; i++) {
 					for (long j = K; j < B; j++) {
 						long num = i&j;
 						if(num<K){
 							count=count.add(BigInteger.ONE);
 						}
 					}
 				}
 				result = count.toString();
 			}
 		}
 	}
 	public void execute(){
 		testCaseCount = getInt();
 		System.out.println(testCaseCount + "" cases"");
 		cases = new ArrayList<TestCase>();
 		for(int i =0; i<testCaseCount; i++){
 			cases.add(getCase());
 		}
 		runParallel();
 		for(int i =0; i<testCaseCount; i++){
 			TestCase cs = cases.get(i);
 			String op = ""Case #"" + (i+1) + "": "" + cs.result;
 			System.out.println(op);
 			writeLine(op);
 		}
 	}
 	public void runParallel(){
 		ExecutorService service = Executors.newFixedThreadPool(TreadCount);
 		for(int i=0;i<testCaseCount;i++){service.execute(cases.get(i));}
 		service.shutdown();
 		while(true){if(service.isTerminated())break;
 		try {Thread.sleep(ThreadCheckTime);} 
 		catch (InterruptedException e) {e.printStackTrace();}
 		}
 	}
 	public TestCase getCase(){
 		return new TestCase();
 	}	
 	public void writeLine(String line){outSc.format(line+'\n');}
 	public String nextLine(){return inSc.nextLine();}
 	public String getWord(){return inSc.next();}	
 	public Integer getInt(){return inSc.nextInt();}	
 	public Double getDouble(){return inSc.nextDouble();}	
 	public Long getLong(){return inSc.nextLong();}	
 	public BigInteger getBigInt(){return  new BigInteger(getWord());}	
 	public BigDecimal getBigDecimal(){return  new BigDecimal(getWord());}
 	public void closeOutputFile(){outSc.flush();outSc.close();}	
 	Scanner inSc;
 	Formatter outSc;	
 	public B() {
 		try {inSc = new Scanner(new File(inFileName));} 
 		catch (FileNotFoundException e1) {e1.printStackTrace();}	
 		try {outSc = new Formatter(outFileNeme);} catch (FileNotFoundException e) {e.printStackTrace();}
 	}	
 	public void complete(){inSc.close();outSc.flush();outSc.close();}
 	public static void main(String[] args) {
 		B st = new B();
 		st.execute();
 		st.complete();
 	}
 }
","package codejam2014;
 import java.io.*;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.*;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class QualD {	
 	private static final int ThreadCheckTime = 2000;
 	private static final int TreadCount = 10;
 	private String inFileName = ""F:\\codejam\\D-large.in"";
 	private String outFileNeme = ""F:\\codejam\\output.txt"";	
 	public int testCaseCount=0;	
 	public List<TestCase> cases;
 	public class TestCase implements Runnable{		
 		public String result;	
 		int n;
 		List<Double> a,b,c,d;
  		public TestCase(){
 			n = getInt();
 			a = new ArrayList<Double>(n);
 			b = new ArrayList<Double>(n);
 			for(int i=0;i<n;i++){
 				a.add(getDouble());
 			}
 			for(int i=0;i<n;i++){
 				b.add(getDouble());
 			}
 			Collections.sort(a);
 			Collections.sort(b);
 			c = new ArrayList<Double>(a);
 			d = new ArrayList<Double>(b);			
 		}		
 		public void run(){
 			int count=0;
 			while(a.size()>0){
 				double num = a.get(a.size()-1);
 				if(num>b.get(b.size()-1)){
 					count++;
 					a.remove(a.size()-1);
 					b.remove(0);
 				}else if (num<b.get(0)){
 					break;
 				}else{
 					int index=0;
 					for(int j=0;j<b.size()-1;j++){
 						if(num>b.get(j) && num<b.get(j+1)){
 							index=j+1;
 							break;
 						}
 					}
 					a.remove(a.size()-1);
 					b.remove(index);
 				}
 			}
 			int count2=0;
 			while(c.size()>0){
 				if(c.get(c.size()-1)<d.get(d.size()-1)){
 					c.remove(0);
 					d.remove(d.size()-1);
 				}else{
 					count2++;
 					c.remove(c.size()-1);
 					d.remove(d.size()-1);
 				}
 			}
 			result = new Integer(count2).toString() + "" "" + new Integer(count).toString();
 		}
 	}	
 	public void execute(){
 		testCaseCount = getInt();
 		cases = new ArrayList<TestCase>();
 		for(int i =0; i<testCaseCount; i++){
 			cases.add(getCase());
 		}
 		runParallel();
 		for(int i =0; i<testCaseCount; i++){
 			TestCase cs = cases.get(i);
 			String op = ""Case #"" + (i+1) + "": "" + cs.result;
 			writeLine(op);
 		}
 	}
 	public void runParallel(){
 		ExecutorService service = Executors.newFixedThreadPool(TreadCount);
 		for(int i=0;i<testCaseCount;i++){service.execute(cases.get(i));}
 		service.shutdown();
 		while(true){if(service.isTerminated())break;
 		try {Thread.sleep(ThreadCheckTime);} 
 		catch (InterruptedException e) {e.printStackTrace();}
 		}
 	}
 	public TestCase getCase(){
 		return new TestCase();
 	}	
 	public void writeLine(String line){outSc.format(line+'\n');}
 	public String nextLine(){return inSc.nextLine();}
 	public String getWord(){return inSc.next();}	
 	public Integer getInt(){return inSc.nextInt();}	
 	public Double getDouble(){return inSc.nextDouble();}	
 	public Long getLong(){return inSc.nextLong();}	
 	public BigInteger getBigInt(){return  new BigInteger(getWord());}	
 	public BigDecimal getBigDecimal(){return  new BigDecimal(getWord());}
 	public void closeOutputFile(){outSc.flush();outSc.close();}	
 	Scanner inSc;
 	Formatter outSc;	
 	public QualD() {
 		try {inSc = new Scanner(new File(inFileName));} 
 		catch (FileNotFoundException e1) {e1.printStackTrace();}	
 		try {outSc = new Formatter(outFileNeme);} catch (FileNotFoundException e) {e.printStackTrace();}
 	}	
 	public void complete(){inSc.close();outSc.flush();outSc.close();}
 	public static void main(String[] args) {
 		QualD st = new QualD();
 		st.execute();
 		st.complete();
 	}
 }
",1
66,62,"import java.io.*;
 import java.math.*;
 import java.util.*;
 import java.text.*;
 import java.util.regex.*;
 
 import static java.lang.Math.*;
 import static java.util.Arrays.*;
 import static java.util.Collections.*;
 import static java.lang.Integer.*;
 import static java.lang.Double.*;
 import static java.lang.Character.*;
 
 
 public class C {
 	
 
 	private static final int mod = 100003;
 
 	Object solve() {
 		int n = sc.nextInt();
 		
 		long[][] dp = new long[n+1][n+1];
 		
 		dp[1][0] = 1;
 		for (int last = 1; last <= n; last++) {
 			for (int pos = 0; pos <= n; pos++) {
 				if (dp[last][pos] == 0) continue;
 				for (int next = last + 1; next <= n; next++) {
 					dp[next][last] = (dp[next][last] + (nCkP[next - last - 1][last - pos - 1]*dp[last][pos]))%mod;
 				}
 			}
 		}
 		
 		long res = 0;
 		for (int i = 0; i <= n; i++)
 			res = (res + dp[n][i])%mod;
 		
 		return res;
 	}
 	
 	private static long[][] nCkP = new long[505][505];
 
 	private static void prepnCkP() {
 		for (int i = 0; i < 505; i++) {
 			nCkP[i][0] = nCkP[i][i] = 1;
 			for (int j = 1; j <= i/2; j++) {
 				nCkP[i][j] = nCkP[i][i-j] = (nCkP[i-1][j-1] + nCkP[i-1][j])%mod;
 			}
 		}
 	}
 	
 	static {
 		prepnCkP();
 	}
 
 	private static Scanner sc; private static PrintWriter fw;
 
 	public static void main(String[] args) throws Exception {
 		String inFile;
 		inFile = ""input.txt"";
 		inFile = ""C-small-attempt0.in"";
 //		inFile = ""C-large.in"";
 		
 		sc = new Scanner(new FileInputStream(inFile));
 		
 		fw = new PrintWriter(new FileWriter(""output.txt"", false));
 
 		
 		int N = sc.nextInt();
 		sc.nextLine();
 		
 		for (int cas = 1; cas <= N; cas++) {
 			fw.print(""Case #"" + cas + "": "");
 //			fw.println(""Case #"" + cas + "": "");
 			Object res = new C().solve();
 			if (res instanceof Double) 
 				fw.printf(""%.10f\n"", res);
 			else
 				fw.printf(""%s\n"", res);
 			fw.flush();
 		}
 		fw.close();
 		sc.close();
 	}
 
 }
","import java.io.*;
 import java.math.*;
 import java.util.*;
 import java.text.*;
 import java.util.regex.*;
 
 import static java.lang.Math.*;
 import static java.util.Arrays.*;
 import static java.util.Collections.*;
 import static java.lang.Integer.*;
 import static java.lang.Double.*;
 import static java.lang.Character.*;
 
 
 public class B {
 	
 
 	Object solve() {
 		int C = sc.nextInt();
 		String[] c = new String[C];
 		for (int i = 0; i < C; i++)
 			c[i] = sc.next();
 		
 		
 		int D = sc.nextInt();
 		String[] d = new String[D];
 		for (int i = 0; i < D; i++)
 			d[i] = sc.next();
 		
 		sc.next();
 //		String st = sc.next();
 //		for (String cc : c) {
 //			st = st.replaceAll(cc.substring(0,2) + ""|"" + cc.substring(1,2) + cc.charAt(0), cc.substring(2,3));
 //		}
 //		
 //		for (String dd : d) {
 //			st = st.replaceAll("".*"" + dd, """");
 //			st = st.replaceAll("".*"" + dd.substring(1,2) + dd.charAt(0), """");
 //		}
 //		
 //		return Arrays.toString(st.toCharArray());
 		
 		String res = """";
 		loop:
 		for (char ch : sc.next().toCharArray()) {
 			res += ch;
 			for (String cc : c) {
 				if (res.endsWith(cc.substring(0,2)) || res.endsWith(cc.substring(1,2) + cc.charAt(0))) {
 					res = res.substring(0, res.length()-2) + cc.charAt(2);
 					continue loop;
 				}
 			}
 			for (String dd : d) {
 				if (ch == dd.charAt(0) && res.indexOf(dd.charAt(1)) != -1) {
 					res = """";
 					continue loop;
 				} else if (ch == dd.charAt(1) && res.indexOf(dd.charAt(0)) != -1) {
 					res = """";
 					continue loop;
 				}
 			}
 		}
 		
 		return Arrays.toString(res.toCharArray());
 	}
 
 	private static Scanner sc; private static PrintWriter fw;
 
 	public static void main(String[] args) throws Exception {
 		String inFile;
 //		inFile = ""input.txt"";
 //		inFile = ""B-small-attempt0.in"";
 		inFile = ""B-large.in"";
 		
 //		sc = new Scanner(System.in);
 		sc = new Scanner(new FileInputStream(inFile));
 		
 		fw = new PrintWriter(new FileWriter(""output.txt"", false));
 
 		
 		int N = sc.nextInt();
 		sc.nextLine();
 		
 		for (int cas = 1; cas <= N; cas++) {
 			fw.print(""Case #"" + cas + "": "");
 //			fw.println(""Case #"" + cas + "": "");
 			Object res = new B().solve();
 			if (res instanceof Double) 
 				fw.printf(""%.10f\n"", res);
 			else
 				fw.printf(""%s\n"", res);
 			fw.flush();
 		}
 		fw.close();
 		sc.close();
 	}
 
 }
",1
67,1111,"import java.io.*;
 import java.util.*;
 import static java.lang.Math.*;
 
 public class Main {
 	BufferedReader in;
 	PrintWriter out;
 	StringTokenizer st;
 	String filename = ""C-small-attempt1.in"";
 
 	final int maxSize = 101;
 
 	boolean[][] v = new boolean[maxSize][maxSize];
 
 	boolean checkA(int x, int y) {
 		boolean a = false, b = false;
 		if (x == 0)
 			a = false;
 		else
 			a = v[x - 1][y];
 		if (y == 0)
 			b = false;
 		else
 			b = v[x][y - 1];
 		return a || b;
 	}
 
 	boolean checkB(int x, int y) {
 		if (x == 0)
 			return false;
 		if (y == 0)
 			return false;
 		return v[x - 1][y] && v[x][y - 1];
 	}
 
 	void out() {
 		for (int i = 0; i < v.length; i++) {
 			for (int j = 0; j < v[i].length; j++) {
 				System.err.print((v[i][j] ? 1 : 0) + "" "");
 
 			}
 			System.err.println();
 		}
 		System.err.println();
 		System.err.println();
 	}
 
 	boolean[][] nv = new boolean[maxSize][maxSize];
 
 	boolean model() {
 		int cnt = 0;
 		for (int i = 0; i < maxSize; ++i)
 			for (int j = 0; j < maxSize; ++j) {
 				if (v[i][j]) {
 					if (checkA(i, j))
 						nv[i][j] = true;
 					else
 						nv[i][j] = false;
 				} else {
 					if (checkB(i, j))
 						nv[i][j] = true;
 					else
 						nv[i][j] = false;
 				}
 				if (nv[i][j])
 					++cnt;
 			}
 		for (int i = 0; i < nv.length; i++) {
 			for (int j = 0; j < nv[i].length; j++) {
 				v[i][j] = nv[i][j];
 
 			}
 		}
 		return cnt > 0;
 	}
 
 	void solve() throws IOException {
 		int t = ni();
 		for (int test = 1; test <= t; ++test) {
 			for (int i = 0; i < v.length; i++) {
 				Arrays.fill(v[i], false);
 			}
 			int n = ni();
 			for (int i = 0; i < n; ++i) {
 				int x1 = ni() - 1, y1 = ni() - 1, x2 = ni() - 1, y2 = ni() - 1;
 				for (int k = y1; k <= y2; ++k)
 					for (int l = x1; l <= x2; ++l)
 						v[k][l] = true;
 			}
 			int res = 1;
 			// out();
 			while (model()) {
 				// out();
 				++res;
 			}
 			// out();
 			out.println(""Case #"" + test + "": "" + res);
 		}
 	}
 
 	public Main() throws IOException {
 		Locale.setDefault(Locale.US);
 		in = new BufferedReader(new FileReader(filename));
 		out = new PrintWriter(filename + "".out"");
 		solve();
 		in.close();
 		out.close();
 	}
 
 	String ns() throws IOException {
 		while (st == null || !st.hasMoreTokens()) {
 			st = new StringTokenizer(in.readLine());
 		}
 		return st.nextToken();
 	}
 
 	int ni() throws IOException {
 		return Integer.valueOf(ns());
 	}
 
 	long nl() throws IOException {
 		return Long.valueOf(ns());
 	}
 
 	double nd() throws IOException {
 		return Double.valueOf(ns());
 	}
 
 	public static void main(String[] args) throws IOException {
 		new Main();
 	}
 }
","import java.io.*;
 import java.util.*;
 
 import static java.lang.Math.*;
 
 public class Solution {
 
 	BufferedReader in;
 	StringTokenizer st;
 	PrintWriter out;
 
 	char[][] v;
 
 	boolean check(int x, int y, int dx, int dy, char c) {
 		for (int i = 0; i < 4; ++i) {
 			if (v[x][y] == c || v[x][y] == 'T')
 				;
 			else
 				return false;
 			x += dx;
 			y += dy;
 		}
 		return true;
 	}
 
 	boolean check(char c) {
 		boolean ret = false;
 		for (int i = 0; i < 4; ++i)
 			ret |= check(i, 0, 0, 1, c);
 		for (int i = 0; i < 4; ++i)
 			ret |= check(0, i, 1, 0, c);
 		ret |= check(0, 0, 1, 1, c);
 		ret |= check(0, 3, 1, -1, c);
 		return ret;
 	}
 
 	boolean hasEmpty() {
 		for (int i = 0; i < 4; ++i)
 			for (int j = 0; j < 4; ++j)
 				if (v[i][j] == '.')
 					return true;
 		return false;
 	}
 
 	void solve() throws IOException {
 		v = new char[4][];
 		for (int i = 0; i < 4; ++i)
 			v[i] = ns().toCharArray();
 		if (check('X'))
 			out.println(""X won"");
 		else if (check('O'))
 			out.println(""O won"");
 		else if (hasEmpty())
 			out.println(""Game has not completed"");
 		else
 			out.println(""Draw"");
 	}
 
 	public Solution() throws IOException {
 		Locale.setDefault(Locale.US);
 		in = new BufferedReader(new FileReader(""input.txt""));
 		out = new PrintWriter(""output.txt"");
 		int test = ni();
 		for (int t = 1; t <= test; ++t) {
 			out.print(""Case #"" + t + "": "");
 			solve();
 		}
 		in.close();
 		out.close();
 	}
 
 	String ns() throws IOException {
 		while (st == null || !st.hasMoreTokens())
 			st = new StringTokenizer(in.readLine());
 		return st.nextToken();
 	}
 
 	int ni() throws IOException {
 		return Integer.valueOf(ns());
 	}
 
 	long nl() throws IOException {
 		return Long.valueOf(ns());
 	}
 
 	double nd() throws IOException {
 		return Double.valueOf(ns());
 	}
 
 	public static void main(String[] args) throws IOException {
 		new Solution();
 	}
 }
",1
68,8103,"import com.sun.corba.se.pept.transport.ListenerThread;
 import org.apache.commons.lang3.ArrayUtils;
 
 import javax.swing.event.ListSelectionEvent;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.lang.reflect.Array;
 import java.util.*;
 
 public class Treasure{
     public static void main(String[] args) throws Exception{
         new Treasure();
     }
 
     public Treasure() throws Exception{
         String fileName = ""/tmp/D-large.in"";
         BufferedReader br = new BufferedReader(new FileReader(fileName));
         int totalCases = new Integer(br.readLine()).intValue();
 
         for( int x = 0; x< totalCases; x++){
 
             String[] kAndN = br.readLine().split("" "");
             int startingKeyCount = Integer.valueOf(kAndN[0]);
             int chests = Integer.valueOf(kAndN[1]);
             //System.out.println(""You have: ""+ startingKeyCount +"" keys"");
             //System.out.println(""There are ""+chests+"" chests"");
 
             String keysString = br.readLine();
             List<String> keysYouHave = Arrays.asList(keysString.split("" ""));
             //System.out.println(""you have keys:""+keysString);
 
             List<Chest> unopenedChests = new ArrayList<Chest>();
             for( int y = 0; y<chests; y++){
                 Chest chest = new Chest();
                 chest.id = (y+1);
 
                 String[] line = br.readLine().split("" "");
                 chest.requiredKey = Integer.parseInt(line[0]);
 
                 int keysInChest = Integer.parseInt(line[1]);
                 for(int z=2;z<2+keysInChest;z++){
                     chest.keysInside.add(line[z]);
                 }
 
                 //System.out.println(""CHEST:""+chest.id);
                 //System.out.println(""-You may open this chest with key:""+chest.requiredKey);
                 //System.out.println(""-There are: ""+keysInChest+"" keys in this chest"");
                 unopenedChests.add(chest);
             }
 
 
             ArrayList<String> pathSoFar = new ArrayList<String>();
             ArrayList<String> resultArray = solver(keysYouHave, unopenedChests, pathSoFar, unopenedChests.size());
 
             String result = flattenListToString(resultArray);
 //            if( result.length() != unopenedChests.size()){
 //                result = ""IMPOSSIBLE"";
 //            }
             ArrayList<String> r = new ArrayList<String>();
             String [] rs = result.split("","");
             for( String rss: rs){
                 r.add(rss);
             }
             //System.out.println(""r.size=""+r.size()+""unopenedChests=count=""+unopenedChests.size());
             if( r.size() != unopenedChests.size() || result.equals("""")){
                 result = ""IMPOSSIBLE"";
             }else{
                 result = result.replaceAll("","","" "");
             }
 
             System.out.println(""Case #""+(x+1)+"": ""+result);
 
 
         }
     }
 
     public static String flattenListToString(ArrayList<String> resultArray){
         if( resultArray.isEmpty()) return """";
         StringBuilder sb = new StringBuilder();
         for(String a : resultArray){
             sb.append(a).append("","");
         }
         return sb.substring(0,sb.length()-1);
     }
 
     public static boolean isThisPossible(List<String> keysYouHave, List<Chest> chestsLeft){
         List<String> keysNeeded = new ArrayList<String>();
         for(Chest c: chestsLeft){
             keysNeeded.add(String.valueOf(c.requiredKey));
         }
 
         List<String> keysAvailable = new ArrayList<String>();
         keysAvailable.addAll(keysYouHave);
         for(Chest c: chestsLeft){
             keysAvailable.addAll(c.keysInside);
         }
 
         //System.out.println(""KeysNeeded:""+keysNeeded.size());
         //System.out.println(""KeysAvailable:""+keysAvailable.size());
 
         for(String keyNeeded: keysNeeded){
             if( keysAvailable.contains(keyNeeded)){
                 keysAvailable.remove(keyNeeded);
             }else{
                 //System.out.println("""");
                 return false;
             }
         }
 
         return true;
     }
 
     public static boolean doAnyOtherChestsHaveThisKey(String key, List<Chest> otherChests){
         for( Chest c: otherChests){
             if( c.keysInside.contains(key)){
                 return true;
             }
         }
         return false;
     }
     public static boolean allKeysReachable(List<String> keysYouHave, List<Chest> chestsLeft){
         for(Chest c: chestsLeft){
             if( keysYouHave.contains(String.valueOf(c.requiredKey))){
                 //
             }else{
                 List<Chest> otherChests = new ArrayList<Chest>();
                 otherChests.addAll(chestsLeft);
                 otherChests.remove(c);
 
                 if( !doAnyOtherChestsHaveThisKey(String.valueOf(c.requiredKey),otherChests)){
                     return false;
                 }
 
             }
         }
         return true;
     }
 
     public static ArrayList<String> solver(List<String> keysYouHave, List<Chest> unopenedChests
             , ArrayList<String> pathSoFar, int maxLength){
         //System.out.println(""SOLVER- keys(""+keysYouHave+"") chests(""+unopenedChests+"") pathSoFar(""+pathSoFar+"")"");
 
         if( !isThisPossible(keysYouHave,unopenedChests)){
             return new ArrayList<String>();
         }
 
         if( !allKeysReachable(keysYouHave, unopenedChests)){
             return new ArrayList<String>();
         }
 
         if( pathSoFar.size() == maxLength){
             return pathSoFar;
         }
 
         List<ArrayList<String>> solutions = new ArrayList<ArrayList<String>>();
 
         for(Chest chest : unopenedChests){
             //System.out.println(""Checking chest:""+chest.id+"" which requiresKey:""+chest.requiredKey);
             if( keysYouHave.contains( String.valueOf(chest.requiredKey))){
                 //System.out.println(""KeyFound"");
                 List<String> keysLeft = new ArrayList<String>();
                 keysLeft.addAll(keysYouHave);
                 keysLeft.remove(String.valueOf(chest.requiredKey));
                 keysLeft.addAll( chest.keysInside);
 
                 //System.out.println(""unopenedChests.count.pre=""+unopenedChests.size());
                 List<Chest> chestsLeft = new ArrayList<Chest>();
                 chestsLeft.addAll(unopenedChests);
                 chestsLeft.remove(chest);
                 //System.out.println(""unopenedChests.count.post=""+unopenedChests.size());
 
                 ArrayList<String> newPath = new ArrayList<String>();
                 newPath.addAll(pathSoFar);
                 newPath.add(String.valueOf(chest.id));
 
                 ArrayList<String> ans = solver(keysLeft, chestsLeft,newPath,maxLength);
                 if( ans.size() == maxLength){
                     return ans;
                 }
                 solutions.add(ans);
             }else{
                 solutions.add(pathSoFar);
                 if( pathSoFar.size() == maxLength ){
                     return pathSoFar;
                 }
                 //System.out.println(""Key not found in our stash"");
             }
         }
 
 
         String result = flattenListToString(pathSoFar);
 
         List<String> sols = new ArrayList<String>();
         for(ArrayList<String> a : solutions){
             sols.add(flattenListToString(a));
         }
 
         Collections.sort(sols);
         //System.out.println(""SolutionsCount""+solutions.size());
         for( String solution : sols ){
             //System.out.println(""SolutionToCheck=""+solution+"": vs result=""+result);
             if( solution.length() > result.length()){
                 result = solution;
                 //System.out.println(""foundResult=""+result+"":pathSoFar+""+pathSoFar);
                 //return result;
             }
         }
 
 
         ArrayList<String> r = new ArrayList<String>();
         String [] rs = result.split("","");
         for( String rss: rs){
             r.add(rss);
         }
         return r;
     }
 
     public class Chest{
         public int id;
         public int requiredKey;
         public List<String> keysInside = new ArrayList<String>();
     }
 }","/**
  * Created by ffetters on 4/12/14.
  */
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 
 
 public class Main3 {
 
     public static int R;
     public static int C;
     public static int M;
 
     public static void main(String[] strings) throws Exception {
 
         String file = ""/tmp/C-small-attempt1.in"";
         //DecimalFormat df = new DecimalFormat(""#.#######"");
 
         BufferedReader br = new BufferedReader(new FileReader(file));
         String line;
 
         int numCases = Integer.valueOf(br.readLine()).intValue();
 
         for (int y = 0; y < numCases; y++) {
 
             String[] vals = br.readLine().split("" "");
             R = Integer.valueOf(vals[0]); // rows
             C = Integer.valueOf(vals[1]); // columns
             M = Integer.valueOf(vals[2]); // mines
 //System.out.println(""R=""+R+"" C=""+C+"" M=""+M);
             String result = ""Impossible"";
 
             // generate a list of possible boards....
 
             String[][] board1 = generateBoard(R,C,M);
   //          System.out.println(""PRE"");
   //          display(board1);
 
             List<String[][]> boards = new ArrayList<String[][]>();
 
             boards.add(board1);
 
 //            System.out.println(""PREBOARD=\n""+display(board1));
 
 //            for(int z=0;z< boards.size();z++){
                 String[][] preBoard = board1;
                 String[][] postBoard = copy2DArray(preBoard);
                 postBoard = makeMoves(null,postBoard);
 //System.out.println(""POST"");
 //            display(postBoard);
 
 //                System.out.println(""POSTBOARD=""+display(postBoard));
 
                 if(!anyDotsLeft(postBoard)){
                     result = display(preBoard);
                 }
 
 
             // evaluate the boards and return the first one that works
 
             // if none work return impossible.
             System.out.println(""Case #"" + (1 + y) + "": "");
             System.out.println(result);
         }
 
         br.close();
     }
 
     public static String[][] setSquare(int row, int col, String val, String[][]board){
         try{
             board[row][col] = val;
         }catch (Exception e){
 
         }
         return board;
     }
 
     public static String[][] generateBoard(int row, int cols, int mines){
         int spaces = row*cols;
         int empty = spaces - mines;
         String[][] board = new String[row][cols];
 
         board[0][0] = ""c"";
         empty--;
 
         if( empty >= 0){
             board = setSquare(1,0,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(0,1,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(2,0,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(1,1,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(0,2,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(3,0,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(2,1,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(1,2,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(0,3,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(4,0,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(3,1,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(2,2,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(1,3,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(0,4,""."",board);
             empty--;
         }
 
         //15 done.
 
         if( empty >= 0){
             board = setSquare(4,1,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(3,2,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(2,3,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(1,4,""."",board);
             empty--;
         }
         //19
 
         if( empty >= 0){
             board = setSquare(4,2,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(3,3,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(2,4,""."",board);
             empty--;
         }
 
         // 22
 
         if( empty >= 0){
             board = setSquare(4,3,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(3,4,""."",board);
             empty--;
         }
 
         if( empty >= 0){
             board = setSquare(4,4,""."",board);
             empty--;
         }
 
         //display(board);
 
         // 25
         return fillTheRestWithMines(board);
     }
 
     public static String[][] fillTheRestWithMines(String [][] board){
         for(int x=0;x<board.length;x++){
             for(int y=0;y<board[0].length;y++){
                 try {
 
                     if( board[x][y] == null){
                         board[x][y] = ""*"";
                     }
 
                    // if (!board[x][y].equals(""."") && !board[x][y].equals(""c"")) {
                      //   board[x][y] = ""*"";
                     //}
                 }catch(Exception e){
 
                 }
             }
         }
         return board;
     }
 
 
 
     public static String display(String [] [] board){
 
         StringBuilder sb = new StringBuilder();
         for(int x=0;x<board.length;x++){
             for(int y=0;y<board[0].length;y++){
                 sb.append(board[x][y]);
             }
             sb.append(""\n"");
         }
         //sb.subSequence(0,sb.length()-2);
         return sb.substring(0,sb.length()-1);
 
     }
 
     public static String[][] makeMoves(List<Spot> movesLeft, String[][] board) {
 
         if( movesLeft == null){
             movesLeft = new ArrayList<Spot>();
             Spot s = new Spot();
             s.row=0;
             s.col=0;
             movesLeft.add(s);
         }
 
         while( !movesLeft.isEmpty()) {
             Spot s = movesLeft.remove(0);
             //System.out.println(""MovesLeft=""+movesLeft.size());
             board = updateSpot(s.row, s.col, board, movesLeft);
             //System.out.println(""MovesLeft.after=""+movesLeft.size());
         }
         return board;
     }
 
     public static String[][] updateSpot(int row, int col, String[][]board, List<Spot> movesLeft){
 
         // if the spot is outside the board, don't do anything
         if( row <0 || col < 0 || row >= board.length || col >= board[0].length){
             return board;
         }
 
         if( board[row][col].equals(""c"") || board[row][col].equals(""."")){
             // it was the click, so count the number of mines
             int numNeighborMines = numberNeighborMines(row,col,board);
             //System.out.println(""NeighborMines=""+numNeighborMines);
             board[row][col] = String.valueOf(numNeighborMines);
 
             if( numNeighborMines > 0 ){
                 board[row][col] = String.valueOf(numNeighborMines);
                 return board;
             }else {
               //  System.out.println(""adding 8 more spots"");
                 // if no mines, then add all neighbor squares to the moves left list
                 Spot s = new Spot();
                 s.row = row - 1;
                 s.col = col - 1;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row - 1;
                 s.col = col;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row - 1;
                 s.col = col + 1;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row;
                 s.col = col - 1;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row;
                 s.col = col + 1;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row + 1;
                 s.col = col - 1;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row + 1;
                 s.col = col;
                 movesLeft.add(s);
                 s = new Spot();
                 s.row = row + 1;
                 s.col = col + 1;
                 movesLeft.add(s);
             }
         }
         return board;
     }
 
     public String[][] evaluate(String[][] board) {
         // assuming we always click the top left spot, let's evaluate it.
 
         int numNeighborMines = numberNeighborMines(0, 0, board);
         board[0][0] = String.valueOf(numNeighborMines);
 
         if (numNeighborMines > 0) {
             return board;
         }
 
 
         return board;
     }
 
     public static int numberNeighborMines(int row, int col, String[][] board) {
         int count = 0;
 
         count += evaluateNeighbor(row - 1, col - 1, ""*"", board) ? 1 : 0;
         count += evaluateNeighbor(row - 1, col, ""*"", board) ? 1 : 0;
         count += evaluateNeighbor(row - 1, col + 1, ""*"", board) ? 1 : 0;
 
         count += evaluateNeighbor(row, col - 1, ""*"", board) ? 1 : 0;
         count += evaluateNeighbor(row, col + 1, ""*"", board) ? 1 : 0;
 
         count += evaluateNeighbor(row + 1, col - 1, ""*"", board) ? 1 : 0;
         count += evaluateNeighbor(row + 1, col, ""*"", board) ? 1 : 0;
         count += evaluateNeighbor(row + 1, col + 1, ""*"", board) ? 1 : 0;
 
         return count;
     }
 
     public static boolean evaluateNeighbor(int row, int col, String val, String[][] board) {
         try {
             if (board[row][col].equals(val)) {
                 return true;
             }
         } catch (Exception e) {
             // :)
         }
         return false;
     }
 
     public static boolean anyDotsLeft(String board[][]) {
         for (int x = 0; x < board.length; x++) {
             for (int y = 0; y < board[0].length; y++) {
                 if (board[x][y].equals(""."")) {
                     return true;
                 }
             }
         }
         return false;
     }
 
     public static String[][] copy2DArray(String[][] board){
         String[][] copy = new String[board.length][board[0].length];
         for( int x=0;x<board.length;x++){
             for( int y=0;y<board[0].length;y++){
                 copy[x][y]=board[x][y];
             }
         }
 
         //for(int x=0;x<board.length;x++){
          //   String[] row = board[x];
           //  int rowLength = row.length;
            // copy[x] = new String[rowLength];
             ///System.arraycopy(copy, 0, board, 0, rowLength);
         //}
         return copy;
     }
 
 
     public static class Spot {
         int row;
         int col;
     }
 }",1
69,12577,"import java.io.*;
 import java.util.*;
 class Candy
 {
 
 	public List<Long> allNum = new ArrayList<Long>();
 		public int numOfNum = 0;
 	public boolean isNotPossible() 
 		{
 			long xor = 0L;
 			for(long k : allNum) {
 				xor = k ^ xor;
 			}
 			if(xor!=0) {
 				return true;
 			}
 			return false;
 		}
 	String calculate() {
 		if (isNotPossible())
 		{		
 				return ""NO"";
 		}
 
 		Collections.sort(allNum);
 		Long sum = 0L;
 		for(int i = 1; i<allNum.size();i++) {
 		sum+= allNum.get(i);
 		}
 
 	return sum.toString();
 	}
 	public static void main(String[] args) throws Exception
 	{
 		
 		FileReader fin = new FileReader(""D:\\P3_in.txt"");
 		FileWriter fout = new FileWriter(""D:\\P3_out.txt"");
 		Scanner scn = new Scanner(fin);
 		int numOfCases = scn.nextInt();
 		scn.nextLine();
 		for(int i = 0; i<numOfCases; i++) {
 			Candy candy = new Candy();
 			int numOfCandy = scn.nextInt();
 			candy.numOfNum = numOfCandy;
 			for(int j=0;j<numOfCandy;j++) {
 
 				long oneValue = scn.nextLong();
 				candy.allNum.add(oneValue);
 			}
 			
 			fout.write(""Case #"" + (i+1)+"": "" + candy.calculate() + ""\n"");
 			
 			//System.out.println(seq.calculate());
 			
 		}
 		fout.close();
 	}
 }","package javaapplication1;
 import java.util.*;
 import java.io.*;
 import java.lang.*;
 class Main
 	{
 		
 			public static void main(String args[]) throws IOException
 			{
 				
 				FileWriter fout=new FileWriter(""C:\\A-small.out"");
 				FileReader fin=new FileReader(""C:\\aa.txt"");
 				Scanner src=new Scanner(fin);
 				int T,N,K;
                         	T=src.nextInt();
 				src.nextLine();
                                 int snappers=0,snaps=0,tempsnaps=0;
 				String light="""";		
                                 int t=0;
 				for(int query=0;query<T;query++)
 					{
 						N=src.nextInt();
                                                 K=src.nextInt();
                                                 
                                                 snaps=K+1;
                                                 System.out.println(snaps);                        
        // if odd then increment                 
                                                // if(snaps%2!=0)  {snaps++;}
                                                // if(K==0) snaps=1;
                                                 for(int i=0;i<N;i++)
                                                 {
                                                     tempsnaps=snaps+(int)Math.pow(2,i)-1;                                         
                                                     //System.out.println(""tsnaps=""+tempsnaps+""tempsnaps/(int)Math.pow(2,i)= ""+tempsnaps/(int)Math.pow(2,i)+"" (tempsnaps/(int)Math.pow(2,i))%(int)Math.pow(2,i)""+(tempsnaps/(int)Math.pow(2,i))%(int)Math.pow(2,i));
                                                     //System.out.println(""light : ""+light);
       // if snap/2^i=even then true else false      
                                                     if((tempsnaps/(int)Math.pow(2,i))%2==0)
                                                     {
                                                         light=""ON"";
                                                     }
                                                     else
                                                     {
                                                         light=""OFF"";
                                                         break;
                                                     }
                                                         
                                                 }
                                                 System.out.println(""light : ""+light);  
                                                 
                                                 	
 			
 							
                                                 
                                                     t=query+1;	
                                                     fout.write(""Case #""+t+"": ""+light+""\n"");					
                                                    
 				
                                                 
                                                 
                                                 
                                                 
                                         }
                         fin.close();
                         fout.close();
         
                         }
                         
         }",1
70,19355,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.HashSet;
 import java.util.Set;
 
 public class FairWarning {
 
 	/**
 	 * read and process the input file. Then write the result to the output
 	 * file.
 	 * 
 	 * @param path
 	 */
 	public void process(String path) {
 		BufferedReader in = null;
 		BufferedWriter out = null;
 		try {
 			try {
 				in = new BufferedReader(new FileReader(path));
 				String outPath = path.replace("".in"", "".out"");
 				out = new BufferedWriter(new FileWriter(outPath));
 				String s = in.readLine();
 				if (s != null) {
 					int caseCount = Integer.valueOf(s);
 					for (int i = 1; i <= caseCount; i++) {
 						if ((s = in.readLine()) != null) {
 							String[] ss = s.split("" "");
 							int n = Integer.valueOf(ss[0]);
 							BigInteger[] ts = new BigInteger[n];
 							for (int j = 0; j < n; j++)
 								ts[j] = new BigInteger(ss[j + 1]);
 							BigInteger y = calculateTime(ts);
 							out.write(""Case #"" + i + "": "" + y + ""\n"");
 						}
 					}
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 		} finally {
 			try {
 				in.close();
 				out.close();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 		}
 	}
 
 	/**
 	 * calculate the time before apocalypse
 	 * 
 	 * @param ts
 	 * @return
 	 */
 	private BigInteger calculateTime(BigInteger[] ts) {
 		Set<BigInteger> subSet = new HashSet<BigInteger>();
 		for (int i = 0; i < ts.length - 1; i++)
 			for (int j = i + 1; j < ts.length; j++) {
 				BigInteger sub = ts[i].subtract(ts[j]);
 				if (!sub.equals(BigInteger.ZERO))
 					subSet.add(sub.abs());
 			}
 		BigInteger[] subs = subSet.toArray(new BigInteger[subSet.size()]);
 		BigInteger gcd = subs[0];
 		for (int i = 1; i < subs.length; i++)
 			gcd = euclidDivision(gcd, subs[i]);
 		BigInteger remainder = ts[0].mod(gcd);
 		if (remainder.equals(BigInteger.ZERO))
 			return BigInteger.ZERO;
 		return gcd.subtract(remainder);
 	}
 
 	/**
 	 * calculate the greatest common divisor by Euclid algorithm
 	 * 
 	 * @param m
 	 * @param n
 	 * @return
 	 */
 	private BigInteger euclidDivision(BigInteger m, BigInteger n) {
 		if (m.compareTo(n) == -1) {
 			BigInteger temp = m;
 			m = n;
 			n = temp;
 		}
 		while (!m.mod(n).equals(BigInteger.ZERO)) {
 			BigInteger temp = n;
 			n = m.mod(n);
 			m = temp;
 		}
 		return n;
 	}
 
 	/**
 	 * main method
 	 * 
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		new FairWarning().process(""B-small-attempt0.in"");
 	}
 }
","package Round1B;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class First
 {
 	final String fname = ""A-large"";
 
 	private BufferedReader in;
 	private PrintWriter out;
 	private StringTokenizer st;
 
 	class VendorPoint
 	{
 		int label;
 		int vendCount;
 		
 		public VendorPoint(int label, int vendCount) 
 		{
 			this.label = label;
 			this.vendCount = vendCount;
 		}
 	}
 
 	First() throws IOException
 	{
 		in = new BufferedReader(new FileReader(""C:\\Udhaya\\codejam\\"" + fname + "".in""));
 		out = new PrintWriter(""C:\\Udhaya\\codejam\\"" + fname + "".out"");
 		getToken("""");
 		
 		int tests = nextInt();
 		
 		for (int test=0; test<tests; test++)
 		{
 			int noTeam = nextInt();
 			String[] teamData = new String[noTeam];
 			for (int j=0; j<noTeam; j++)
 			{
 				teamData[j] = nextLine();
 			}
 			
 			
 			out.print(""Case #"" + (test+1) + "":\n"" + solve(noTeam,teamData));
 			System.out.print(""Case #"" + (test+1) + "":\n"" + solve(noTeam,teamData));
 		}
 		out.close();
 	}
 
 	
 	
 //	void solve() throws IOException
 //    {
 //        String s[] = {"".10"",""0.1"",""10.""};
 //        String s1[] = {"".11."",""0.00"",""01.1"","".10.""};
 //        testCase(2, 3, s);
 //        testCase(2, 4, s1);
 //        
 //    }
     
     public String solve(int noOfTeams,String[] teamData)
     {
     	StringBuffer str = new StringBuffer();
 
         double[] teamWP = new double[noOfTeams];
         double[] teamOWP = new double[noOfTeams];
         double[] teamOOWP = new double[noOfTeams];
         double[] teamRPS = new double[noOfTeams];
         for ( int i = 0;i < noOfTeams;i++){
             teamWP[i] = getWP(teamData[i]);
             System.out.println(""teamWP :""+teamWP[i]);
         }
         for ( int i = 0;i < noOfTeams;i++){
             teamOWP[i] = getOWP(i,teamData[i],teamData);
 //            System.out.println(""teamOWP :""+teamOWP[i]);
         }
         for ( int i = 0;i < noOfTeams;i++){
             teamOOWP[i] = getOOWP(teamData[i],teamOWP);
 //            System.out.println(""teamOOWP :""+teamOOWP[i]);
         }
         for ( int i = 0;i < noOfTeams;i++){
             teamRPS[i] = 0.25 * teamWP[i] + 0.50 * teamOWP[i] + 0.25 * 
 teamOOWP[i];
             str.append (teamRPS[i] + ""\n"");
             System.out.println(""TeamRPI :"" + teamRPS[i]);
         }
 
         return str.toString();
         
     }
     
     public double getWP(String schedule){
         int countWin = 0,countMatch = 0;
         for ( int i = 0;i < schedule.length();i++){
             if ( schedule.charAt(i) == '1'){
                 countWin++;
             }
             if ( schedule.charAt(i) != '.'){
                 countMatch++;
             }
         }
         return (double)countWin/countMatch;
     }
     
     public double getOWP(int teamIndex,String schedule,String[] teamData){
         double OWP = 0;
         int countWin = 0,countMatch = 0;
         int countTeamSchedule = 0;
         String oppSchedule = """";
             for ( int i = 0;i < schedule.length();i++){
                 countWin = 0;countMatch = 0;
                 if ( schedule.charAt(i) != '.'){
                     countTeamSchedule++;
                     oppSchedule = teamData[i];
                     for ( int j = 0;j < oppSchedule.length();j++){
                         if ( j != teamIndex ){
                             if ( oppSchedule.charAt(j) == '1'){
                                 countWin++;
                             }
                             if ( oppSchedule.charAt(j) != '.'){
                                 countMatch++;
                             }
                         }
                     }
                     OWP += (double)countWin / countMatch;
 //          System.out.println(""count WIn :""+countWin+"",countMatch:""+countMatch);
                 }
             }
         return OWP/countTeamSchedule;
     }
     
     public double getOOWP(String schedule,double[] teamOWP){
         double OOWP = 0;
         int count = 0;
         for ( int i = 0;i < schedule.length();i++){
             if ( schedule.charAt(i) != '.'){
                 count++;
                 OOWP += teamOWP[i];
             }
         }
         return OOWP/count;
     }
 
 
 
 	void getToken (String str)
 	{
 		st = new StringTokenizer (str);
 	}
 
 	String nextLine() throws IOException
 	{
 		return in.readLine();
 	}
 
 	String next() throws IOException
 	{
 		while (!st.hasMoreTokens ())
 		{
 			String line = in.readLine ();
 			if (line == null)
 				return null;
 			
 			getToken (line);
 		}
 		return st.nextToken ();
 	}
 
 	int nextInt() throws IOException
 	{
 		
 		return Integer.parseInt(next());
 	}
 
 	long nextLong() throws IOException 
 	{
 		return Long.parseLong(next());
 	}
 	
 	double nextDouble() throws IOException 
 	{
 		return Double.parseDouble(next());
 	}
 
 	public static void main (String[] args) throws IOException
 	{
 		
 		new First();
 	}
 }
",0
71,8137,"package round1C;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class QualificationA {
 
 
 	public static String getLine(int[] tourA, int[] tourB){
 		String resul = null;
 		int nbInterections = 0;
 		for(int i = 0; i < tourA.length; i++ ){
 			for(int j = 0; j < tourA.length; j++ ){
 					
 			if(tourA[i] > tourA[j] && tourB[i] < tourB[j]){
 				nbInterections++;
 			}
 			else if(tourA[i] < tourA[j] && tourB[i] > tourB[j]){
 				nbInterections++;
 			}
 			}
 		}
 		
 		
 		return """"+nbInterections/2;
 	}
 
 		
 	public static void main(String[] args) throws IOException {
 		//String fileName = ""A-small-attempt0"";
 		String fileName = ""A-large"";
 		
 		String inputFile=""D:\\googleCodeJam\\round1\\""+ fileName +"".in"";
 		File f = new File(inputFile);
 		FileReader fr = new FileReader(f);
 		BufferedReader br = new BufferedReader(fr);		
 		String outputFile=""D:\\googleCodeJam\\round1\\""+ fileName +"".out"";
 		FileWriter fw = new FileWriter(outputFile);
 		
 		
 		String line1 = br.readLine();
 		
 		//Extraction of number of cases
 		int nbCases = Integer.parseInt(line1);
 		
 		for(int i=1; i<=nbCases; i++){
 			String line2 = br.readLine();
 			int nbCables = Integer.parseInt(line2);
 			
 			int[] tourA = new int[nbCables];
 			int[] tourB = new int[nbCables];
 			
 				//String tourAString = br.readLine();
 				//String tourBString = br.readLine();
 				
 				//String[] tourAStringTab = tourAString.split("" "");
 				//String[] tourBStringTab = tourBString.split("" "");
 				
 				for(int l=0; l<nbCables; l++){
 					String lineCable = br.readLine();
 					String[] lineCableTab = lineCable.split("" "");
 					tourA[l] = Integer.parseInt(lineCableTab[0]);
 					tourB[l] = Integer.parseInt(lineCableTab[1]);
 				}
 			
 			String lineResult = getLine(tourA, tourB);
 			Outils.writeLine(lineResult, i, fw);
 		}
 	
 		fw.close();
 	}
 }
","package onlineQualification;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 
 public class QualificationC {
 
 	
 
 	public static String getLine(int nbTours, int nbPlaces, String[] groupesTab, int nbGroups){
 		
 		int resulInt = 0;
 		ArrayList groups = new ArrayList();
 		for(int i = 0; i < groupesTab.length; i++){
 			groups.add(groupesTab[i]);
 		}
 
 		int indexGroup = 0;
 		int[] solutions = new int[nbGroups];
 		int[] indexGroupEnd = new int[nbGroups];
 		for(int i = 0; i < nbTours; i++){
 			boolean full = false;
 			int nbPersonnes = 0;
 			int nbGroupesInside = 0;
 			int indexGroupStart = indexGroup;
 			
 
 			if(solutions[indexGroupStart]!=0){
 				full = true;
 				resulInt+=solutions[indexGroupStart];
 				indexGroup = indexGroupEnd[indexGroupStart];
 			}
 			
 			while(!full){
 				int nextGroupe = Integer.parseInt(groups.get(indexGroup).toString());
 				if(nextGroupe + nbPersonnes <= nbPlaces && nbGroupesInside < nbGroups){
 					nbPersonnes+=nextGroupe;
 					nbGroupesInside++;
 					indexGroup = (indexGroup + 1) % nbGroups;
 				}
 				else{
 					full=true;
 					resulInt+=nbPersonnes;
 					solutions[indexGroupStart]=nbPersonnes;
 					indexGroupEnd[indexGroupStart]= indexGroup;
 				}
 			}
 			
 		}
 		
 		
 		return """" + resulInt;
 	}
 	
 	
 	
 	
 	public static void main(String[] args) throws IOException {
 		String fileName = ""C-large"";
 		
 		String inputFile=""D:\\googleCodeJam\\onlineQualification\\""+ fileName +"".in"";
 		File f = new File(inputFile);
 		FileReader fr = new FileReader(f);
 		BufferedReader br = new BufferedReader(fr);		
 		String outputFile=""D:\\googleCodeJam\\onlineQualification\\""+ fileName +"".out"";
 		FileWriter fw = new FileWriter(outputFile);
 		
 		
 		String line1 = br.readLine();
 		
 		//Extraction of number of cases
 		int nbCases = Integer.parseInt(line1);
 		
 		for(int i=1; i<=nbCases; i++){
 			System.out.println(""ligne "" + i + ""sur "" + nbCases);
 			String variables = br.readLine();
 			String[] variablesTab = variables.split("" "");
 			int nbTours = Integer.parseInt(variablesTab[0]);
 			int nbPlaces = Integer.parseInt(variablesTab[1]);
 			int nbGroups = Integer.parseInt(variablesTab[2]);
 			String groupes = br.readLine();
 			String[] groupesTab = groupes.split("" "");
 			
 			String lineResult = getLine(nbTours, nbPlaces, groupesTab, nbGroups);
 			Outils.writeLine(lineResult, i, fw);
 		}
 		fw.close();
 	}
 }
",1
72,4962,"import java.io.*;
 import java.util.*;
 
 class kingdom {
 	public static void main (String [] args) throws IOException {
 		long start = System.currentTimeMillis();
 		BufferedReader br = new BufferedReader(new FileReader(""kingdom.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""kingdom.out"")));
 		int T = Integer.parseInt(br.readLine());
 		for (int i = 0; i < T; i++) {
 			int levels = Integer.parseInt(br.readLine());
 			boolean[] levelsdone = new boolean[levels];
 			boolean[] levelsdone1star = new boolean[levels];
 			int[][] levelreqs = new int[levels][2];
 			boolean haszero = false;
 			int levelzero = -1;
 			int levelzeromax = -1;
 			int levelzero2star = -1;
 			for (int j = 0; j < levels; j++) {
 				StringTokenizer st = new StringTokenizer(br.readLine());
 				levelreqs[j][0] = Integer.parseInt(st.nextToken());
 				levelreqs[j][1] = Integer.parseInt(st.nextToken());
 				if (levelreqs[j][1] == 0) {
 					levelzero2star = j;
 					haszero = true;
 				} else if (levelreqs[j][0] == 0 && levelzeromax < levelreqs[j][1]) {
 					levelzeromax = levelreqs[j][1];
 					levelzero = j;
 					haszero = true;
 				}
 				if (levelreqs[j][1] > 2*levels) {
 					haszero = false;
 				}
 			}
 			if (!haszero) {
 				out.println(""Case #"" + (i+1) + "": Too Bad"");
 				continue;
 			}
 			int answer = 0;
 			int numstars = 0;
 			if (levelzero2star != -1) {
 				int first = levelzero2star;
 				levelsdone[first] = true;
 				answer++;
 				numstars += 2;
 				while (true) {
 					boolean done = true;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k]) {
 							done = false;
 						}
 					}
 					if (done) { 
 						break; 
 					}
 					done = false;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k] && levelreqs[k][1] <= numstars && !levelsdone1star[k]) {
 							numstars += 2;
 							answer++;
 							levelsdone[k] = true;
 							done = true;
 							System.out.println(k);
 							continue;
 						}
 					}
 					if (done) { 
 						continue; 
 					}
 					
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k] && levelreqs[k][1] <= numstars && levelsdone1star[k]) {
 							numstars += 1;
 							answer++;
 							levelsdone[k] = true;
 							done = true;
 							System.out.println(k);
 							continue;
 						}
 					}
 					if (done) { 
 						continue; 
 					}
 					int max = -1;
 					int desired = -1;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone1star[k] && levelreqs[k][0] <= numstars && levelreqs[k][1] > max && !levelsdone[k]) {
 							desired = k;
 							max = levelreqs[k][1];
 							done = true;
 						}
 					}
 					if (done) { 
 						numstars += 1;
 						answer++;
 						levelsdone1star[desired] = true;
 						System.out.println(desired);
 						continue; 
 					}			
 					if (!done) {
 						answer = Integer.MAX_VALUE;
 						break;
 					}
 				}
 			} else {
 				int first = levelzero;
 				System.out.println(first);
 				levelsdone1star[first] = true;
 				answer++;
 				numstars += 1;
 				while (true) {
 					boolean done = true;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k]) {
 							done = false;
 						}
 					}
 					if (done) { 
 						break; 
 					}
 					done = false;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k] && levelreqs[k][1] <= numstars && !levelsdone1star[k]) {
 							numstars += 2;
 							answer++;
 							levelsdone[k] = true;
 							done = true;
 							System.out.println(k + "" "" + numstars);
 							continue;
 						}
 					}
 					if (done) { 
 						continue; 
 					}
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone[k] && levelreqs[k][1] <= numstars && levelsdone1star[k]) {
 							numstars += 1;
 							answer++;
 							levelsdone[k] = true;
 							done = true;
 							System.out.println(k + "" "" + numstars);
 							continue;
 						}
 					}
 					if (done) { 
 						continue; 
 					}
 					int max = -1;
 					int desired = -1;
 					for (int k = 0; k < levels; k++) {
 						if (!levelsdone1star[k] && levelreqs[k][0] <= numstars && levelreqs[k][1] > max && !levelsdone[k]) {
 							desired = k;
 							max = levelreqs[k][1];
 							done = true;
 						}
 					}
 					if (done) { 
 						numstars += 1;
 						answer++;
 						levelsdone1star[desired] = true;
 						System.out.println(desired + "" "" + numstars);
 						continue; 
 					}
 					if (!done) {
 						answer = Integer.MAX_VALUE;
 						break;
 					}
 				}
 			}
 			if (answer == Integer.MAX_VALUE) {
 				out.println(""Case #"" + (i+1) + "": Too Bad"");
 			} else {
 				out.println(""Case #"" + (i+1) + "": "" + answer);
 			}
 			out.flush();
 		}
 		long end = System.currentTimeMillis();
 		System.out.println(end-start);
 		out.close();
 		System.exit(0);
 	}
 }
 
","/*
 ID: 14vikra1
 LANG: JAVA
 TASK: QualA2011
 */
 import java.io.*;
 import java.util.*;
 import java.math.BigInteger;
 
 public class BotTrust {
   public static void main (String [] args) throws IOException {
     BufferedReader f = new BufferedReader(new FileReader(""A-large-qual.in""));
     //PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""1A.out"")));
     int numberTest = Integer.parseInt(f.readLine());
     for (int i = 1; i <= numberTest; i++) {
     	String testCase = f.readLine();
     	String[] testDescription = testCase.split("" "");
     	int numberMoves = Integer.parseInt(testDescription[0]);
     	int answer = 0;
     	int oPos = 1;
     	int bPos = 1;
     	int oCorr = 0;
     	int bCorr = 0;
     	for (int j = 1; j <= numberMoves; j++) {
     		String whichBot = testDescription[2*j-1];
     		int whichNum = Integer.parseInt(testDescription[2*j]);
     		if (whichBot.equals(""O"")) {
     			answer = answer + Math.max(Math.abs(whichNum - oPos)-oCorr,0) + 1;
     			bCorr = bCorr + Math.max(Math.abs(whichNum - oPos)-oCorr,0) + 1;
     			oPos = whichNum;
     			oCorr = 0;
     		} else if (whichBot.equals(""B"")) {
     			answer = answer + Math.max(Math.abs(whichNum - bPos)-bCorr,0) + 1;
     			oCorr = oCorr + Math.max(Math.abs(whichNum - bPos)-bCorr,0) + 1;
     			bPos = whichNum;
     			bCorr = 0;
     		}
     		//System.out.println(oPos + "" "" + oCorr + "" "" + bPos + "" "" + bCorr + "" "" + answer);
     	}
     	System.out.println(""Case #"" + i + "": "" + answer);
     }
     //out.close();                                  
     System.exit(0);                               
   }
  
 }
 
",1
73,8207,"import java.util.*;
 import java.io.*;
 public class SolutionA
 {
 	public static void main(String[] args) throws Exception
 	{
 		Scanner sc = new Scanner(new File(""A-large.in""));
 		int T = sc.nextInt();
 		for(int i = 0;i< T;i++)
 		{
 			sc.nextLine();
 			System.out.printf(""Case #%d: "",i+1);
 			String[] board = new String[4];
 			for(int j = 0;j < 4;j++)
 			{
 				 board[j] = sc.nextLine();
 			}
 			getWinner(board);
 			System.out.println();
 		}
 	}
 
 	public static void print(char winner)
 	{
 		switch(winner)
 		{
 			case 'O':
 				System.out.print(""O won"");
 				break;
 			case 'X':
 				System.out.print(""X won"");
 				break;
 			case 'D':
 				System.out.print(""Draw"");
 				break;
 			default:
 				System.out.print(""Game has not completed"");
 		}
 	}
 	public static void getWinner(String[] board)
 	{
 		char winner = 'D';
 		for(int i =0; i < 4; i++)
 		{
 			char[] chars = board[i].toCharArray();
 			char c = winner(chars);
 			if(c != 'N')
 			{
 				winner = c;
 				print(winner);
 				return;
 			}
 		}
 		for(int i = 0; i < 4;i++)
 		{
 			char[] chars = new char[4];
 			chars[0] = board[0].charAt(i);
 			chars[1] = board[1].charAt(i);
 			chars[2] = board[2].charAt(i);
 			chars[3] = board[3].charAt(i);
 			char c = winner(chars);
 			if(c != 'N')
 			{
 				winner = c;
 				print(winner);
 				return;
 			}
 		}
 		char[] chars = new char[4];
 		chars[0] = board[0].charAt(0);
 		chars[1] = board[1].charAt(1);
 		chars[2] = board[2].charAt(2);
 		chars[3] = board[3].charAt(3);
 		char c = winner(chars);
 		if(c != 'N')
 		{
 			winner = c;
 			print(winner);
 			return;
 		}
 		chars[0] = board[0].charAt(3);
 		chars[1] = board[1].charAt(2);
 		chars[2] = board[2].charAt(1);
 		chars[3] = board[3].charAt(0);
 		c = winner(chars);
 		if(c != 'N')
 		{
 			winner = c;
 			print(winner);
 			return;
 		}
 		winner = isDraw(board);
 		print(winner);
 	}
 
 	public static char isDraw(String[] board)
 	{
 		for(int i = 0; i < 4;i++)
 		{
 			for(int j = 0; j < 4;j++)
 			{
 				char c = board[i].charAt(j);
 				if(c == '.')
 				{
 					return 'N';
 				}
 			}
 		}
 		return 'D';
 	}
 	public static char winner(char[] chars)
 	{
 		char c = chars[0];
 		char r = c;
 		for(char t:chars)
 		{
 			if(t!=c && t!= 'T')
 			{
 				return 'N';
 			}
 		}
 		if(c != '.')
 		{
 			return c;
 		}
 		else
 		{
 			return 'N';
 		}
 	}
 }","import java.util.*;
 import java.io.*;
 public class SolutionA
 {
 	public static void main(String[] args) throws Exception
 	{
 		Scanner sc = new Scanner(new File(""A-small-attempt2.in""));
 		int T = sc.nextInt();
 		for(int i = 0;i< T;i++)
 		{
 			sc.nextLine();
 			System.out.printf(""Case #%d: "",i+1);
 			String[] board = new String[4];
 			for(int j = 0;j < 4;j++)
 			{
 				 board[j] = sc.nextLine();
 			}
 			getWinner(board);
 			System.out.println();
 		}
 	}
 
 	public static void print(char winner)
 	{
 		switch(winner)
 		{
 			case 'O':
 				System.out.print(""O won"");
 				break;
 			case 'X':
 				System.out.print(""X won"");
 				break;
 			case 'D':
 				System.out.print(""Draw"");
 				break;
 			default:
 				System.out.print(""Game has not completed"");
 		}
 	}
 	public static void getWinner(String[] board)
 	{
 		char winner = 'D';
 		for(int i =0; i < 4; i++)
 		{
 			char[] chars = board[i].toCharArray();
 			char c = winner(chars);
 			if(c != 'N')
 			{
 				winner = c;
 				print(winner);
 				return;
 			}
 		}
 		for(int i = 0; i < 4;i++)
 		{
 			char[] chars = new char[4];
 			chars[0] = board[0].charAt(i);
 			chars[1] = board[1].charAt(i);
 			chars[2] = board[2].charAt(i);
 			chars[3] = board[3].charAt(i);
 			char c = winner(chars);
 			if(c != 'N')
 			{
 				winner = c;
 				print(winner);
 				return;
 			}
 		}
 		char[] chars = new char[4];
 		chars[0] = board[0].charAt(0);
 		chars[1] = board[1].charAt(1);
 		chars[2] = board[2].charAt(2);
 		chars[3] = board[3].charAt(3);
 		char c = winner(chars);
 		if(c != 'N')
 		{
 			winner = c;
 			print(winner);
 			return;
 		}
 		chars[0] = board[0].charAt(3);
 		chars[1] = board[1].charAt(2);
 		chars[2] = board[2].charAt(1);
 		chars[3] = board[3].charAt(0);
 		c = winner(chars);
 		if(c != 'N')
 		{
 			winner = c;
 			print(winner);
 			return;
 		}
 		winner = isDraw(board);
 		print(winner);
 	}
 
 	public static char isDraw(String[] board)
 	{
 		for(int i = 0; i < 4;i++)
 		{
 			for(int j = 0; j < 4;j++)
 			{
 				char c = board[i].charAt(j);
 				if(c == '.')
 				{
 					return 'N';
 				}
 			}
 		}
 		return 'D';
 	}
 	public static char winner(char[] chars)
 	{
 		char c = chars[0];
 		char r = c;
 		for(char t:chars)
 		{
 			if(t!=c && t!= 'T')
 			{
 				return 'N';
 			}
 		}
 		if(c != '.')
 		{
 			return c;
 		}
 		else
 		{
 			return 'N';
 		}
 	}
 }",1
74,9988,"package com.codejam.round1C2013;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class A {
 	public static void main(String[] args) throws Exception{
 		A a = new A();
 		a.process(""A-sample.in"");
 		a.process(""A-small-attempt0.in"");
 		//a.process(""A-large-practice.in"");
 	}
 	void process(String fileName) throws Exception
 	{
 		Scanner scanner = new Scanner(new File(""data/"" + fileName));
 		FileWriter fw = new FileWriter(new File(""output/"" + fileName + "".out""));
 		int line = scanner.nextInt();
 		scanner.nextLine();
 		for(int i=0;i<line;i++)
 		{
 			String[] l1 = scanner.nextLine().split("" "");
 			long result = solve(l1[0],Integer.parseInt(l1[1]));
 			String o = ""Case #"" + (i+1) + "": "" + result + ""\n"";
 			fw.write(o);
 			System.out.print(o);
 		}
 		scanner.close();
 		fw.close();
 	}
 	public long solve(String s,int n)
 	{
 		long total = 0;
 		for(int i=0;i<s.length();i++)
 		{
 			int count = 0;
 			for(int j=i;j<s.length();j++)
 			{
 				char c = s.charAt(j);
 				if(c == 'a' || c=='i' || c=='e' || c=='o' || c == 'u')
 				{
 					count=0;
 					continue;
 				}
 				count++;
 				if(count >= n)
 				{
 					total+= s.length() - j;
 					break;
 				}
 			}
 			
 		}
 		return total;
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.HashSet;
 
 public class TicTacToeTomek {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		// open file and create a buffered reader
 		FileReader input = new FileReader(args[0]);
 		BufferedReader buffer = new BufferedReader(input);
 		
 		//read the number of testcases
 		int max = Integer.parseInt(buffer.readLine().trim());
 		
 		// read a line and call the solving procedure for a single test case.  We expect back the result as a string
 		for (int i = 1; i <= max; i++) {
 			System.out.println(""Case #""+i+"": "" + solve(buffer.readLine(),buffer.readLine(),buffer.readLine(),buffer.readLine()));
 			buffer.readLine();
 		}
 	}
 
 	private static String solve(String line1, String line2, String line3, String line4) {
 		boolean full = true;
 		switch(line1.charAt(0))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line1.charAt(1) == 'X' || line1.charAt(1) == 'T') && (line1.charAt(2) == 'X' || line1.charAt(2) == 'T') && (line1.charAt(3) == 'X' || line1.charAt(3) == 'T'))
 					return new String(""X won"");
 				if((line2.charAt(1) == 'X' || line2.charAt(1) == 'T') && (line3.charAt(2) == 'X' || line3.charAt(2) == 'T') && (line4.charAt(3) == 'X' || line4.charAt(3) == 'T'))
 					return new String(""X won"");
 				if((line2.charAt(0) == 'X' || line2.charAt(0) == 'T') && (line3.charAt(0) == 'X' || line3.charAt(0) == 'T') && (line4.charAt(0) == 'X' || line4.charAt(0) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line1.charAt(1) == 'O' || line1.charAt(1) == 'T') && (line1.charAt(2) == 'O' || line1.charAt(2) == 'T') && (line1.charAt(3) == 'O' || line1.charAt(3) == 'T'))
 					return new String(""O won"");
 				if((line2.charAt(1) == 'O' || line2.charAt(1) == 'T') && (line3.charAt(2) == 'O' || line3.charAt(2) == 'T') && (line4.charAt(3) == 'O' || line4.charAt(3) == 'T'))
 					return new String(""O won"");
 				if((line2.charAt(0) == 'O' || line2.charAt(0) == 'T') && (line3.charAt(0) == 'O' || line3.charAt(0) == 'T') && (line4.charAt(0) == 'O' || line4.charAt(0) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line1.charAt(1) == 'X' && line1.charAt(2) == 'X' && line1.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(1) == 'X' && line3.charAt(2) == 'X' && line4.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(0) == 'X' && line3.charAt(0) == 'X' && line4.charAt(0) == 'X')
 					return new String(""X won"");
 				if(line1.charAt(1) == 'O' && line1.charAt(2) == 'O' && line1.charAt(3) == 'O')
 					return new String(""O won"");
 				if(line2.charAt(1) == 'O' && line3.charAt(2) == 'O' && line4.charAt(3) == 'O')
 					return new String(""O won"");
 				if(line2.charAt(0) == 'O' && line3.charAt(0) == 'O' && line4.charAt(0) == 'O')
 					return new String(""O won"");
 				break;
 		}
 
 		switch(line1.charAt(1))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line2.charAt(1) == 'X' || line2.charAt(1) == 'T') && (line3.charAt(1) == 'X' || line3.charAt(1) == 'T') && (line4.charAt(1) == 'X' || line4.charAt(1) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line2.charAt(1) == 'O' || line2.charAt(1) == 'T') && (line3.charAt(1) == 'O' || line3.charAt(1) == 'T') && (line4.charAt(1) == 'O' || line4.charAt(1) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line2.charAt(1) == 'X' && line3.charAt(1) == 'X' && line4.charAt(1) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(1) == 'O' && line3.charAt(1) == 'O' && line4.charAt(1) == 'O')
 					return new String(""O won"");
 				break;
 		}
 		
 		switch(line1.charAt(2))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line2.charAt(2) == 'X' || line2.charAt(2) == 'T') && (line3.charAt(2) == 'X' || line3.charAt(2) == 'T') && (line4.charAt(2) == 'X' || line4.charAt(2) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line2.charAt(2) == 'O' || line2.charAt(2) == 'T') && (line3.charAt(2) == 'O' || line3.charAt(2) == 'T') && (line4.charAt(2) == 'O' || line4.charAt(2) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line2.charAt(2) == 'X' && line3.charAt(2) == 'X' && line4.charAt(2) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(2) == 'O' && line3.charAt(2) == 'O' && line4.charAt(2) == 'O')
 					return new String(""O won"");
 				break;
 		}
 		
 		switch(line1.charAt(3))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line2.charAt(3) == 'X' || line2.charAt(3) == 'T') && (line3.charAt(3) == 'X' || line3.charAt(3) == 'T') && (line4.charAt(3) == 'X' || line4.charAt(3) == 'T'))
 					return new String(""X won"");
 				if((line2.charAt(2) == 'X' || line2.charAt(2) == 'T') && (line3.charAt(1) == 'X' || line3.charAt(1) == 'T') && (line4.charAt(0) == 'X' || line4.charAt(0) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line2.charAt(3) == 'O' || line2.charAt(3) == 'T') && (line3.charAt(3) == 'O' || line3.charAt(3) == 'T') && (line4.charAt(3) == 'O' || line4.charAt(3) == 'T'))
 					return new String(""O won"");
 				if((line2.charAt(2) == 'O' || line2.charAt(2) == 'T') && (line3.charAt(1) == 'O' || line3.charAt(1) == 'T') && (line4.charAt(0) == 'O' || line4.charAt(0) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line2.charAt(3) == 'X' && line3.charAt(3) == 'X' && line4.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(2) == 'X' && line3.charAt(1) == 'X' && line4.charAt(0) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(3) == 'O' && line3.charAt(3) == 'O' && line4.charAt(3) == 'O')
 					return new String(""O won"");
 				if(line2.charAt(2) == 'O' && line3.charAt(1) == 'O' && line4.charAt(0) == 'O')
 					return new String(""O won"");
 				break;
 		}
 		
 		switch(line2.charAt(0))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line2.charAt(1) == 'X' || line2.charAt(1) == 'T') && (line2.charAt(2) == 'X' || line2.charAt(2) == 'T') && (line2.charAt(3) == 'X' || line2.charAt(3) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line2.charAt(1) == 'O' || line2.charAt(1) == 'T') && (line2.charAt(2) == 'O' || line2.charAt(2) == 'T') && (line2.charAt(3) == 'O' || line2.charAt(3) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line2.charAt(1) == 'X' && line2.charAt(2) == 'X' && line2.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line2.charAt(1) == 'O' && line2.charAt(2) == 'O' && line2.charAt(3) == 'O')
 					return new String(""O won"");
 				break;
 		}
 
 		switch(line3.charAt(0))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line3.charAt(1) == 'X' || line3.charAt(1) == 'T') && (line3.charAt(2) == 'X' || line3.charAt(2) == 'T') && (line3.charAt(3) == 'X' || line3.charAt(3) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line3.charAt(1) == 'O' || line3.charAt(1) == 'T') && (line3.charAt(2) == 'O' || line3.charAt(2) == 'T') && (line3.charAt(3) == 'O' || line3.charAt(3) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line3.charAt(1) == 'X' && line3.charAt(2) == 'X' && line3.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line3.charAt(1) == 'O' && line3.charAt(2) == 'O' && line3.charAt(3) == 'O')
 					return new String(""O won"");
 				break;
 		}
 
 		switch(line4.charAt(0))
 		{
 			case '.':
 				full = false;
 				break;
 			case 'X':
 				if((line4.charAt(1) == 'X' || line4.charAt(1) == 'T') && (line4.charAt(2) == 'X' || line4.charAt(2) == 'T') && (line4.charAt(3) == 'X' || line4.charAt(3) == 'T'))
 					return new String(""X won"");
 				break;
 			case 'O':
 				if((line4.charAt(1) == 'O' || line4.charAt(1) == 'T') && (line4.charAt(2) == 'O' || line4.charAt(2) == 'T') && (line4.charAt(3) == 'O' || line4.charAt(3) == 'T'))
 					return new String(""O won"");
 				break;
 			case 'T':
 				if(line4.charAt(1) == 'X' && line4.charAt(2) == 'X' && line4.charAt(3) == 'X')
 					return new String(""X won"");
 				if(line4.charAt(1) == 'O' && line4.charAt(2) == 'O' && line4.charAt(3) == 'O')
 					return new String(""O won"");
 				break;
 		}
 
 		if( !full || line2.charAt(1) == '.'  || line2.charAt(2) == '.'  || line2.charAt(3) == '.'
 			 			|| line3.charAt(1) == '.'  || line3.charAt(2) == '.'  || line3.charAt(3) == '.'
 				 		|| line4.charAt(1) == '.'  || line4.charAt(2) == '.'  || line4.charAt(3) == '.')
 			return new String(""Game has not completed"");
 				
 		return new String(""Draw"");
 	}
 
 }
",0
75,3024,"import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class C
 {
 
 	public static void main(String[] args)
 	{
 		new C();
 	}
 	
 	int R,k;
 	
 	int Gn;
 	BigInteger[] G=new BigInteger[1000];
 	int[] N=new int[1000];
 	BigInteger[] NC=new BigInteger[1000];
 	
 	int[] L=new int[1000];
 	int[] C=new int[1000];
 	
 	C()
 	{
 		Scanner in = new Scanner(System.in);
 		for (int T=in.nextInt(),TC=1; T-->0; ++TC)
 		{
 			R=in.nextInt();
 			k=in.nextInt();
 			Gn=in.nextInt();
 			for (int i=0; i<Gn; ++i)
 				G[i]=new BigInteger(in.nextInt());
 			
 			for (int i=0; i<Gn; ++i)
 			{
 				BigInteger sum=G[i];
 				int at=(i+1)%Gn;
 				int cnt=1;
 				while (at!=i && sum+G[at]<=k)
 				{
 					sum+=G[at];
 					at=(at+1)%Gn;
 					++cnt;
 				}
 				N[i]=cnt;
 				NC[i]=sum;
 			}
 			
 			Arrays.fill(C, 0);
 			int at=0;
 			while (true)
 			{
 				++C[at];
 				if (C[at]==2) break;
 				int nat=(at+N[at])%Gn;
 				L[at]=nat;
 				at=nat;
 			}
 			
 			int cycleLen=1;
 			BigInteger cycleSum=NC[at];
 			int start=at;
 			at=L[start];
 			while (at!=start)
 			{
 				++cycleLen;
 				cycleSum+=NC[at];
 				at=L[at];
 			}
 			
 			BigInteger money=0;
 			at=0;
 			for (int r=0; r<R; )
 			{
 				if (at==start)
 				{
 					BigInteger times=(R-r)/cycleLen;
 					money+=times*cycleSum;
 					r+=times*cycleLen;
 				}
 				
 				if (r==R) break;
 				
 				money+=NC[at];
 				at=L[at];
 				++r;
 			}
 			
 			System.out.printf(""Case #%d: %d%n"", TC,money);
 		}
 	}
 
 }
","import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class B {
 
 	int N;
 	int S;
 	int p;
 	int[] A = new int[100];
 	
 	int[][] memo = new int[100][100];
 	
 	boolean[][] normal = new boolean[11][31];
 	boolean[][] surprise = new boolean[11][31];
 	
 	B() {
 		for (int a=0; a<=10; ++a) {
 			for (int b=a; b<=10 && b<=a+2; ++b) {
 				for (int c=b; c<=10 && c<=a+2; ++c) {
 					if (c-a<=1)
 						normal[c][a+b+c]=true;
 					else
 						surprise[c][a+b+c]=true;
 				}
 			}
 		}
 		
 		Scanner in=new Scanner(System.in);
 		for (int T=in.nextInt(),TC=1; T-->0; ++TC) {
 			N=in.nextInt();
 			S=in.nextInt();
 			p=in.nextInt();
 			for (int i=0; i<N; ++i)
 				A[i]=in.nextInt();
 			for (int[] m : memo)
 				Arrays.fill(m, -1);
 			System.out.printf(""Case #%d: %d%n"",TC,go(0,0));
 		}
 	}
 	
 	int go(int at, int sur) {
 		if (at==N)
 			return 0;
 		if (memo[at][sur]>-1)
 			return memo[at][sur];
 		
 		int res=0;
 		for (int max=0; max<=10; ++max) {
 			int add=max>=p?1:0;
 			if (normal[max][A[at]])
 				res=Math.max(res,add+go(at+1,sur));
 			if (sur<S && surprise[max][A[at]])
 				res=Math.max(res,add+go(at+1,sur+1));
 		}
 		return memo[at][sur]=res;
 	}
 	public static void main(String[] args) {
 		new B();
 	}
 
 }
",1
76,2037,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class TicTacTicTomek {
 
 	/**
 	 * @param args
 	 */
 	static int count[] = new int[3];
 	public static void main(String[] args) throws IOException {
 		// TODO Auto-generated method stub
 		BufferedReader in = new BufferedReader(new FileReader(""A-small-attempt2.in""));
 		PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));
 		char tic[][] = new char[4][4];
 		int t = Integer.parseInt(in.readLine());
 		int i,j,k;
 		String s;
 		boolean isEmpty;
 		int returnValue = 0;
 		for(i = 1; i <= t; i++)
 		{
 			if(i != 1)
 				in.readLine();
 			
 		    isEmpty = false;
 			
 			for(j = 0; j <= 3; j++)
 			{
 				s = in.readLine();
 				tic[j] = s.toCharArray();
 				for(k =0; k <= 3; k++)
 				{
 					if(tic[j][k] == '.')
 						isEmpty = true;
 						
 					
 				}
 			}
 			
 			for(j = 0; j <= 3; j++)  //row-wise
 			{
 				Arrays.fill(count, 0);
 				for(k =0; k <= 3; k++)
 				{
 					if(tic[j][k] == 'X')
 						count[0]++;
 					else
 						if(tic[j][k] == 'O')
 							count[1]++;
 						else
 							if(tic[j][k] == 'T')
 								count[2]++;
 				}
 				returnValue = isWon();
 				if(returnValue != -1)
 				{
 					break;
 				}
 			}
 			if(returnValue == -1)
 			for(j = 0; j <= 3; j++) //column-wise
 			{
 				Arrays.fill(count, 0);
 				for(k =0; k <= 3; k++)
 				{
 					if(tic[k][j] == 'X')
 						count[0]++;
 					else
 						if(tic[k][j] == 'O')
 							count[1]++;
 						else
 							if(tic[k][j] == 'T')
 								count[2]++;
 				}
 				returnValue = isWon();
 				if(returnValue != -1)
 				{
 					break;
 				}
 			}
 			if(returnValue == -1)
 			{
 				Arrays.fill(count, 0);
 				for(j = 0; j <= 3; j++)  //left-diagonal
 			{
 					if(tic[j][j] == 'X')
 						count[0]++;
 					else
 						if(tic[j][j] == 'O')
 							count[1]++;
 						else
 							if(tic[j][j] == 'T')
 								count[2]++;
 			}
 			returnValue = isWon();
 		    }
 			if(returnValue == -1)
 			{
 				Arrays.fill(count, 0);
 				for(j = 3; j >= 0; j--)  //right-diagonal
 			{
 					if(tic[j][3-j] == 'X')
 						count[0]++;
 					else
 						if(tic[j][3-j] == 'O')
 							count[1]++;
 						else
 							if(tic[j][3-j] == 'T')
 								count[2]++;
 			}
 			returnValue = isWon();
 	     	}
 			
 			writer.print(""Case #"" + i + "": "");
 			if(returnValue == 0)
 			{
 				writer.println(""X won"");
 			}
 			else
 				if(returnValue == 1)
 			{
 				writer.println(""O won"");
 			}
 				else
 					if(returnValue == -1 && isEmpty == false)
 			{
 				writer.println(""Draw"");
 			}
 					else
 						writer.println(""Game has not completed"");
 			
 		}
 		in.close();
 		writer.close();
 		
 	}
 	public static int  isWon()
 	{
 		if(count[0] == 4)
 			return 0;
 		if(count[1] == 4)
 			return 1;
 		if(count[0] == 3 && count[2] == 1)
 			return 0;
 		if(count[1] == 3 && count[2] == 1)
 			return 1;
 		return -1;
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class CodeJamBoredSalesmanProblem {
 
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	
 	static int directions[][];
 	static int[] zips;
 	static boolean[] visited;
 	static PrintWriter writer;
 	static int n,m;
 	public static void main(String[] args) throws FileNotFoundException {
 		// TODO Auto-generated method stub
 
 		Scanner in = new Scanner(new File(""input.txt""));
 		writer = new PrintWriter(new File(""output.txt""));
 	//	Scanner in = new Scanner(System.in);
 		int t = in.nextInt();
 		for(int i  = 1; i <= t; i++)
 		{
 			n = in.nextInt();
 			m = in.nextInt();
 			zips = new int[n+1];
 			visited = new boolean[n+1];
 			for(int j = 1; j <= n;j++ )
 				zips[j] = in.nextInt();
 			directions = new int[n+1][n+1]; 
 			for(int j = 0; j < m ; j++)
 			{
 				int x = in.nextInt();
 				int y = in.nextInt();
 				directions[x][y] = 1; 
 			}
 			writer.print(""Case #""+i+"": "");
 			dfs(1);
 			writer.println();
 			
 		}
 		writer.close();
 		in.close();
 	}
 	
 	public static void dfs(int n)
 	{
 		visited[n] = true;
 		writer.print(zips[n]);
 		for(int i = 1; i <= n ; i++)
 		{
 			if(directions[n][i] == 1 && !visited[i])
 			{
 				dfs(i);
 			}
 		}
 	}
 
 }
",1
77,1542,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.sql.RowId;
 import java.util.StringTokenizer;
 
 
 public class QualificationRoundC {
 
 	public static void main(String[] args) throws Exception {
 		QualificationRoundC c = new QualificationRoundC();
 		c.solve();
 	}
 	
 	private void solve() throws Exception {
 //		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		BufferedReader br = new BufferedReader(new FileReader(""input.txt""));
 		int numberOfTestCases = Integer.valueOf(br.readLine());
 		for(int testCase = 1; testCase <= numberOfTestCases; testCase++) {
 			int r,c,m;
 			StringTokenizer st = new StringTokenizer(br.readLine());
 			r = Integer.valueOf(st.nextToken());
 			c = Integer.valueOf(st.nextToken());
 			m = Integer.valueOf(st.nextToken());
 			
 			System.out.println(""Case #"" + testCase + "":"");
 			int freeSpaces = r*c-m;
 //			System.out.println(""Freespaces: "" + freeSpaces);
 			boolean success = false;
 			int recRows=0,recCols=0,addDown=0,addUp=0;
 			boolean turn = r > c;
 			if(turn) {
 				int temp = r;
 				r = temp;
 				r = c;
 				c = temp;
 			}
 			
 			int longer = r > c ? r : c;
 			int shorter = r > c ? c : r;
 			if(shorter == 1 || freeSpaces == 1) {
 				recCols = freeSpaces;
 				recRows = 1;
 				success = true;
 			} else {
 				out: for(recRows = shorter;recRows >= 2;recRows--) {
 					for(recCols = longer;recCols >= 2; recCols--) {
 						int total = recRows*recCols;
 						int rest = freeSpaces - total;
 //						System.out.println(""Rest: ""+ rest);
 						if(rest < 0) {
 							continue;
 						}
 						if(rest == 0) {
 							addDown = 0;
 							addUp = 0;
 							success = true;
 							break out;
 						} else if(rest < recCols) {
 							if(recRows == shorter) {
 								continue;
 							}
 							addDown = rest;
 							if(addDown == 1)
 								continue;
 							addUp = 0;
 							success = true;
 							break out;
 						} else if(rest < recCols*2) {
 							if(recRows > shorter-2)
 								continue;
 							if(recRows < 3)
 								continue;
 							int half = rest/2;
 							addUp = half;
 							if(addUp == 1)
 								continue;
 							addDown = rest-half;
 							if(addDown == 1)
 								continue;
 							success = true;
 							break out;
 						} else {
 							continue;
 						}
 						
 					}
 				}
 			}
 			if(success) {
 				String[][] field = new String[r][c];
 //				System.out.println(""recRows = "" + recRows + "", recCols = "" + recCols + "", addUp = "" + addUp + "", addDown = "" + addDown + "", r = ""+ r + "", c = "" + c);
 //				if(addUp != 0) {
 //					for(int col = 0; col < recCols-addUp; col++) {
 //						field[0][col] = ""*"";
 //					}
 //					for(int col = recCols-addUp; col < recCols; col++) {
 //						field[0][col] = ""."";
 //					}
 //					for(int col = recCols; col < c; col++) {
 //						field[0][col] = ""*"";
 //					}
 //				}
 				if(addUp != 0) {
 					for(int col = 0; col < addUp; col++) {
 						field[0][col] = ""."";
 					}
 					for(int col = addUp; col < c; col++) {
 						field[0][col] = ""*"";
 					}
 				}
 				for(int row = 0; row < recRows; row++) {
 					int rowIndex = addUp == 0 ? row : row+1;
 					for(int col = 0; col < recCols; col++) {
 							field[rowIndex][col] = ""."";
 					}
 					for(int col = recCols; col < c; col++) {
 						field[rowIndex][col] = ""*"";
 					}
 				}
 				int rowIndex = addUp == 0 ? recRows : recRows+1;
 				if(addDown != 0) {
 					boolean move = recCols - addDown > 1 && recCols - addUp > 1;
 					if(move) {
 						for(int col = 0; col < recCols-addDown; col++) {
 							field[rowIndex][col] = ""*"";
 						}
 						for(int col = recCols-addDown; col < recCols; col++) {
 							field[rowIndex][col] = ""."";
 						}
 						for(int col = recCols; col < c; col++) {
 							field[rowIndex][col] = ""*"";
 						}
 						rowIndex++;
 					} else {
 						for(int col = 0; col < addDown; col++) {
 							field[rowIndex][col] = ""."";
 						}
 						for(int col = addDown; col < c; col++) {
 							field[rowIndex][col] = ""*"";
 						}
 						rowIndex++;
 
 					}
 				}
 				for(int row = rowIndex; row < r; row++) {
 					for(int col = 0; col < c; col++) {
 						field[row][col] = ""*"";
 					}
 				}
 				boolean found = false;
 				out: for(int col = 0; col < c; col++) {
 					for(int row = 0; row < r; row++) {
 						if(field[row][col].equals(""*""))
 							continue;
 						if(freeSpaces == 1) {
 							field[row][col] = ""c"";
 							break out;
 						}
 						if(col != 0 && row != 0) {
 							if(field[row-1][col-1].equals(""*""))
 								continue;
 						}
 						if(row != 0) {
 							if(field[row-1][col].equals(""*""))
 								continue;
 						}
 						if(col != c-1 && row != 0) {
 							if(field[row-1][col+1].equals(""*""))
 								continue;
 						}
 						if(col != c-1) {
 							if(field[row][col+1].equals(""*""))
 								continue;
 						}
 						if(col != c-1 && row != r-1) {
 							if(field[row+1][col+1].equals(""*""))
 								continue;
 						}
 						if(row != r-1) {
 							if(field[row+1][col].equals(""*""))
 								continue;
 						}
 						if(col != 0 && row != r-1) {
 							if(field[row+1][col-1].equals(""*""))
 								continue;
 						}
 						if(col != 0) {
 							if(field[row][col-1].equals(""*""))
 								continue;
 						}
 						field[row][col] = ""c"";
 						found = true;
 						break out;
 					}
 					if(!found) {
 						throw new IllegalStateException(""Fuck"");
 					}
 				}
 				
 				int countedMines = 0;
 //				turn = false;
 				if(turn) {
 					for(int col = 0; col < c; col++) {
 						for(int row = 0; row < r; row++) {
 							System.out.print(field[row][col]);
 							if(field[row][col].equals(""*""))
 								countedMines++;
 						}
 						System.out.println();
 					}
 				} else {
 					for(int row = 0; row < r; row++) {
 						for(int col = 0; col < c; col++) {
 								System.out.print(field[row][col]);
 								if(field[row][col].equals(""*""))
 									countedMines++;
 						}
 						System.out.println();
 					}
 				}
 				if(countedMines != m) {
 					throw new IllegalStateException();
 				}
 			} else {
 				System.out.println(""Impossible"");
 			}
 		}
 	}
 
 }
","import java.io.*;
 import java.util.*;
 import java.util.regex.*;
 import java.math.*;
 
 /**
  * 
  * Google Code Jam 2013
  * @author Milo ernilovsk - milhaus
  *
  */
 public class Main {
 	public static final String FILE_NAME = ""A-small-attempt2""; 
 	private static boolean TEST = false;
 	//private static final boolean BIG = false;
 	//private static final BigInteger MAX = BIG ? BigInteger.valueOf(1000000) : BigInteger.valueOf(100);
 	private static final BigInteger TWO = BigInteger.valueOf(2);
 
 	public static void main(String[] args) throws IOException {
 		if(TEST) {
 			System.out.println(""TEST !!!"");
 			createTestFile();
 		}
 		System.setIn(new FileInputStream(FILE_NAME + "".in""));
 		System.setOut(new PrintStream(FILE_NAME + "".out""));
 		FastReader in = FastReader.SYSTEM_READER;
 		int t = in.nextInt();
 		
 		for (int z = 1; z <= t; z++) {
 			int a = in.nextInt();
 			int n = in.nextInt();
 			int[] motes = new int[n];
 			for(int i = 0; i < n; i++) {
 				motes[i] = in.nextInt();
 			}
 			Arrays.sort(motes);
 			BigInteger sizeOfMote1 = BigInteger.valueOf(a), sizeOfMote2 = sizeOfMote1;
 			//System.out.println(""initial: "" + sizeOfMote);
 			int numOfOperations1 = 0, numOfOperations2 = 0;
 			int counter = 0;
 			for(int i = 0; i < n; i++) {
 				BigInteger currentMote = BigInteger.valueOf(motes[i]);
 				//System.out.println(""currentMote: "" + currentMote);
 				if(sizeOfMote1.compareTo(currentMote) != 1) {
 					BigInteger candidate = sizeOfMote1;
 					if(counter < n) {
 						while(candidate.compareTo(currentMote) != 1 && counter < n) {
 							numOfOperations1++;
 							counter++;
 							candidate = candidate.multiply(TWO).subtract(BigInteger.ONE);
 							//System.out.println(""not bigger"");
 							//System.out.println(""candidate: "" + candidate);
 						}
 					} else {
 						numOfOperations1 = n;
 						break;
 					}
 					sizeOfMote1 = candidate;
 					if(sizeOfMote1.compareTo(currentMote) == 1) {
 						//System.out.println(""enlargened mote bigger"");
 						sizeOfMote1 = sizeOfMote1.add(currentMote);
 					}
 					/*System.out.println(""not bigger"");
 					numOfOperations++;
 					BigInteger candidate = sizeOfMote.multiply(TWO).subtract(BigInteger.ONE);
 					System.out.println(""candidate: "" + candidate);
 					if(candidate.compareTo(currentMote) == 1) {
 						System.out.println(""candidate bigger"");
 						sizeOfMote = candidate;
 						sizeOfMote = sizeOfMote.add(currentMote);
 					} else {
 						System.out.println(""candidate not bigger"");
 					}*/
 				} else {
 					sizeOfMote1 = sizeOfMote1.add(currentMote);
 					//System.out.println(""bigger, sizeOfMote: "" + sizeOfMote1);
 				}
 			}
 			
 			for(int i = 0; i < n; i++) {
 				BigInteger currentMote = BigInteger.valueOf(motes[i]);
 				//System.out.println(""currentMote: "" + currentMote);
 				if(sizeOfMote2.compareTo(currentMote) != 1) {
 					//System.out.println(""not bigger"");
 					numOfOperations2++;
 					BigInteger candidate = sizeOfMote2.multiply(TWO).subtract(BigInteger.ONE);
 					//System.out.println(""candidate: "" + candidate);
 					if(candidate.compareTo(currentMote) == 1) {
 						//System.out.println(""candidate bigger"");
 						sizeOfMote2 = candidate;
 						sizeOfMote2 = sizeOfMote2.add(currentMote);
 					}/* else {
 						//System.out.println(""candidate not bigger"");
 					}*/
 				} else {
 					sizeOfMote2 = sizeOfMote2.add(currentMote);
 					//System.out.println(""bigger, sizeOfMote: "" + sizeOfMote2);
 				}
 			}
 			
 			System.out.println(""Case #"" + z + "": "" + Math.min(numOfOperations1, numOfOperations2));
 		}
 	}
 	
 	private static void createTestFile() throws FileNotFoundException {
 		System.out.println(""Creating a test file ..."");
 		PrintWriter pw = new PrintWriter(FILE_NAME + "".in"");
 		
 		
 		
 		pw.flush();
 		pw.close();
 		System.out.println(""Done."");
 	}
 
 }
 
 final class FastReader {
 	public static final FastReader SYSTEM_READER = new FastReader(System.in);
 	private final InputStream in;
 	private final byte[] buffer = new byte[512];
 	private int pos, count;
 
 	public FastReader(InputStream in) {
 		this.in = in;
 		pos = count = 0;
 	}
 
 	public int nextInt() {
 		int c;
 		while ((c = read()) < '0')
 			;
 		int result = c - '0';
 		while ((c = read() - '0') >= 0)
 			result = 10 * result + c;
 		if(c == -35) { // new line's \r (attention, here c = read()-'0', that's why it's -35)
 			if(read() != 10) { // check whether the next one is \n
 				pos--;// if not, go back
 			}
 		}
 		return result;
 	}
 
 	public String nextString() {
 		StringBuilder s = new StringBuilder();
 		int c;
 		while ((c = read()) >= 33)
 			s.append((char) c);
 		if(c == 13) { // new line's \r
 			if(read() != 10) { // check whether the next one is \n
 				pos--;// if not, go back
 			}
 		}
 		return s.toString();
 	}
 
 	private void fillBuffer() {
 		try {
 			count = in.read(buffer, pos = 0, buffer.length);
 		} catch (Exception e) {
 		}
 	}
 
 	public int read() {
 		if (pos == count)
 			fillBuffer();
 		return buffer[pos++];
 	}
 }",1
78,2285,"package main.java.service;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
 
 public class FairWarning {
 	private String getTimeToApo(BigInteger maxInput, List<BigInteger> inputs) {
 		List<BigInteger> diff = new ArrayList<BigInteger>();
 		
 		for (BigInteger input : inputs) {
 			if (!input.equals(maxInput)) {
 				diff.add(maxInput.subtract(input));
 			}
 		}
 		
 		if (diff.size() == 0) {
 			return ""0"";
 		}
 		
 		boolean isSuccess = true;
 		BigInteger resultGCD = diff.get(0);
 		for (int i = 1; i < diff.size(); i++) {
 			resultGCD = resultGCD.gcd(diff.get(0).gcd(diff.get(i)));
 		}
 				
 		if (resultGCD.equals(BigInteger.ONE)) {
 			isSuccess = false;
 		}
 		
 		if (isSuccess) {
 			System.out.println(resultGCD.toString());
 			BigInteger result = resultGCD.subtract(maxInput.divideAndRemainder(resultGCD)[1]);
 			if (result.equals(resultGCD)) {
 				return ""0"";
 			} else {
 				return result.toString();
 			}
 		}
 		
 		return ""0"";
 	}
 	
 	public static void main(String[] args) {
 		FairWarning module = new FairWarning();
 //		String max = ""26"";
 //		String input = ""11"";
 //		String input2 = ""6"";
 //		
 //		BigInteger maxValue = new BigInteger(max);
 //		List<BigInteger> inputs = new ArrayList<BigInteger>();
 //		inputs.add(new BigInteger(max));
 //		inputs.add(new BigInteger(input));
 //		inputs.add(new BigInteger(input2));
 //		
 //		System.out.println(module.getTimeToApo(maxValue, inputs));
 		
 		try {
 			BufferedReader reader = new BufferedReader(new FileReader(new File(""/Users/totworld/Downloads/B-small-attempt3.in"")));
 			BufferedWriter writer = new BufferedWriter(new FileWriter(new File(""/Users/totworld/Downloads/B-result.out.txt"")));
 			String line = reader.readLine();
 			int numberOfCase = Integer.valueOf(line);
 			for (int i = 0; i < numberOfCase; i++) {
 				String[] infos = reader.readLine().split(""[ ]"");
 				BigInteger maxInput = BigInteger.ONE;
 				List<BigInteger> inputs = new ArrayList<BigInteger>();
 				for (int j = 1; j < infos.length; j++) {
 					BigInteger curInput = new BigInteger(infos[j]); 
 					inputs.add(curInput);
 					
 					if (curInput.compareTo(maxInput) > 0) {
 						maxInput = curInput;
 					}
 				}
 				
 				String result = module.getTimeToApo(maxInput, inputs);
 				
 				System.out.print(""Case #"" + (i + 1) + "": "");
 				writer.write(""Case #"" + (i + 1) + "": "");
 				
 				writer.write(result);
 				writer.write(""\r\n"");
 				
 				System.out.println(result);
 			}
 			
 			writer.flush();
 			writer.close();
 			
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
","package cj2011;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class PA {
 	public enum RUNNING_MODE {
 		SYS, FILE
 	};
 	
 	private static final int INPUT_COUNT_FOR_CASE = 2;
 	private static final String INPUT_FILE_PATH_STR = ""/Users/Paul/Documents/A-large.in"";
 	private static final String OUTPUT_FILE_PATH_STR = ""/Users/Paul/Documents/A-large.out"";
 	
 	public static void main(String[] args) {
 		RUNNING_MODE inputRunningMode = RUNNING_MODE.FILE;
 		RUNNING_MODE outputRunningMode = RUNNING_MODE.FILE;
 
 		//Optional for SYS Mode
 		String[] inputs = {
 //				""4"",
 //				"".11."",
 //				""0.00"",
 //				""01.1"",
 //				"".10."",				
 				""3"",
 				"".10"",
 				""0.1"",
 				""10."",
 				""4"",
 				"".11."",
 				""0.00"",
 				""01.1"",
 				"".10."",				
 		};
 		
 		String[] answers = {
 				""Case #1:"",
 				""0.5"",
 				""0.5"",
 				""0.5"",
 //				""Case #2:"",
 //				""0.645833333333"",
 //				""0.368055555556"",
 //				""0.604166666667"",
 //				""0.395833333333"",			
 		};
 		
 		go(inputRunningMode, outputRunningMode, inputs, answers);
 	}
 	
 	private static List<String> logic(List<String> input) {
 		int n = Integer.valueOf(input.get(0));
 		
 		List<Double> wp = new ArrayList<Double>();
 		List<Double> owp = new ArrayList<Double>();
 		List<Double> oowp = new ArrayList<Double>();
 		
 		List<Integer> pCnt = new ArrayList<Integer>();
 		List<List<Integer>> wMap = new ArrayList<List<Integer>>();
 		List<List<Integer>> lMap = new ArrayList<List<Integer>>();
 		
 		for (int i = 0; i < n; i++) {
 			String curS = input.get(i + 1);
 
 			int wCnt = 0;
 			int lCnt = 0;
 			List<Integer> curWMap = new ArrayList<Integer>();
 			List<Integer> curLMap = new ArrayList<Integer>();
 			for (int j = 0; j < n; j++) {
 				char r = curS.charAt(j);
 				if (r == '1') {
 					curWMap.add(j);
 					wCnt++;
 				} else if (r == '0') {
 					curLMap.add(j);
 					lCnt++;
 				}
 			}
 			
 			wp.add((double)wCnt / (double)(wCnt + lCnt));
 			pCnt.add(wCnt + lCnt);
 			wMap.add(curWMap);
 			lMap.add(curLMap);
 		}
 		
 		for (int i = 0; i < n; i++) {
 			List<Integer> curWMap = wMap.get(i);
 			List<Integer> curLMap = lMap.get(i);
 			
 			double sum = 0.0;
 			for (int idx : curWMap) {
 				if (pCnt.get(idx) > 1) {
 					int wCnt = 0;
 					List<Integer> curOWMap = wMap.get(idx);
 					for (int idx2 : curOWMap) {
 						if (idx2 != i) {
 							wCnt++;
 						}
 					}
 					
 					sum += (double)wCnt / (double)(pCnt.get(idx) - 1);
 				}
 			}
 
 			for (int idx : curLMap) {
 				if (pCnt.get(idx) > 1) {
 					int wCnt = 0;
 					List<Integer> curOWMap = wMap.get(idx);
 					for (int idx2 : curOWMap) {
 						if (idx2 != i) {
 							wCnt++;
 						}
 					}
 					
 					sum += (double)wCnt / (double)(pCnt.get(idx) - 1);
 				}
 			}
 			
 			owp.add(sum / (double)pCnt.get(i));
 		}
 		
 		for (int i = 0; i < n; i++) {
 			List<Integer> curWMap = wMap.get(i);
 			List<Integer> curLMap = lMap.get(i);
 			
 			double sum = 0.0;
 			for (int idx : curWMap) {
 				sum += owp.get(idx);
 			}
 			for (int idx : curLMap) {
 				sum += owp.get(idx);
 			}
 			
 			oowp.add(sum / (double)(pCnt.get(i)));
 		}
 		
 		List<String> result = new ArrayList<String>();
 		for (int i = 0; i < n; i++) {
 			result.add(String.valueOf(0.25 * wp.get(i) + 0.50 * owp.get(i) + 0.25 * oowp.get(i)));
 		}
 		
 		
 		
 		return result;
 	}
 
 	private static void go(RUNNING_MODE inputRunningMode,
 			RUNNING_MODE outputRunningMode, String[] inputs, String[] answers) {
 		List<String> answerResult = new ArrayList<String>();
 		boolean answerMode = false;
 		if ((inputRunningMode == RUNNING_MODE.SYS) 
 				&& (answers.length == (inputs.length / INPUT_COUNT_FOR_CASE)))
 			answerMode = true;
 		
 		List<List<String>> inputCases = readInputCases(inputRunningMode, inputs);
 		
 		int caseCnt = 1;
 		List<String> outputs = new ArrayList<String>();
 		for (List<String> inputCase : inputCases) {
 			List<String> result = logic(inputCase);
 			
 			outputs.add(""Case #"" + caseCnt++ + "": "");
 			outputs.addAll(result);
 		}
 		
 		writeOutputCase(outputRunningMode, outputs, answerResult, inputCases);
 	}
 
 	private static void writeOutputCase(RUNNING_MODE outputRunningMode,
 			List<String> resultStrs, List<String> answerResult, List<List<String>> inputCases) {
 		
 		boolean answerMode = false;
 		if (answerResult.size() == resultStrs.size())
 			answerMode = true;
 		
 		if (outputRunningMode == RUNNING_MODE.FILE) {
 			try {
 				BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE_PATH_STR));
 				for (String resultStr : resultStrs) {
 					writer.write(resultStr + ""\r\n"");
 				}
 				writer.close();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 		}
 		else if (outputRunningMode == RUNNING_MODE.SYS) {
 			for (String resultStr : resultStrs) {
 				System.out.println(resultStr);
 			}
 		}
 	}
 
 	private static List<List<String>> readInputCases(RUNNING_MODE inputRunningMode, 
 			String[] curInputSet) {
 		
 		List<List<String>> inputCases = new ArrayList<List<String>>();
 		
 		List<String> lines = new ArrayList<String>();
 		
 		if (inputRunningMode == RUNNING_MODE.FILE) {
 		
 			BufferedReader reader;
 			try {
 				reader = new BufferedReader(new FileReader(INPUT_FILE_PATH_STR));
 				String line = """";
 				
 				reader.readLine();
 				while ((line = reader.readLine()) != null) {
 					lines.add(line.trim());
 				}
 				
 				reader.close();
 			} catch (FileNotFoundException e) {
 				e.printStackTrace();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			
 		} else if (inputRunningMode == RUNNING_MODE.SYS) {
 			for (String input : curInputSet)
 				lines.add(input);				
 		}
 		
 		int lineNum = 0;
 		int target = 0;
 		
 		List<String> curInput = new ArrayList<String>();
 		
 		
 		for (String line : lines) {
 			if (target == 0 || lineNum > target) {
 				if (target == 0) {
 					target = Integer.valueOf(line);
 					curInput.add(line);
 				} else {
 					inputCases.add(curInput);
 					curInput = new ArrayList<String>();
 					lineNum = 0;
 					target = Integer.valueOf(line);
 					curInput.add(line);
 				}
 			} else {
 				curInput.add(line);
 			}
 			
 			lineNum++;
 		}
 		inputCases.add(curInput);
 		
 		return inputCases;
 	}
 	
 }",1
79,13792,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 
 public class Main {
 	private static final String IN_FILE_NAME = ""in.txt"";
 	private static final String OUT_FILE_NAME = ""out.txt"";
 	
 	private static Vector<Stat> readFile(String filename) throws Exception{
 		BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));
 		int rows = Integer.parseInt(r.readLine());
 		
 		Vector<Stat> res = new Vector<Stat>();
 		for(int i = 0; i < rows; i++){
 			StringTokenizer tok = new StringTokenizer(r.readLine(), "" "");
 			Stat s = new Stat();
 			s.n = Long.parseLong(tok.nextToken());
 			s.pd = Long.parseLong(tok.nextToken());
 			s.pg = Long.parseLong(tok.nextToken());
 			
 			res.add(s);
 		}
 		
 		r.close();
 		
 		return res;
 	}
 	
 	private static void writeResult(Vector<String> res, String filename) throws Exception{
 		BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filename)));
 		
 		for(int i = 0; i < res.size(); i++){
 			w.write(""Case #"" + (i+1) +"": "" +res.get(i) +""\n"");
 		}
 		
 		w.close();
 	}
 	
 	private static Vector<String> processData(Vector<Stat> data){
 		Vector<String> res = new Vector<String>();
 		String possible = ""Possible"";
 		String broke = ""Broken"";
 		
 		outter:
 		for(Stat s : data){
 			if((s.pg == 100 && s.pd != 100) || (s.pg == 0 && s.pd != 0))
 				res.add(broke);
 			else if(s.n >= 100)
 				res.add(possible);
 			else if(s.pd == 0)
 				res.add(possible);
 			else{
 				for(long i = 1; i <= s.n; i++){
 					long y = i*s.pd/100;
 					if(y*100/s.pd == i){
 						res.add(possible);
 						continue outter;
 					}
 				}
 				
 				res.add(broke);
 			}
 		}
 		
 		return res;
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception{
 		Vector<Stat> data = readFile(IN_FILE_NAME);
 		Vector<String> result = processData(data);
 		writeResult(result, OUT_FILE_NAME);
 	}
 }
 
 class Stat{
 	long n;
 	long pd;
 	long pg;
 }","import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 
 public class Main2 {
 	private static final String IN_FILE = ""in.txt"";
 	private static final String OUT_FILE = ""out.txt"";
 	
 	private static List<Xxx> parseFile() throws IOException  {
 		BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(IN_FILE)));
 		
 		int count = Integer.parseInt(r.readLine());
 		List<Xxx> res = new ArrayList<Xxx>();
 		for(int i = 0; i < count; i++){
 			String line = r.readLine();
 			String[] tupel = line.split("" "");
 			Xxx d = new Xxx();
 			d.min = Integer.parseInt(tupel[0]);
 			d.max = Integer.parseInt(tupel[1]);
 			
 			res.add(d);
 		}
 		r.close();
 		
 		return res;
 	}
 	
 	private static List<Integer> process(List<Xxx> dl){
 		List<Integer> res = new ArrayList<Integer>();
 		
 		for(Xxx d : dl){
 			int count = 0;
 			
 //			System.out.println(""-----------------------------------------"");
 			List<String> xxx = new ArrayList<String>();
 			for(int x = d.min; x < d.max; x++){
 				String sx_orig = String.valueOf(x);
 				int len = sx_orig.length();
 				String sy = null;
 				xxx.clear();
 				
 				if(len > 1){
 					for(int y = x + 1; y <= d.max && (sy = String.valueOf(y)).length() == len; y++){
 						String sx = sx_orig;
 						
 						for(int i = 1; i < sx.length(); i++){
 							char c = sx.charAt(sx.length()-1);
 							sx = c  + sx.substring(0, sx.length() - 1);
 							
 							if(sx.equals(sy)){
 								
 								if(!xxx.contains(sx)){
 									xxx.add(sx);
 //									System.out.println(sx_orig +""\t"" +sx);
 									count++;
 									continue;
 								}
 							}
 						}
 					}
 				}
 			}
 			
 			res.add(count);
 		}
 		
 		return res;
 	}
 	
 	private static void writeOutput(List<Integer> data) throws IOException {
 		BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(OUT_FILE)));
 		
 		for(int i = 0; i < data.size(); i++){
 			if(i > 0){
 				w.write(""\n"");
 			}
 			
 			String s = ""Case #"" +(i+1) +"": "" +data.get(i);
 			w.write(s);
 		}
 		w.close();
 	}
 	
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		List<Xxx> l = parseFile();
 		List<Integer> r = process(l);
 		writeOutput(r);
 		
 		System.out.println(""Done"");
 	}
 	
 	private static class Xxx {
 		public int min;
 		public int max;
 	}
 }",1
80,6879,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 import java.util.SortedSet;
 import java.util.TreeSet;
 
 
 public class Main {
 	public static void main(String[] args) throws FileNotFoundException {
 		
 		Scanner s = new Scanner(new File(""inputl""));
 		
 		int n = s.nextInt();
 			
 		for (int t = 1; t<=n;t++) {
 			int N = s.nextInt();
 			int M = s.nextInt();
 			SortedSet<Integer> numbers = new TreeSet<Integer>(); 
 			
 			int[][] lawn = new int[N][M];
 			
 			for (int i = 0; i<N; i++) {
 				for (int j = 0; j<M; j++) {
 					int number = s.nextInt();
 					numbers.add(number);
 					lawn[i][j] = number;
 				}
 			}
 			
 			int previous = -1;
 			boolean ok = true;
 			for (int number : numbers) {
 				if (previous != -1) {
 					substitute(lawn, N, M, previous, number);
 				}
 				
 				ok &= check(lawn, number, N, M);
 				if (ok) {
 					previous = number;
 				} else {
 					break;
 				}
 			}
 			
 			System.out.println(""Case #"" + t + "": "" + (ok ? ""YES"" : ""NO""));
 		}
 		
 		s.close();
 	}
 	
 	private static void substitute(int[][] lawn, int N, int M, int previous,
 			int number) {
 		for (int i = 0; i<N; i++) {
 			for (int j = 0; j<M; j++) {
 				if (lawn[i][j] == previous) {
 					lawn[i][j] = number;
 				}
 			}
 		}
 	}
 
 	public static boolean check(int[][] lawn, int number, int N, int M) {
 		int[][] passed = new int[N][M];
 		
 		for (int i = 0; i<N; i++) {
 			if (lawn[i][0] == number) {
 				checkLine(lawn, number, M, i, passed);
 			}
 		}
 		
 		for (int j = 0; j<M; j++) {
 			if (lawn[0][j] == number) {
 				checkColumn(lawn, number, N, j, passed);
 			}
 		}
 
 		for (int i = 0; i<N; i++) {
 			for (int j = 0; j<M; j++) {
 				if (lawn[i][j] == number && passed[i][j] != 1) {
 					return false;
 				}
 			}
 		}
 		
 		return true;
 	}
 	
 	public static boolean checkColumn(int[][] lawn, int number, int length, int i, int[][] passed) {
 		boolean ok = true;
 		for (int k = 0; k < length; k++) {
 			ok &= lawn[k][i] == number;
 		}
 		
 		if (ok) {
 			for (int k = 0; k < length; k++) {
 				passed[k][i] = 1;
 			}
 		}
 		
 		return ok;
 	}
 	
 	public static boolean checkLine(int[][] lawn, int number, int length, int i, int[][] passed) {
 		boolean ok = true;
 		for (int k = 0; k < length; k++) {
 			ok &= lawn[i][k] == number;
 		}
 		
 		if (ok) {
 			for (int k = 0; k < length; k++) {
 				passed[i][k] = 1;
 			}
 		}
 		
 		return ok;
 	}
 }
","package codejam;
 
 import java.util.List;
 
 public abstract class Task {
 	public abstract List<String> split(String input);
 	
 	public String solve(String input) {
 		StringBuilder builder = new StringBuilder();
 		List<String> inputs = split(input);
 		for (int i = 0; i < inputs.size(); i++) {
 			String caseInput = inputs.get(i);
 			builder.append(""Case #"" + (i+1) + "": "" + solveCase(caseInput) + ""\n"");
 		}
 		return builder.toString();
 	}
 	
 	public abstract String solveCase(String input);
 }
",0
81,14947,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class Main {
 
 	public static void main(String[] args) {
 		try {
 			FileReader fr = new FileReader(""A-small-attempt0.in"");
 			FileWriter fw = new FileWriter(""A-small-attempt0.out"");
 			Scanner scanner = new Scanner(fr);
 			int T = scanner.nextInt();
 			
 			for (int i = 0; i < T; i++) {
 				int result = 0;
 				int N = scanner.nextInt();
 				int M = scanner.nextInt();
 
 				Set<String> definedDirectories = new HashSet<String>();
 				for (int j = 0; j < N; j++) {
 					String hierachy = scanner.next();
 					
 					while(!hierachy.equals("""")) {
 						definedDirectories.add(hierachy);
 						hierachy = hierachy.substring(0, hierachy.lastIndexOf(""/""));
 					}
 				}
 				
 				for(int k = 0; k < M; k++) {
 					String wantToCreateDirectory = scanner.next();
 					while(!wantToCreateDirectory.equals("""")) {
 						if(!definedDirectories.contains(wantToCreateDirectory)) {
 							definedDirectories.add(wantToCreateDirectory);
 							result++;
 						}
 						wantToCreateDirectory = wantToCreateDirectory.substring(0, wantToCreateDirectory.lastIndexOf(""/""));
 					}
 				}
 				
 				fw.write(""Case #"" + (i + 1) + "": "" + result + ""\n"");
 			}
 
 			fr.close();
 			fw.close();
 		} catch (IOException ioe) {
 			ioe.printStackTrace();
 		}
 	}
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class Main {
 
 	public static void main(String[] args) {
 		try {
 			FileReader fr = new FileReader(""A-large.in"");
 			FileWriter fw = new FileWriter(""A-large.out"");
 			Scanner scanner = new Scanner(fr);
 			int T = scanner.nextInt();
 			
 			for (int i = 0; i < T; i++) {
 				int result = 0;
 				int N = scanner.nextInt();
 				int M = scanner.nextInt();
 
 				Set<String> definedDirectories = new HashSet<String>();
 				for (int j = 0; j < N; j++) {
 					String hierachy = scanner.next();
 					
 					while(!hierachy.equals("""")) {
 						definedDirectories.add(hierachy);
 						hierachy = hierachy.substring(0, hierachy.lastIndexOf(""/""));
 					}
 				}
 				
 				for(int k = 0; k < M; k++) {
 					String wantToCreateDirectory = scanner.next();
 					while(!wantToCreateDirectory.equals("""")) {
 						if(!definedDirectories.contains(wantToCreateDirectory)) {
 							definedDirectories.add(wantToCreateDirectory);
 							result++;
 						}
 						wantToCreateDirectory = wantToCreateDirectory.substring(0, wantToCreateDirectory.lastIndexOf(""/""));
 					}
 				}
 				
 				fw.write(""Case #"" + (i + 1) + "": "" + result + ""\n"");
 			}
 
 			fr.close();
 			fw.close();
 		} catch (IOException ioe) {
 			ioe.printStackTrace();
 		}
 	}
 }
",1
82,14876,"package codejam;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class Candy {
 	
 	public static void main(String[] args) {
 		Scanner scan = null;
 		try {
 			scan = new Scanner(new File(""data.in""));
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 		String s = scan.nextLine();
 		int n = new Integer(s);
 		String ret = """";
 		for (int i=0; i<n; i++) {
 			scan.nextLine();
 			int[] candy = parse(scan.nextLine());
 			int temp = solve(candy);
 			ret += ""Case #""+(i+1)+"": ""+(temp==-1?""NO"":temp)+""\n"";
 		}
 		try {
 		    FileWriter fstream = new FileWriter(""data.out"");
 		    BufferedWriter out = new BufferedWriter(fstream);
 		    out.write(ret);
 		    out.close();
 	    } catch (Exception e) {
 	    	System.err.println(""Error: "" + e.getMessage());
 	    }
 	}
 	
 	public static int[] parse(String line) {
 		String[] nums = line.split("" "");
 		int[] ret = new int[nums.length];
 		for(int i=0; i<nums.length; i++) {
 			ret[i] = new Integer(nums[i]);
 		}
 		return ret;
 	}
 	
 	public static int solve(int[] candy) {
 		int ret = -1;
 		for(int num=1; num<candy.length; num++) {
 			int first = 0;
 			int second = 0;
 			int realFirst = 0;
 			int realSecond = 0;
 			if (num != 0) {
 				first = candy[0];
 				realFirst = candy[0];
 			}
 			if (num != candy.length) {
 				second = candy[num];
 				realSecond = candy[num];
 			}
 		//	System.out.println(first+"", ""+second+"", ""+realFirst+"", ""+realSecond);
 			for (int i=1; i<num; i++) {
 				first = first^candy[i];
 				realFirst += candy[i];
 			}
 			for (int i=num+1; i<candy.length; i++) {
 				second = second^candy[i];
 				realSecond += candy[i];
 			}
 		//	System.out.println(first+"", ""+second+"", ""+realFirst+"", ""+realSecond);
 			if (first != second) continue;
 			int max = Math.max(realFirst, realSecond);
 			if (max > ret) ret = max;
 		}
 	//	System.out.println();
 		return ret;
 	}
 
 }
","import java.io.*;
 
 public class LoadTesting {
 	
 	private static final String IN_FILE = ""B-small-attempt1.in"";
 	private static final String OUT_FILE = ""B-small-attempt1_output.txt"";
 
 	public static void main(String[] args) {
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(IN_FILE));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(OUT_FILE));
 			String line = br.readLine();
 			final int T_CASES = Integer.parseInt(line);
 			for (int t = 1; t <= T_CASES; t++) {
 				line = br.readLine();
 				String[] parts = line.split("" "");
 				int L = Integer.parseInt(parts[0]); // can support L people
 				int P = Integer.parseInt(parts[1]); // cannot support P people
 				int C = Integer.parseInt(parts[2]); // factor
 				
 				int a = L;
 				int iterations = 0;
 				System.out.println(""case: "" + t + ""; a = "" + a); //debug
 				
 				int cumulativeFactor = C;
 				if (a * C < P) {
 					while (a < P) {
 						cumulativeFactor = cumulativeFactor * cumulativeFactor;
 						a = L * cumulativeFactor;
 						iterations++;
 						System.out.println(""a = "" + a + ""; iterations = "" + iterations); //debug
 					}
 				}
 
 				//iterations = (iterations + iterations % 2) / 2 ;
 
 				bw.write(""Case #"" + t + "": "" + iterations);
 				bw.newLine();
 			}
 			
 			bw.close();
 			br.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 }
",0
83,6907,"package gcj;
 
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class GCJ2014R1BB {
 
 	String solve(int a, int b, int k) {
 		int ans = 0;
 		for (int i = 0; i < a; i++) {
 			for (int j = 0; j < b; j++) {
 				if ((i & j) < k) {
 					ans++;
 				}
 			}
 		}
 		return ans + """";
 	}
 
 	String solve(Scanner sc) {
 		StringBuilder sb = new StringBuilder();
 		int testCaseSize = sc.nextInt();
 		for (int tc = 1; tc <= testCaseSize; tc++) {
 			int a = sc.nextInt();
 			int b = sc.nextInt();
 			int k = sc.nextInt();
 			sb.append(""Case #"").append(tc).append("": "").append(solve(a, b, k))
 					.append('\n');
 		}
 		return sb.toString();
 	}
 
 	String solve(String inputFilePath) throws FileNotFoundException {
 		Scanner sc = new Scanner(new FileReader(inputFilePath));
 		String ans = solve(sc);
 		sc.close();
 		return ans;
 	}
 
 	final static String WORK_DIR = ""dat/gcj2014r1b/"";
 
 	public static void main(String[] args) throws IOException {
 //		String fileName = ""B-sample"";
 				String fileName = ""B-small-attempt0"";
 		//		String fileName = ""B-large"";
 		String inputFileName = fileName + "".in"";
 		String outputFileName = fileName + "".out"";
 		PrintWriter pw = new PrintWriter(new FileWriter(WORK_DIR
 				+ outputFileName));
 		pw.print(new GCJ2014R1BB().solve(WORK_DIR + inputFileName));
 		pw.flush();
 		pw.close();
 	}
 
 }
","package gcj;
 
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class GCJ2014QD {
 
 	String solve(int n, double[] a, double[] b) {
 		Arrays.sort(a);
 		Arrays.sort(b);
 		int win = 0, dWin = 0;
 		for (int i = 0, j = 0;;) {
 			if (a[i] < b[j]) {
 				i++;
 			}
 			j++;
 			if (i >= n || j >= n) {
 				win = n - i;
 				break;
 			}
 		}
 
 		for (int i = 0, j = 0;;) {
 			if (b[i] < a[j]) {
 				i++;
 			}
 			j++;
 			if (i >= n || j >= n) {
 				dWin = i;
 				break;
 			}
 		}
 
 		return dWin + "" "" + win;
 	}
 
 	String solve(Scanner sc) {
 		StringBuilder sb = new StringBuilder();
 		int testCaseSize = sc.nextInt();
 		for (int tc = 1; tc <= testCaseSize; tc++) {
 			int n = sc.nextInt();
 			double[] blocksA = new double[n];
 			double[] blocksB = new double[n];
 			for (int i = 0; i < n; i++) {
 				blocksA[i] = sc.nextDouble();
 			}
 			for (int i = 0; i < n; i++) {
 				blocksB[i] = sc.nextDouble();
 			}
 			sb.append(""Case #"").append(tc).append("": "")
 					.append(solve(n, blocksA, blocksB)).append('\n');
 		}
 		return sb.toString();
 	}
 
 	String solve(String inputFilePath) throws FileNotFoundException {
 		Scanner sc = new Scanner(new FileReader(inputFilePath));
 		String ans = solve(sc);
 		sc.close();
 		return ans;
 	}
 
 	public static void main(String[] args) throws IOException {
 		String workDir = ""dat/gcj2014q/"";
 		String inputFileName = ""D-large.in"";
 		String outputFileName = ""D-large.out"";
 		PrintWriter pw = new PrintWriter(new FileWriter(workDir
 				+ outputFileName));
 		pw.print(new GCJ2014QD().solve(workDir + inputFileName));
 		pw.flush();
 		pw.close();
 	}
 
 }
",1
84,16378,"package cj_13_q;
 
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.util.Scanner;
 
 /**
  *
  * @author amahdy
  */
 public class CJ_13_QC {
 
     private boolean isP(long x) {
         String X = x+"""";
         int l = X.length();
         int l2 = l/2;
         for(int i=0; i<l2; i++) {
             if(X.charAt(i)!=X.charAt(l-i-1)) {
                 return false;
             }
         }
         return true;
     }
 
     public void start() throws FileNotFoundException  {
         Scanner in = new Scanner(
                 new FileReader(""/home/amahdy/C.in""));
         int T = in.nextInt();
         
         for(int t=0; t<T; ) {
             System.out.print(""Case #"" + ++t + "": "");
             
             long A = in.nextLong();
             long B = in.nextLong();
             long count=0;
             
             long base = (long) Math.sqrt(A);
             if(A > (base*base)) {
                 base++;
                 A = base*base;
             }
             while (A<=B) {
                 if(isP(base) && isP(A)) {
                     count++;
                 }
                 base++;
                 A = base*base;
             }
             System.out.println(count);
         }
     }
 
     public static void main(String[] args) throws FileNotFoundException {
         new CJ_13_QC().start();
     }
 }
","package test.googlejam.year2012.jam;
 
 import java.io.IOException;
 
 import test.googlejam.base.ProblemProcessor;
 
 public class KingdomRush extends ProblemProcessor
 {
 
 	static java.util.Map<Integer, Integer> mapping = new java.util.TreeMap<Integer, Integer>();
 	public static void main(String[] args) throws java.io.IOException
 	{
 		KingdomRush processor;
 
 		final String FILE_BASE = ""C:/Users/cjbolanos/workspace/Google Code Jam/src/""
 				+ KingdomRush.class.getName().substring(0, 
 						KingdomRush.class.getName().lastIndexOf('.')).replace('.', '/'); 
 		final String FILE_NAME = KingdomRush.class.getName().substring(
 				KingdomRush.class.getName().lastIndexOf('.') + 1); 
 		final String CASE_NAME = ""small""; 
 		processor = new KingdomRush();
 		processor.setInputFileName(FILE_BASE + ""/"" + FILE_NAME + ""-"" + CASE_NAME + "".in"");
 		processor.setOutputFileName(FILE_BASE + ""/"" + FILE_NAME + ""-"" + CASE_NAME + "".out"");
 		processor.start();
 	}
 
 	@Override
 	public String processCase(int caseNumber) throws IOException
 	{
 		int levels = this.readInteger();
 		int[][] reqLevelStars = new int[levels][];
 		
 		for ( int i = 0; i < levels; i++ )
 			reqLevelStars[i] = this.readIntegerArray("" "");
 		
 		int[] levelStars = new int[levels];
 		int totalStars = 0;
 
 		int totalPlays = 0;
 		start: while ( true )
 		{
 			// which levels with two stars can I play?
 			for ( int i = 0; i < levels; i++ )
 			{
 				if ( reqLevelStars[i][1] <= totalStars )
 				{
 					if ( levelStars[i] == 2 ) continue;
 
 					totalStars += 2 - levelStars[i];
 					levelStars[i] = 2;
 					totalPlays++;
 					continue start;
 				}
 			}
 
 			// Determine which first level to try
 			int bestLevel = -1;
 			int bestLevelReqStars = -1;
 			for ( int i = 0; i < levels; i++ )
 			{
 				if ( levelStars[i] > 0 ) continue;
 				if ( reqLevelStars[i][0] <= totalStars )
 				{
 					if ( reqLevelStars[i][1] > bestLevelReqStars )
 					{
 						bestLevel = i;
 						bestLevelReqStars = reqLevelStars[i][1];
 					}
 				}
 			}
 			
 			if ( -1 != bestLevel )
 			{
 				totalStars++;
 				levelStars[bestLevel] = 1;
 				totalPlays++;
 				continue;
 			}
 
 			// Nothing to play. Are we done?
 			for ( int i = 0; i < levels; i++ )
 			{
 				if ( levelStars[i] < 2 )
 					return ""Too Bad"";
 			}
 			
 			break;
 		}
 
 		return Integer.toString(totalPlays);
 	}
 }
",0
85,6243,"import java.io.*;
 import java.util.StringTokenizer;
 
 public class clicker{
 	public static void main(String args[]) throws Exception{
 		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
 		int T;
 		double c,x,f,time,ctime,start_time,slope;
 		String s;
 		StringTokenizer st;
 		
 		s=br.readLine();
 		T=Integer.parseInt(s);
 		for(int I=1;I<=T;I++){
 			start_time=0;
 			slope=2;
 		
 			s=br.readLine();
 			st=new StringTokenizer(s,"" "");
 			c=Double.parseDouble(st.nextToken());
 			f=Double.parseDouble(st.nextToken());
 			x=Double.parseDouble(st.nextToken());
 			while(true){
 				time=start_time+x/slope;
 				ctime=start_time+(c/slope)+(x/(slope+f));
 				if(ctime>=time){
 					break;
 				}else{
 					start_time+=(c/slope);
 					slope+=f;
 				}
 			}
 			System.out.println(""Case #""+I+"": ""+time);
 		}
 	}
 }","
 package codejam;
 
 import java.io.*;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 public class C {
     static String str = ""C:\\carl\\cl.txt"";
     static String text = """";
 
     static int A, B, T, cnt;
     static HashMap hm;
 
 
     public static void main(String[] args) {
 
         try {
             int count = 0;
 
             hm = new HashMap();
 
             File file = new File(str);
             BufferedReader br = new BufferedReader(new FileReader(file));
             PrintWriter outer = new PrintWriter(new FileWriter(""C:\\carl\\clo.txt""));
 
 
             while((text = br.readLine()) != null) {
                 StringTokenizer st = new StringTokenizer(text);
 
                 if(count == 0) {
                     T = Integer.parseInt(st.nextToken());
                     count++;
                 } else  {
 
                     A = Integer.parseInt(st.nextToken());
                     int n = A;
                     B = Integer.parseInt(st.nextToken());
 
                     while (n != B) {
                         char[] temp = Integer.toString(n).toCharArray();
                         scramble(temp, n);
                         n++;
                     }
                     outer.println(""Case #"" + count + "": "" + hm.entrySet().size());
                 //System.out.println(hm.entrySet().size());
                 hm.clear();
                 count++;
                     
                 }
                 
             }
 
             
             outer.close();
 
         } catch(IOException ex) {
             System.out.println(""Error with IO you foooool"");
         } catch(Exception ex) {
             System.out.println(""Generic Error. Noob."");
             ex.printStackTrace();
         }
     }
 
     public static void scramble(char[] temp, int n) {
         Integer[] no = new Integer[temp.length];
         for(int i=0; i<temp.length;i++) { no[i] = Integer.parseInt( Character.toString(temp[i]) ); }
         //Integer[] test = {1, 2, 3, 4, 5};
         for (int i = 0; i < temp.length - 1; i++) {
             Collections.rotate(Arrays.asList(no), -1);
 
             int m = trans(no);
             //System.out.println(n + "" "" + m);
             if( n < m && m <= B && no[0] != 0 ) {
 
                 if( !hm.containsKey(n + "" "" + m)) {
                     hm.put(n + "" "" + m, n + "" "" + m);
                     //System.out.println(n + "", "" + m);
                 }
 
                 //System.out.println(b);
             }
         }
 
 
     }
 
     public static int trans(Integer[] a) {
         String s = """";
         for(int i : a) {
             s = s + i;
         }
         //System.out.println("" @@ "" + s);
         return Integer.parseInt(s);
     }
 
 }
",0
86,3794,"// BEGIN CUT HERE
 
 // END CUT HERE
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.*;
 
 
 public class Main {
 
     static public void main(String args[]) throws FileNotFoundException {
 	//Scanner sc = new Scanner(new FileInputStream(""B-small-attempt0.in""));
 	Scanner sc = new Scanner(new FileInputStream(""B-large.in""));
 	//Scanner sc = new Scanner(new FileInputStream(""in.txt""));
 	PrintWriter pw = new PrintWriter(""ans.txt"");
 	int T = sc.nextInt();
 
 	for (int cas = 1; cas <= T; cas++) {
 
 	    int C = sc.nextInt();
 	    int [][]cb = new int[300][300];
 	    int [][]ob = new int[300][300];
 
 	    for(int i = 0; i < C; i++){
 		String comb = sc.next();
 		char a = comb.charAt(0);
 		char b = comb.charAt(1);
 		char c = comb.charAt(2);
 		cb[a][b] = cb[b][a] = c;
 	    }
 
 	   int D = sc.nextInt();
 	   for(int i = 0; i < D; i++){
 		String oppo = sc.next();
 		char a = oppo.charAt(0);
 		char b = oppo.charAt(1);
 		ob[a][b] = ob[b][a] = 1;
 	   }
 	   
 	   int sz = sc.nextInt();
 	   String invoke = sc.next();
 	   Stack<Character> sk = new Stack<Character>();
 
 	   for(int i = 0; i < invoke.length(); i++){
 		char next = invoke.charAt(i);
 		if( !sk.empty() && cb[sk.peek()][next] != 0){
 		    next = (char)cb[sk.peek()][next];
 		    sk.pop();
 		    sk.push(next);
 		}else{
 		    Stack<Character> copy = new Stack<Character>();
 		    boolean bingo = false;
 		    while(!sk.empty()){
 			if( ob[ sk.peek() ][next] != 0)bingo = true;
 			copy.push( sk.pop() );
 		    }
 		    if(!bingo){
 			while(!copy.empty()){
 			    sk.push( copy.pop() );
 			}
 			sk.push(next);
 		    }
 	       }
 	   }
 	   ArrayList<Character> res = new ArrayList<Character>();
 	   while(!sk.empty()){
 		res.add( sk.pop() );
 	   }
 	   StringBuilder sb = new StringBuilder();
 	   sb.append('[');
 	   for(int i = ( (int)res.size() ) - 1; i >= 0; i--){
 		sb.append(res.get(i));
 	       if(i != 0)
 		    sb.append(',').append(' ');
 	   }
 	   sb.append(']');
 	   pw.println(""Case #""+cas+"": ""+sb.toString());
 	}
 	pw.flush();
     }
 
     static void P(Object o) {
 	System.out.print(o);
     }
 
     static void Pln(Object o) {
 	System.out.println(o);
     }
 }
","import java.io.*;
 import java.util.*;
 
 public class Minesweeper{
 	private static final char emptyChar = '.';
 	private static final char mineChar = '*';
 			
 	public static void main(String[] args) throws Exception {
 		PrintWriter pw = new PrintWriter (new File(""./output.txt""));
 
 		//Scanner sc = new Scanner(System.in);
 		//Scanner sc = new Scanner(new File(""./sample.txt""));
 		//Scanner sc = new Scanner(new File(""./small.txt""));
 		Scanner sc = new Scanner(new File(""./large.txt""));
 		int T = sc.nextInt();
 		for (int cas = 1; cas <= T; cas++ ){
 			pw.println(""Case #""+ cas + "": "");
 			int R = sc.nextInt();
 			int C = sc.nextInt();
 			int M = sc.nextInt();
 
 			int empty = R*C - M;
 
 			char [][] board = new char[R][C];
 
 			if(R == 1 || C == 1 || empty ==1){
 				int count = empty;
 				for(int i = 0; i < R; i++){
 					for(int j = 0; j < C; j++){
 						if(count > 0){
 							board[i][j] = emptyChar;
 							count--;
 						}else{
 							board[i][j] = mineChar;
 						}
 					}
 				}
 			}else if(R==2 || C==2){
 				if(empty %2 != 0 || empty == 2){
 					pw.println(""Impossible"");
 					continue;
 				}else{
 					fillEven(board, R, C, empty);
 				}
 			} else{
 				if(empty % 2 != 0){
 					if(empty < 9){
 						pw.println(""Impossible"");
 						continue;
 					}else{
 						fillOdd(board, R, C, empty);
 					}
 				}else{
 					if(empty < 4){
 						pw.println(""Impossible"");
 						continue;
 					}else{
 						fillEven(board, R, C, empty);
 					}
 				}
 			}
 
 			board[0][0] = 'c';
 			for(int j = 0; j < R; j++){
 				for(int k = 0; k < C; k++){
 					pw.print(board[j][k]);
 				}
 				pw.println();
 			}
 
 		}
 		pw.flush();
 		pw.close();	
 	}
 
 	private static void fillEven(char[][] board, int R, int C, int emptyCells){
 		int count = emptyCells;
 		for(int i = 0; i < R; i++){
 			if(count > 0){
 				board[i][0] = emptyChar;
 				board[i][1] = emptyChar;
 				count-=2;
 			}else{
 				board[i][0] = mineChar;
 				board[i][1] = mineChar;
 			}
 
 		}
 		for(int i = 2; i < C; i++){
 			if(count > 0){
 				board[0][i] = emptyChar;
 				board[1][i] = emptyChar;
 				count-=2;
 			}else{
 				board[0][i] = mineChar;
 				board[1][i] = mineChar;
 			}
 
 		}
 		for(int i = 2; i < R; i++){
 			for(int j = 2; j < C; j++){
 				if(count > 0){
 					board[i][j] = emptyChar;
 					count--;
 				}else{
 					board[i][j] = mineChar;
 				}
 			}
 		}
 	}
 
 
 	private static void fillOdd(char[][] board, int R, int C, int emptyCells){
 		int count = emptyCells;
 
 		for(int i = 0; i < 3; i++){
 			for(int j = 0; j < 3; j++){
 				board[i][j] = emptyChar;
 				count--;
 			}
 		}
 		
 		for(int i = 3; i < R; i++){
 			if(count > 0){
 				board[i][0] = emptyChar;
 				board[i][1] = emptyChar;
 				count-=2;
 			}else{
 				board[i][0] = mineChar;
 				board[i][1] = mineChar;
 			}
 
 		}
 		for(int i = 3; i < C; i++){
 			if(count > 0){
 				board[0][i] = emptyChar;
 				board[1][i] = emptyChar;
 				count-=2;
 			}else{
 				board[0][i] = mineChar;
 				board[1][i] = mineChar;
 			}
 
 		}
 		for(int i = 2; i < R; i++){
 			for(int j = 2; j < C; j++){
 				if(i==2 && j==2)continue;
 				if(count > 0){
 					board[i][j] = emptyChar;
 					count--;
 				}else{
 					board[i][j] = mineChar;
 				}
 			}
 		}
 	}
 	
 	private static String construct(int length, char content){
 		char[] bytes = new char[length];
 		Arrays.fill(bytes, content);
 		return new String(bytes);
 	}
 }",1
87,9427,"import java.io.*;
 import java.util.*; 
 class MagicTrick
 {
 	public static void main(String[] args) 
 	{
 		try {  
 			Scanner in = new Scanner(new File(""A-small-attempt0.in""));
 			FileWriter fstream = new FileWriter(""output.txt"");
 			BufferedWriter out = new BufferedWriter(fstream);
 			int casenum = in.nextInt(); 
 			for(int i = 0; i < casenum;i++){ 
 				int num1 = in.nextInt(); 
 				int[][] board1 = new int[4][4]; 
 				for(int j =0; j < 4;j++){
 					for(int k =0; k < 4;k++){
 						board1[j][k] = in.nextInt();  
 					}  
 				}  
 				int num2 = in.nextInt(); 
 				int[][] board2 = new int[4][4]; 
 				for(int j =0; j < 4;j++){
 					for(int k =0; k < 4;k++){
 						board2[j][k] = in.nextInt();  
 					} 
 				}  
 				String result = gameresult(num1,num2,board1,board2);
 				out.write(""Case #"" + (i+1) +"": ""+result);    
 				out.newLine();
 			} 
 			out.close();
 		} catch (Exception e){//Catch exception if any
 				System.err.println(""Error: "" + e.getMessage());
 		}
 	} 
 	public static String gameresult(int num1,int num2,int[][] board1,int[][] board2){
 		String output = """";
 		int count = 0;
 		for(int i = 0; i < 4; i++){
 			for(int j =0; j < 4;j++){
 				if(board1[num1-1][i] == board2[num2-1][j]){
 					count++;
 					if(count == 1)
 						output += board1[num1-1][i];
 				}
 			}
 		}
 		if(count > 1)
 			output = ""Bad magician!"";
 		else if(count == 0)
 			output = ""Volunteer cheated!""; 
  		return output;
 	}
 }
","import java.io.*;
 import java.util.*; 
 class MagicTrick
 {
 	public static void main(String[] args) 
 	{
 		try {  
 			Scanner in = new Scanner(new File(""A-small-attempt0.in""));
 			FileWriter fstream = new FileWriter(""output.txt"");
 			BufferedWriter out = new BufferedWriter(fstream);
 			int casenum = in.nextInt(); 
 			for(int i = 0; i < casenum;i++){ 
 				int num1 = in.nextInt(); 
 				int[][] board1 = new int[4][4]; 
 				for(int j =0; j < 4;j++){
 					for(int k =0; k < 4;k++){
 						board1[j][k] = in.nextInt();  
 					}  
 				}  
 				int num2 = in.nextInt(); 
 				int[][] board2 = new int[4][4]; 
 				for(int j =0; j < 4;j++){
 					for(int k =0; k < 4;k++){
 						board2[j][k] = in.nextInt();  
 					} 
 				}  
 				String result = gameresult(num1,num2,board1,board2);
 				out.write(""Case #"" + (i+1) +"": ""+result);    
 				out.newLine();
 			} 
 			out.close();
 		} catch (Exception e){//Catch exception if any
 				System.err.println(""Error: "" + e.getMessage());
 		}
 	} 
 	public static String gameresult(int num1,int num2,int[][] board1,int[][] board2){
 		String output = """";
 		int count = 0;
 		for(int i = 0; i < 4; i++){
 			for(int j =0; j < 4;j++){
 				if(board1[num1-1][i] == board2[num2-1][j]){
 					count++;
 					if(count == 1)
 						output += board1[num1-1][i];
 				}
 			}
 		}
 		if(count > 1)
 			output = ""Bad magician!"";
 		else if(count == 0)
 			output = ""Volunteer cheated!""; 
  		return output;
 	}
 }
",1
88,8701,"/**
  * 
  */
 package com.laperradaonline.codejam.manageenergy;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 /**
  * @author Carlos Alberto
  *
  */
 public class Main {
 
 	private File inputFile;
 	private File outputFile;
 	public Main(String filename) {
 		this.inputFile = new File(filename);
 		
 		int lastIndex = filename.lastIndexOf('.');        
         
         this.outputFile = new File (filename.substring(0, lastIndex)+"".out"");
 	}
 	
 	private void run() {
 		FileReader reader = null;
 		BufferedReader bReader = null;
 		FileWriter writer = null;
 		try
 		{
 			writer = new FileWriter(outputFile);
 			reader = new FileReader(inputFile);
 			bReader = new BufferedReader(reader);
 			String line;
 			if (( line = bReader.readLine())!=null) {
 				
 				
 				int resting = Integer.parseInt(line);
 				
 				for (int index = 1;  index <= resting; index++ ) {
 					String tok[] = bReader.readLine().split(""\\s+"");
 					Solver solve = new Solver(Long.parseLong(tok[0]),Long.parseLong(tok[1]));	
 						
 					
 					solve.addActivity(bReader.readLine().split(""\\s+""));
 					
 					
 					String outStr = String.format(""Case #%d: %s\r\n"", index,solve.calculate());
 					writer.write(outStr);
 					System.out.print(outStr);
 				}
 				
 				
 			}
 			
 		} catch (Exception ex){
 			ex.printStackTrace();
 		} finally {
 			
 			if (writer != null){
 				try {
 					writer.close();
 				} catch (IOException e) {				
 					e.printStackTrace();
 				}
 			}
 			
 			safeCloseReader(bReader);
 			safeCloseReader(reader);
 		}
 		
 	}
 
 
 		private void safeCloseReader( java.io.Reader reader) {
 			if (reader != null){
 				try {
 					reader.close();
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 			}
 			
 		}
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		Main main = new Main(args[0]);
 		main.run();
 	}
 }
","package com.laperradaonline.codejam.fairandsquares;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigDecimal;
 
 public class Main {
 
 	private File inputFile;
 	private File outputFile;
 	
 	public Main(String filename) {
 		this.inputFile = new File(filename);
 		
 		int lastIndex = filename.lastIndexOf('.');        
         
         this.outputFile = new File (filename.substring(0, lastIndex)+"".out"");
 	}
 	
 	public Main() {
 
 	}
 
 	private void generatePalindromeFile(){
 		File palindromesFile = new File (""palindromes.db"");
 		FileWriter writer = null;
 		
 		PalindromeLord lord = new PalindromeLord();
 		try
 		{
 			writer = new FileWriter(palindromesFile);
 			
 			BigDecimal iter = BigDecimal.ZERO;
 			BigDecimal max = new BigDecimal(""1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"");
 			
 			while (iter.compareTo(max) <= 0) {
 				iter = lord.buildNextFairyPalindrome2(iter);
 				writer.write(iter.toString());
 				writer.write(""\10"");
 				System.out.println(iter.toString());
 				iter = iter.add(BigDecimal.ONE);
 			}
 			
 		} catch (Exception ex){
 			ex.printStackTrace();
 		} finally {
 			
 			if (writer != null){
 				try {
 					writer.close();
 				} catch (IOException e) {				
 					e.printStackTrace();
 				}
 			}
 			}
 	}
 	
 	private void run() {
 		FileReader reader = null;
 		BufferedReader bReader = null;
 		FileWriter writer = null;
 		try
 		{
 			writer = new FileWriter(outputFile);
 			reader = new FileReader(inputFile);
 			bReader = new BufferedReader(reader);
 			String line;
 			if (( line = bReader.readLine())!=null) {
 				
 				
 				int resting = Integer.parseInt(line);
 				
 				for (int index = 1;  index <= resting; index++ ) {
 					line = bReader.readLine();
 					String[] interval = line.split(""\\s"");
 					
 					FairAndSquareCounter counter = new FairAndSquareCounter(new BigDecimal(interval[0]), new BigDecimal(interval[1]));	
 					
 					String outStr = String.format(""Case #%d: %s\r\n"", index,counter.count());
 					writer.write(outStr);
 					System.out.print(outStr);
 				}
 				
 				
 			}
 			
 		} catch (Exception ex){
 			ex.printStackTrace();
 		} finally {
 			
 			if (writer != null){
 				try {
 					writer.close();
 				} catch (IOException e) {				
 					e.printStackTrace();
 				}
 			}
 			
 			safeCloseReader(bReader);
 			safeCloseReader(reader);
 		}
 		
 	}
 
 
 		private void safeCloseReader( java.io.Reader reader) {
 			if (reader != null){
 				try {
 					reader.close();
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 			}
 			
 		}
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		
 		if (args.length >= 1){
 			Main main = new Main(args[0]);
 			main.run();
 		} else {
 			Main main = new Main();
 			main.generatePalindromeFile();
 		}
 	}
 	
 }
 
",1
89,4704,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Iterator;
 import java.util.Scanner;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 public class C1 implements OneCaseSolver {
 
 	static DynamicArray<Long> v = DynamicArray.create();
 
 	static {
 		for(long i=1;i*i<=1000000000000000L;i++) {
 			long cand = i*i;
 			if(ispal(i) && ispal(cand)) {
 				v.addToLast(cand);
 			}
 		}
 	}
 
 	private static boolean ispal(long cand) {
 		String s = Long.toString(cand);
 		boolean ok = true;
 		for(int j : Indices.create(s.length()/2)) 
 			if(s.charAt(j) != s.charAt(s.length()-1-j))
 				ok = false;
 		return ok;
 	}
 
 	long a, b;
 	
 	@Override
 	public void input(Scanner in) {
 		a = in.nextLong();
 		b = in.nextLong();
 	}
 	
 	@Override
 	public String solve() {
 		IndexBinarySearcherResult<Int32> r1 = IndexBinarySearcher.searchFirstTrue(new IndexBinarySearcherData<Int32>() {
 			@Override
 			public boolean get(Int32 index) {
 				return a <= v.get(index.toPrimitive());
 			}
 		}, new Int32(0), new Int32(v.size()-1));
 		
 		IndexBinarySearcherResult<Int32> r2 = IndexBinarySearcher.searchFirstTrue(new IndexBinarySearcherData<Int32>() {
 			@Override
 			public boolean get(Int32 index) {
 				return b < v.get(index.toPrimitive());
 			}
 		}, new Int32(0), new Int32(v.size()-1));
 		return (r2.getIndex().toPrimitive() - r1.getIndex().toPrimitive()) + """";
 	}
 
 	public static void main(String[] args) throws Exception {
 		CodeJamProblemSolver.launch(1, ""C-large-1.in"", new OneCaseSolverFactory() {
 			@Override
 			public OneCaseSolver createSolver() {
 				return new C1();
 			}
 		});
 	}
 }
 class IndexBinarySearcher {
 
 	public static class FoundResult<T> implements IndexBinarySearcherResult<T> {
 		public T index;
 		public FoundResult(T index) {
 			this.index = index;
 		}
 		public T getIndex() {
 			return index;
 		}
 		public boolean isExist() {
 			return true;
 		}
 	}
 
 	public static class NotFoundResult<T> implements IndexBinarySearcherResult<T> {
 		public T getIndex() {
 			throw new CannotFindProperIndexException();
 		}
 		public boolean isExist() {
 			return false;
 		}
 	}
 
 	public static <T extends Int<T>> IndexBinarySearcherResult<T> searchFirstTrue(IndexBinarySearcherData<T> data, T left, T right) {
 		boolean found = false;
 		T index = left;
 		T one = left.getOne();
 		T two = left.get(2);		
 		while(left.compareTo(right) <= 0) {
 			T mid = left.plus(right).floorDivide(two);
 			if(data.get(mid)) {
 				found = true;
 				index = mid;
 				right = mid.minus(one);
 			} else 
 				left = mid.plus(one);
 		}
 		if(found)
 			return new IndexBinarySearcher.FoundResult<T>(index);
 		else
 			return new IndexBinarySearcher.NotFoundResult<T>();
 	}
 
 }
 interface Int<T extends Int<T>> extends Multiplicative<T> {
 	T mod(T v);
 	T floorDivide(T v);
 	double toDouble();
 }
 interface Multiplicative<T extends Multiplicative<T>> extends Additive<T> {
 	T times(T a);
 	T getOne();
 	T get(int v);
 	boolean isOne();
 }
 interface Additive<T extends Additive<T>> extends Number<T> {
 	T plus(T v);
 	T minus(T v);
 	T getAddInvert();
 	T getZero();
 	boolean isPositive();
 	boolean isZero();
 	boolean isNegative();
 	int getSign();
 }
 interface Number<T> extends Comparable<T> {
 }
 class CannotFindProperIndexException extends RuntimeException {
 	private static final long serialVersionUID = 1L;
 }
 interface IndexBinarySearcherData<T> {
 	boolean get(T index);
 }
 interface IndexBinarySearcherResult<T> {
 	
 	boolean isExist();
 	T getIndex();
 	
 }
 class CodeJamProblemSolver {
 
 	public static void launch(int threadNumber, String inputFileNameOnDesktop, OneCaseSolverFactory factory, Integer... caseNumbers) throws Exception {
 		String outputFileNameOnDesktop = inputFileNameOnDesktop.substring(0, inputFileNameOnDesktop.length()-3) + "".out"";
 		String desktopDir = System.getProperty(""user.home"") + ""/Desktop"";
 		String inputFile = desktopDir + ""/"" + inputFileNameOnDesktop;
 		String outputFile = desktopDir + ""/"" + outputFileNameOnDesktop;
 		CodeJamStyleProblemSolver.launch(threadNumber, inputFile, outputFile, factory, caseNumbers);
 	}
 
 }
 class CodeJamStyleProblemSolver {
 	
 	public static void launch(final int threadNumber, String inputFilePath, String outputFilePath, final OneCaseSolverFactory factory, Integer... caseIndices) throws Exception {
 		final Object lock = new Object();
 		final long startTime = System.currentTimeMillis();
 		final Scanner in = new Scanner(new File(inputFilePath));
 		final int casen = in.nextInt();
 		final int[] nextIndex = {0}; 
 		final String[] results = new String[casen];
 		final java.util.Set<Integer> caseIndexToSolve = createCaseIndicesToSolve(casen, caseIndices);
 		ExecutorService executor = Executors.newFixedThreadPool(threadNumber);
 		for(int i=0;i<casen;i++) {
 			executor.execute(new Runnable() {
 				@Override
 				public void run() {
 					int casei;
 					String result = null;
 					{
 						OneCaseSolver caseSolver = factory.createSolver();
 						synchronized(lock) {
 							caseSolver.input(in);
 							casei = nextIndex[0]++;
 						}
 						if(caseIndexToSolve.contains(casei+1))
 							result = caseSolver.solve();
 					}
 					if(result != null) {
 						synchronized(lock) {
 							results[casei] = result;
 							int solved = countNotNull(results);
 							outputProgess(startTime, solved, caseIndexToSolve.size());
 						}
 					}
 				}
 			});
 		}
 		executor.shutdown();
 		executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
 		printLine();
 		outputResult(results, outputFilePath);
 		printLine();
 		System.out.println(""Output is written to "" + outputFilePath);
 	}
 
 	private static java.util.Set<Integer> createCaseIndicesToSolve(int casen, Integer... caseIndices) {
 		final java.util.Set<Integer> set = new java.util.TreeSet<Integer>();
 		if(caseIndices.length == 0) {
 			for(int i=1;i<=casen;i++)
 				set.add(i);
 		} else {
 			for(int v : caseIndices) {
 				if(v < 1 || v > casen)
 					throw new RuntimeException(""invalid case index : "" + v);
 				set.add(v);
 			}
 		}
 		return set;
 	}
 
 	private static void printLine() {
 		for(int i=0;i<100;i++)
 			System.out.print(""-"");
 		System.out.println();
 	}
 
 	private static int countNotNull(final String[] results) {
 		int solved = 0;
 		for(String s : results)
 			if(s != null)
 				solved++;
 		return solved;
 	}
 
 	private static void outputProgess(long startTime, int solved, int caseNumberToSolve) {
 		long duration = System.currentTimeMillis() - startTime;
 		long estimation = (long)Math.round((double)duration * caseNumberToSolve / solved / 1000);
 		System.out.printf(""%.03fs : %d/%d solved (estimated : %dm %ds)\n"", (double)duration / 1000, solved,  caseNumberToSolve, estimation / 60, estimation % 60);
 	}
 
 	private static void outputResult(final String[] results, String outputFilePath) throws FileNotFoundException {
 		PrintStream ps = new PrintStream(outputFilePath);
 		for(int i=0;i<results.length;i++) {
 			if(results[i] != null) {
 				String line = String.format(""Case #%d: %s"", i+1, results[i]);
 				System.out.println(line);
 				ps.println(line);
 			}
 		}
 		ps.close();
 	}
 
 }
 interface OneCaseSolver {
 	void input(Scanner in);
 	String solve();
 }
 interface OneCaseSolverFactory {
 	OneCaseSolver createSolver();
 }
 class Indices {
 
 	public static IntSequenceIterable create(int len) {
 		return new IntSequenceIterable(0, len);
 	}
 
 }
 class IntSequenceIterable implements Iterable<Integer> {
 	
 	private final int from;
 	private final int size;
 
 	public IntSequenceIterable(int from, int size) {
 		this.from = from;
 		this.size = size;
 	}
 
 	@Override
 	public Iterator<Integer> iterator() {
 		return new AbstractIterator<Integer>() {
 			int next = from;
 			@Override
 			public boolean hasNext() {
 				return next < from + size;
 			}
 			@Override
 			public Integer next() {
 				return next++;
 			}
 		};
 	}
 }
 abstract class AbstractIterator<T> implements Iterator<T> {
 
 	@Override
 	public final void remove() {
 		throw new UnsupportedOperationException();
 	}
 
 }
 class DynamicArray<T> extends AbstractReadableArray<T>  implements StaticArray<T> {
 	
 	public static <T> DynamicArray<T> create() {
 		return new DynamicArray<T>();
 	}
 	
 	private T[] a;
 	private int asize;
 	
 	
 	@SuppressWarnings(""unchecked"")
 	private void init(int cap) {
 		asize = 0;
 		a = (T[])new Object[Math.max(1, cap)];		
 	}
 	
 	public DynamicArray() {
 		init(1);
 	}
 	
 	public DynamicArray(int initialCapacity) {
 		init(initialCapacity);
 	}
 	
 	public T get(int index) {
 		return a[index];
 	}	
 	
 	public void set(int index, T value) {
 		a[index] = value;		
 	}
 	
 	public int size() {
 		return asize;
 	}
 	
 	public void clear() {
 		asize = 0;
 	}
 	
 	@SuppressWarnings(""unchecked"")
 	public void reserve(int size) {
 		if(a.length < size) {
 			T[] ta = (T[])new Object[size];
 			for(int i=0;i<a.length;i++)
 				ta[i] = a[i];
 			a = ta;
 		}
 	}
 	
 	@SuppressWarnings(""unchecked"")
 	public void addToLast(T value) {
 		if(a.length == asize) {
 			T[] ta = (T[])new Object[asize*2];
 			for(int i=0;i<asize;i++)
 				ta[i] = a[i];
 			a =ta;
 		}
 		a[asize++] = value;						
 	}
 	
 	public void addToLastAll(Iterable<? extends T> values) {
 		for(T v : values)
 			addToLast(v);
 	}
 	
 	public T removeLast() {
 		T r = last();
 		a[--asize] = null;
 		return r;
 	}
 	
 	@Override
 	public boolean equals(Object obj) {
 		return StrictEqualityChecker.isEquals(this, obj, new EqualityChecker<DynamicArray<T>>() {
 			@Override
 			public boolean isEquals(DynamicArray<T> o1, DynamicArray<T> o2) {
 				if(o1.size() != o2.size())
 					return false;
 				for(int i=0;i<o1.size();i++)
 					if(!o1.get(i).equals(o2.get(i)))
 						return false;		
 				return true;
 			}
 		});
 	}
 
 	@Override
 	public int hashCode() {
 		int r = 0;
 		for(int i=0;i<size();i++)
 			r ^= Int32Hash.hash(get(i).hashCode());
 		return r;
 	}
 	
 }
 interface EqualityChecker<T> {
 	boolean isEquals(T o1, T o2);
 }
 class Int32Hash {
 
 	public static int hash(int key) {
 	  key = ~key + (key << 15); // key = (key << 15) - key - 1;
 	  key = key ^ (key >>> 12);
 	  key = key + (key << 2);
 	  key = key ^ (key >>> 4);
 	  key = key * 2057; // key = (key + (key << 3)) + (key << 11);
 	  key = key ^ (key >>> 16);
 	  return key;
 	}
 }
 class StrictEqualityChecker {
 	@SuppressWarnings(""unchecked"")
 	public static <T> boolean isEquals(T me, Object you, EqualityChecker<T> ec) {
 		if(me == you)
 			return true;
 		if(you == null)
 			return false;
 		if(you.getClass() != me.getClass())
 			return false;
 		return ec.isEquals(me, (T)you);
 	}
 }
 abstract class AbstractReadableArray<T> extends AbstractContainer<T> implements ReadableArray<T> {
 	
 	@Override
 	public final boolean isEmpty() {
 		return size() == 0;
 	}
 	
 	@Override
 	public final T last() {
 		return get(size()-1);
 	}
 	
 	@Override
 	public final T first() {
 		return get(0);
 	}	
 	
 	@Override
 	public final Iterator<T> iterator() {
 		return new AbstractIterator<T>() {
 			int p = 0;
 			public boolean hasNext() {
 				return p < size();
 			}
 			public T next() {
 				return get(p++);
 			}
 		};
 	}
 
 }
 abstract class AbstractContainer<T> implements Container<T> {
 
 	@Override
 	public final String toString() {
 		StringBuilder sb = new StringBuilder();
 		sb.append('(');
 		boolean first = true;
 		for(T v : this) {
 			if(first)
 				first = false;
 			else
 				sb.append(',');
 			sb.append(v);
 		}
 		sb.append(')');
 		return sb.toString();
 	}
 	
 }
 interface Container<T> extends Iterable<T> {
 	int size();
 	boolean isEmpty();
 }
 interface ReadableArray<T> extends Container<T> {
 	T get(int index);
 	T last();
 	T first();
 }
 interface StaticArray<T> extends ReadableArray<T>{
 	void set(int index, T value);	
 }
 class Int32 implements Int<Int32>, EqualityChecker<Int32> {
 	
 	private final int v;
 	
 	public Int32(int v) {
 		this.v = v;
 	}
 
 	public Int32 plus(Int32 t) {
 		return new Int32(v + t.v);
 	}
 	
 	public Int32 minus(Int32 t) {
 		return new Int32(v - t.v);
 	}
 	
 	public int toPrimitive() {
 		return v;
 	}
 	
 	public Int32 getAddInvert() {
 		return new Int32(-v);
 	}
 	
 	public int compareTo(Int32 o) {
 		return compare(v, o.v);
 	}
 
 	public static int compare(int v1, int v2) {
 		if(v1 > v2)
 			return 1;
 		else if(v1 < v2)
 			return -1;
 		return 0;
 	}
 	
 	public String toString() {
 		return Integer.toString(v);
 	}
 	
 	public Int32 getZero() {
 		return ZERO;
 	}
 	
 	public Int32 getOne() {
 		return ONE;
 	}
 	
 	@Override
 	public boolean isOne() {
 		return v == 1;
 	}
 	
 	public Int32 times(Int32 a) {
 		return new Int32(v * a.v);
 	}	
 	
 	public Int32 floorDivide(Int32 o) {
 		return new Int32(v / o.v);
 	}
 	
 	public Int32 mod(Int32 o) {
 		return new Int32(v % o.v);
 	}		
 	
 	public double toDouble() {
 		return v;
 	}
 	
 	@Override
 	public boolean equals(Object obj) {
 		return StrictEqualityChecker.isEquals(this, obj, this);
 	}
 	
 	@Override
 	public boolean isEquals(Int32 o1, Int32 o2) {
 		return o1.v == o2.v;
 	}
 	
 	@Override
 	public int hashCode() {
 		return Int32Hash.hash(v);
 	}	
 	
 	@Override
 	public int getSign() {
 		if(v > 0)
 			return 1;
 		else if(v < 0)
 			return -1;
 		return 0;
 	}
 
 	@Override
 	public final Int32 get(int v) {
 		return new Int32(v);
 	}
 
 	@Override
 	public final boolean isPositive() {
 		return v > 0;
 	}
 
 	@Override
 	public final boolean isNegative() {
 		return v < 0;
 	}
 
 	@Override
 	public final boolean isZero() {
 		return v == 0;
 	}
 
 	static final public Int32 ZERO = new Int32(0);
 	static final public Int32 ONE = new Int32(1);
 }
","import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
  
 public class solver implements Runnable {         
         BufferedReader in;
         PrintWriter out;
         StringTokenizer tok = new StringTokenizer("""");
  
         void init() throws FileNotFoundException {
         	in = new BufferedReader(new InputStreamReader(System.in));
             out = new PrintWriter(System.out);   
             
             in=new BufferedReader(new FileReader(""A-large.in""));
             //in=new BufferedReader(new FileReader(""input.txt""));
             out=new PrintWriter(""output.txt"");
         }
  
         String readString() throws IOException {
                 while (!tok.hasMoreTokens()) {
                         try {
                                 tok = new StringTokenizer(in.readLine());
                         } catch (Exception e) {
                                 return null;
                         }
                 }
                 return tok.nextToken();
         }
  
         int readInt() throws IOException {
                 return Integer.parseInt(readString());
         }
  
         long readLong() throws IOException {
                 return Long.parseLong(readString());
         }
  
         double readDouble() throws IOException {
                 return Double.parseDouble(readString());
         }
  
         public static void main(String[] args) {
                 new Thread(null, new solver(), """", 128 * (1L << 20)).start();
         }
  
         
  
         public void run() {
                 try {
                         init();
                         solve();
                         out.close();                        
                 } catch (IOException e) {
                 	    System.err.println(e.getMessage());
                         System.exit(-1);
                 }
         }
         
         
         
         
         
         
         void solve() throws IOException{        	
         	int t=readInt();
         	for (int test=1;test<=t;test++){
         		out.print(""Case #""+test+"": "");        		
         		
         		int n=readInt();
         		char[][] a=new char[n][];  		
         		for (int i=0;i<n;i++) a[i]=readString().toCharArray();
         		
         		
         		int[] pos=new int[n];
         		int[] k=new int[n];
         		int[] x=new int[n];
         		int ans=0;
         		boolean faik=false;
         		while (true){     
         			int sum=0;
         			for (int i=0;i<n;i++){
         				x[i]='$';        				
         				if (pos[i]==a[i].length) continue;
         				x[i]=a[i][pos[i]];            			      			
             			while (pos[i]<a[i].length && a[i][pos[i]]==x[i]) {
             				pos[i]++;
             				k[i]++;
             			}      
             			sum+=k[i];
         			}    
         			Arrays.sort(x);
         			if (x[0]!=x[n-1]){
         				faik=true;
         				break;
         			}
         			if (x[0]=='$') break;
         			
         			int sr=sum/n;
         			int min=Integer.MAX_VALUE;
         			int res=0;
         			for (int i=0;i<n;i++){
         				res+=Math.abs(sr-k[i]);        				
         			}
         			min=res;
         			res=0;
         			for (int i=0;i<n;i++){
         				res+=(Math.abs(sr+1-k[i]));
         			}
         			min=Math.min(min, res);
         			ans+=min;
         			for (int i=0;i<n;i++) k[i]=0;
         		}
         		if (faik){
         			out.println(""Fegla Won"");
         		}else{
         			out.println(ans);
         		}
         		
         	}
         	
         	
         		    	    	
         }
 }",0
90,20454,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package dancing;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author Serban
  */
 public class Input {
     
     PrintWriter out;
 
     public Input(String fileName) {
         //C-large-practice.in
         try {
             out = new PrintWriter(new File(""result.txt""));
             Scanner scan = new Scanner(new File(fileName));
             int T = scan.nextInt();
             scan.nextLine();
             for (int i = 0; i < T; i++) {
                 int N = scan.nextInt();
                 int S = scan.nextInt();
                 int p = scan.nextInt();
                 int[] marks = new int[N]; 
                 for(int j=0;j<N;j++) {
                     marks[j] = scan.nextInt();
                 }
                 solve(N, S, p, marks, i);
             }
             out.close();
         } catch (Exception e) {
             System.out.println(e.getMessage());
         }
     }
     
     private void solve(int N, int S, int p, int[] marks, int testCase) {
         out.print(""Case #"" + (testCase + 1) + "": "");
         int nr = 0;
         int leftS = S;
         for(int i=0;i<N;i++) {
             //System.out.print(marks[i]+"" "");
             int c = marks[i];
             switch(p) {
                 case 0:
                     nr++;
                     break;
                 case 1:
                     if(c>=1)
                         nr++;
                     break;
                 default:
                     if(c >= 3*p-2)
                         nr++;
                     else
                         if(leftS > 0 && c >= 3*p-4) {
                             nr++;
                             leftS--;
                         }
             }
         }
         System.out.println(nr);
         out.print(nr);
         out.println();
         out.flush();
     }
 }
","import java.io.*;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.Vector;
 
 import org.jgrapht.*;
 import org.jgrapht.experimental.dag.DirectedAcyclicGraph;
 import org.jgrapht.graph.*;
 import org.jgrapht.alg.*;
 
 public class CodeJam
 {
 	static String baseDir = ""C:\\Users\\Chris\\Desktop\\"";
 	static String problem = ""B-small-attempt1.in"";
 	static NumberFormat codeJamAnswer = NumberFormat.getNumberInstance();
 	
 	public String solveCase( int L, long t, int N, int C, long[] a )
 	{
 		long[][] T = new long [L+1][N+1];
 		for( int i = 0; i <= L; i++ )
 			T[i][0] = 0;
 		for( int j = 1; j <= N; j++ )
 			T[0][j] = T[0][j-1] + ( 2 * a[(j-1)%C] );
 		
 		for( int j = 0; j <= N; j++ )
 			for( int i = 1; i <= L; i++ )
 			{
 				if( i <= j )
 				{
 					long min = T[0][N] + t;
 					for( int k = 0; k <= j; k++ )
 					{
 						long time = T[i-1][k] + bestOne( k, j, a, T[i-1][k], C, t );
 						if( time < min )
 							min = time;
 					}
 					T[i][j] = min;
 				}
 				else
 					T[i][j] = T[j][j];
 			}
 		
 		String caseAnswer = """" + T[L][N];
 		return caseAnswer;
 	}
 	
 	public long bestOne( int start, int end, long[] a, long t2, int C, long t )
 	{
 		long totalTime = t2, maxSave = 0, dTotal = 0;
 		for( int s = start; s < end; s++ )
 		{
 			long timeLeft = t - totalTime;
 			timeLeft = Math.max( timeLeft, 0 );
 			long d = a[s%C];
 			long save = d - ( timeLeft / 2 );
 			if( save > maxSave )
 				maxSave = save;
 			dTotal += d;
 			totalTime += ( d * 2 );
 		}
 		maxSave = Math.max( 0, maxSave );
 		return dTotal * 2 - maxSave;
 	}
 	
 	public void solve()
 	{
         BufferedReader 	reader = null;
         PrintWriter 	writer = null;
         try
         {
         	writer = new PrintWriter( new FileWriter( baseDir + ""Output.txt"" ) );
             reader = new BufferedReader( new FileReader( new File( baseDir + problem ) ) );
             codeJamAnswer.setGroupingUsed( false );
         	codeJamAnswer.setMinimumFractionDigits( 1 );
             long caseNumber = 1;
             String inputLine = reader.readLine();
             while( ( inputLine = reader.readLine()) != null )
             {
             	String[] input = inputLine.split( "" "" );
             	int L = Integer.parseInt( input[ 0 ] );
             	long t = Long.parseLong( input[ 1 ] );
             	int N = Integer.parseInt( input[ 2 ] );
             	int C = Integer.parseInt( input[ 3 ] );
             	long[] a = new long [ C ];
             	for( int i = 0; i < C; i++ )
             		a[ i ] = Integer.parseInt( input[ i + 4 ] );
 
             	// Here we go...
             	String caseAnswer = solveCase( L, t, N, C, a );
 
             	String output = ""Case #"" + caseNumber++ + "": "" + caseAnswer;
                 writer.println( output );
                 System.out.println( output );
             }
             reader.close();
             writer.close();
         }
         catch( FileNotFoundException e ){ e.printStackTrace(); }
         catch( IOException e ) 			{ e.printStackTrace(); }
 	}
 	
 	public static void main( String[] args )
 	{
 		CodeJam problem = new CodeJam();
 		problem.solve();
 	}
 }",0
91,5726,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.Closeable;
 import java.io.FileWriter;
 import java.io.BufferedWriter;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.math.BigInteger;
 
 
 public class Rotate {
 
     //-------------------------------------------------------------
     // Constants - Private - Static
     //-------------------------------------------------------------
 
     private static final int NO_COLOR = 0;
     private static final int RED_COLOR = 1;
     private static final int BLUE_COLOR = 2;
 
 
     //-------------------------------------------------------------
     // Variables - Private
     //-------------------------------------------------------------
 
     private FileReader fileReader = null;
     private BufferedReader bufferedReader = null;
 
     private FileWriter fileWriter = null;
     private BufferedWriter bufferedWriter = null;
 
 
     //-------------------------------------------------------------
     // Methods - Public
     //-------------------------------------------------------------
 
     public void init(String inputFileName, String outputFileName)
             throws IOException {
         reset();
 
         fileReader = new FileReader(inputFileName);
         bufferedReader = new BufferedReader(fileReader);
 
         fileWriter = new FileWriter(outputFileName);
         bufferedWriter = new BufferedWriter(fileWriter);
     }
 
 
     public void reset() {
         closeCloseable(bufferedReader);
         closeCloseable(fileReader);
 
         closeCloseable(bufferedWriter);
         closeCloseable(fileWriter);
 
         bufferedReader = null;
         fileReader = null;
         bufferedWriter = null;
         fileWriter = null;
     }
 
 
     public void execute()
             throws IOException {
         String line = bufferedReader.readLine();
         int numCases = Integer.parseInt(line.trim());
 
         for (int i = 0; i < numCases; i++) {
             line = bufferedReader.readLine();
 
             if (line == null) {
                 System.out.println(""Unexpected EOF at line "" + (i + 1) + "", expected "" + (numCases + 1));
                 break;
             }
 
             String[] splitLine = line.split("" "");
 
             if (splitLine != null && splitLine.length >= 2) {
                 int n = Integer.parseInt(splitLine[0]);
                 int k = Integer.parseInt(splitLine[1]);
                 int[][] matrix = new int[n][n];
 
                 // Filling out the matrix rotated
                 for (int p = 0; p < n; p++) {
                     line = bufferedReader.readLine();
                     //System.out.println(line);
                     int actualY = n - 1;
                     for (int q = n - 1; q >= 0; q--) {
                     //for (int q = 0; q < n; q++) {
                         if (line.charAt(q) == 'R') {
                             matrix[actualY][n - p - 1] = RED_COLOR;
                             actualY--;
                         } else if (line.charAt(q) == 'B') {
                             matrix[actualY][n - p - 1] = BLUE_COLOR;
                             actualY--;
                         }
                     }
                 }
                 /*System.out.println(""---------"" + k + ""----------"");
 
                 for (int p = 0; p < n; p++) {
                     StringBuilder sb = new StringBuilder();
                     for (int q = 0; q < n; q++) {
                         if (matrix[p][q] == RED_COLOR) {
                             sb.append(""R"");
                         } else if (matrix[p][q] == BLUE_COLOR) {
                             sb.append(""B"");
                         } else {
                             sb.append(""."");
                         }
                     }
                     System.out.println(sb);
                 }*/
 
                 int max_r_in_row = 0;
                 int max_b_in_row = 0;
 
                 for (int p = 0; p < n; p++) {
                     for (int q = 0; q < n; q++) {
                         int val = matrix[p][q];
                         if (val != NO_COLOR) {
                             int max = findRowCount(matrix, n, p, q, val);
 
                             if (val == RED_COLOR) {
                                 if (max > max_r_in_row) {
                                     max_r_in_row = max;
                                 }
                             } else {
                                 if (max > max_b_in_row) {
                                     max_b_in_row = max;
                                 }
                             }
                         }
                     }
                 }
 
                 String str = """";
                 if (max_r_in_row >= k && max_b_in_row >= k) {
                     str = ""Both"";
                 } else if (max_r_in_row >= k) {
                     str = ""Red"";
                 } else if (max_b_in_row >= k) {
                     str = ""Blue"";
                 } else {
                     str = ""Neither"";
                 }
 
                 bufferedWriter.write(""Case #"" + (i + 1) + "": "" + str + ""\n"");
                 System.out.println(""Case #"" + (i + 1) + "": "" + str);
             } else {
                 System.out.println(""Something is wrong. Failed to match: "" + line);
             }
         }
 
         bufferedWriter.flush();
     }
 
 
     private int findRowCount(int[][] matrix, int n, int p, int q, int color) {
         int max_count = 0;
         int horizontalCount = 0;
         for (int i = q; i < n; i++) {
             if (matrix[p][i] == color) {
                 horizontalCount++;
             } else {
                 break;
             }
         }
         max_count = horizontalCount;
 
         int verticalCount = 0;
         for (int j = p; j < n; j++) {
             if (matrix[j][q] == color) {
                 verticalCount++;
             } else {
                 break;
             }
         }
 
         max_count = Math.max(max_count, verticalCount);
 
         int diagonalRight = 0;
         for (int i = 0; (p + i) < n && (q + i) < n; i++) {
             if (matrix[p + i][q + i] == color) {
                 diagonalRight++;
             } else {
                 break;
             }
         }
 
         max_count = Math.max(max_count, diagonalRight);
 
         int diagonalLeft = 0;
         for (int i = 0; (p + i) < n && (q - i) >= 0; i++) {
             if (matrix[p + i][q - i] == color) {
                 diagonalLeft++;
             } else {
                 break;
             }
         }
 
         return Math.max(max_count, diagonalLeft);
     }
 
 
     //-------------------------------------------------------------
     // Methods - Private
     //-------------------------------------------------------------
 
     private void closeCloseable(Closeable closeable) {
         if (closeable != null) {
             try {
                 closeable.close();
             } catch (IOException e) {
                 System.err.println(""Failed to close closeable: "" + e);
             }
         }
     }
 
 
     //-------------------------------------------------------------
     // Entrypoint
     //-------------------------------------------------------------
 
     public static void main(String[] args) {
         Rotate prog = new Rotate();
 
         if (args.length != 2) {
             System.out.println(""Usage: java Rotate inputFile outputFile"");
             System.exit(0);
         }
 
         try {
             prog.init(args[0], args[1]);
 
             long startTime = System.currentTimeMillis();
 
             prog.execute();
 
             System.out.println(""Runtime: "" + ((System.currentTimeMillis() - startTime) / 1000));
         } catch (IOException e) {
             System.err.println(e);
         } finally {
             prog.reset();
         }
     }
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.StringTokenizer;
 
 
 public class p1 {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		
 		
 		BufferedReader is = new BufferedReader(new FileReader(""C-small-attempt0.in""));
 		BufferedWriter os = new BufferedWriter(new FileWriter(""p1a.out""));
 		
 		int t= Integer.parseInt(is.readLine());
 		int a,b;
 		
 		ArrayList<Integer> c = new ArrayList<Integer>();
 		//int[] l
 		int ans = 0;
 		StringTokenizer st;
 		
 		//faster to pre compute
 		for(int i = 1; i <= 31;i++ )
 		{
 			
 			if(isPal(i)&& isPal(i*i))
 			{
 				c.add(new Integer(i*i));
 			}
 		}
 		
 		for(int i = 0; i < t; i++)
 		{
 			
 			st = new StringTokenizer(is.readLine());
 			a = Integer.parseInt(st.nextToken());
 			b = Integer.parseInt(st.nextToken());
 			
 			ans = 0;
 			for(int j =a ; j <= b;  j++)
 			{
 				if(c.contains(new Integer(j)))
 				{
 					
 					ans++;
 					
 					//System.out.println( j + "" "" +ans);
 				}
 			}
 			
 			os.write(""Case #""+ (i+1) +"": ""+ans+""\n"");
 			//System.out.print(""Case #""+ (i+1) +"": ""+ans+""\n"");
 		}
 		
 		is.close();
 		os.close();
 		
 		
 
 	}
 
 	public static boolean isPal(int k) {
 		String s = Integer.toString(k);
 
 		for(int i = 0; i < s.length()/2; i++)
 		{
 			if(s.charAt(i) != s.charAt(s.length() -(i+1)))
 			{
 				return false;
 			}
 		}
 
 		//System.out.println(k);
 		return true;
 	}
 
 }
",0
92,18492,"/*
  * To change this license header, choose License Headers in Project Properties.
  * To change this template file, choose Tools | Templates
  * and open the template in the editor.
  */
 
 //package googlecodejam;
 import java.io.*;
 import java.util.ArrayList;
 /**
  *
  * @author Hamza
  */
 public class GoogleCodeJamRound1BB {
     public static void main(String[] args) throws Exception
     {
         BufferedReader br = new BufferedReader(new FileReader(""A-small-attempt0.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""A-small-attempt0.out""));
         
         String line = br.readLine();
         int T = Integer.parseInt(line);
         
         for (int i = 1; i <= T; i++)
         {
             int N = Integer.parseInt(br.readLine());
             String[] strs = new String[N];
             for (int j = 0; j < N; j++)
                 strs[j] = br.readLine();
             
             int index = 0, index2 = 0;
             char ch;
             
             ArrayList[] lists;
             lists = new ArrayList[N];
             for (int j = 0; j < N; j++)
                 lists[j] = getChars(strs[j]);
             
             boolean equal = checkEquality(lists);
             if (!equal) {
                 bw.write(""Case #""+i+"": Fegla Won\n"");
                 continue;
             }
             
             int moves = 0;
             for (int j = 0; j < lists[0].size(); j++) {
                 char c = (char)lists[0].get(j);
                 
                 int count1 = 0, count2 = 0, indx = 0;
                 while (indx < strs[0].length() && strs[0].charAt(indx) == c) {
                     count1++;
                     indx++;
                 }
                 indx = 0;
                 while (indx < strs[1].length() && strs[1].charAt(indx) == c) {
                     count2++;
                     indx++;
                 }
                 
                 int diff = Math.abs(count1 - count2);
                 moves += diff;
                 
                 strs[0] = strs[0].substring(count1);
                 strs[1] = strs[1].substring(count2);
             }
             bw.write(""Case #""+i+"": ""+moves+""\n"");
 			bw.flush();
         }
         bw.flush();
         br.close();
         bw.close();
     }
     
     private static ArrayList<Character> getChars(String str)
     {
         int index = 0;
         char ch;
         ArrayList<Character> list = new ArrayList<>();
         while (index < str.length())
         {
             ch = str.charAt(index);
             while (index < str.length() && str.charAt(index) == ch) index++;
             list.add(ch);
         }
         return list;
     }
     
     private static boolean checkEquality(ArrayList[] lists)
     {
         boolean equal = true;
         
         for (int j = 1; j < lists.length; j++)
             if (lists[j-1].size() != lists[j].size()) equal = false;
         
         if (!equal) return equal;
         
         for (int i = 0; i < lists[0].size(); i++)
             for (int j = 1; j < lists.length; j++)
             {
                 if (lists[j-1].get(i) != lists[j].get(i)) equal = false;
             }
         
         return equal;
     }
 }
","/*
  * To change this license header, choose License Headers in Project Properties.
  * To change this template file, choose Tools | Templates
  * and open the template in the editor.
  */
 
 //package googlecodejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 /**
  *
  * @author Hamza
  */
 public class GoogleCodeJam3 {
     static BufferedReader br;
     static BufferedWriter bw;
     public static void main(String[] args) throws Exception {
         br = new BufferedReader(new FileReader(""C-small-attempt1.in""));
         bw = new BufferedWriter(new FileWriter(""C-small-attempt1.out""));
         
         int T = Integer.parseInt(br.readLine());
         for (int i = 1; i <= T; i++)
         {
             String[] vals = br.readLine().split("" "");
             int R = Integer.parseInt(vals[0]), C = Integer.parseInt(vals[1]), M = Integer.parseInt(vals[2]);
             int freeSpaces = R * C - M;
             
             char[][] map = new char[R][];
             initializeMap(map, C);
             setFreeSpaces(map, freeSpaces);
             
             updateMap(map);
             bw.write(""Case #""+i+"":\n"");
             //System.out.print(""Case #""+i+"":\n"");
             if (!checkPossibility(map) && freeSpaces != 1)
             {
                 bw.write(""Impossible\n"");
                 //System.out.print(""Impossible\n"");
             }
             else
             {
                 map[0][0] = 'c';
                 printMap(map);
             }
             
             bw.flush();
         }
         
         br.close();
         bw.close();
     }
     
     private static void initializeMap(char[][] map, int cols)
     {
         for (int i = 0; i < map.length; i++)
         {
             map[i] = new char[cols];
             for (int j = 0; j < cols; j++)
             {
                 map[i][j] = '*';
             }
         }
     }
 
     private static void setFreeSpaces(char[][] map, int freeSpaces)
     {
         int freeRows = (int)Math.ceil(Math.sqrt(freeSpaces));
         int freeCols = (int)Math.ceil(freeSpaces / (double)freeRows);
         
         int spacesMarked = 0;
         
         for (int i = 0; i < map[0].length * 2 && i < 4; i++)
         {
             if (spacesMarked >= freeSpaces) return;
             
             if (i % 2 == 0) {
                 map[0][i/2] = '.';
                 spacesMarked++;
             }
             else if (map.length > 1) {
                 map[1][i/2] = '.';
                 spacesMarked++;
             }
         }
         int pos = 0;
         for (int i = 2; i < map.length || i < map[0].length; i++)
         {
             if (spacesMarked >= freeSpaces) return;
 
             if (pos == 0 && i < map[0].length)
             {
                 map[0][i] = '.';
                 spacesMarked++;
             }
             else if (pos == 1 && i < map[0].length && map.length > 1)
             {
                 map[1][i] = '.';
                 spacesMarked++;
             }
             else if (pos == 2 && i < map.length)
             {
                 map[i][0] = '.';
                 spacesMarked++;
             }
             else if (pos == 3 && i < map.length &&  map[0].length > 1)
             {
                 map[i][1] = '.';
                 spacesMarked++;
             }
             
             if (pos <= 2) i--;
             
             pos = (pos+1)%4;
         }
         
         int i=0;
         while (spacesMarked < freeSpaces)
         {
             try {
                 int row = 2+i/(map[0].length-2), col = 2+i%(map[0].length-2);
                 if (map[row][col] == '*')
                     map[row][col] = '.';
                 else if (map[row][col] == '.')
                     map[row][col] = '#';
                 else
                     map[row][col] = '@';
 
                 i++;
                 spacesMarked++;
             }
             catch (IndexOutOfBoundsException e) { System.out.println(e.getMessage()); }
         }
     }
     
     private static void setFreeSpaces2(char[][] map, int freeSpaces)
     {
         int freeRows = (int)Math.ceil(Math.sqrt(freeSpaces));
         int freeCols = (int)Math.ceil(freeSpaces / (double)freeRows);
         
         int spacesMarked = 0;
         
         for (int i = 0; i < map[0].length*2;i++)
         {
             if (spacesMarked >= freeSpaces) return;
             
             if (i % 2 == 0) {
                 map[0][i/2] = '.';
                 spacesMarked++;
             }
             else if (map.length > 1) {
                 map[1][i/2] = '.';
                 spacesMarked++;
             }
         }
         for (int i = 4; i < map.length*2;i++)
         {
             if (spacesMarked >= freeSpaces) return;
             if (i % 2 == 0) {
                 map[i/2][0] = '.';
                 spacesMarked++;
             }
             else if (map.length > 1) {
                 map[i/2][1] = '.';
                 spacesMarked++;
             }
         }
         
         int i=0;
         while (spacesMarked < freeSpaces)
         {
             try {
                 int row = 2+i/(map[0].length-2), col = 2+i%(map[0].length-2);
                 if (map[row][col] == '*')
                     map[row][col] = '.';
                 else if (map[row][col] == '.')
                     map[row][col] = '#';
                 else
                     map[row][col] = '@';
 
                 i++;
                 spacesMarked++;
             }
             catch (IndexOutOfBoundsException e) { System.out.println(e.getMessage()); }
         }
     }
     
     private static void printMap(char[][] map) throws Exception
     {
         for (int i=0;i<map.length;i++)
         {
             for (int j=0;j<map[i].length;j++)
             {
                 char out = map[i][j];
                 if (out == '#') out = '.';
                 bw.write(out+"""");
                 //System.out.print(out+"""");
             }
             bw.write(""\n"");
             //System.out.print(""\n"");
         }
     }
 
     private static void updateMap(char[][] map)
     {
         for (int i=0;i<map.length;i++)
         {
             for (int j=0;j<map[i].length;j++)
             {
                 if (map[i][j] == '.')
                     updatePosition(map, i, j);
             }
         }
     }
     
     private static void updatePosition(char[][] map, int row, int col)
     {
         if (
                 (row > 0 && col < map[0].length-1 && map[row-1][col+1] == '*') || // right-up
                 (col < map[0].length-1 && map[row][col+1] == '*') || // right
                 (row < map.length - 1 && col < map[0].length-1 && map[row+1][col+1] == '*') || // right-below
                 (row < map.length-1 && map[row+1][col] == '*') || // below
                 (row < map.length - 1 && col > 0 && map[row+1][col-1] == '*') // left-below
             ) {
                 map[row][col] = '#';
             }
     }
 
     private static boolean checkPossibility(char[][] map)
     {
         if (map[0][0] == '.') return true;
         return false;
     }
 }
",1
93,1804,"import java.io.*;
 import java.util.*;
 public class CandySplitting {
     public static void main( String[] args) throws IOException {
         FileInputStream fs = new FileInputStream(""C-large.in"");
         DataInputStream in = new DataInputStream(fs);
         BufferedReader br = new BufferedReader(new InputStreamReader(in));
         BufferedWriter out = new BufferedWriter(new FileWriter(""C-large-output.txt""));
 
         int t, n, i, j, k, flag, sum;
 
         t = Integer.parseInt(br.readLine());
         for(i = 1; i <= t; i++) {
             n = Integer.parseInt(br.readLine());
             String[] s = br.readLine().split("" "");
             int[] c = new int[s.length];
             flag = 0;
             for(j = 0; j < s.length; j++) {
                 c[j] = Integer.parseInt(s[j]);
                 flag = flag^c[j];
             }
             String z;
             if(flag != 0) {
                 z = ""Case #""+i+"": NO"";
                 //System.out.println(z);
                 out.write(z);
                 out.newLine();
                 continue;
             }
             Arrays.sort(c);
             sum = 0;
             for(k = 1; k < c.length; k++) {
                 sum = sum + c[k];
             }
             z = ""Case #""+i+"": ""+sum;
             //System.out.println(z);
             out.write(z);
             out.newLine();
         }
         out.close();
         br.close();
     }
 }
","import java.io.*;
 import java.util.*;
 public class CandySplitting {
     public static void main( String[] args) throws IOException {
         FileInputStream fs = new FileInputStream(""C-large.in"");
         DataInputStream in = new DataInputStream(fs);
         BufferedReader br = new BufferedReader(new InputStreamReader(in));
         BufferedWriter out = new BufferedWriter(new FileWriter(""C-large-output.txt""));
 
         int t, n, i, j, k, flag, sum;
 
         t = Integer.parseInt(br.readLine());
         for(i = 1; i <= t; i++) {
             n = Integer.parseInt(br.readLine());
             String[] s = br.readLine().split("" "");
             int[] c = new int[s.length];
             flag = 0;
             for(j = 0; j < s.length; j++) {
                 c[j] = Integer.parseInt(s[j]);
                 flag = flag^c[j];
             }
             String z;
             if(flag != 0) {
                 z = ""Case #""+i+"": NO"";
                 //System.out.println(z);
                 out.write(z);
                 out.newLine();
                 continue;
             }
             Arrays.sort(c);
             sum = 0;
             for(k = 1; k < c.length; k++) {
                 sum = sum + c[k];
             }
             z = ""Case #""+i+"": ""+sum;
             //System.out.println(z);
             out.write(z);
             out.newLine();
         }
         out.close();
         br.close();
     }
 }
",1
94,6543,"package com.pong;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 
 import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter.DEFAULT;
 
 public class DeceitfulWar {
 
 //	static String inputFileName = ""Inputs/sample.in.txt"";
 	static String inputFileName = ""Inputs/D-small-attempt1.in.txt"";
 //	static String inputFileName = ""Inputs/D-large.in.txt"";
 	static String outputFileName = ""output.txt"";
 	
 	static float EPSILON = 0.00000001f;
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		BufferedReader br = null;		
 		int T = 0;
 		
 		// read the input from a file
 		try {
 			br = new BufferedReader(new FileReader(inputFileName));
 			
 			String line = br.readLine();
 			T = Integer.parseInt(line);	
 			
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	
 		File file = new File(outputFileName);
 		if (!file.exists()) {
 			try {
 				file.createNewFile();
 			} catch (IOException e) {
 				// TODO Auto-generated catch block
 				e.printStackTrace();
 			}
 		}
 		FileWriter fw = null;
 		try {
 			fw = new FileWriter(file.getAbsoluteFile());
 		} catch (IOException e1) {
 			// TODO Auto-generated catch block
 			e1.printStackTrace();
 		}
 		BufferedWriter bw = new BufferedWriter(fw);
 		
 		// Solve the problem
 		int N = 0;
 		ArrayList<Float> naomis = new ArrayList<Float>();
 		ArrayList<Float> kens = new ArrayList<Float>();
 		ArrayList<Float> kens2 = new ArrayList<Float>();
 		
 		for (int t = 1; t <= T; t++) {
 			
 			String line = null;
 			naomis.clear();
 			kens.clear();
 			kens2.clear();
 			
 			try {
 				line = br.readLine();
 				N = Integer.parseInt(line);
 				
 				line = br.readLine();
 				String[] weighs = line.split("" "");
 				for (String weigh : weighs) {
 					naomis.add(Float.parseFloat(weigh));
 				}
 				
 				line = br.readLine();
 				weighs = line.split("" "");
 				for (String weigh : weighs) {
 					kens.add(Float.parseFloat(weigh));
 				}
 				
 			} catch (IOException e1) {
 				// TODO Auto-generated catch block
 				e1.printStackTrace();
 			}			
 			
 			Collections.sort(naomis);
 			Collections.sort(kens);			
 			kens2.addAll(kens);		
 			
 			System.out.print(""N: "");
 			for (Float naomi : naomis) {
 				System.out.print(naomi + "" "");
 			}
 			System.out.println();
 			
 			System.out.print(""K: "");
 			for (Float ken : kens) {
 				System.out.print(ken + "" "");
 			}
 			System.out.println();
 			
 			int war = 0;
 			int deceifulWar = 0;					
 			
 			// play war
 			for (float naomi : naomis) {
 				// find the next higher weigh in Ken's blocks
 				int index = Collections.binarySearch(kens, naomi);
 				
 				index++;
 				if (index < 0) {
 					index = index * -1;
 				}
 				if (index > kens.size() - 1) {
 					// ken will have to choose his highest block
 					index--;
 				}
 				if (kens.get(index) < naomi) {
 					war++;
 				}
 				kens.remove(index);
 			}
 			
 
 			// Let's play deceitful war
 			while (naomis.size() > 0) {
 				
 				if (naomis.get(0) > kens2.get(0)) {
 					// naomi get win with the smallest block
 					deceifulWar++;
 					naomis.remove(0);
 					kens2.remove(0);
 				}
 				else {
 					// naomi uses the smallest block to get ken's largest block
 					naomis.remove(0);
 					kens2.remove(kens2.size() - 1);
 				}
 			}					
 			
 			try {
 				System.out.println(String.format(""Case #%d: %d %d"", t, deceifulWar, war));
 				bw.write(String.format(""Case #%d: %d %d\n"", t, deceifulWar, war));
 			} catch (IOException e) {
 				// TODO Auto-generated catch block
 				e.printStackTrace();
 			}
 		}
 		
 		try {
 			br.close();
 			bw.close();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 		System.out.println(""done"");
 	}
 
 }
","package com.codejam.karl;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class QualificationB {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		String sampleInputFilePath = ""inputs/sample.in.txt"";
 		String smallInputFilePath = ""inputs/B-small-attempt0.in.txt"";
 		String largeInputFilePath = ""inputs/B-large.in.txt"";
 		
 		FileWriter fileWriter = null;
 		try {
 			fileWriter = new FileWriter(""output.txt"");
 		} catch (IOException e1) {
 			// TODO Auto-generated catch block
 			e1.printStackTrace();
 		}
 		
 		FileReader fr = null;		
 		try {
 			fr = new FileReader(smallInputFilePath);
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 		BufferedReader br = new BufferedReader(fr);
 		String s = null;
 		int T = 0;
 		
 		try {
 			T = Integer.parseInt(br.readLine());
 		} catch (NumberFormatException e1) {
 			// TODO Auto-generated catch block
 			e1.printStackTrace();
 		} catch (IOException e1) {
 			// TODO Auto-generated catch block
 			e1.printStackTrace();
 		}		
 		
 		boolean isPossible;
 		int N, M;
 		for (int t = 0; t < T; t++)
 		{			
 			isPossible = true;
 			
 			// retrieve the dimension
 			try {
 				s = br.readLine();
 			} catch (IOException e) {
 				// TODO Auto-generated catch block
 				e.printStackTrace();
 			}
 			String[] dimensions = s.split("" "");
 			N = Integer.parseInt(dimensions[0]);
 			M = Integer.parseInt(dimensions[1]);
 			
 			int[][] lawn = new int[N][M];
 			
 			// retrieve the lawn (grass height)
 			for (int n = 0; n < N; n++)
 			{
 				try {
 					s = br.readLine();					
 				} catch (IOException e) {
 					// TODO Auto-generated catch block
 					e.printStackTrace();
 				}
 				
 				String[] heights = s.split("" "");
 				for (int m = 0; m < M; m++)
 				{
 					lawn[n][m] = Integer.parseInt(heights[m]);
 				}
 			}
 			
 			// check if the lawn is possible
 			//	inspect each height, the lawn is possible if
 			//	- if there is a horizontal or vertical path that no spot is higher than it
 			int maxHeight = 0;
 			boolean isHorizontalPossible, isVerticalPossible;
 			for (int n = 0; n < N; n++) {
 				for (int m = 0; m < M; m++) {					
 					isHorizontalPossible = true;
 					isVerticalPossible = true;
 					
 					maxHeight = lawn[n][m];
 					for (int p = 0; p < N; p++)
 					{
 						if (lawn[p][m] > maxHeight)
 						{
 							isVerticalPossible = false;
 							break;
 						}
 					}
 					for (int q = 0; q < M; q++)
 					{
 						if (lawn[n][q] > maxHeight)
 						{
 							isHorizontalPossible = false;
 							break;
 						}
 					}
 					if (!isVerticalPossible && !isHorizontalPossible)
 					{
 						isPossible = false;
 						break;
 					}
 				}
 				if (!isPossible)
 				{
 					break;
 				}
 			}
 			
 			
 			try {
 				fileWriter.write(""Case #"" + (t + 1) + "": "" + (isPossible ? ""YES\n"" : ""NO\n""));
 			} catch (IOException e1) {
 				// TODO Auto-generated catch block
 				e1.printStackTrace();
 			}
 		}
 		
 		try {
 			fileWriter.close();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 		System.out.println(""Execution completed"");
 	}
 
 }
",1
95,16246,"import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class Run3 {
 	class ll {
 		public lln f;
 		public lln l;
 	}
 
 	class lln {
 		public Object v;
 		public lln n;
 	}
 
 	private static Scanner sc;
 
 	public static int gi() {
 		return Integer.parseInt(sc.next());
 	}
 
 	public static String gn() {
 		return sc.next();
 	}
 
 	public static void main(String[] args) throws IOException {
 		System.setIn(new FileInputStream(""B-small-attempt8.in""));
 		System.setOut(new PrintStream(""output.txt""));
 
 		sc = new Scanner(System.in);
 
 		int T = gi();
 
 		for (int z = 0; z < T; z++) {
 
 			int N = gi();
 			int S = gi();
 			int P = gi();
 
 			int[] ti = new int[N];
 			for(int i = 0; i < N; i++) {
 				ti[i] = gi();
 			}
 
 			int c = 0;
 			int[][] sc = new int[N][3];
 			//System.out.println(""z: "" + z);
 			//System.out.println(""N: "" + N);
 			//System.out.println(""S: "" + S);
 			//ystem.out.println(""P: "" + P);
 			//System.out.println(/*N + "" "" + */S + "" "" + P /*+ ' ' + z + "" ""*/);
 
 			int temp = 0;
 			for(int i = 0; i < N; i++) {
 				temp = ti[i];
 				for(int j = 2; j >= 0; j--) {
 					sc[i][j] = temp/(j+1);
 					temp -= temp/(j+1);
 				}
 				Arrays.sort(sc[i]);
 				//System.out.println(ti[i] + ""\t"" + sc[i][0] + "","" + sc[i][1] + "",""  + sc[i][2] + ""\t"" + (sc[i][0] + sc[i][1] + sc[i][2]));
 			}
 
 			int c2 = 0;
 			boolean incc2;
 
 			for (int i = 0; i < N; i++) {
 				incc2 = false;
 				if(c2 < S) {
 					if(sc[i][2] < P && sc[i][2] + 1 == P) {
 						/*if(sc[i][2] - sc[i][0] == 1 && sc[i][2] - sc[i][1] == 0) {
 							sc[i][2] += 1;
 							sc[i][1] -= 1;
 							incc2 = true;
 						}
 						else */
 						if(sc[i][0] > 0 && sc[i][2] - sc[i][0] == 0) {
 							sc[i][2] += 1;
 							sc[i][0] -= 1;
 							incc2 = true;
 						}
 						else if(sc[i][1] > 0 && sc[i][2] - sc[i][0] == 1 && sc[i][2] - sc[i][1] == 0) {
 							sc[i][2] += 1;
 							sc[i][1] -= 1;
 							incc2 = true;
 						}
 					}
 					if(incc2) {
 						c2++;
 					}
 				}
 				if(sc[i][2] >= P) {
 					c++;
 				}
 			}
 
 			System.out.format(""Case #%d: %d\r\n"", z + 1, c);
 		}
 	}
 
 }
","
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  *
  * @author Chathura
  */
 public class Solution {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         Scanner scnr = new Scanner(new File(""D:\\Test\\cj\\test.txt""));
         int T = scnr.nextInt();
 
         ArrayList<Double> answeres = new ArrayList<>();
         for (int i = 0; i < T; i++) {
 
             double C = scnr.nextDouble();
             double F = scnr.nextDouble();
             double X = scnr.nextDouble(); 
             double rate = 2;
             double time = 0;
             while (true) {
                 if (X / rate > ((C / rate) + ((X) / (rate + F)))) {
                     time += (C / rate);
                     rate += F;
                 } else {
                     time += (X / rate);
                     break;
                 }
             }
             answeres.add(time);
         }
         String out = """";
         for (int i = 0; i < T; i++) {
             out += ""Case #"" + (i + 1) + "": "";
             out += answeres.get(i);
             out += ""\r\n"";
         }
         System.out.println(out);
         File outF = new File(""D:\\Test\\cj\\out.out"");
         FileWriter fw = new FileWriter(outF);
         fw.write(out);
         fw.flush();
 
     }
 }
",0
96,13066,"/**
  * By Patrick Mead
  * patrick@meadia.com.au
  *
  * Takes one argument: The name of the input file
  * Outputs to the same filename but with a .out extension.
  */
 
 import java.io.*;
 import java.util.*;
 
 public class RPI {
     private static Scanner in;
     private static PrintStream out;
 
     public static void main(String[] args) throws FileNotFoundException {
         
         in = new Scanner(new FileReader(new File(args[0]))); // Instantiate a Scanner for input
         out = new PrintStream(new FileOutputStream(new File( // And a PrintStream for output
             args[0].replaceFirst(""(\\.in)?$"", "".out""))       // Change .in extension (if it exists) to .out
         ));
 
         int t = in.nextInt();
         in.nextLine();
         
         for (int testCase = 1; testCase <= t; testCase++) {
             //System.out.println(""Case #"" + testCase + "":"");
             out.println(""Case #"" + testCase + "":"");
             
             int n = in.nextInt();
             in.nextLine();
             
             int[][] schedule = new int[n][n];
             
             for (int i = 0; i < n; i++) {
                 String line = in.nextLine();
                 for (int j = 0; j < n; j++) {
                     switch (line.charAt(j)) {
                         case '1':
                             schedule[i][j] = 1;
                             break;
                         case '0':
                             schedule[i][j] = -1;
                             break;
                         case '.':
                             schedule[i][j] = 0;
                             break;
                     }
                 }
             }
             
             double[] wp = new double[n];
             for (int i = 0; i < n; i++) {
                 int games = 0;
                 for (int j = 0; j < n; j++) {
                     switch (schedule[i][j]) {
                         case 1:
                             wp[i]++;
                         case -1:
                             games++;
                             break;
                     }
                 }
                 wp[i] = wp[i] / games;
             }
             
             double[] owp = new double[n];
             for (int i = 0; i < n; i++) {
                 int opponents = 0;
                 for (int j = 0; j < n; j++) {
                     if (schedule[i][j] != 0) {
                         opponents++;
                         int games = 0;
                         int wins = 0;
                         for (int k = 0; k < n; k++) {
                             if (i == k) {
                                 continue;
                             }
                             switch (schedule[j][k]) {
                                 case 1:
                                     wins++;
                                 case -1:
                                     games++;
                                     break;
                             }
                         }
                         owp[i] += wins * 1.0 / games;
                     }
                 }
                 owp[i] = owp[i] / opponents;
             }
 
             double[] oowp = new double[n];
             for (int i = 0; i < n; i++) {
                 int opponents = 0;
                 for (int j = 0; j < n; j++) {
                     if (schedule[i][j] != 0) {
                         opponents++;
                         oowp[i] += owp[j];
                     }
                 }
                 oowp[i] = oowp[i] / opponents;
             }
             
             for (int i = 0; i < n; i++) {
                 //System.out.println(wp[i] + "" "" + owp[i] + "" "" + oowp[i]);
                 out.println(0.25 * wp[i] + 0.5 * owp[i] + 0.25 * oowp[i]);
             }
             
         }
         
         System.out.println(""Done!"");
         
     }
     
 }","import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.StringReader;
 import java.util.HashMap;
 
 
 public class Googleese {
 	private static final HashMap<Character,Character> map = new HashMap<Character,Character>();
 	
 	static
 	{
 		//z
 		map.put('y', 'a');
 		map.put('n', 'b');
 		map.put('f', 'c');
 		map.put('i', 'd');
 		map.put('c', 'e');
 		map.put('w', 'f');
 		map.put('l', 'g');
 		map.put('b', 'h');
 		map.put('k', 'i');
 		map.put('u', 'j');
 		map.put('o', 'k');
 		map.put('m', 'l');
 		map.put('x', 'm');
 		map.put('s', 'n');
 		map.put('e', 'o');
 		map.put('v', 'p');
 		map.put('z', 'q');
 		map.put('p', 'r');
 		map.put('d', 's');
 		map.put('r', 't');
 		map.put('j', 'u');
 		map.put('g', 'v');
 		map.put('t', 'w');
 		map.put('h', 'x');
 		map.put('a', 'y');
 		map.put('q', 'z');
 		map.put(' ', ' ');
 	}
 	
 	public static void main(String [] args) throws NumberFormatException, IOException
 	{
 		BufferedReader in = new BufferedReader(new StringReader(args[0]));
 		int rows = Integer.parseInt(in.readLine());
 		for ( int i = 1; i <= rows; i++)
 		{
 			System.out.print(""Case #"" + i + "": "");
 			String line = in.readLine();
 			for ( int j=0; j<line.length();j++)
 			{
 				System.out.print(map.get(line.charAt(j)));
 			}
 			System.out.println("""");
 		}
 	}
 }
",0
97,7538,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package orangenblue;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author Ostap
  */
 public class OrangenBlue {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws FileNotFoundException, IOException {
         BufferedReader in=new BufferedReader(new FileReader(""A-small-attempt.in""));
         PrintWriter out=new PrintWriter(new FileWriter(""1.txt""));
     int k=Integer.parseInt(in.readLine());
     for (int q=1;q<=k;q++){
     String[] s=in.readLine().split("" "");
     int po=1;
     int pb=1;
     int sum=0;
     int ko=0;
     int kb=0;
     int n=Integer.parseInt(s[0]);
     int i=1;
     for (int j=0;j<n;j++){
        if (s[i].equals(""O"")){
            if (Math.abs(Integer.parseInt(s[i+1])-po)>kb){
        sum+=Math.abs(Integer.parseInt(s[i+1])-po)-kb;
        ko+=Math.abs(Integer.parseInt(s[i+1])-po)-kb;
            }
        po=Integer.parseInt(s[i+1]);
        sum++;
        ko++;
        kb=0;
        }
      if (s[i].equals(""B"")){
          if (Math.abs(Integer.parseInt(s[i+1])-pb)>ko){
       sum+=Math.abs(Integer.parseInt(s[i+1])-pb)-ko;
       kb+=Math.abs(Integer.parseInt(s[i+1])-pb)-ko;}
        pb=Integer.parseInt(s[i+1]);      
        ko=0;
        sum++;
        kb++;
        }   
      i+=2;   
     }
     out.print(""Case #""+Integer.toString(q)+"": ""+Integer.toString(sum));
     out.println();
     }
     out.flush();
     out.close();
     }
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package orangenblue;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author Ostap
  */
 public class OrangenBlue {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws FileNotFoundException, IOException {
         BufferedReader in=new BufferedReader(new FileReader(""A-large.in""));
         PrintWriter out=new PrintWriter(new FileWriter(""1.txt""));
     int k=Integer.parseInt(in.readLine());
     for (int q=1;q<=k;q++){
     String[] s=in.readLine().split("" "");
     int po=1;
     int pb=1;
     int sum=0;
     int ko=0;
     int kb=0;
     int n=Integer.parseInt(s[0]);
     int i=1;
     for (int j=0;j<n;j++){
        if (s[i].equals(""O"")){
            if (Math.abs(Integer.parseInt(s[i+1])-po)>kb){
        sum+=Math.abs(Integer.parseInt(s[i+1])-po)-kb;
        ko+=Math.abs(Integer.parseInt(s[i+1])-po)-kb;
            }
        po=Integer.parseInt(s[i+1]);
        sum++;
        ko++;
        kb=0;
        }
      if (s[i].equals(""B"")){
          if (Math.abs(Integer.parseInt(s[i+1])-pb)>ko){
       sum+=Math.abs(Integer.parseInt(s[i+1])-pb)-ko;
       kb+=Math.abs(Integer.parseInt(s[i+1])-pb)-ko;}
        pb=Integer.parseInt(s[i+1]);      
        ko=0;
        sum++;
        kb++;
        }   
      i+=2;   
     }
     out.print(""Case #""+Integer.toString(q)+"": ""+Integer.toString(sum));
     out.println();
     }
     out.flush();
     out.close();
     }
 }
",1
98,3684,"package com.meituan.tests.algorithms.gcj2014;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class DataPacking1 {
 
     public static void main(String[] args) throws Exception {
         File folder=new File(""/Users/zms/Downloads/"");
         System.out.println(folder.exists());
         File input=new File(folder,""A-large.in"");
         File output=new File(folder,""A-large.out"");
         int[] b1=new int[701];
         try(Scanner scanner=new Scanner(new FileInputStream(input))) {
             try(PrintWriter writer=new PrintWriter(new FileOutputStream(output))) {
                 int T = scanner.nextInt();
                 for (int a1 = 0; a1 < T; a1++) {
                     for(int i=1;i<=700;i++) {
                         b1[i]=0;
                     }
                     int N = scanner.nextInt();
                     int X = scanner.nextInt();
                     int n;
                     for (int i = 0; i < N; i++) {
                         n = scanner.nextInt();
                         b1[n]++;
                     }
                     int k = 0;
                     for(int i=700;i>=1;i--) {
                         if(b1[i]>0) {
                             int b2=Math.min(X-i,i);
                             for(int j=b2;j>=1;j--) {
                                 while(b1[j]>0 && b1[i]>0) {
                                     if(i==j && b1[i]==1) {
                                         break;
                                     }
                                     b1[i]--;
                                     b1[j]--;
                                     k++;
                                 }
                                 if(b1[i]<=0) {
                                     break;
                                 }
                             }
                             assert b1[i]>=0;
                             k+=b1[i];
                             b1[i]=0;
                         }
                     }
                     writer.printf(""Case #%d: %d\n"",a1+1,k);
                 }
             }
         }
     }
 
 }
","package com.meituan.tests.topcoder.jam2013;
 
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class ManyPrizes {
 
     public int[] cal(int n, int p) {
         int k = (int) Math.pow(2, n);
         final int[] ints1 = new int[k];
         int a = 0;
         int index = 0;
         ints1[index++] = a;
         int b = n;
         int e = k - 1;
         while (true) {
             b--;
             int c = (int) Math.pow(2, b);
             int d = 2 * a + 1;
             for (int i = 0; i < c; i++) {
                 ints1[index++] = d;
             }
             a = d;
             if (index >= k) {
                 break;
             }
         }
         /*for (int n1 : ints1) {
             System.out.println(n1);
         }*/
         final int[] ints2 = new int[k];
         for (int i = 0; i < k; i++) {
             ints2[k - i - 1] = e - ints1[i];
         }
         /*System.out.println(""--"");
         for (int n1 : ints2) {
             System.out.println(n1);
         }*/
         int[] results = new int[2];
         for (int i = 0; i < k; i++) {
             if (ints2[i] < p) {
                 results[0] = i;
             }
             if (ints1[i] < p) {
                 results[1] = i;
             }
         }
         return results;
     }
 
     public static void main(String[] args) throws Exception {
         ManyPrizes test = new ManyPrizes();
         //test.test();
         File file = new File(""/Users/zms/Downloads/B-small-attempt0.in"");
         System.out.println(file.exists());
         try (Scanner scanner = new Scanner(new FileReader(file))) {
             File out = new File(file.getParentFile(), ""a.dat"");
             try (PrintWriter writer = new PrintWriter(out)) {
                 int count = scanner.nextInt();
                 for (int i = 0; i < count; i++) {
                     int N = scanner.nextInt();
                     int M = scanner.nextInt();
                     int[] results=test.cal(N,M);
                     writer.printf(""Case #%d: %d %d\n"", i+1,results[0],results[1]);
                 }
                 writer.flush();
             }
         }
     }
 
 }
",1
99,6573,"import java.io.*;
 import java.util.*;
 import java.math.BigInteger;
 
 
 public class A{
 	public static void main(String[] args) throws IOException{
 		BufferedReader br = new BufferedReader(new FileReader(""in.txt""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""out.txt""));
 
 		long mod = 1000002013;
 
 		int T = Integer.parseInt(br.readLine());
 
 		for(int t = 1; t <= T; t++) {
 			String[] s = br.readLine().split("" "");
 			int N = Integer.parseInt(s[0]);
 			int M = Integer.parseInt(s[1]);
 
 			long[][] info = new long [M][3];
 
 			HashSet<Long> set = new HashSet<Long>();
 
 			long ret = 0;
 
 			for(int i = 0; i < M; i++) {
 				s = br.readLine().split("" "");
 				info[i][0] = Long.parseLong(s[0]);
 				info[i][1] = Long.parseLong(s[1]);
 				info[i][2] = Long.parseLong(s[2]);
 
 				set.add(info[i][0]);
 				set.add(info[i][1]);
 
 				ret += cost(info[i][0], info[i][1],N) * (info[i][2] % mod);
 				ret %= mod;
 			}
 
 			int K = set.size();
 
 			long[] times = new long[K];
 			int j = 0;
 			for(long l : set) {
 				times[j] = l;
 				j++;
 			}
 
 
 			Arrays.sort(times);
 
 			long[] enter = new long[K];
 			long[] exit = new long[K];
 
 
 			for(int i = 0; i < M; i++) {
 				j = Arrays.binarySearch(times, info[i][0]);
 				enter[j] += info[i][2];
 				j = Arrays.binarySearch(times, info[i][1]);
 				exit[j] += info[i][2];
 			}
 
 
 			long[] left = new long[K];
 
 			System.out.println(ret);
 
 			for(int i = 0; i < K; i++) {
 				left[i] = enter[i];
 
 				long exiting = exit[i];
 
 				j = i;
 				while(exiting > 0) {
 					if(left[j] > 0) {
 						if(left[j] >= exiting) {
 							System.out.println(i + "" "" + j + ""  "" + left[j] + ""   "" + exiting + ""~"");
 							left[j] -= exiting;
 							ret -= cost(times[j],times[i],N) * (exiting % mod);
 							ret %= mod;
 							exiting = 0;
 						} else {
 							System.out.println(i + "" "" + j + ""  "" + left[j] + ""   "" + exiting + ""~~"");
 							ret -= cost(times[j],times[i],N) * (left[j] % mod);
 							ret %= mod;
 							exiting -= left[j];
 							left[j] = 0;
 						}
 					}
 					j--;
 				}
 			}
 
 			if(ret < 0) ret += mod;
 			pw.println(""Case #"" + t + "": "" + ret);
 			System.out.println(""~~~~~~~~~~~~~~~"");
 		}
 
 
 		pw.flush();
 		pw.close();
 	}
 
 	public static long cost(long x, long y, long N) {
 		long b = N;
 		long a = y-x;
 
 		long mod = 1000002013;
 
 		long ret = b;
 		ret *= (b+1);
 		ret /= 2;
 		ret %= mod;
 
 		long t = a;
 		t *= (a+1);
 		t /= 2;
 		t %= mod;
 
 		ret -= t;
 
 		ret %= mod;
 
 		return ret;
 
 
 
 	}
 
 }","import java.io.*;
 import java.util.*;
 
 public class D{
 	public static long mod = 1000000007;
 
 	public static void main(String[] args) throws IOException{
 		BufferedReader br = new BufferedReader(new FileReader(""in.txt""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""out.txt""));
 
 		int N2 = Integer.parseInt(br.readLine());
 
 		for(int p = 0; p < N2; p++) {
 			String[] s = br.readLine().split("" "");
 			int N = Integer.parseInt(s[1]);
 			int M = Integer.parseInt(s[0]);
 
 			String[] v = new String[M];
 			for(int i = 0; i < M; i++) {
 				v[i] = br.readLine();
 			}
 
 			long max = 0;
 			long num = 0;
 
 			long tot = 1;
 			for(int i = 0; i < M; i++) tot *= N;
 
 			Lp: for(long k = 0; k < tot; k++) {
 				HashSet<?>[] ss = new HashSet<?>[N];
 				for(int i = 0; i < N; i++) ss[i] = new HashSet<String>();
 				long c = k;
 				for(int i = 0; i < M; i++) {
 					((HashSet<String>)ss[(int)(c%N)]).add(v[i]);
 					c/=N;
 				}
 				long ans = 0;
 				for(int i = 0; i < N; i++) {
 					if(ss[i].size() == 0) continue Lp;
 					ans += count(((HashSet<String>)ss[i]));
 				}
 
 				if(ans > max) {
 					max = ans;
 					num = 1;
 				} else if (ans == max) {
 					num++;
 					num %= mod;
 				}
 			}
 
 			pw.println(""Case #"" + (p+1) + "": "" + max + "" "" + (num % mod));
 		}
 
 
 		pw.flush();
 		pw.close();
 
 	}
 
 
 	public static int count(HashSet<String> st) {
 		HashSet<String> p = new HashSet<String>();
 		for(String s : st) {
 			for(int i = 0; i <= s.length(); i++) {
 				p.add(s.substring(0,i));
 			}
 		}
 		return p.size();
 	}
 }",1
100,6910,"package y2013.q;
 import static java.util.Arrays.deepToString;
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.util.Scanner;
 
 public class A {
 	Scanner sc = new Scanner(System.in);
 	char [][] grid = new char[4][4];
 	boolean dotFound = false;
 	void read() {
 		dotFound = false;
 		for (int i = 0; i < grid.length; i++) {
 			String line = sc.nextLine();
 			for (int j = 0; j < grid.length; j++) {
 				grid[i][j] = line.charAt(j);
 				if(grid[i][j] == '.') dotFound = true;
 			}
 		}
 		sc.nextLine();
 	}
 
 	void solve() {
 		boolean xWon = false;
 		boolean yWon = false;
 		// Check lines
 		for (int i = 0; i < grid.length; i++) {
 			int x = 0;
 			int y = 0;
 			for (int j = 0; j < grid.length; j++) {
 				if(grid[i][j] == 'X') x++;
 				if(grid[i][j] == 'O') y++;
 				if(grid[i][j] == 'T') {
 					x++; y++;
 				}
 			}
 			if(x == 4) xWon = true;
 			if(y == 4) yWon = true;
 		}
 		// Check columns
 		for (int i = 0; i < grid.length; i++) {
 			int x = 0;
 			int y = 0;
 			for (int j = 0; j < grid.length; j++) {
 				if(grid[j][i] == 'X') x++;
 				if(grid[j][i] == 'O') y++;
 				if(grid[j][i] == 'T') {
 					x++; y++;
 				}
 			}
 			if(x == 4) xWon = true;
 			if(y == 4) yWon = true;
 		}
 		// Check diagonals
 
 			int x = 0;
 			int y = 0;
 			for (int j = 0; j < grid.length; j++) {
 				if(grid[j][j] == 'X') x++;
 				if(grid[j][j] == 'O') y++;
 				if(grid[j][j] == 'T') {
 					x++; y++;
 				}
 			}
 			if(x == 4) xWon = true;
 			if(y == 4) yWon = true;
 			
 			x = 0;
 			y = 0;
 			int rev = 3;
 			for (int j = 0; j < grid.length; j++) {
 				if(grid[j][rev] == 'X') x++;
 				if(grid[j][rev] == 'O') y++;
 				if(grid[j][rev] == 'T') {
 					x++; y++;
 				}
 				rev--;
 			}
 			if(x == 4) xWon = true;
 			if(y == 4) yWon = true;
 			
 			if(xWon) {
 				System.out.println(""X won"");
 			} else if(yWon) {
 				System.out.println(""O won"");
 			} else if(!dotFound) {
 				System.out.println(""Draw"");
 			} else {
 				System.out.println(""Game has not completed"");
 			}
 	}
 	
 	void display() {
 		for (int i = 0; i < grid.length; i++) {
 			for (int j = 0; j < grid.length; j++) {
 				System.out.print(grid[i][j]);
 			}
 			System.out.println();
 		}
 	}
 
 	void run() {
 		int caseN = sc.nextInt();
 		sc.nextLine();
 		for (int caseID = 1; caseID <= caseN; caseID++) {
 			read();
 			System.out.printf(""Case #%d: "", caseID);
 			solve();
 			System.out.flush();
 		}
 	}
 
 	void debug(Object... os) {
 		System.err.println(deepToString(os));
 	}
 
 	public static void main(String[] args) {
 		try {
 			System.setIn(new BufferedInputStream(new FileInputStream(
 					args.length > 0 ? args[0] : (A.class.getName() + "".in""))));
 		} catch (Exception e) {
 		}
 		new A().run();
 	}
 }
","package y2013.Round1B;
 
 import static java.util.Arrays.deepToString;
 import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.PriorityQueue;
 import java.util.Scanner;
 import java.util.TreeSet;
 /**
  * 
  * @author PierreB
  * Notes:
  */
 public class A {
 	final String ROUND = ""Round1B"";
 
 	int size, N, max;
 	ArrayList<Integer> motes;
 	void read(Scanner sc) {
 		size = sc.nextInt();
 		N = sc.nextInt();
 		motes = new ArrayList<Integer>();
 		for (int i = 0; i < N; i++) {
 			motes.add( sc.nextInt() );
 		}
 		Collections.sort(motes);
 	}
 	// Check that it is solvable;
 	void solve() {
 		int operations = 0;
 		int altops = 0;
 		boolean alUsed = false;
 		int total = size;
 		while(total <= motes.get(motes.size()-1)) {
 			// try adding a mote just smaller
 			int curr = motes.get(0);
 			if(curr < total) {
 				total += curr;
 				motes.remove(0);
 			} else if(curr >= total + total -1 && !alUsed){
 				altops += motes.size();
 				alUsed = true;
 			} else  {
 				operations++;
 
 				if(!alUsed) {
 					altops++;					
 				} else {
 					if(operations > altops) {
 						break;
 					}
 				}
 				total += total-1;
 			}
 			// try removing one larger
 		}
 		int fin = operations;
 		if(alUsed) {
 			fin = Math.min(operations, altops);
 		}
 		System.out.println(fin);
 	}
 	
 	// EXTRA METHODS
 
 	void run() throws FileNotFoundException {
 		Scanner sc = new Scanner(new File(""y2013/""+ROUND+""/a.in""));
 		int caseN = sc.nextInt();
 		for (int caseID = 1; caseID <= caseN; caseID++) {
 			read(sc);
 			System.out.printf(""Case #%d: "", caseID);
 			solve();
 			System.out.flush();
 		}
 	}
 
 	void debug(Object... os) {
 		System.err.println(deepToString(os));
 	}
 
 	public static void main(String[] args)  {
 		try {
 			new A().run();
 		} catch (FileNotFoundException e) {
 			System.out.println(e.getMessage());
 			System.out.println(System.getProperty(""user.dir""));
 		}
 	}
 }
",1
101,11876,"package qualification;
 
 import java.io.*;
 import java.util.*;
 
 public class problema {
 	private BufferedReader reader;
 	private BufferedWriter writer;
 	
 	private class button{
 		char a;
 		int pos;
 		public button(char _a, int _pos){
 			this.a = _a;
 			this.pos = _pos;
 		}
 	}
 	
 	public boolean Load(){
 		try{
 			reader = new BufferedReader(new FileReader(""A-large.in""));
 			writer = new BufferedWriter(new FileWriter(""A-large.out""));
 		}
 		catch(IOException ex){
 			ex.printStackTrace();
 			return false;
 		}
 		return true;
 	}
 	
 	public int solvecase(String line){
 		int ret = 0;
 		int poso = 1, posb = 1;
 		int nexto = 0, netxb = 0;
 		
 		
 		String[] strs = line.split("" "");
 		int N = Integer.parseInt(strs[0]); 
 		button[] btns = new	button[N];
 		for(int i = 1; i <= N; ++i){
 			int tmp = Integer.parseInt(strs[2 * i]);			
 			btns[i - 1] = new button(strs[2*i - 1].charAt(0), tmp);
 		}
 		
 		char curr;
 		for(int i = 0; i < N; ++i){
 			curr = btns[i].a;
 			int j = i + 1;
 			if('O' == curr){ // O move
 				while(j < N && btns[j].a != 'B') ++j;
 				int dis = poso < btns[i].pos ? btns[i].pos - poso : poso - btns[i].pos;
 				ret += dis + 1;
 				poso = btns[i].pos;
 				if(j != N){
 					boolean flag = btns[j].pos < posb;
 					int disTmp = flag ? posb - btns[j].pos : btns[j].pos - posb;
 					if(disTmp < dis + 1)
 						posb = btns[j].pos;
 					else{
 						if(flag)
 							posb -= dis + 1;
 						else
 							posb += dis + 1;
 					}
 				}
 			}
 			else{ //B move
 				while(j < N && btns[j].a != 'O') ++j;
 				int dis = posb < btns[i].pos ? btns[i].pos - posb : posb - btns[i].pos;
 				ret += dis + 1;
 				posb = btns[i].pos;
 				if(j != N){
 					boolean flag = btns[j].pos < poso;
 					int disTmp = flag ? poso - btns[j].pos : btns[j].pos - poso;
 					if(disTmp < dis + 1)
 						poso = btns[j].pos;
 					else{
 						if(flag)
 							poso -= dis + 1;
 						else
 							poso += dis + 1;
 					}
 				}
 			}
 		}
 		
 		return ret;
 	}
 	
 	public void solve(){
 		try{
 			Load();
 			int T = Integer.parseInt(reader.readLine());
 			for(int i = 0; i < T; ++i){
 				int ret = solvecase(reader.readLine());
 				
 				String s = String.format(""Case #%d: %d\n"", i + 1, ret);
 				System.out.print(s);
 				writer.write(s);
 				writer.flush();
 			}
 		}
 		catch(IOException ex)		{
 			ex.printStackTrace();
 		}	
 	}
 	
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		problema p = new problema();
 		p.solve();
 		//System.out.println(p.solvecase(""4 O 2 B 1 B 2 O 4""));
 	}
 
 }
","import java.util.Scanner;
 
 public class A {
 	
 	public static void main(String[] args) {
 		
 		Scanner in = new Scanner(System.in);
 		
 		int T = in.nextInt(); in.nextLine();
 		
 		String mapping = ""yhesocvxduiglbkrztnwjpfmaq"";
 		
 		for (int i = 1; i <= T; i++)
 		{
 			String line = in.nextLine();
 			
 			String translation = """";
 			
 			for (int j = 0; j < line.length(); j++)
 			{
 				char character = line.charAt(j);
 				
 				if (character == ' ')
 					translation += ' ';
 				else
 					translation += mapping.charAt(character - 'a');
 			}
 			
 			System.out.format(""Case #%d: %s\n"", i, translation);
 		}
 	}
 }",0
102,10416,"import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 
 public class A {
 	
 	public long solve(BufferedReader in) throws IOException {
 		String[] line = in.readLine().split("" "");
 		char[] s = line[0].toCharArray(); int n = Integer.parseInt(line[1]);
 		int[] run = new int[s.length];
 		run[s.length - 1] = vow[s[s.length-1]] ? 0 : 1;
 		for (int i = s.length - 2; i >= 0; i--) {
 			if (vow[s[i]]) {
 				run[i] = 0;
 			} else {
 				run[i] = run[i+1]+1;
 			}
 		}
 		
 		long total = 0;
 		int lastStart = 0;
 		for (int i = 0; i < s.length; i++) {
 			if (run[i] >= n) {
 				total += s.length - (i+n-1);
 				if (lastStart < i) {
 					total += (s.length - (i+n-1)) * (i - lastStart);
 				}
 				lastStart = i + 1;
 			}
 		}
 		return total;
 	}
 	
 	public static boolean vow[];
 	
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		vow = new boolean[300];
 		for (char c : new char[]{'a', 'e', 'i', 'o', 'u'}) { 
 			vow[(int)c] = true;
 		}
 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 		int T = Integer.parseInt(in.readLine());
 		for (int iT = 1; iT <= T; iT++) {
 			long res = new A().solve(in);
 			System.out.println(""Case #"" + iT + "": "" + res);
 		} 
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class Main {
 
 	public static int findX(int x, int y, int z, int score)
 	{
 		int a = -1;
 		
 		a = (score - x-y-z)/3;
 		if(a+x + a+y + a+z == score)
 			return a+x;
 		else
 			return -1;
 	}
 	
 	public static int findValid(int score, int max) {
 		int x=-1, y=-1,z=-1;
 		int evalid = 0;
 		/*Case: x x x*/
 		if( (x = findX(0,0,0, score))!= -1 && evalid != 2)
 		{
 			y=z=x;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 	
 		/*Case: x x x+1*/
 		if( (x = findX(0,0,1, score))!= -1 && evalid !=2)
 		{
 			y=x;
 			z=x+1;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 		
 		/*Case: x x+1 x+1*/
 		if( (x = findX(0,1,1, score))!= -1 && evalid != 2)
 		{
 			y=x+1;
 			z=x+1;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 		return evalid;
 	}
 	
 	public static int findSurprised(int score, int max) {
 		int x=-1, y=-1,z=-1;
 		int evalid = 0;
 		/*Case: x x x+2*/
 		if( (x = findX(0,0,2, score))!= -1 && evalid != 2)
 		{
 			y=x;
 			z=x+2;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 	
 		/*Case: x x+1 x+2*/
 		if( (x = findX(0,1,2, score))!= -1 && evalid !=2)
 		{
 			y=x+1;
 			z=x+2;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 		
 		/*Case: x x+2 x+2*/
 		if( (x = findX(0,2,2, score))!= -1 && evalid != 2)
 		{
 			y=x+2;
 			z=x+2;
 			if(z >= max)
 				evalid = 2;
 			else
 				evalid = 1;
 		}
 		return evalid;
 	}
 	
 	public static void fillOptions(int[] scores, int[] valid, int[]surprised, int max )
 	{
 		for(int i = 0; i< scores.length; i++)
 		{
 			valid[i] = findValid(scores[i], max);
 			surprised[i] = findSurprised(scores[i], max);
 			valid[i] = valid[i]*10 + surprised[i];
 		}
 	}
 	
 	public static int findNextSerprised(int[] valid)
 	{
 		int val =0;
 		Arrays.sort(valid);
 		int index = Arrays.binarySearch(valid, 2);
 		if(index < 0)
 			index = Arrays.binarySearch(valid, 12);
 		if(index < 0)
 			index = Arrays.binarySearch(valid, 22);
 		if(index < 0)
 			index = Arrays.binarySearch(valid, 01);
 		if(index < 0)
 			index = Arrays.binarySearch(valid, 11);
 		if(index < 0)
 			index = Arrays.binarySearch(valid, 21);
 		if(index >= 0)
 		{
 			val = valid[index];
 			valid[index] = 0;
 		}
 		return val;
 	}
 	
 	public static void runCase (int[] scores, int S, int max, int caseNum)
 	{
 		int[] valid = new int[scores.length];
 		int[] surprised = new int[scores.length];
 		int count =0;
 		fillOptions(scores, valid, surprised, max);
 		for(int i =0; i< S; i++)
 		{
 			int val = findNextSerprised(valid);
 			if(val%10 == 2)
 				count++;
 		}
 		for(int i=0; i< scores.length; i++)
 			if(valid[i] >= 20)
 				count++;
 		System.out.print(""Case #"" +caseNum + "": ""+ count + ""\n"");
 	}
 	
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		if(args.length != 1)
 		{
 			System.out.print(""Please enter file name!\n"");
 			return;
 		}
 		File fileName = new File(args[0]);
 	    Scanner inFile = new Scanner(fileName);
 	    int T = inFile.nextInt();
 		for(int i=0; i < T; i++)
 		{
 			int N = inFile.nextInt();
 			int S = inFile.nextInt();
 			int max = inFile.nextInt();
 			
 			int[] scores = new int[N];
 			for(int j=0; j<N; j++)
 				scores[j]=inFile.nextInt();
 			
 			runCase(scores, S, max, i+1);	
 		}
 		
 		
 	}
 
 }
",0
103,565,"import java.util.*;
 import java.io.*;
 
 public class codejam4{
 	public static void main(String[] args) throws IOException{
 		Scanner sc = new Scanner(new FileReader(""D-small-attempt0.in""));
 		BufferedWriter write = new BufferedWriter(new FileWriter(""output.txt""));
 
 		int caseN = sc.nextInt();
 		sc.nextLine();
 		String[] allCase = new String[caseN];
 
 		int win = 0;
 		int dwin = 0;
 
 		ArrayList<Float> naomi,naomi_temp,ken,ken_temp;
 		int time;
 		boolean pop = false;
 
 		for(int icase=0;icase<caseN;icase++){
 			time = sc.nextInt();
 			sc.nextLine();
 			naomi = new ArrayList<Float>();
 			ken = new ArrayList<Float>();
 
 			for(int round=0;round<time;round++)
 				naomi.add(sc.nextFloat());
 			for(int round=0;round<time;round++)
 				ken.add(sc.nextFloat());
 
 			naomi_temp = new ArrayList<Float>(naomi);
 			ken_temp = new ArrayList<Float>(ken);
 
 			Collections.reverse(naomi);
 			Collections.sort(ken,Collections.reverseOrder());
 
 			for(int chk=time-1;chk>=0;chk--){
 				for(int j=chk;j>=0 && !pop;j--){
 					if(ken.get(j)>naomi.get(chk)){
 						naomi.remove(chk);
 						ken.remove(j);
 						pop = true;
 					}
 					else if(ken.get(0) < naomi.get(chk)){
 						naomi.remove(chk);
 						ken.remove(chk);
 						pop = true;
 						win++;
 					}
 				}
 				pop = false;
 			}
 
 			pop=false;
 
 			naomi = new ArrayList<Float>(naomi_temp);
 			ken = new ArrayList<Float>(ken_temp);
 
 
 			Collections.sort(naomi,Collections.reverseOrder());
 			Collections.sort(ken);
 
 			for(int chk=time-1;chk>=0;chk--){
 				for(int k=chk;k>=0 && !pop;k--){
 					if(naomi.get(chk)>ken.get(k)){
 						naomi.remove(chk);
 						ken.remove(k);
 						pop=true;
 						dwin++;
 					}
 					else if(k==0 && naomi.get(chk)<ken.get(k)){
 						naomi.remove(chk);
 						ken.remove(chk);
 						pop=true;
 					}
 
 				}
 				pop = false;
 				//System.out.println(naomi+""\n""+ken);
 			}
 			allCase[icase] = ""Case #""+(icase+1)+"": ""+dwin+"" ""+win;
 			//System.out.println(dwin +"", ""+win);
 
 			win=0;
 			dwin=0;
 		}
 
 
 		for(int i=0;i<allCase.length;i++){
 			//System.out.println(allCase[i]);
 			write.append(allCase[i]+""\n"");
 		}
 		write.close();
 
 	}
 
 }","package codejam.round1.bottrust;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class BotTrust {
 	public static void main(String[] args) {
 		/* FOR ECLIPSE USE ONLY */
 		/*
 		try {
 			System.setIn(new FileInputStream(""./src/codejam/round1/bottrust/A-large.in""));
 		} catch(FileNotFoundException fnfe) {
 			System.err.println(""File not found! Using standard input."");
 		}
 		*/
 		/* END ECLIPSE CODE */
 		
 		Scanner in = new Scanner(System.in);
 		
 		// get test cases
 		int N = Integer.parseInt(in.nextLine());
 		for(int n = 0;n < N; ++n) {
 			String[] splitLine = in.nextLine().split("" "");
 			int totalButtons = Integer.parseInt(splitLine[0]);
 			int[] buttonLocations = new int[totalButtons];
 			char[] bots = new char[totalButtons];
 			for(int i = 1; i < splitLine.length; i+=2) {
 				bots[i/2] = splitLine[i].charAt(0);
 				buttonLocations[i/2] = Integer.parseInt(splitLine[i+1])-1; // - 1 to zero base the buttons
 			}
 			int bluePtr = -1, orangePtr = -1;
 			for(int i = 0; i < bots.length; ++i) {
 				if(bots[i] == 'B' && bluePtr == -1)
 					bluePtr = i;
 				if(bots[i] == 'O' && orangePtr == -1)
 					orangePtr = i;
 			}
 			int blueLoc = 0, orangeLoc = 0;
 			int time = 0;
 			//boolean blueCanMove = true, orangeCanMove = true;
 			boolean blueDone = false, orangeDone = false;
 			if(bluePtr == -1)
 				blueDone = true;
 			if(orangePtr == -1)
 				orangeDone = true;
 			char activeBot = bots[0];
 			while(!blueDone || !orangeDone) {
 				time++;
 				activeBot = orangePtr < bluePtr ? 'O' : 'B';
 				if(blueDone) activeBot = 'O';
 				if(orangeDone) activeBot = 'B';
 				if(activeBot == 'B') {
 					// can blue press the button?
 					if(blueLoc == buttonLocations[bluePtr]) {
 						// if we can, press the button and move the ptr
 						buttonLocations[bluePtr] = -1;
 						boolean ptrSet = false;
 						for(int i = bluePtr+1; i < bots.length; ++i) {
 							if(bots[i] == 'B') {
 								ptrSet = true;
 								bluePtr = i;
 								break;
 							} 
 						}
 						if(!ptrSet)
 							blueDone = true;
 					} else {
 						// if we can not press the button, move toward it
 						if(blueLoc > buttonLocations[bluePtr])
 							blueLoc--;
 						else if(blueLoc < buttonLocations[bluePtr])
 							blueLoc++;
 					}
 					// now try and move orange if we can
 					if(!orangeDone) {
 						if(orangeLoc > buttonLocations[orangePtr])
 							orangeLoc--;
 						else if(orangeLoc < buttonLocations[orangePtr])
 							orangeLoc++;
 					}
 				} else {
 					// orangeLoc orange press the button?
 					if(orangeLoc == buttonLocations[orangePtr]) {
 						// if we can, press the button and move the ptr
 						buttonLocations[orangePtr] = -1;
 						boolean ptrSet = false;
 						for(int i = orangePtr+1; i < bots.length; ++i) {
 							if(bots[i] == 'O') {
 								ptrSet = true;
 								orangePtr = i;
 								break;
 							}
 						}
 						if(!ptrSet)
 							orangeDone = true;
 					} else {
 						// if we can not press the button, move toward it
 						if(orangeLoc > buttonLocations[orangePtr]) 
 							orangeLoc--;
 						else if(orangeLoc < buttonLocations[orangePtr])
 							orangeLoc++;
 					}
 					// now try and move blue if we can
 					if(!blueDone) {
 						if(blueLoc > buttonLocations[bluePtr])
 							blueLoc--;
 						else if(blueLoc < buttonLocations[bluePtr])
 							blueLoc++;
 					}
 				}
 			}
 			System.out.printf(""Case #%d: %d\n"",n+1,time);
 		}
 	}
 }",0
104,14374,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.LinkedList;
 
 
 public class Problem {
 	
 	public static final String NAME = ""A-large"";
 	
 	public static void main(String args[]) throws FileNotFoundException{
 		Scanner in = new Scanner(new File(NAME + "".in""));
 		PrintWriter out = new PrintWriter(new File(NAME + "".out""));
 		writeSolution(in, out);
 		out.close();
 	}
 	
 	private static void writeSolution(Scanner in, PrintWriter out){
 		int cases = in.nextInt();
 		for (int cas = 0; cas<cases ; cas++){
 			String answer = ""Case #"" + (cas + 1) + "": "" + compute(in);
 			out.println(answer);
 			System.out.println(answer);
 		}
 	}
 	
 	private static int compute(Scanner in){
 		int commands = in.nextInt();
 		int opos = 1;
 		int bpos = 1;
 		int turn = 0;
 		LinkedList<Integer> bcommands = new LinkedList<Integer>();
 		LinkedList<Integer> ocommands = new LinkedList<Integer>();
 		LinkedList<Boolean> bturn = new LinkedList<Boolean>();
 		//read in commands
 		for (int com = 0; com<commands; com++){
 			if (in.next().equals(""B"")){
 				bturn.offer(true);
 				bcommands.offer(in.nextInt());
 			} else {
 				bturn.offer(false);
 				ocommands.offer(in.nextInt());
 			}
 		}
 		while(!bturn.isEmpty()){
 			if (bcommands.peek() != null && bpos == bcommands.peek()){
 				if (bturn.peek()){
 					bcommands.poll();
 					bturn.poll();
 					if (ocommands.peek() != null){
 						if (ocommands.peek() > opos){
 							opos++;
 						} else if (ocommands.peek() < opos){
 							opos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			if (ocommands.peek() != null && opos == ocommands.peek()){
 				if (!bturn.peek()){
 					ocommands.poll();
 					bturn.poll();
 					if (bcommands.peek() != null){
 						if (bcommands.peek() > bpos){
 							bpos++;
 						} else if (bcommands.peek() < bpos){
 							bpos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			int bdistance = Math.abs((bcommands.peek() == null ? bpos : bcommands.peek()) - bpos);
 			int odistance = Math.abs((ocommands.peek() == null ? opos : ocommands.peek()) - opos);
 			
 			if (bdistance == 0 || odistance == 0){
 				if (bdistance > 0){
 					bpos = bcommands.peek();
 					turn = turn + bdistance; 
 				} else {
 					opos = ocommands.peek();
 					turn = turn + odistance;
 				}
 			} else
 			//if both are not 0
 			if (bdistance > odistance){
 				if (bcommands.peek() > bpos){
 					bpos = bpos + odistance;
 				} else {
 					bpos = bpos - odistance;
 				}
 				opos = ocommands.peek();
 				turn = turn + odistance;
 			} else {
 				if (ocommands.peek() > opos){
 					opos = opos + bdistance;
 				} else {
 					opos = opos - bdistance;
 				}
 				bpos = bcommands.peek();
 				turn = turn + bdistance;
 			}
 		}
 		
 		return turn;
 	}
 }
","import java.util.ArrayList;
 import java.util.Scanner;
 
 
 public class runner {
 
 	/**
 	 * @param args
 	 */
 	private static Scanner sc = new Scanner(System.in);
 	
 	public static void main(String[] args) {
 		long count = inputRows();
 		ArrayList<Long> counts = new ArrayList<Long>();
 		for (long i=0;i<count;i++){
 			long start = inputStart();
 			long end = inputEnd();
 			counts.add(checkRange(start,end));
 			
 		}
 		output(counts);
 	}
 	
 	private static long inputEnd() {
 		Long end = sc.nextLong();
 		sc.nextLine();
 		return end;
 	}
 
 	private static long inputStart() {
 		return sc.nextLong();
 	}
 
 	private static long inputRows() {
 		Long rows = sc.nextLong();
 		sc.nextLine();
 		return rows;
 	}
 
 	private static void output(ArrayList<Long> counts) {
 		int i=1;
 		for (Long long1 : counts) {
 			System.out.println(""Case #""+i+++"": ""+long1);
 		}
 		
 	}
 
 	private static long checkRange(long start,long end){
 		long count =0;
 		long trueStart = Math.round(Math.ceil(Math.sqrt(start)));
 		long trueEnd = Math.round(Math.floor(Math.sqrt(end)));
 		for (long subject =trueStart;subject<(trueEnd+1);subject++){
 			if (checkRoot(subject)){
 				count++;
 			}
 		}
 		return count;
 	}
 	
 	private static boolean checkRoot(long subject){
 		return (checkPalendrome(subject)&& checkPalendrome(subject*subject));
 	}
 
 	private static boolean checkPalendrome(long subject) {
 		 ArrayList<Long> digits = digitize(subject);
 		 return checkOppositeDigits(digits);
 	}
 
 	private static boolean checkOppositeDigits(ArrayList<Long> digits) {
 		while (digits.size()>1){
 			 long last = digits.remove(digits.size()-1);
 			 long first = digits.remove(0);
 			 if (!(last ==first)){
 				 return false;
 			 }
 		 }
 		return true;
 	}
 
 	private static ArrayList<Long> digitize(long subject) {
 		ArrayList<Long> digits = new ArrayList<Long>();
 		 while (subject > 0) {
 		     digits.add(subject%10);
 		     subject/=10;
 		 }
 		return digits;
 	}
 
 }
",0
105,20105,"package googleCodeJam2011;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class BotTrust {
 
 	public static void main(String[] args) throws Exception {
 		
 		BufferedReader f = new BufferedReader(new FileReader(""Google Code Jam 2011\\A-large.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""Google Code Jam 2011\\A-large.out"")));
 		StringTokenizer st = new StringTokenizer(f.readLine());
 		
 		int T = Integer.parseInt(st.nextToken());
 		
 		for(int i = 1; i <= T; i++)
 		{
 			st = new StringTokenizer(f.readLine());
 			
 			int N = Integer.parseInt(st.nextToken());
 			
 			boolean[] whosTurn = new boolean[N]; //true if blue, false if orange
 			int[] orangeSwitches = new int[N];
 			int[] blueSwitches = new int[N];
 			int orangeCounter = 0;
 			int blueCounter = 0;
 			
 			for(int j = 0; j < N; j++)
 			{
 				char who = st.nextToken().charAt(0);
 				if (who == 'O')
 				{
 					orangeSwitches[orangeCounter++] = Integer.parseInt(st.nextToken());
 					whosTurn[j] = false;
 				} else
 				{
 					blueSwitches[blueCounter++] = Integer.parseInt(st.nextToken());
 					whosTurn[j] = true;
 				}
 			}
 			
 			int orangePosition = 1;
 			int bluePosition = 1;
 //			int maxOrange = orangeCounter;
 //			int maxBlue = blueCounter;
 			orangeCounter = 0;
 			blueCounter = 0;
 			int time = 0;
 			for(int j = 0; j < N; j++)
 			{
 				if (!whosTurn[j])
 				{
 					int dOrange = 0;
 					if (orangeSwitches[orangeCounter] < orangePosition)
 					{
 						dOrange = orangePosition - orangeSwitches[orangeCounter];
 						orangePosition = orangeSwitches[orangeCounter];
 					} else if (orangeSwitches[orangeCounter] > orangePosition)
 					{
 						dOrange = orangeSwitches[orangeCounter] - orangePosition;
 						orangePosition = orangeSwitches[orangeCounter];
 					}
 					dOrange++;
 					if (blueSwitches[blueCounter] < bluePosition)
 					{
 						bluePosition = dOrange < bluePosition - blueSwitches[blueCounter] ? bluePosition - dOrange : blueSwitches[blueCounter];
 					} else if (blueSwitches[blueCounter] > bluePosition)
 					{
 						bluePosition = dOrange < blueSwitches[blueCounter] - bluePosition ? bluePosition + dOrange : blueSwitches[blueCounter];
 					}
 					time += dOrange;
 					orangeCounter++;
 				} else
 				{
 					int dBlue = 0;
 					if (blueSwitches[blueCounter] < bluePosition)
 					{
 						dBlue = bluePosition - blueSwitches[blueCounter];
 						bluePosition = blueSwitches[blueCounter];
 					} else if (blueSwitches[blueCounter] > bluePosition)
 					{
 						dBlue = blueSwitches[blueCounter] - bluePosition;
 						bluePosition = blueSwitches[blueCounter];
 					}
 					dBlue++;
 					if (orangeSwitches[orangeCounter] < orangePosition)
 					{
 						orangePosition = dBlue < orangePosition - orangeSwitches[orangeCounter] ? orangePosition - dBlue : orangeSwitches[orangeCounter];
 					} else if (orangeSwitches[orangeCounter] > orangePosition)
 					{
 						orangePosition = dBlue < orangeSwitches[orangeCounter] - orangePosition ? orangePosition + dBlue : orangeSwitches[orangeCounter];
 					}
 					time += dBlue;
 					blueCounter++;
 				}
 			}
 			String result = ""Case #"" + i + "": "" + time;
 			
 			System.out.println(result);
 			out.println(result);
 		}
 		
 		out.close();
 	}
 }
","import static java.util.Arrays.*;
 import static java.lang.Math.*;
 import static java.math.BigInteger.*;
 import java.util.*;
 import java.math.*;
 import java.io.*;
 
 public class B implements Runnable
 {
 	String file = ""B-large"";
 	
 	void init() throws IOException
 	{
 		input = new BufferedReader(new FileReader(file + "".in""));
 		out = new PrintWriter(new BufferedWriter(new FileWriter(file + "".out"")));
 	}
 	
 	void solve() throws IOException
 	{
 		int C = nextInt();
 		char[][] cs = new char[C][];
 		for(int i = 0; i < C; i++) cs[i] = next().toCharArray();
 		int D = nextInt();
 		char[][] ds = new char[D][];
 		for(int i = 0; i < D; i++) ds[i] = next().toCharArray();
 		int N = nextInt();
 		StringBuilder sb = new StringBuilder();
 		char[] com = next().toCharArray();
 		for(int i = 0; i < N; i++)
 		{
 			if(i == 0 || sb.length() == 0) sb.append(com[i]);
 			else
 			{
 				char p = sb.charAt(sb.length() - 1);
 				if(combine(p, com[i], cs, sb)) continue;
 				if(combine(com[i], p, cs, sb)) continue;
 				
 				if(delete(com[i], ds, sb)) continue;
 				
 				sb.append(com[i]);
 			}
 		}
 		String res = get(sb.toString().toCharArray());
 		gcj(res.substring(1, res.length() - 1));
 	}
 	
 	String get(Object... cs)
 	{
 		return deepToString(cs);
 	}
 	
 	boolean combine(char a, char b, char[][] cs, StringBuilder sb)
 	{
 		for(int i = 0; i < cs.length; i++)
 			if(cs[i][0] == a && cs[i][1] == b)
 			{
 				sb.deleteCharAt(sb.length() - 1);
 				sb.append(cs[i][2]);
 				return true;
 			}
 		return false;
 	}
 	boolean delete(char a, char[][] ds, StringBuilder sb)
 	{
 		for(int i = 0; i < sb.length(); i++)
 		{
 			if(find(sb.charAt(i), a, ds) || find(a, sb.charAt(i), ds)) 
 			{
 				sb.setLength(0);
 				return true;
 			}
 		}
 		return false;
 	}
 	boolean find(char a, char b, char[][] ds)
 	{
 		for(int i = 0; i < ds.length; i++)
 			if(ds[i][0] == a && ds[i][1] == b) return true;
 		return false;
 	}
 	
 	String next() throws IOException
 	{
 		while(tokenizer == null || !tokenizer.hasMoreTokens()) tokenizer = new StringTokenizer(input.readLine());
 		return tokenizer.nextToken();
 	}
 	
 	int nextInt() throws IOException
 	{
 		return Integer.parseInt(next());
 	}
 	
 	long nextLong() throws IOException
 	{
 		return Long.parseLong(next());
 	}
 	
 	double nextDouble() throws IOException
 	{
 		return Double.parseDouble(next());
 	}
 	
 	void print(Object... o)
 	{
 		System.out.println(deepToString(o));
 	}
 	
 	void gcj(Object o)
 	{
 		String s = String.valueOf(o);
 		out.println(""Case #"" + test + "": "" + s);
 		System.out.println(""Case #"" + test + "": "" + s);
 	}
 	
 	BufferedReader input;
 	PrintWriter out;
 	StringTokenizer tokenizer;
 	int test;
 	
 	public static void main(String[] args) throws IOException
 	{
 		new Thread(null, new B(), """", 1 << 20).start();
 	}
 	
 	public void run()
 	{
 		try
 		{
 			init();
 			int TEST = nextInt();
 			for(test = 1; test <= TEST; test++)
 			{
 				System.out.println(""Running on testcase #"" + test);	
 				solve();
 			}	
 			out.close();		
 		}
 		catch(Exception e)
 		{
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 }",0
106,1072,"import java.io.File;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class A3 {
 	static String _class=""A3"";
 	static int _switch=1;
 	static Scanner in=null;
 	static PrintStream out=null;
 	public static void main(String ... args) throws Exception{
 		switch(_switch){
 		case 0: in=new Scanner(new File(_class+""test.in"")); out = System.out;break;
 		case 1: in=new Scanner(new File(_class+""small.in"")); out = new PrintStream(new File(_class+""small.out""));break;
 		case 2: in=new Scanner(new File(_class+""large.in"")); out = new PrintStream(new File(_class+""large.out""));break;
 		}
 		int T = in.nextInt();
 		for(int t=1;t<=T;t++){
 			int N=in.nextInt();
 			
 			int[] c=new int[N];
 			for(int n=0;n<N;n++){
 				c[n]=in.nextInt();
 			}
 			
 			int max=-1;
 			for(int i=1;i<(1<<N)-1;i++){
 				
 				int o1=0; int o2=0; int p=0;
 				for(int j=0;j<N;j++){
 					
 					if((i&(1<<j))>0){
 						o2^=c[j];
 						p+=c[j];
 					}else{
 						o1^=c[j];
 					}
 				}
 				if(o1==o2 && p>max){
 					
 					max=p;
 				}
 				
 				
 			}
 			out.print(""Case #""+t+"": "");
 			if(max>-1) out.println(max);
 			else out.println(""NO"");
 		}
 		//out.print(in.nextInt());
 	}
 	
 	
 }
","import java.io.File;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class A3 {
 	static String _class=""A3"";
 	static int _switch=1;
 	static Scanner in=null;
 	static PrintStream out=null;
 	public static void main(String ... args) throws Exception{
 		switch(_switch){
 		case 0: in=new Scanner(new File(_class+""test.in"")); out = System.out;break;
 		case 1: in=new Scanner(new File(_class+""small.in"")); out = new PrintStream(new File(_class+""small.out""));break;
 		case 2: in=new Scanner(new File(_class+""large.in"")); out = new PrintStream(new File(_class+""large.out""));break;
 		}
 		int T = in.nextInt();
 		for(int t=1;t<=T;t++){
 			int N=in.nextInt();
 			
 			int[] c=new int[N];
 			for(int n=0;n<N;n++){
 				c[n]=in.nextInt();
 			}
 			
 			int max=-1;
 			for(int i=1;i<(1<<N)-1;i++){
 				
 				int o1=0; int o2=0; int p=0;
 				for(int j=0;j<N;j++){
 					
 					if((i&(1<<j))>0){
 						o2^=c[j];
 						p+=c[j];
 					}else{
 						o1^=c[j];
 					}
 				}
 				if(o1==o2 && p>max){
 					
 					max=p;
 				}
 				
 				
 			}
 			out.print(""Case #""+t+"": "");
 			if(max>-1) out.println(max);
 			else out.println(""NO"");
 		}
 		//out.print(in.nextInt());
 	}
 	
 	
 }
",1
107,1650,"import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Scanner;
 
 public class D {
 
     public static void main(String[] args) {
 
         Scanner in = new Scanner(System.in);
 
         int T = in.nextInt();
         for (int t = 1; t <= T; t++) {
             System.out.printf(""Case #%d: "", t);
             solve(in);
         }
 
     }
 
     public static void solve(Scanner in) {
 
         int N = in.nextInt();
         double[] naomi = new double[N];
         double[] ken = new double[N];
 
         for (int i = 0; i < N; i++) {
             naomi[i] = in.nextDouble();
         }
         for (int i = 0; i < N; i++) {
             ken[i] = in.nextDouble();
         }
         Arrays.sort(naomi);
         Arrays.sort(ken);
 //        System.out.println(Arrays.toString(naomi));
 //        System.out.println(Arrays.toString(ken));
 
         int normalWar = playWar(naomi, ken);
         int otherWar = playOther(naomi, ken);
 
         System.out.println(otherWar + "" "" + normalWar);
 
     }
 
     public static int playOther(double[] nao, double[] ken) {
         int N = ken.length;
 
         int ans = 0;
 
         // Throw the first i mathces to knock out his best
         for (int i = 0; i < N; i++) {
 
             int res = 0;
             for (int j = 0; j < N - i; j++) {
                 if (ken[j] < nao[i + j]) res++;
             }
             ans = Math.max(ans, res);
         }
 
         //        for (int i = 0; i < N; i++) {
         //            double naoTurn = nao[i];
         //            double kenTurn = ken[N - 1 - i];
         //
         //            if (naoTurn > kenTurn) {
         //                ans++;
         //            }
         //
         //        }
 
         return ans;
 
     }
 
     public static int playWar(double[] nao, double[] ken) {
         int N = ken.length;
 
         int ans = 0;
 
         ArrayList<Double> kens = new ArrayList<Double>();
         for (Double d : ken)
             kens.add(d);
 
         // Each round
         for (int i = 0; i < N; i++) {
 
             double naoTurn = nao[i];
             double kenTurn = -1;
 
             for (int j = 0; j < kens.size(); j++) {
                 if (kens.get(j) > naoTurn) {
                     kenTurn = kens.remove(j);
                     break;
                 }
             }
 
             if (kenTurn == -1) {
                 kenTurn = kens.remove(0);
             }
 
             if (naoTurn > kenTurn) ans++;
 
         }
 
         return ans;
     }
 
 }
","import java.util.Scanner;
 
 public class CNaive {
 
     public static void main(String[] args) {
 
         Scanner in = new Scanner(System.in);
 
         int T = in.nextInt();
         for (int t = 1; t <= T; t++) {
             System.out.println(""Case #"" + t + "":"");
             solve(in);
         }
 
     }
 
     public static void solve(Scanner in) {
 
         int R = in.nextInt();
         int C = in.nextInt();
         int M = in.nextInt();
 
         // If the answer is a single 'c'...
         if (R * C - M == 1) {
             for (int i = 0; i < R; i++) {
                 for (int j = 0; j < C; j++) {
                     if (i == 0 && j == 0)
                         System.out.print('c');
                     else
                         System.out.print('*');
                 }
                 System.out.println();
             }
             return;
         }
 
         if (!backtrack(new boolean[R][C], 0, 0, M, R * C)) {
             System.out.println(""Impossible"");
         }
 
     }
 
     public static boolean backtrack(boolean[][] mine, int i, int j, int M,
             int spaces) {
 
         int n = mine.length;
         int m = mine[0].length;
 
         if (M == 0) {
 
             if (!valid(mine, spaces)) { return false; }
 
             boolean needC = true;
 
             for (int x = 0; x < n; x++) {
                 for (int y = 0; y < m; y++) {
                     if (mine[x][y]) {
                         System.out.print(""*"");
                         continue;
                     }
 
                     if (needC && numMines(mine, x, y) == 0) {
                         needC = false;
                         System.out.print('c');
                     }
                     else {
                         System.out.print(""."");
                     }
                 }
                 System.out.println();
             }
             return true;
         }
         if (i == n) return false;
 
         int nextJ = (j + 1) % m;
         int nextI = nextJ == 0 ? i + 1 : i;
 
         mine[i][j] = true;
         if (backtrack(mine, nextI, nextJ, M - 1, spaces - 1)) return true;
         mine[i][j] = false;
 
         return backtrack(mine, nextI, nextJ, M, spaces);
     }
 
     public static boolean valid(boolean[][] mine, int howMany) {
 
         boolean[][] seen = new boolean[mine.length][mine[0].length];
 
         for (int i = 0; i < mine.length; i++) {
             for (int j = 0; j < mine[0].length; j++) {
                 if (!mine[i][j] && numMines(mine, i, j) == 0)
                     return howMany == dfs(mine, seen, i, j);
             }
         }
 
         return false;
     }
 
     public static int numMines(boolean[][] mine, int i, int j) {
         int n = mine.length;
         int m = mine[0].length;
 
         int ans = 0;
 
         for (int x = -1; x <= 1; x++) {
             for (int y = -1; y <= 1; y++) {
                 if (x == 0 && y == 0) continue;
                 if (inBounds(i + x, y + j, n, m) && mine[i + x][j + y]) ans++;
             }
         }
         return ans;
     }
 
     public static int dfs(boolean[][] mine, boolean[][] seen, int i, int j) {
 
         int n = seen.length;
         int m = seen[0].length;
 
         if (!inBounds(i, j, n, m)) return 0;
         if (seen[i][j] || mine[i][j]) return 0;
 
         seen[i][j] = true;
 
         // If bomb adjacent, don't recurse
         for (int x = -1; x <= 1; x++) {
             for (int y = -1; y <= 1; y++) {
                 if (inBounds(i + x, j + y, n, m) && mine[i + x][j + y])
                     return 1;
             }
         }
 
         int res = 1;
 
         for (int x = -1; x <= 1; x++) {
             for (int y = -1; y <= 1; y++) {
                 res += dfs(mine, seen, i + x, j + y);
             }
         }
 
         return res;
     }
 
     public static boolean inBounds(int i, int j, int n, int m) {
         if (i < 0 || i >= n || j < 0 || j >= m) return false;
         return true;
     }
 
     public static void printTests() {
         System.out.println(""225"");
         for (int r = 1; r <= 5; r++) {
             for (int c = 1; c <= 5; c++) {
                 for (int k = 0; k < r * c; k++) {
                     System.out.println(r + "" "" + c + "" "" + k);
                 }
             }
         }
 
     }
 
 }
",1
108,16566,"package com.googlerese.file;
 
 import java.io.*;
 import java.util.HashMap;
 import java.util.Map;
 
 public class FileRead {
 
     private static FileRead instance = new FileRead();
 
     private FileRead() {
     }
 
     public static FileRead getInstance() {
         return instance;
     }
 
     public Map<Integer, GooglersBean> read( final String fileName ) {
         FileInputStream fstream = null;
         DataInputStream in = null;
         BufferedReader br = null;
         Map<Integer, GooglersBean> input = null;
         try {
             // Open the file that is the first 
             // command line parameter
             fstream = new FileInputStream( fileName );
             // Get the object of DataInputStream
             in = new DataInputStream( fstream );
             br = new BufferedReader( new InputStreamReader( in ) );
             String strLine;
             //Read File Line By Line
             int count = 0;
             while ( ( strLine = br.readLine() ) != null ) {
                 // Print the content on the console
                 if ( count == 0 ) {
                     input = new HashMap<Integer, GooglersBean>( Integer.parseInt( strLine ) );
                 } else {
                     System.out.println( count + "" : "" + strLine );
                     GooglersBean bean = new GooglersBean();
                     String[] arr = strLine.split( ""\\s+"" );
                     bean.setNumGooglers( Integer.parseInt( arr[0] ) );
                     bean.setSurprising( Integer.parseInt( arr[1] ) );
                     bean.setResult( Integer.parseInt( arr[2] ) );
                     for ( int i = 3; i < arr.length; i++ ) {
                         bean.addScore( ( i - 3 ), Integer.parseInt( arr[i] ) );
                     }
                     input.put( count, bean );
                 }
                 count++;
             }
         } catch ( Exception e ) {//Catch exception if any
             System.err.println( ""Error: "" + e.getMessage() );
         } finally {
             //Close the input stream
             try {
                 if ( br != null ) {
                     br.close();
                 }
                 if ( in != null ) {
                     in.close();
                 }
                 if ( fstream != null ) {
                     fstream.close();
                 }
             } catch ( IOException e ) {
                 // TODO Auto-generated catch block
                 e.printStackTrace();
             }
         }
         return input;
     }
 }
","import java.util.*;
 import java.io.*;
 import java.lang.Math.*;
 
 public class A {
 	
 	public static void main(String args[]) throws IOException {
 		
 		File in = new File(""A.in"");
 		File out = new File(""A.out"");
 		Scanner scan = new Scanner(in);
 		Formatter output = new Formatter(out);
 		int t = scan.nextInt();
 		scan.nextLine();
 		
 		for(int i=1; i<=t; i++) {
 			int m = scan.nextInt();
 			int n = scan.nextInt();
 			scan.nextLine();
 			char[][] pic = new char[m][n];
 			for(int j=0; j<m; j++) {
 				String s = scan.nextLine();
 				for(int k=0; k<n;k++) {
 					pic[j][k] = s.charAt(k);
 				}
 			}
 			boolean possible = true;
 			for(int j=0; j<m && possible; j++) {
 				for(int k=0; k<n; k++) {
 					if(pic[j][k] == '#') {
 						if(j<m-1 && k<n-1 && pic[j+1][k] == '#' && pic[j][k+1] == '#' && pic[j+1][k+1] == '#') {
 							pic[j][k] = pic[j+1][k+1] = '/';
 							pic[j+1][k] = pic[j][k+1] = '\\';
 						}	
 						else
 							possible = false;
 					}
 				}
 			}
 			output.format(""Case #%d: \n"", i);
 			if(possible) {
 				for(int j=0; j<m && possible; j++) {
 					for(int k=0; k<n; k++) {
 						output.format(""%c"", pic[j][k]);
 					}
 					output.format(""\n"");
 				}
 			}
 			else
 				output.format(""Impossible\n"");
 			System.out.printf(""Case #%d: Complete\n"", i);
 		}
 		
 		output.close();
 	}
 }",0
109,805,"import java.io.*;
 import java.util.*;
 
 public class CandySplitting {
 
 	public static void main(String args[]) throws Exception {
 		String file =
 		//	""C-example.in""
 		//	""C-small-attempt0.in""
 			""C-large.in""
 		;
 		BufferedReader in = new BufferedReader(new FileReader(file));
 		PrintWriter out = new PrintWriter(new FileWriter(file + "".out""));
 		final int T = Integer.parseInt(in.readLine());
 		for(int casenr = 1; casenr  <= T; casenr++) {
 			int N = Integer.parseInt(in.readLine());
 			StringTokenizer st = new StringTokenizer(in.readLine());
 			int sum = 0;
 			int min = 10000000;
 			int xor = 0;
 			for(int i = 0; i < N; i++) {
 				int c = Integer.parseInt(st.nextToken());
 				sum += c;
 				if(c < min)
 					min = c;
 				xor ^= c;
 			}
 			out.println(""Case #"" + casenr + "": "" + (xor != 0 ? ""NO"" : Integer.toString(sum - min)));
 			out.flush();
 		}
 		out.close();
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class CandySplitting {
 
 	public static void main(String args[]) throws Exception {
 		String file =
 		//	""C-example.in""
 		//	""C-small-attempt0.in""
 			""C-large.in""
 		;
 		BufferedReader in = new BufferedReader(new FileReader(file));
 		PrintWriter out = new PrintWriter(new FileWriter(file + "".out""));
 		final int T = Integer.parseInt(in.readLine());
 		for(int casenr = 1; casenr  <= T; casenr++) {
 			int N = Integer.parseInt(in.readLine());
 			StringTokenizer st = new StringTokenizer(in.readLine());
 			int sum = 0;
 			int min = 10000000;
 			int xor = 0;
 			for(int i = 0; i < N; i++) {
 				int c = Integer.parseInt(st.nextToken());
 				sum += c;
 				if(c < min)
 					min = c;
 				xor ^= c;
 			}
 			out.println(""Case #"" + casenr + "": "" + (xor != 0 ? ""NO"" : Integer.toString(sum - min)));
 			out.flush();
 		}
 		out.close();
 	}
 }
",1
110,13586,"
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.List;
 
 
 public class Solve2014R1BA {
 	private static String filePath = ""A-small-attempt0.in"";
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		long startDatetime = System.currentTimeMillis();
 
 		StringBuffer answer = new StringBuffer();
 		try {
 			BufferedReader br = null;
 			String line = null;
 			if (filePath == null) br = new BufferedReader(new InputStreamReader(System.in));
 			else br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));
 
 			int T = Integer.parseInt(br.readLine());
 			//System.out.println(T);
 
 			for (int x = 1; x <= T; x++) {
 				if ( (line = br.readLine()) == null) { throw new Exception(""wrong! Case #"" + x); }
 				System.out.println(""Case #"" + x + "": "");
 				answer.append(""Case #"" + x + "": "");
 
 				int N = Integer.parseInt(line);
 				String[] Si = new String[N];
 				for (int i = 0; i < N; i++) {
 					if ( (Si[i] = br.readLine()) == null) { throw new Exception(""wrong! Case #"" + x); }
 				}
 
 				int y = 0;
 				List<Character> cs = new ArrayList<Character>();
 				int[][] cnts = new int[N][100];
 				char c = ' ';
 				int idx = -1;
 				for (int p = 0; p < Si[0].length(); p++) {
 					char curr = Si[0].charAt(p);
 					if (curr != c) {
 						cs.add(curr);
 						c = curr;
 						cnts[0][++idx] = 1;
 					} else {
 						cnts[0][idx]++;
 					}
 				}
 				int size = cs.size();
 				boolean FeglaWon = false;
 				for (int i = 1; i < N; i++) {
 					idx = 0;
 					if (Si[i].charAt(0) != cs.get(idx)) {
 						FeglaWon = true;
 						break;
 					}
 					for (int p = 0; p < Si[i].length(); p++) {
 						char curr = Si[i].charAt(p);
 						if (curr == cs.get(idx)) {
 							cnts[i][idx]++;
 						} else {
 							idx++;
 							if (idx >= size) {
 								FeglaWon = true;
 								break;
 							}
 							if (curr == cs.get(idx)) {
 								cnts[i][idx]++;
 							} else {
 								FeglaWon = true;
 								break;
 							}
 						}
 					}
 					if (FeglaWon) break;
 					if (idx != size - 1) {
 						FeglaWon = true;
 						break;
 					}
 				}
 
 				if (FeglaWon) answer.append(""Fegla Won\n"");
 				else {
 					for (int i = 0; i < size; i++) {
 						int ymin = 999999999;
 						for (int j = 0; j < N; j++) {
 							int ycurr = 0;
 							for (int k = 0; k < N; k++) {
 								if (cnts[j][i] > cnts[k][i])
 									ycurr += cnts[j][i] - cnts[k][i];
 								else
 									ycurr += cnts[k][i] - cnts[j][i];
 							}
 							if (ycurr < ymin) ymin = ycurr;
 						}
 						y += ymin;
 					}
 					answer.append(y).append(""\n"");
 				}
 			}
 			br.close();
 			br = null;
 			output(answer);
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		long tm = System.currentTimeMillis() - startDatetime;
 		long tms = tm / 1000;
 		System.out.println(""The process time: "" + tms + ""s "" + (tm%1000) + ""ms"");
 	}
 
 	private static void output(StringBuffer answer) throws Exception {
 		String outPath = ""answer.out"";
 		if (filePath != null) outPath = filePath.substring(0, filePath.length()-2) + ""out"";
 		FileOutputStream fos = new FileOutputStream(outPath, false);
 		fos.write(answer.toString().getBytes());
 		fos.close();
 		fos = null;
 	}
 }
","package andresrcb.codejam14.qual.solutions;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class ProblemA {
 
 	public static void main(String[] args) {
 
 		try {
 			String fileName;
 			String outputName;
 			int runType = 1;
 			switch(runType) {
 			case 0:
 				fileName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-sample.in"";
 				outputName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-sample.out"";
 				break;
 			case 1:
 				fileName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-small-attempt0.in"";
 				outputName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-small-attempt0.out"";
 				break;
 			default:
 				fileName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-big.in"";
 				outputName = ""/Users/andrescontreras/Development/codeJamIO/qualification/1/A-big.out"";
 			}
 
 
 			BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
 			Scanner s = new Scanner(bufferedReader);
 			final int T = s.nextInt();
 			String[] results = new String[T];
 			int firstRowNumber;
 			int[] firstRow = new int[4];
 			int secondRowNumber;
 			int[] secondRow = new int[4];
 			int possibleCard;
 			int count;
 			for (int i = 0; i<T ; ++i) {
 				firstRowNumber = s.nextInt();
 				for (int r = 1; r<=4 ; ++r) {
 					if(r == firstRowNumber) {
 						firstRow[0] = s.nextInt();
 						firstRow[1] = s.nextInt();
 						firstRow[2] = s.nextInt();
 						firstRow[3] = s.nextInt();
 					}
 					else {
 						s.nextInt();s.nextInt();s.nextInt();s.nextInt();
 					}
 				}
 
 				secondRowNumber = s.nextInt();
 				for (int r = 1; r<=4 ; ++r) {
 					if(r == secondRowNumber) {
 						secondRow[0] = s.nextInt();
 						secondRow[1] = s.nextInt();
 						secondRow[2] = s.nextInt();
 						secondRow[3] = s.nextInt();
 					}
 					else {
 						s.nextInt();s.nextInt();s.nextInt();s.nextInt();
 					}
 				}
 				possibleCard = 0;
 				count = 0;
 				for(int j = 0; j<4;++j) {
 					for (int k = 0; k<4;++k) {
 						if(firstRow[j]==secondRow[k]) {
 							count++;
 							possibleCard = firstRow[j];
 						}
 					}
 				}
 				if(count == 1) {
 					results[i] =""Case #"" + (i+1) + "": "" + possibleCard;
 				}
 				else if (count == 0) {
 					results[i] =""Case #"" + (i+1) + "": Volunteer cheated!"";
 				}
 				else {
 					results[i] =""Case #"" + (i+1) + "": Bad magician!"";
 				}
 
 			}
 			s.close();
 			bufferedReader.close();
 
 
 
 			
 			File outputFile = new File(outputName);
 
 			if (!outputFile.exists()) {
 				System.out.println(outputFile.getName());
 				outputFile.createNewFile();
 			}
 
 			FileWriter fw = new FileWriter(outputFile.getAbsoluteFile());
 			BufferedWriter bw = new BufferedWriter(fw);
 			for (int i = 0; i<T;++i) {
 				bw.write(results[i] + ""\n"");				
 			}
 			
 			bw.close();
 
 		} catch (Exception e) {
 			e.printStackTrace();
 
 		}
 
 	}
 
 }",0
111,16588,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class EN2014QB {
 	public static void main(String[] args) {
 		File inputFile = new File(""c:/tmp/B-large.in"");
 		File outputFile = new File(""c:/tmp/B-large.out"");
 		FileReader filereader = null;
 		BufferedReader br = null;
 		FileWriter filewriter = null;
 		BufferedWriter bw = null;
 
 		try {
 			// 入力
 			filereader = new FileReader(inputFile);
 			br = new BufferedReader(filereader);
 
 			// 出力
 			filewriter = new FileWriter(outputFile);
 			bw = new BufferedWriter(filewriter);
 
 			/**************************************************************************************
 			// 全体パラメータの読み込み
 			 **************************************************************************************/
 			int T;
 
 			// テストケースの個数
 			String lineStr = br.readLine();
 			T = Integer.parseInt(lineStr);
 			System.out.println(""T = "" + T + ""\n"");
 
 			/**************************************************************************************
 			// Caseを1つづつ処理
 			 **************************************************************************************/
 			long caseIndex = 1;
 			for(int t=0; t < T; t++) {
 				/**************************************************************************************
 				// Caseを処理
 				 **************************************************************************************/
 				// 答え
 				String caseAnser = null;
 
 				lineStr = br.readLine();
 				String line[] = lineStr.split("" "");
 				double C = Double.parseDouble(line[0]);
 				double F = Double.parseDouble(line[1]);
 				double X = Double.parseDouble(line[2]);
 				
 				System.out.println(""C = "" + C + "", "" + ""F = "" + F + "", "" + ""X = "" + X);
 				
 				// Cの時点でそのままとfarmを買った場合でXに到達するまで時間を比較する
 				// そのまま　：(X-C)/(nF+2)
 				// farmを買う：(X)/(nF+F+2)
 				// そのままがよいのは以下の式を満たす場合
 				// (X-C)/(nF+2) < (X)/(nF+F+2)
 				// n > (XF-CF-2C)/CF			
 				double x = (X*F-C*F-2*C)/(C*F);
 				if(x < 0){
 					x = 0.0;
 				}
 				System.out.println(""x = "" + x);
 				
 				// 切り上げで整数を求める
 				int n = (int)Math.ceil(x);
 				System.out.println(""n = "" + n);	
 				
 				// n回farmを買う
 				double totalTime = 0.0;
 				for(int i=0; i < n; i++){
 					// Cに到達するまでの時間
 					double time = C/(2+i*F);
 					totalTime = totalTime + time;
 //					System.out.println(""time = "" + time + "", total time = "" + totalTime);
 				}
 				// 最後は、Xに到達するまでの時間
 				double time = X/(2+n*F);
 				totalTime = totalTime + time;
 //				System.out.println(""time = "" + time + "", total time = "" + totalTime);
 				
 				caseAnser = String.format(""%.7f"", totalTime);
 				
 				/**************************************************************************************
 				// Caseを出力
 				 **************************************************************************************/
 				String output = ""Case #"" + caseIndex + "": "" + caseAnser;
 				caseIndex++;
 				System.out.println(output);
 				bw.write(output);
 				bw.newLine();
 				bw.flush();
 
 				/**************************************************************************************
 				// 次のCaseの読み込み
 				 **************************************************************************************/
 				System.out.println();
 			}
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (br != null) {
 					br.close();
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 
 			try {
 				if (filereader != null) {
 					filereader.close();
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 
 			try {
 				if (bw != null) {
 					bw.close();
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 
 			try {
 				if (filewriter != null) {
 					filewriter.close();
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 		}
 	}
 }
","package _2012.round1A;
 
 import java.math.BigDecimal;
 import java.util.Scanner;
 
 public class PasswordProblem {
 	public static void main(String[] args) {
 		Scanner consola = new Scanner(System.in);
 		double []probCorr;
 		double min, prob, acum;
 		int nTypped, longPass, times = consola.nextInt();
 		for(int t = 1; t <= times; t++){
 			nTypped = consola.nextInt();
 			longPass = consola.nextInt();
 			probCorr = new double[nTypped];
 			prob = 0;
 			for(int i = 0; i < nTypped; i++){
 				probCorr[i] = Double.parseDouble(consola.next());
 				prob *= probCorr[i];
 			}
 			
 			// reset
 			min = longPass + 2;
 			// continue
 			acum = (longPass - nTypped + 1) * prob;
 			acum += ((longPass) * 2 - nTypped + 2) * (1 - prob);
 			if(acum < min)
 				min = acum;
 			// backspace
 			prob = 1;
 			for(int i = 1; i <= nTypped; i++){
 				prob *= probCorr[i - 1];
 				acum = (longPass - (i * 2) + 1 + nTypped) * prob;
 				acum += ((longPass * 2) - (i * 2) + 2 + nTypped) * (1 - prob);
 				if(acum < min)
 					min = acum;
 			}
 			
 			System.out.println(""Case #"" + t + "": "" + new BigDecimal(min).setScale (6, BigDecimal.ROUND_HALF_UP));
 		}
 	}
 }",0
112,3938,"public class Bullseye
 {
     long r, t;
     public Bullseye(long r, long t)
     {
         this.r=r;
         this.t=t;
     }
     
     public long area()
     {
         boolean partial=true;
         long Area= (r+1)*(r+1) - r*r;
         long number=1;
         long times=0;
         while(partial)
         {
             long newArea=(r+number)*(r+number);
             long addArea=(newArea-(r+number-1)*(r+number-1));
             Area+=addArea;
             t-=addArea;
             if (t<0)
             {
                 partial=false;
                 times--;
             }
             number+=2;
             times++;
         }
         
         return times;
     }
     
 }","import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class MagicTrick {
 	public static void main(String args[]) throws Exception
 	{
 		Scanner sca = new Scanner (new File(""/home/swaranjit/Downloads/Input.in""));
         FileWriter fw = new FileWriter(""/home/swaranjit/Downloads/Output.out"");
         PrintWriter output = new PrintWriter(fw);
         int line=0;
         int possCase=sca.nextInt();
         for (int x=0; x<possCase; x++)
         {
         	int y = x+1;
         	int value=0;
         	int cards1[][] = new int[4][4];
         	int cards2[][] = new int[4][4];
         	int row1 = sca.nextInt()-1;
         	for (int i=0; i<4; i++)
         	{
         		for(int j=0; j<4; j++)
         		{
         			cards1[i][j]=sca.nextInt();
         		}
         	}
         	int row2 = sca.nextInt()-1;
         	for (int i=0; i<4; i++)
         	{
         		for(int j=0; j<4; j++)
         		{
         			cards2[i][j]=sca.nextInt();
         		}
         	}
         	value = magic(cards1, cards2, row1, row2);
         	
         	switch(value)
         	{
         		case 17:
         		{
         			output.println(""Case #"" + y + "": Bad magician!"");
         			break;
         		}
         		case 18:
         		{
         			output.println(""Case #"" + y + "": Volunteer cheated!"");
         			break;
         		}
         		default:
         		{
         			output.println(""Case #"" + y + "": "" + value);
         			break;
         		}
         	}
         }
 		sca.close();
 		output.close();
 		
 	
 	}
 	
 	public static int magic(int[][] cards1, int[][] cards2, int row1, int row2)
 	{
 		int[] K = new int[4];
 		K[0] = cards1[row1][0];
 		K[1] = cards1[row1][1];
 		K[2] = cards1[row1][2];
 		K[3] = cards1[row1][3];
 		
 		int[] L = new int[4];
 		L[0] = cards2[row2][0];
 		L[1] = cards2[row2][1];
 		L[2] = cards2[row2][2];
 		L[3] = cards2[row2][3];
 		
 		int same=0;
 		boolean clifBar=true;
 		for (int i = 0; i<4; i++)
 		{
 			for (int j = 0; j<4; j++)
 			{
 				if (K[i]==L[j])
 				{
 					if (clifBar==false)
 						return 17;
 					same = K[i];
 					clifBar=false;
 				}
 			}
 		}
 		if (same==0)
 			return 18;
 		
 		
 		return same;
 	}
 }
",1
113,17165,"package codejamQual2014;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 
 public class ProblemA {
 	
 	public static void p(String s) {
 		System.out.println(s);
 	}
 	
 	public static void main(String[] args) throws IOException {
 		BufferedReader br = new BufferedReader(new FileReader(""res/Qual2014/A-small-attempt2.in""));
 		Writer wr = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""bin/output.txt""), ""utf-8""));
 		
 		int numCases = Integer.parseInt(br.readLine());
 		
 		for (int i = 0; i < numCases; i++) {
       int a1 = Integer.parseInt(br.readLine())-1;
       int[][] c1 = new int[4][4];
       for (int j = 0; j < 4; ++j) {
         String[] line = br.readLine().split("" "");
         for (int k = 0; k < 4; ++k)
           c1[j][k] = Integer.parseInt(line[k]);
       }
       int a2 = Integer.parseInt(br.readLine())-1;
       int[][] c2 = new int[4][4];
       for (int j = 0; j < 4; ++j) {
         String[] line = br.readLine().split("" "");
         for (int k = 0; k < 4; ++k)
           c2[j][k] = Integer.parseInt(line[k]);
       }
 
       int count = 0;
       int num = 0;
       for (int j = 0; j < c1.length; ++j){
         for (int k = 0; k < c2.length; ++k) {
           if (c1[a1][j] == c2[a2][k]) {
             ++count;
             num = c1[a1][j];
           }
         }
       }
 
       String answer = num + """";
       if (count == 0) {
         answer = ""Volunteer cheated!"";
       } else if (count > 1) {
         answer = ""Bad magician!"";
       }
 
       p(""Case #"" + (i+1) + "": "" + answer);
       wr.write(""Case #"" + (i+1) + "": "" + answer+""\n"");
 		}
 		
 		br.close();
 		wr.close();
 	}
 }
","package codejam2014Round1B;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 
 public class ProblemA {
   
   public static void p(String s) {
     System.out.println(s);
   }
   
   public static void main(String[] args) throws IOException {
     BufferedReader br = new BufferedReader(new FileReader(""res/2014Round1B/A-small-attempt0.in""));
     Writer wr = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""bin/output.txt""), ""utf-8""));
     
     int numCases = Integer.parseInt(br.readLine());
     
     for (int i = 0; i < numCases; ++i) {
     	String ans = """";
     	boolean fail = false;
     	int N = Integer.parseInt(br.readLine());
     	String[] s = new String[N];
     	for (int j = 0; j < N; j++) {
 			s[j] = br.readLine();
 		}
     	ArrayList<char[]> schars = new ArrayList<char[]>();
     	ArrayList<int[]> dups = new ArrayList<int[]>();
     	for (int j = 0; j < N; j++) {
 			schars.add(s[j].toCharArray());
 		}
     	StringBuffer sb = new StringBuffer();
     	sb.append(schars.get(0)[0]);
     	for (int j = 1; j < schars.get(0).length; j++) {
     		if (schars.get(0)[j] != schars.get(0)[j-1]) {
     			sb.append(schars.get(0)[j]);
     		}
 		}
     	for (int j = 0; j < N; j++) {
     		dups.add(new int[sb.length()]);
 		}
     	for (int j = 0; j < N && !fail; j++) {
 			StringBuffer tempsb = new StringBuffer();
 			tempsb.append(schars.get(j)[0]);
 			int dupsi = 0;
 			for (int k = 1; k < schars.get(j).length; k++) {
 	    		if (schars.get(j)[k] != schars.get(j)[k-1]) {
 	    			tempsb.append(schars.get(j)[k]);
 	    			++dupsi;
 	    		} else {
 	    			++dups.get(j)[dupsi];
 	    		}
 			}
 			if (!sb.toString().equals(tempsb.toString())) {
 				fail = true;
 				ans = ""Fegla Won"";
 				break;
 			}
 		}
     	if (!fail) {
     		int count = 0;
     		int len = sb.length();
     		for (int j = 0; j < len; j++) {
     			int tot = 0;
     			for (int k = 0; k < N; k++) {
 					tot += dups.get(k)[j];
 				}
     			int mean = (int)Math.round(tot/(double)N);
     			for (int k = 0; k < N; k++) {
 					count += Math.abs(dups.get(k)[j]-mean);
 				}
 			}
     		ans = count + """";
     	}
     	
 
       p(""Case #"" + (i+1) + "": "" + ans);
       wr.write(""Case #"" + (i+1) + "": "" + ans+""\n"");
     }
     
     br.close();
     wr.close();
   }
 }
",1
114,9302,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 
 public class B {
 	private final static String FNAME=""/home/trieuvan/codejam/B-small-attempt0"";
 	public static void main(String[] args) throws FileNotFoundException {
 
 		Scanner inp=new Scanner(new File(FNAME+"".in""));
 		PrintStream out = new PrintStream(new FileOutputStream(FNAME+"".out""));
 
 		
 		int T=inp.nextInt();
 		start:
 		for (int t = 1; t <= T; t++) {
 			int R=inp.nextInt();
 			int C=inp.nextInt();
 			int D=inp.nextInt();
 			int A[][]=new int[R][C];
 			for (int i = 0; i < R; i++) {
 				String line=inp.next();
 				for (int j = 0; j < C; j++) {
 					A[i][j]=D+(line.charAt(j)-'0');
 				}		
 			}
 			
 			int k=Math.min(C, R);
 			while (k>=3) {
 				//System.out.println(k);
 				for (int m = 0; m <= R-k; m++) {
 					for (int n = 0; n <= C-k; n++) {
 						double c=(k-1)/2.0;
 						double sumX=0;
 						double sumY=0;
 						for (int i = 0; i < k; i++) {
 							for (int j = 0; j < k; j++) {
 								if (((i==0) || i==(k-1))
 									&&((j==0) || j==(k-1))) continue;
 								sumX+=A[i+m][j+n]*(i-c);
 								sumY+=A[i+m][j+n]*(j-c);
 							}
 						}
 						//System.out.println(m+"" ""+n+"" ""+sumX+"" ""+sumY);
 						if (Math.abs(sumX)<=0.0000001 && Math.abs(sumY)<=0.0000001) {
 							out.println(""Case #""+t+"": ""+k);
 							continue start;
 						}
 					}
 				}
 				k--;
 			}
 			
 			out.println(""Case #""+t+"": IMPOSSIBLE"");
 		}
 
 		
 		out.flush();
 		out.close();
 
 
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class A {
 	private final static String FNAME=""/home/trieuvan/codejam/A-small-attempt0"";
 	public static void main(String[] args) throws FileNotFoundException {
 		
 		Scanner inp=new Scanner(new File(FNAME+"".in""));
 		PrintStream out = new PrintStream(new FileOutputStream(FNAME+"".out""));
 		
 		int n=inp.nextInt();
 		
 		for (int i = 0; i < n; i++) {
 			int count=inp.nextInt();
 			int O=1;
 			int B=1;
 			int time=0;
 			int t1=0;
 			int t2=0;
 			for (int c = 0; c < count; c++) {
 				String s=inp.next();
 				int p=inp.nextInt();
 				if (""O"".equals(s)) {
 					int total=Math.abs(O-p);
 					O=p;
 					if (total>t1)
 						total=total-t1;
 					else total=0;
 					total++;
 					time+=total;
 					t2+=total;
 					t1=0;
 				}
 				else {
 					int total=Math.abs(B-p);
 					B=p;
 					if (total>t2)
 						total=total-t2;
 					else total=0;
 					total++;
 					time+=total;
 					t1+=total;
 					t2=0;
 				}
 			}
 			out.println(""Case #""+(i+1)+"": ""+time);
 		}
 		
 		out.flush();
 		out.close();
 		
 		
 	}
 }
",1
115,19132,"package qr;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Scanner;
 
 public class P1_Tic {
 	public static FileWriter log = null;
 	public static final int SIZE = 4;
 	public static final String[] STATUS = { ""X won"", ""O won"", ""Draw"",
 			""Game has not completed"" };
 
 	public static void main(String[] args) throws IOException {
 
 		long startTime = System.nanoTime();
 		Scanner sip = null;
 		FileWriter fwop = null;
 		try {
 			String ipfile = ""A-large.in.txt"";
 			log = new FileWriter(
 					""X:\\Un-official\\programming\\CJ13\\QR\\1\\log.txt"");
 
 			sip = new Scanner(new File(
 					""X:\\Un-official\\programming\\CJ13\\QR\\1\\"" + ipfile));
 
 			// create output file
 			fwop = new FileWriter(
 					""X:\\Un-official\\programming\\CJ13\\QR\\1\\output.txt"");
 
 			int T = sip.nextInt();
 			char[][] desc = new char[SIZE][SIZE];
 			StringBuilder line = new StringBuilder(SIZE);
 			int result = -1;
 
 			for (int i = 0; i < T; i++) {
 				log.write(""\nCase #"" + (i + 1) + "":\n"");
 
 				// read input
 				for (int ir = 0; ir < SIZE; ir++) {
 					line.replace(0, SIZE, sip.next());
 					for (int ic = 0; ic < SIZE; ic++) {
 						desc[ir][ic] = line.charAt(ic);
 					}
 				}
 				sip.nextLine();
 
 				result = findStatus(desc);
 
 				// print output
 				fwop.write(""Case #"" + (i + 1) + "": "" + STATUS[result]);
 				if (i < T - 1)
 					fwop.write(""\n"");
 			}
 			long endTime = System.nanoTime();
 			log.write(""\nTotal execution time: "" + (endTime - startTime)
 					+ "" nano seconds"");
 			log.write(""\nTotal execution time: "" + (endTime - startTime)
 					/ 1000.0 + "" micro seconds"");
 			log.write(""\nTotal execution time: "" + (endTime - startTime)
 					/ 1000000.0 + "" milli seconds"");
 			log.write(""\nTotal execution time: "" + (endTime - startTime)
 					/ 1000000000.0 + "" seconds"");
 
 		} catch (Exception e) {
 			e.printStackTrace();
 		} finally {
 			System.out.println(""Finally executed"");
 			log.write(""\n\nFinally executed"");
 			sip.close();
 			fwop.flush();
 			fwop.close();
 			log.flush();
 			log.close();
 		}
 	}
 
 	private static int findStatus(char[][] desc) throws IOException {
 		// log the input
 		for (int ir = 0; ir < SIZE; ir++) {
 			for (int ic = 0; ic < SIZE; ic++) {
 				log.write(desc[ir][ic]);
 			}
 			log.write(""\n"");
 		}
 		log.write(""\n"");
 
 		// start processing
 		int totalDots = 0;
 
 		Map symbols = new HashMap<Character, Integer>();
 		symbols.put('X', 0);
 		symbols.put('O', 1);
 		symbols.put('T', 2);
 		symbols.put('.', 3);
 
 		int[] counts = new int[symbols.size()];
 
 		// 1. process row-wise
 		for (int ir = 0; ir < SIZE; ir++) {
 			// reset count for every row
 			for (int icount = 0; icount < counts.length; icount++)
 				counts[icount] = 0;
 
 			// process every column
 			for (int ic = 0; ic < SIZE; ic++) {
 				counts[(int) symbols.get(desc[ir][ic])]++;
 			}
 
 			// process result
 			if (counts[(int) symbols.get('X')] + counts[(int) symbols.get('T')] == SIZE)
 				return 0;
 			else if (counts[(int) symbols.get('O')]
 					+ counts[(int) symbols.get('T')] == SIZE)
 				return 1;
 			else
 				totalDots += counts[(int) symbols.get('.')];
 		}
 
 		// 2. process column-wise
 		for (int ic = 0; ic < SIZE; ic++) {
 			// reset count for every column
 			for (int icount = 0; icount < counts.length; icount++)
 				counts[icount] = 0;
 
 			// process every row
 			for (int ir = 0; ir < SIZE; ir++) {
 				counts[(int) symbols.get(desc[ir][ic])]++;
 			}
 
 			// process result
 			if (counts[(int) symbols.get('X')] + counts[(int) symbols.get('T')] == SIZE)
 				return 0;
 			else if (counts[(int) symbols.get('O')]
 					+ counts[(int) symbols.get('T')] == SIZE)
 				return 1;
 			else
 				totalDots += counts[(int) symbols.get('.')];
 		}
 
 		// 3. process primary diagonal
 		// reset count
 		for (int icount = 0; icount < counts.length; icount++)
 			counts[icount] = 0;
 
 		for (int ir = 0, ic = 0; ir < SIZE; ir++, ic++) {
 			counts[(int) symbols.get(desc[ir][ic])]++;
 		}
 		// process result
 		if (counts[(int) symbols.get('X')] + counts[(int) symbols.get('T')] == SIZE)
 			return 0;
 		else if (counts[(int) symbols.get('O')]
 				+ counts[(int) symbols.get('T')] == SIZE)
 			return 1;
 		else
 			totalDots += counts[(int) symbols.get('.')];
 
 		// 4. process secondary diagonal
 		// reset count
 		for (int icount = 0; icount < counts.length; icount++)
 			counts[icount] = 0;
 
 		for (int ir = 0, ic = SIZE - 1; ir < SIZE; ir++, ic--) {
 			counts[(int) symbols.get(desc[ir][ic])]++;
 		}
 		// process result
 		if (counts[(int) symbols.get('X')] + counts[(int) symbols.get('T')] == SIZE)
 			return 0;
 		else if (counts[(int) symbols.get('O')]
 				+ counts[(int) symbols.get('T')] == SIZE)
 			return 1;
 		else
 			totalDots += counts[(int) symbols.get('.')];
 
 		// 5. Default
 		if (totalDots > 0)
 			return 3;
 		else
 			return 2;
 	}
 }","package dev.code.jam.c1;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 
 public class PartElf {
 
 	public void process(String fileName) {
 		try {
 			FileInputStream fis = new FileInputStream(new File(fileName));
 			BufferedReader bis = new BufferedReader(new InputStreamReader(fis));
 			String line = bis.readLine();
 			int nrOfCases = Integer.parseInt(line);
 
 			FileOutputStream fos = new FileOutputStream(
 					""output/A-small-attempt0.out"");
 			BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));
 			StringBuffer sb = new StringBuffer();
 
 			for (int i = 0; i < nrOfCases; i++) {
 				String input = bis.readLine();
 
 				int checkAncestor = checkAncestor(input);
 				if (checkAncestor != -1) {
 					sb.append(""Case #"").append(i + 1).append("": "")
 							.append(checkAncestor).append(""\r\n"");
 				} else {
 					sb.append(""Case #"").append(i + 1).append("": "")
 							.append(""impossible"").append(""\r\n"");
 				}
 
 			}
 
 			System.out.println(""Writing to file:\r\n"" + sb.toString());
 			bw.write(sb.toString());
 			bw.close();
 			fos.close();
 			bis.close();
 		} catch (NumberFormatException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 
 	private int checkAncestor(String input) {
 
 		String[] value = input.split(""/"");
 		long v1 = Long.parseLong(value[0]);
 		long v2 = Long.parseLong(value[1]);
 		if ((v2 & (-v2)) != v2 && (v2 % v1) != 0) {
 			return -1;
 		} else if ((v2 & (-v2)) != v2 && (v2 % v1) == 0) {
 			long findGCD = findGCD(v1, v2);
 			long newV2 = v2 / findGCD;
 			long newV1 = v1 / findGCD;
 			if ((newV2 & (-newV2)) != newV2) {
 				return -1;
 			} else {
 				// check if newV1 can be written as a number of power 2
 				boolean checkSum = checkSumPow2(newV1);
 				if (!checkSum) {
 					return -1;
 				} else {
 					return getPower(newV2);
 				}
 			}
 		} else if ((v2 & (-v2)) == v2 && (v2 % v1) != 0) {
 			int powerV1 = getPower(v1);
 			int powerV2 = getPower(v2);
 			return Math.abs(powerV2 - powerV1);
 
 		} else if ((v2 & (-v2)) == v2 && (v2 % v1) == 0) {
 			int powerV1 = getPower(v1);
 			int powerV2 = getPower(v2);
 			return Math.abs(powerV2 - powerV1);
 		} else {
 			return -1;
 		}
 
 	}
 
 	private boolean checkSumPow2(long newV1) {
 		long pow = 1;
 		boolean isPowCheckSum = false;
 		while (pow != 0) {
 			if ((newV1 & pow) != 0) {
 				isPowCheckSum = true;
 			}
 			pow = pow <<= 1;
 		}
 		return isPowCheckSum;
 	}
 
 	private int getPower(long newV2) {
 		long pow = 1;
 		int p = -1;
 		int intP = 0;
 		while (pow != 0) {
 			if ((newV2 & pow) != 0) {
 				p = intP;
 			}
 			pow = pow <<= 1;
 			intP++;
 		}
 		return p;
 	}
 
 	public long findGCD(long v1, long v2) {
 		while (v2 > 0) {
 			long temp = v2;
 			v2 = v1 % v2;
 			v1 = temp;
 		}
 		return v1;
 	}
 
 	public static void main(String[] args) {
 
 		PartElf pe = new PartElf();
 		pe.process(""input/A-small-attempt0.in"");
 	}
 }
",0
116,7224,"import java.io.*;
 import java.util.StringTokenizer;
 
 public class A {
     public void run() {
         int t = nextInt();
         for (int i = 1; i <= t; ++i) {
             System.out.println(""Case #"" + i + "":"");
             solve();
         }
     }
 
     private void solve() {
         int n = nextInt();
         int[][] a = new int[n][n];
         double[] wp = new double[n];
         for (int i = 0; i < n; ++i) {
             String s = nextToken();
             int games = 0;
             int won = 0;
             for (int j = 0; j < n; ++j) {
                 a[i][j] = s.charAt(j) == '1' ? 1 : s.charAt(j) == '0' ? -1 : 0;
                 games += Math.abs(a[i][j]);
                 won += Math.max(0, a[i][j]);
             }
             wp[i] = (double)won / games;
         }
         double[] owp = new double[n];
         for (int i = 0; i < n; ++i) {
             int opponents = 0;
             for (int j = 0; j < n; ++j) {
                 if (a[i][j] != 0) {
                     int games = 0;
                     int won = 0;
                     for (int k = 0; k < n; ++k) {
                         if (k != i) {
                             games += Math.abs(a[j][k]);
                             won += Math.max(0, a[j][k]);
                         }
                     }
                     owp[i] += (double)won / games;
                     ++opponents;
                 }
             }
             owp[i] /= opponents;
         }
         double[] oowp = new double[n];
         for (int i = 0; i < n; ++i) {
             int opponents = 0;
             for (int j = 0; j < n; ++j) {
                 if (a[i][j] != 0) {
                     oowp[i] += owp[j];
                     ++opponents;
                 }
             }
             oowp[i] /= opponents;
         }
         for (int i = 0; i < n; ++i) {
             System.out.println(0.25 * wp[i] + 0.50 * owp[i] + 0.25 * oowp[i]);
         }
 
     }
 
     static {
 
         try {
             System.setIn(new FileInputStream(""A.in""));
         } catch (FileNotFoundException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
         try {
             System.setOut(new PrintStream(""A.out""));
         } catch (FileNotFoundException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
     }
     public static PrintStream out = new PrintStream(new BufferedOutputStream(System.out));
     public static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
     public static StringTokenizer tokenizer;
 
     public static void main(String[] args) throws IOException {
         new A().run();
         out.close();
     }
 
     public static String nextToken() {
         while (tokenizer == null || !tokenizer.hasMoreTokens()) {
             try {
                 tokenizer = new StringTokenizer(reader.readLine());
             } catch (IOException e) {
                 throw new Error(e);
             }
         }
         return tokenizer.nextToken();
     }
 
     public static int nextInt() {
         return Integer.parseInt(nextToken());
     }
 
     public static long nextLong() {
         return Long.parseLong(nextToken());
     }
 
     public static double nextDouble() {
         return Double.parseDouble(nextToken());
     }
 }
","import java.io.*;
 import java.util.*;
 
 public class PasswordProblem {
 	public static void main(String[] args) {
 		try {
 			FileWriter output = new FileWriter(new File(""output.txt""));
 			Scanner s = new Scanner(new File(""input.in""));
 			int trials = s.nextInt();
 			s.nextLine();
 			for (int i = 0; i < trials; i++) {
 				int charsTyped = s.nextInt();
 				int charsTotal = s.nextInt();
 				double totalProbCorrect = 1;
 				double minCount = Double.MAX_VALUE;
 				for (int b = 0; b < charsTyped; b++) {
 					double newD = s.nextDouble();
 					double predictedForBackspace = (2 * (charsTyped - b))
 							+ (charsTotal - charsTyped) + 1
 							+ ((1 - totalProbCorrect) * (1 + charsTotal));
 					minCount = Math.min(predictedForBackspace, minCount);
 					totalProbCorrect *= newD;
 				}
 				double base = Math.min(doubleEnter(charsTotal),
 						keepTyping(charsTotal, charsTyped, totalProbCorrect));
 				output.write(""Case #"" + (i + 1) + "": ""
 						+ Math.min(base, minCount));
 				output.write('\n');
 			}
 			System.out.println(""Done"");
 			s.close();
 			output.close();
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 	public static double doubleEnter(int wordLength) {
 		return wordLength + 2;
 	}
 
 	public static double keepTyping(int wordLength, int charactersSoFar,
 			double probabilityCorrect) {
 		double ifNotCorrect = (wordLength - charactersSoFar) + wordLength + 2;
 		double ifCorrect = wordLength - charactersSoFar + 1;
 		return (ifCorrect * probabilityCorrect)
 				+ (ifNotCorrect * (1 - probabilityCorrect));
 	}
 }
",0
117,15253,"
 import java.io.*;
 import java.util.*;
 
 public class FairSquare {
 
     Scanner sc;
     PrintWriter out;
     long min,max;
     boolean te;
 
     public static void main(String[] sArgs) throws IOException {
 	new FairSquare();
     }
 
     FairSquare() throws IOException {
 	sc = new Scanner(new File(""FairSquare.dat""));
 	PrintWriter out = new PrintWriter(""FairSquare.out"");
 	int iRuns = Integer.parseInt(sc.nextLine().trim());
 	on:
 	for (int i = 0; i < iRuns; i++) {
 	    //System.out.println(""BLARG 1"");
 	    out.print(""Case #"" + (i + 1) + "": "");
 	    long i1 = 0, i2 = 0;
 	    int ind = 0;
 	    String line = sc.nextLine();
 	    while (line.charAt(ind) != ' ') {
 		i1 = i1 * 10 + line.charAt(ind++) - '0';
 	    }
 	    //System.out.println(""BLARG 2"");
 	    ind++;
 	    while (ind < line.length()) {
 		i2 = i2 * 10 + line.charAt(ind++) - '0';
 	    }
 	    //System.out.println(""BLARG 3"");
 	    min = i1;
 	    max = i2;
 	    long low = (long) Math.floor(Math.sqrt(i1));
 	    long high = (long) Math.ceil(Math.sqrt(i2));
 	    te = false;
 	    while (!isPal(low)) {
 		low++;
 	    }
 	    while (!isPal(high)) {
 		high--;
 	    }
 	    te = true;
 	    /*String tmp = low + """";
 	    System.out.println(""BLARG ""+(i+1));
 	    int len = (tmp.length() + 1) / 2;
 	    while (tmp.length() > len) {
 		tmp = tmp.substring(0, tmp.length() - 1);
 	    }
 	    long half = Long.parseLong(tmp), count = 0;
 	    if ((low+"""").length() % 2 == 0) {
 		//System.out.println(""BLIP"");
 		while (getDigs(half) == len) {
 		    long blah = getFull(half++);
 		    if (isPal(blah * blah)) {
 			System.out.println(blah*blah);
 			count++;
 		    }
 		}
 	    }*/
 	    long half = 1;
 	    int count=0;
 	    while(getMost(half)<low/10)half++;
 	    while (true) {
 		long blah = getMost(half);
 		//System.out.println(""HERE 1"");
 		if (blah > high) {
 		    break;
 		}
 		//System.out.println(""HERE 2"");
 		if (isPal(blah * blah)) {
 		    count++;
 		    System.out.println(blah * blah);
 		}
 		blah = getFull(half++);
 		if (blah > high) {
 		    continue;
 		}
 		if (isPal(blah * blah)) {
 		    count++;
 		    System.out.println(blah * blah);
 		}
 	    }
 	    //System.out.println(""HERE 3"");
 	    out.println(count);
 	}
 	out.close();
     }
 
     long getMost(long half) {
 	long add = 0, tmp = half;
 	while (tmp > 9) {
 	    add = 10 * add + tmp % 10;
 	    tmp /= 10;
 	    half *= 10;
 	}
 	return half + add;
     }
 
     long getFull(long half) {
 	long add = 0, tmp = half;
 	while (tmp > 0) {
 	    add = 10 * add + tmp % 10;
 	    tmp /= 10;
 	    half *= 10;
 	}
 	return half + add;
     }
 
     int getDigs(long test) {
 	int c = 0;
 	while (test > 0) {
 	    test /= 10;
 	    c++;
 	}
 	return c;
     }
 
     boolean isPal(long test) {
 	if(te&&(test<min || test>max))return false;
 	String t = test + """";
 	for (int i = 0, j = t.length() - 1; i < j; i++, j--) {
 	    if (t.charAt(i) != t.charAt(j)) {
 		return false;
 	    }
 	}
 	return true;
     }
 }","/**
  * @(#)GoroSort.java
  *
  * GoroSort application
  *
  * @author 
  * @version 1.00 2011/5/7
  */
 import java.io.*;
 import java.util.*;  
 public class GoroSort {
     public static HashMap valueHash;
     public static HashMap idxHash;
     public static int [] filled;
     public static boolean sorted(int[]arr1, int[] arr2 ){
     	Boolean ans = true;
     	for(int i =0; i< arr1.length; i++){
     		if(arr1[i] != arr2[i]){
     			ans= false;
     		}else{
     			filled[i] = 1;
     		}
     	}
     	return ans;
     }
     public static int[] findPositionToSwap(int[] workingCopy,int[] listNum){
     	int[] index = new int[2];
     	for(int i=0; i< workingCopy.length-1;i++){
     		if(filled[i] == 0){
     			for(int j=i+1;j< listNum.length;j++){
     				if(filled[j]==0){
     				   if( (listNum[j]==workingCopy[i])&&(listNum[i]==workingCopy[j]) ){
     				   	  index[0] =i;
     				   	  index[1] =j;
     				   	  return index;
     				   }
     				}
     			}
     		}
     	}
     	for(int i=0; i< workingCopy.length-1;i++){
     		if(filled[i] == 0){
     			for(int j=i+1;j< listNum.length;j++){
     				if(filled[j]==0){
     				   if( (listNum[j]==workingCopy[i])){
     				   	  index[0] =i;
     				   	  index[1] =j;
     				   	  return index;
     				   }
     				}
     			}
     		}
     	}
     	return null;
     	
     }
     public static void print_r(int [] arr){
     	for(int i = 0; i < arr.length; i++){
     		System.out.print(arr[i]+"" "");
     	}
     	System.out.println();
     }
     public static void run(){
     	try{
     		BufferedReader in  = new BufferedReader(new FileReader(""D-small.in""));
     		int N = Integer.parseInt(in.readLine());
     		for(int i =0; i<N; i++){
     			System.out.println(""----"");
     			System.out.println();
     			valueHash = new HashMap();
     			idxHash = new HashMap();
     			int arrSize = Integer.parseInt(in.readLine());
     			    filled = new int[arrSize];
     				String words = in.readLine();
     				String wordsArr[] = words.split("" "");
     				int listNum [] = new int[arrSize];
     				int workingCopy[] = new int[arrSize];
     				for(int j = 0; j < arrSize;j++){
     					listNum[j] = Integer.parseInt(wordsArr[j]);
     					workingCopy[j] = listNum[j];
     					filled[j]=0;
     					
     				}
     				Arrays.sort(listNum);
     				int totalcost = 0;
     				while(!sorted(workingCopy,listNum)){
     					print_r(workingCopy);
     					print_r(filled);
     					System.out.println();
     					int [] swapArr = findPositionToSwap(workingCopy,listNum);
     					int temp = workingCopy[swapArr[0]];
     					workingCopy[swapArr[0]] = workingCopy[swapArr[1]];
     					workingCopy[swapArr[1]] =  temp; 
     					totalcost += 2;
     					print_r(workingCopy);
     					print_r(filled);
     					System.out.println();
     				}
     				try{
     					PrintWriter out = new PrintWriter(new FileWriter(""D-small.out"",true));
     				
     					out.println(""Case #""+(i+1)+"": ""+totalcost+"".000000"");
     					out.close();
     		    	}catch(IOException ex2){
     					System.out.println(ex2);
     					System.exit(1);
     			    }
     				
     			
     			
     		
     			
     		}
     	}catch(IOException ex){
     		System.out.println(ex);
     		System.exit(1);
     	}
     }
     public static void main(String[] args) {
     	
          try{
     		PrintWriter out = new PrintWriter(new FileWriter(""D-small.out""));
     	}catch(IOException ex){
     		System.out.println(ex);
     	}
     	run();
     }
 }
",0
118,1746,"/*
  * To change this license header, choose License Headers in Project Properties.
  * To change this template file, choose Tools | Templates
  * and open the template in the editor.
  */
 
 //package googlecodejam;
 
 import java.io.*;
 
 /**
  *
  * @author Hamza
  */
 public class GoogleCodeJamRound1BA {
     public static void main(String[] args) throws IOException
     {
         BufferedReader br = new BufferedReader(new FileReader(""B-small-attempt0.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""B-small-attempt0.out""));
         
         String line = br.readLine();
         int T = Integer.parseInt(line);
         
         for (int i = 1; i <= T; i++)
         {
             line = br.readLine();
             String[] nos = line.split("" "");
             int A = Integer.parseInt(nos[0]);
             int B = Integer.parseInt(nos[1]);
             int K = Integer.parseInt(nos[2]);
             
             int count = 0;
             for (int j = 0; j<A; j++)
             {
                 for (int m = 0; m < B; m++)
                 {
                     int s = j & m;
                     if (s < K) {
                         //System.out.print(""<""+j + "",""+m+"">,"");
                         count++;
                     }
                 }
             }
             bw.write(""Case #""+i+"": ""+count+""\n"");
             bw.flush();
         }
         bw.close();
         br.close();
     }
 }
 
","import java.util.*;
 
 public class a {
 
 	public static void main(String[] args) {
 
 		Scanner stdin = new Scanner(System.in);
 
 		int numCases = stdin.nextInt();
 
 		for (int loop=1; loop<=numCases; loop++) {
 
 			int N = stdin.nextInt();
 			boolean[][] graph = new boolean[N][N];
 
 			for (int i=0; i<N; i++)
 				for (int j=0; j<N; j++)
 					graph[i][j] = false;
 
 			for (int i=0; i<N; i++) {
 
 				int size = stdin.nextInt();
 
 				for (int j=0; j<size; j++) {
 
 					int myclass = stdin.nextInt();
 					myclass--;
 					graph[myclass][i] = true;
 				}
 			}
 
 
 
 
 
 			// Run Floyd's.
 			boolean flag = false;
 			for (int k=0; k<N; k++) {
 				for (int i=0; i<N; i++) {
 					for (int j=0; j<N; j++) {
 
 						if (graph[i][k] && graph[k][j] && graph[i][j])
 							flag = true;
 						else if (graph[i][k] && graph[k][j])
 							graph[i][j] = true;
 
 						if (flag == true)
 							break;
 					}
 
 					if (flag) break;
 				}
 
 				if (flag) break;
 			}
 
 
 
 			if (flag)
 				System.out.println(""Case #""+loop+"": Yes"");
 			else
 				System.out.println(""Case #""+loop+"": No"");
 		}
 	}
 }",0
119,11743,"package cj;
 
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Stack;
 import java.util.StringTokenizer;
 import java.util.logging.Level;
 
 import com.sun.istack.internal.logging.Logger;
 
 public class D {
 	private static String base = ""/home/wz/workspaces/cj-workspace/"";
 
 	public static void main(String[] args) {
 		String input = base + ""input/"" + ""d.in"";
 		String output = base + ""output/"" + ""d.out"";
 
 		try {
 			Scanner sc = new Scanner(new FileReader(input));
 			PrintWriter pw = new PrintWriter(output);
 
 			int n = sc.nextInt();
 			sc.nextLine();
 			for (int c = 0; c < n; c++) {
 				System.out.println(""Test case "" + (c + 1) + ""..."");
 				pw.print(""Case #"" + (c + 1) + "": "");
 				D d = new D();
 				d.test(sc, pw);
 				if (c < n - 1) {
 					pw.print(""\n"");
 				}
 			}
 			pw.flush();
 			pw.close();
 			sc.close();
 		} catch (FileNotFoundException ex) {
 			Logger.getLogger(D.class).log(Level.SEVERE, null, ex);
 		}
 	}
 
 	private void test(Scanner sc, PrintWriter pw) {
 		sc.nextLine();
 
 		String line = sc.nextLine();
 		StringTokenizer st = new StringTokenizer(line, "" "");
 		List<BigDecimal> naomiD = new ArrayList<BigDecimal>();
 		while (st.hasMoreTokens()) {
 			BigDecimal d = new BigDecimal(st.nextToken());
 			d.setScale(5, RoundingMode.CEILING);
 			naomiD.add(d);
 		}
 		Collections.sort(naomiD);
 		Collections.reverse(naomiD);
 		List<BigDecimal> naomiO = new ArrayList<BigDecimal>(naomiD.size());
 		copy(naomiO, naomiD);
 		System.out.println(naomiD);
 
 		line = sc.nextLine();
 		st = new StringTokenizer(line, "" "");
 		List<BigDecimal> kenD = new ArrayList<BigDecimal>();
 
 		while (st.hasMoreTokens()) {
 			BigDecimal d = new BigDecimal(st.nextToken());
 			d.setScale(5, RoundingMode.CEILING);
 			kenD.add(d);
 		}
 		Collections.sort(kenD);
 		Collections.reverse(kenD);
 		List<BigDecimal> kenO = new ArrayList<BigDecimal>(kenD.size());
 		copy(kenO, kenD);
 		System.out.println(kenD);
 
 		int decivals = playDecival(naomiD, kenD);
 
 		int war = playOptimal(naomiO, kenO);
 		System.out.println(""decivals:["" + decivals + ""], war:["" + war + ""]"");
 		pw.print(decivals + "" "" + war);
 	}
 
 	private void copy(List<BigDecimal> dest, List<BigDecimal> src) {
 		for (BigDecimal s : src) {
 			dest.add(s);
 		}
 	}
 
 	private int playDecival(List<BigDecimal> naomi, List<BigDecimal> ken) {
 		int win = 0;
 		if (naomi.size() == 0) {
 			return 0;
 		}
 		if (naomi.get(0).compareTo(ken.get(0)) < 0
 				&& naomi.get(naomi.size() - 1).compareTo(
 						ken.get(ken.size() - 1)) < 0) {
 			naomi.remove(naomi.size() - 1);
 			ken.remove(ken.get(0));
 		}
 		else if(naomi.get(0).compareTo(ken.get(0)) < 0
 				&& naomi.get(naomi.size() - 1).compareTo(
 						ken.get(ken.size() - 1)) > 0){
 			naomi.remove(naomi.size() - 1);
 			ken.remove(ken.get(ken.size()-1));
 			win++;
 		} else if (naomi.get(0).compareTo(ken.get(0)) > 0) {
 			naomi.remove(naomi.get(0));
 			ken.remove(ken.get(0));
 			win++;
 		} else if (naomi.get(naomi.size() - 1).compareTo(
 				ken.get(ken.size() - 1)) < 0) {
 			naomi.remove(naomi.size() - 1);
 			ken.remove(ken.size() - 1);
 		}
 
 		win += playDecival(naomi, ken);
 
 		return win;
 	}
 
 	private int playOptimal(List<BigDecimal> naomi, List<BigDecimal> ken) {
 		int win = 0;
 
 		if (!isNaomiBigger(naomi, ken)) {
 			BigDecimal topKen = ken.get(0);
 			BigDecimal naomiChoose = findInBetween(topKen, naomi);
 			if (naomiChoose == null) {
 				naomiChoose = naomi.get(0);
 			}
 			naomi.remove(naomiChoose);
 			ken.remove(topKen);
 		} else {
 			return naomi.size();
 		}
 
 		win += playOptimal(naomi, ken);
 
 		return win;
 	}
 
 	private boolean isNaomiBigger(List<BigDecimal> naomi, List<BigDecimal> ken) {
 		for (BigDecimal n : naomi) {
 			for (BigDecimal k : ken) {
 				if (n.compareTo(k) < 0) {
 					return false;
 				}
 			}
 		}
 		return true;
 	}
 
 	private BigDecimal findInBetween(BigDecimal topKen, List<BigDecimal> naomi) {
 		BigDecimal chosen = null;
 		for (BigDecimal nBigDecimal : naomi) {
 			if (nBigDecimal.compareTo(topKen) < 0) {
 				chosen = nBigDecimal;
 				break;
 			}
 		}
 		return chosen;
 	}
 
 }
","import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.TreeSet;
 
 public class A {
 
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner(new File(""A-small-attempt0.in""));
 
 		PrintWriter out = new PrintWriter(""as0.out"");
 		
 		TreeSet<Long> pows = new TreeSet<Long>();
 		for (int i = 0; pows.isEmpty() || pows.last() < 10e12; i++) {
 			pows.add((long) Math.round(Math.pow(2, i)));
 		}
 
 		int t = Integer.parseInt(in.nextLine().trim());
 		for (int casen = 1; casen <= t; casen++) {
 			out.printf(""Case #%d: "", casen);
 			
 			String[] inps = in.nextLine().trim().split(""[/]"");
 			long a = Long.parseLong(inps[0]);
 			long b = Long.parseLong(inps[1]);
 			long gcd = gcd(a,b);
 			a /= gcd;
 			b /= gcd;
 			System.out.println(a+""/""+b);
 			
 			if (!pows.contains(b)) {
 				out.println(""impossible"");
 				out.flush();
 				continue;
 			}
 			
 			int gen = 0;
 			
 			while (gen <= 40 && a/b<1) {
 				gen++;
 				a *= 2;
 				// reduce
 				gcd = gcd(a,b);
 				a /= gcd;
 				b /= gcd;
 			}
 			out.println(gen);
 			out.flush();
 		}
 		
 		
 		out.close();
 		in.close();
 	}
 	
 	private static long gcd(long a, long b) {
 		if (a < b) {
 			long temp = b;
 			b = a;
 			a = temp;
 		}
 		
 		if (a == b)
 			return a;
 		
 		while (b != 0) {
 			long mod = a % b;
 			a = b;
 			b = mod;
 		}
 		return a;
 	}
 
 }
",0
120,1894,"import java.util.*;
 
 public class B {
 	static void p(Object a) {
 		System.out.print(a);
 	}
 	static void pln(Object a) {
 		System.out.println(a);
 	}
 
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 
 		int T = in.nextInt();
 		for (int t = 1; t <= T; t++) {
 			p(""Case #"" + t + "": "");
 
 			int E = in.nextInt();
 			int R = in.nextInt();
 			int N = in.nextInt();
 			int[] vs = new int[N];
 			for (int i = 0; i < N; i++) vs[i] = in.nextInt();
 			int[] av = new int[N];
 			Arrays.fill(av, E);
 			int tot = 0;
 
 			while (true) {
 				int max = 0;
 				int maxi = -1;
 				for (int i = 0; i < N; i++) {
 					if (av[i] > 0) {
 						if (vs[i] > max) {
 							max = vs[i];
 							maxi = i;
 						}
 					}
 				}
 				if (maxi == -1) break;
 
 				tot += av[maxi] * vs[maxi];
 				int diff = av[maxi];
 				av[maxi] -= E;
 				//pln(""eating "" + maxi + "": "" + tot);
 				for (int j = 1; j+maxi < N; j++) {
 					int i = j + maxi;
 					if (av[i] <= j*R) break;
 					av[i] = j*R;
 					//pln(""+ "" + i + "" set to "" + av[i]);
 					if (av[i] >= E) {
 						av[i] = E;
 						break;
 					}
 				}
 				for (int i = maxi - 1; i >= 0; i--) {
 					diff -= R;
 					if (diff <= 0) break;
 					av[i] -= diff;
 					if (av[i] <= 0) break;
 					//pln(""- "" + i + "" set to "" + av[i]);
 				}
 			}
 
 			pln(tot);
 		}
 	}
 }
 
","import java.util.*;
 
 public class B {
   private static void print  (String p) { System.out.print(p);   }
   private static void println(String p) { System.out.println(p); }
   
   public static void main(String[] args) {
     Scanner in = new Scanner(System.in);
     
     int P = in.nextInt();
     in.nextLine();
     
     for (int p = 1; p <= P; p++) {
       int l = in.nextInt();
       int t = (int) in.nextLong() / 2;
       int n = in.nextInt();
       int c = in.nextInt();
       
       int totalDist = 0;
       
       int[] a = new int[c];
       for (int i = 0; i < c; i++) {
         a[i] = in.nextInt();
       }
       
       int time = 0;
       int first = 0;
       int distLeftOnFirst = 0;
       if (t > 0) {
         for (int i = 0; i < n; i++) {
           time += a[i%c];
           
           if (time >= t) {
             first = i;
             distLeftOnFirst = (time - t);
             break;
           }
         }
       }
       
       totalDist += time;
       
       TreeSet<Integer> others = new TreeSet<Integer>();
       if (t > 0)  others.add(distLeftOnFirst); 
       
       int fullAs = n/c;
       
       if (t > 0) {
         fullAs -= (first+1)/c;
         if ((first+1)%c > 0) {
           fullAs--;
           for (int i = (first+1)%c; i < c ; i++) {
             others.add(a[i]);
             totalDist += a[i];
           }
         }
       }
       
       if (n%c > 0) fullAs--;
       
       for (int i = 0; i < n%c; i++) {
         others.add(a[i]);
         totalDist += a[i];
       }
       
 
       for (int x: a) {
         totalDist += fullAs*x;
       }
       
       
       Arrays.sort(a);
       int ai = a.length-1;
       
       int distanceToHalf = 0;
       while (l > 0) {
         if ( ! others.isEmpty()  &&  (others.last() > a[ai]  ||  fullAs == 0  ||  ai < 0)) {
           distanceToHalf += others.last();
           others.remove(others.last());
           l--;
         } else {
           for (int i = 0; i < fullAs  &&   l > 0; i++, l--) {
             distanceToHalf += a[ai];
           }
           ai--;
         }
       }
       
       //println(totalDist+"" ""+fullAs);
       int ans = 2*totalDist - distanceToHalf;
       
       System.out.printf(""Case #%d: %d\n"", p, ans);
     }
     
   }
 }",1
121,12815,"package es.jegumi;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 public class RoundB {
 
 	public static class Osmos {
 		int dasboard[];
 		int a;
 		int n;
 		int operations = 0;
 		List<Integer> motes = new ArrayList<Integer>();
 
 		public Osmos(int a, int n) {
 			super();
 			this.a = a;
 			this.n = n;
 		}
 
 		private void solve(int b, List<Integer>motesNew) {
 			while (motesNew.size() > 0) {
 				int value = findSmallmote(b, motesNew);
 				if (value < b) {
 					b += value;
 					motesNew.remove((Integer) value);
 				} else {
 					if (value < b + b -1) {
 						b += b - 1 + value;
 						motesNew.remove((Integer) value);
 						operations++;
 					} else {
 						int newOperations = 0;
 						int c = b;
 						for (int i = 0; i< motesNew.size(); i++) {
 							c += c-1;
 							value = findSmallmote(c, motesNew);
 							newOperations++;
 							if (value < c) {
 								break;
 							}
 						}
 						if (newOperations < motesNew.size()) {
 							b = c + value;
 							motesNew.remove((Integer) value);
 							operations += newOperations;
 						} else {
 							motesNew.remove((Integer) value);
 							operations++;
 						}
 					}
 
 				}
 			}
 		}
 
 		private int findSmallmote(int b, List<Integer>motesNew) {
 			int diff = 0;
 			for (int mote : motesNew) {
 				if (mote < b) {
 					return mote;
 				} else {
 					if (mote + b - 1 < b) {
 						return mote;
 					} else if (mote > diff) {
 						diff = mote;
 					}
 				}
 			}
 			return diff;
 		}
 
 		private void fillDashBoard(String text) {
 			String dasb[] = text.split("" "");
 			for (int i = 0; i < n; i++) {
 				motes.add(Integer.parseInt(dasb[i]));
 			}
 		}
 	}
 
 	public static String readFile() {
 		File archivo = null;
 		FileReader fr = null;
 		BufferedReader br = null;
 		String out = """";
 
 		try {
 			archivo = new File(""A-large.in"");
 			fr = new FileReader(archivo);
 			br = new BufferedReader(fr);
 
 			String linea;
 			while ((linea = br.readLine()) != null)
 				out += linea + ""\n"";
 		} catch (Exception e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (null != fr) {
 					fr.close();
 				}
 			} catch (Exception e2) {
 				e2.printStackTrace();
 			}
 		}
 		return out;
 	}
 
 	public static void writeFile(String output) {
 		FileWriter fichero = null;
 		PrintWriter pw = null;
 		try {
 			fichero = new FileWriter(""output.out"");
 			pw = new PrintWriter(fichero);
 			pw.print(output);
 
 		} catch (Exception e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (null != fichero)
 					fichero.close();
 			} catch (Exception e2) {
 				e2.printStackTrace();
 			}
 		}
 	}
 
 	public static void main(String[] args) {
 		String input = readFile();
 		String output = """";
 		int numTest = Integer.parseInt(input.split(""\n"")[0]);
 		String lines[] = input.substring(input.indexOf('\n') + 1).split(""\n"");
 		int currentLine = 0;
 
 		for (int i = 0; i < numTest; i++) {
 			String gameId = ""Case #"" + (i + 1) + "": "";
 			String lawn[] = lines[currentLine].split("" "");
 			int a = Integer.parseInt(lawn[0]);
 			int n = Integer.parseInt(lawn[1]);
 			currentLine++;
 			Osmos game = new Osmos(a, n);
 			String dasb = lines[currentLine];
 			game.fillDashBoard(dasb);
 			currentLine++;
 			game.solve(game.a, game.motes);
 			output += gameId + game.operations + ""\n"";
 		}
 		writeFile(output);
 	}
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.List;
 
 public class CookieClicker {
 	final double c;
 	final double f;
 	final double x;
 	double currentF = 2;
 	double time;
 	final int numberCase;
 	
 	public CookieClicker(int numberCase, double c, double f, double x) {
 		this.numberCase = numberCase;
 		this.c = c;
 		this.f = f;
 		this.x = x;
 	}
 
 	public static String[] readLines(String filename) throws IOException {
 		FileReader fileReader = new FileReader(filename);
 		BufferedReader bufferedReader = new BufferedReader(fileReader);
 		List<String> lines = new ArrayList<String>();
 		String line = null;
 		while ((line = bufferedReader.readLine()) != null) {
 			lines.add(line);
 		}
 		bufferedReader.close();
 		return lines.toArray(new String[lines.size()]);
 	}
 	
 	public double getSolution() {
 		double initTime = time + getTimeToGetXCookies();
 
 		buyFarm();
 		double newTime = time + getTimeToGetXCookies();
 		if (newTime >= initTime) {
 			return initTime;
 		} else {
 			return getSolution();
 		}
 	}
 	
 	public void buyFarm() {
 		time += c / currentF;
 		currentF += f;
 	}
 	
 	public double getTimeToGetXCookies() {
 		return x / currentF;
 	}
 	
 	public String getOutput(int numberCase) {
 		BigDecimal sol = new BigDecimal(getSolution());
 		return ""Case #"" + numberCase + "": "" + sol.setScale(7, BigDecimal.ROUND_HALF_EVEN).toString();
 	}
 	
 	public static void printOutput(String output) {
 		try {
 	        File newTextFile = new File(""output.txt"");
 	
 	        FileWriter fw = new FileWriter(newTextFile);
 	        fw.write(output);
 	        fw.close();
 	
 	    } catch (IOException iox) {
 	        iox.printStackTrace();
 	    }
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		int numberTestCases;
 		String solution = """";
 		String[] input = null;
 		try {
 			input = CookieClicker.readLines(""B-small-attempt0.in"");
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 		if (input == null) {
 			System.out.println(""Error reading file"");
 		}
 		numberTestCases = Integer.valueOf(input[0]);
 		String[] line;
 		for (int i = 0 ; i < numberTestCases ; i++) {
 			line = input[i + 1].split("" "");
 			CookieClicker cookierClicker = new CookieClicker(i, Double.valueOf(line[0]), Double.valueOf(line[1]), Double.valueOf(line[2]));
 			solution += cookierClicker.getOutput(i + 1) + ""\n"";
 		}
 		printOutput(solution);
 	}
 }
",1
122,16802,"package gcj.war;
 
 import gcj.GcjHelpers;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 
 public class Wars {
 	private static class GameInput {
 		private final List<Double> kens;
 		private final List<Double> naomis;
 
 		public GameInput(List<Double> kens, List<Double> naomis, int length) {
 			this.kens = kens;
 			this.naomis = naomis;
 			Preconditions.checkArgument(kens.size() == naomis.size());
 			Preconditions.checkArgument(length == naomis.size());
 		}
 
 		public List<Double> getKens() {
 			return new ArrayList<Double>(kens);
 		}
 
 		public List<Double> getNaomis() {
 			return new ArrayList<Double>(naomis);
 		}
 
 		public GameInput deceive() {
 
 			List<Double> sk = sort(getKens(), false);
 			List<Double> sn = sort(getNaomis(), false);
 			double max = ((double) (max(sk) + 1.0)) / ((double) 2.0);
 			BitSet hasPair = new BitSet();
 
 			for (int in = 0; in < sn.size(); in++) {
 				double naomis = sn.get(in);
 
 				for (int ik = 0; ik < sk.size(); ik++) {
 					double kens = sk.get(ik);
 					if (naomis > kens && !hasPair.get(ik)) {
 						if ((ik + 1) < sk.size()) {
 							double next = sk.get(ik + 1);
 							sn.set(in, max);
 							hasPair.set(ik, true);
 							break;
 						}
 					}
 				}
 
 			}
 			// List<Double> snsorted = sort(sn, false);
 			return new GameInput(sk, sn, sn.size());
 		}
 
 		static double max(List<Double> a) {
 			double max = -1;
 			for (Double double1 : a) {
 				if (max == -1 || double1 > max) {
 					max = double1;
 				}
 
 			}
 			return max;
 		}
 
 		public GameInput deceive2() {
 
 			List<Double> sk = sort(getKens(), true);
 			List<Double> sn = sort(getNaomis(), false);
 			BitSet hasPair = new BitSet();
 			for (int in = 0; in < sn.size(); in++) {
 				double naomis = sn.get(in);
 
 				for (int ik = 0; ik < sk.size(); ik++) {
 					double kens = sk.get(ik);
 					if (naomis < kens && !hasPair.get(ik)) {
 						if ((ik + 1) < sk.size()) {
 							double next = sk.get(ik + 1);
 							sn.set(in, (kens + next) / (double) 2.0);
 							hasPair.set(ik, true);
 							break;
 						}
 					}
 				}
 
 			}
 			// List<Double> snsorted = sort(sn, false);
 			return new GameInput(sk, sn, sn.size());
 		}
 
 	}
 
 	public static List<Double> sort(List<Double> d, final boolean descending) {
 		Collections.sort(d, new Comparator<Double>() {
 
 			public int compare(Double o1, Double o2) {
 				if (o1 > o2) {
 					return descending ? -1 : 1;
 				}
 				if (o1 < o2) {
 					return descending ? 1 : -1;
 				}
 				return 0;
 			}
 		});
 		return d;
 	}
 
 	private static int war(GameInput game) {
 		final List<Double> n = game.getNaomis();
 		final List<Double> k = game.getKens();
 
 		int nScore = 0;
 
 		for (int in = 0; in < n.size(); in++) {
 			double chosenNaomi = n.get(in);
 
 			double chosenKen = -1.0;
 			int pos = -1;
 
 			double minKen = -1;
 			int minPos = -1;
 
 			for (int ik = 0; ik < k.size(); ik++) {
 				double actualKen = k.get(ik);
 				if (actualKen > chosenNaomi && (chosenKen == -1 || chosenKen > actualKen)) {
 					chosenKen = actualKen;
 					pos = ik;
 				}
 				if (minKen == -1 || actualKen < minKen) {
 					minKen = actualKen;
 					minPos = ik;
 				}
 			}
 			// Naomi had the biggest than all Kens.
 			if (pos == -1) {
 				chosenKen = minKen;
 				pos = minPos;
 				nScore++;
 			}
 			k.remove(pos);
 			// System.err.println(chosenNaomi + "" "" + chosenKen + "" "" + nScore);
 		}
 
 		return nScore;
 	}
 
 	static List<Double> parseLine(String line, int length) {
 		Iterable<String> values = Splitter.on("" "").omitEmptyStrings().trimResults().limit(length).split(line);
 		List<Double> ret = new ArrayList<Double>();
 		for (String s : values) {
 			ret.add(Double.parseDouble(s));
 		}
 
 		return ret;
 	}
 
 	static GameInput parseGameInput(Iterator<String> lines) {
 		int length = Integer.parseInt(lines.next());
 		List<Double> naomis = parseLine(lines.next(), length);
 		List<Double> kens = parseLine(lines.next(), length);
 		return new GameInput(kens, naomis, length);
 	}
 
 	public static void main(String[] args) {
 		GcjHelpers.redirectStandardStreamsTo(new File(""output.txt""));
 		String fileName = Wars.class.getResource(""D-small-attempt1.in"").getFile();
 		// String fileName = Wars.class.getResource(""sample.txt"").getFile();
 		Iterator<String> lines = GcjHelpers.textFileIterableFactory(new File(fileName)).iterator();
 		lines.next();
 		int count = 1;
 		while (lines.hasNext()) {
 			GameInput g = parseGameInput(lines);
 			int w = war(g);
 			// System.err.println(""decc"");
 			GameInput gd = g.deceive();
 			int dw = war(gd);
 
 			System.err.println(""Case #"" + count + "": "" + dw + "" "" + w);
 			count++;
 			// System.exit(0);
 		}
 
 	}
 }
","/*
  * Abstract class that reads either the standard input, a named file, or prompts at the terminal.
  * Implement ""process"" for each CodeJam problem.
  * Reads input through a ReadWrapper, wrapping a BufferedReader.
  */
 
 import java.io.*;
 import java.util.*;
 import java.util.StringTokenizer;
 import java.text.*;
 
 public abstract class CodeJammer {
 
 	protected ReadWrapper reader;
 	protected int caseNum = 1;
 	
 	//Processes one case
 	public abstract void process() throws IOException;
 	
 	public void init() {
 		//Do nothing unless overridden.
 	}
 	
 	//Process all cases... usually just read the number of them and then run process on each.
 	//Override if necessary.
 	public void processAll() throws IOException {
 		init();
 		int numTrials = reader.readInt();
 		for (int i=0; i<numTrials; i++) {
 			process();
 		}
 	}
 	
 	public void output(String s) {
 		if (s == null) System.out.println(""Case #"" + (caseNum++) + "":""); //no space
 		else System.out.println(""Case #"" + (caseNum++) + "": "" + s);
 	}
 	
 	public void output(int n) {
 		output(Integer.toString(n));
 	}
 	
 	public void output(long n) {
 		output(Long.toString(n));
 	}
 	
 	//Prints a double with the specified number of digits after the decimal.
 	public void output(double d, int digits) {
 		String s = ""0."";
 		for (int i=0; i<digits; i++) s += ""0"";
 		DecimalFormat f = new DecimalFormat(s);
 		output(f.format(d));
 	}
 	
 	public void output(double d) {
 		output(Double.toString(d));
 	}
 	
 	public void output(int[] array) {
 		String s = """";
 		for (int i=0; i<array.length; i++)
 			s += "" "" + array[i];
 		output(s.substring(1));
 	}
 	
 	public void output(long[] array) {
 		String s = """";
 		for (int i=0; i<array.length; i++)
 			s += "" "" + array[i];
 		output(s.substring(1));
 	}
 	
 	public void output(char[] array) {
 		String s = """";
 		for (int i=0; i<array.length; i++)
 			s += "" "" + array[i];
 		output(s.substring(1));
 	}
 	
 	public void run(String[] args) {
 		BufferedReader buff;
 		if (args.length == 0) {
 			buff = new BufferedReader(new InputStreamReader(System.in));
 		} else {
 			String filename = args[0];
 			try {
 				buff = new BufferedReader(new FileReader(filename));
 			} catch (FileNotFoundException ex) {
 				System.out.println(""File not found."");
 				return;
 			}
 		}
 		reader = new ReadWrapper(buff);
 		try {
 			processAll();
 		} catch (IOException ex) {
 			System.out.println(ex.getMessage());
 		}
 	}
 	
 	public static class ReadWrapper {
 		
 		private BufferedReader in;
 		
 		public ReadWrapper(BufferedReader in) {
 			this.in = in;
 		}
 		
 		public String readString() throws IOException {
 			return in.readLine();
 		}
 		
 		public int readInt() throws IOException {
 			String line = in.readLine();
 			try {
 				return Integer.parseInt(line);
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected an int and read "" + line));
 			}
 		}
 		
 		public int[] readArray() throws IOException {
 			String line = in.readLine();
 			try {
 				StringTokenizer t = new StringTokenizer(line);
 				int[] result = new int[t.countTokens()];
 				for (int i=0; t.hasMoreTokens(); i++) {
 					result[i] = Integer.parseInt(t.nextToken());
 				}
 				return result;
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected an int array and read "" + line));
 			}
 		}
 		
 		public long readLong() throws IOException {
 			String line = in.readLine();
 			try {
 				return Long.parseLong(line);
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected a long and read "" + line));
 			}
 		}
 		
 		public long[] readLongArray() throws IOException {
 			String line = in.readLine();
 			try {
 				StringTokenizer t = new StringTokenizer(line);
 				long[] result = new long[t.countTokens()];
 				for (int i=0; t.hasMoreTokens(); i++) {
 					result[i] = Long.parseLong(t.nextToken());
 				}
 				return result;
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected a long array and read "" + line));
 			}
 		}
 		
 		public double readDouble() throws IOException {
 			String line = in.readLine();
 			try {
 				return Double.parseDouble(line);
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected a double and read "" + line));
 			}
 		}
 		
 		public double[] readDoubleArray() throws IOException {
 			String line = in.readLine();
 			try {
 				StringTokenizer t = new StringTokenizer(line);
 				double[] result = new double[t.countTokens()];
 				for (int i=0; t.hasMoreTokens(); i++) {
 					result[i] = Double.parseDouble(t.nextToken());
 				}
 				return result;
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected a double array and read "" + line));
 			}
 		}
 		
 		public String[] readStringArray() throws IOException {
 			String line = in.readLine();
 			try {
 				StringTokenizer t = new StringTokenizer(line);
 				String[] result = new String[t.countTokens()];
 				for (int i=0; t.hasMoreTokens(); i++) {
 					result[i] = t.nextToken();
 				}
 				return result;
 			} catch (NumberFormatException ex) {
 				throw (new IOException(""ReadWrapper expected a String array and read "" + line));
 			}
 		}
 		
 		//Methods to read a single token at a time... for cases where input goes over multiple lines
 		private StringTokenizer t = null;
 		private String delims = null;
 		private boolean returnDelims = false;
 		
 		public void setDelims(String delims, boolean returnThem) {
 			this.delims = delims;
 			returnDelims = returnThem;
 		}
 		
 		public String getToken() throws IOException {
 			while (t==null || !t.hasMoreTokens()) {
 				if (delims == null) {
 					t = new StringTokenizer(readString());
 				} else {
 					t = new StringTokenizer(readString(), delims, returnDelims);
 				}
 			}
 			return t.nextToken();
 		}
 		
 		public int getInt() throws IOException {
 			String s = getToken();
 			try {
 				return Integer.parseInt(s);
 			} catch (NumberFormatException e) {
 				throw (new IOException(""ReadWrapper expected an int and read "" + s));
 			}
 		}
 		
 		public long getLong() throws IOException {
 			String s = getToken();
 			try {
 				return Long.parseLong(s);
 			} catch (NumberFormatException e) {
 				throw (new IOException(""ReadWrapper expected a long and read "" + s));
 			}
 		}
 		
 		public double getDouble() throws IOException {
 			String s = getToken();
 			try {
 				return Double.parseDouble(s);
 			} catch (NumberFormatException e) {
 				throw (new IOException(""ReadWrapper expected a double and read "" + s));
 			}
 		}
 		
 	}
 	
 }
",0
123,15979,"
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author igor_kz
  */
 public class CandySplitting {
 
     static boolean ok;
 
     public static void main(String[] args) throws Exception {
         Scanner in = new Scanner(new File(""input.txt""));
         PrintWriter out = new PrintWriter(""output.txt"");
         int test = in.nextInt();
         for (int t = 1; t <= test; t++) {
             int n = in.nextInt();
             int[] a = new int[n];
             for (int i = 0; i < n; i++) {
                 a[i] = in.nextInt();
             }
             int res = -1;
             for (int mask = 1; mask < (1 << n) - 1; mask++) {
                 ok = false;
                 Solve(mask, a, n);
                 if (ok) {
                     int res1 = 0;
                     int res2 = 0;
                     for (int i = 0; i < n; i++) {
                         if ((mask & (1 << i)) == 0) {
                             res1 += a[i];
                         } else res2 += a[i];
                     }
                     res = Math.max(res , Math.max(res1 , res2));
                 }
             }
             if (res == -1) out.println(""Case #"" + t + "": "" + ""NO"");
             else out.println(""Case #"" + t + "": "" + res);
         }
 
 
         out.close();
     }
 
     private static void Solve(int mask, int[] a, int n) {
         int sum1 = 0;
         int sum2 = 0;
         for (int i = 0 ; i < n ; i++) {
             if ((mask & (1 << i)) != 0) sum1 ^= a[i]; else sum2 ^= a[i];
         }
         if (sum1 == sum2) ok = true;
     }
 }
","
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.StringTokenizer;
 
 /**
  *
  * @author igor_kz
  */
 public class PerfectHarmony {
     static int[] a;
     static int n;
     public static void main(String[] args) throws Exception {
         Scanner in = new Scanner(new File(""input.txt""));
         PrintWriter out = new PrintWriter(""output.txt"");
         int test = Integer.parseInt(in.nextLine());
         for (int t = 1; t <= test; t++) {
             String nums = in.nextLine();
             StringTokenizer st = new StringTokenizer(nums);
             n = Integer.parseInt(st.nextToken());
             int l = Integer.parseInt(st.nextToken());
             int h = Integer.parseInt(st.nextToken());
             a = new int[n];
             nums = in.nextLine();
             st = new StringTokenizer(nums);
             for (int i = 0 ; i < n ; i++)
                 a[i] = Integer.parseInt(st.nextToken());
             boolean ok = false;
             while (l <= h) {
                 if (canBe(l)) {
                     ok = true;
                     break;
                 }
                 l++;
             }
             out.print(""Case #"" + t + "": "");
             if (ok) out.println(l); else out.println(""NO"");
         }
         out.close();
     }
 
     private static boolean canBe(int l) {
         for (int i = 0 ; i < n ; i++)
             if (l % a[i] == 0 || a[i] % l == 0) ; else return false;
         return true;
     }
 }
",1
124,14347,"package jp.kitora.gcj2010.q;
 
 import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Comparator;
 
 /**
  * j
  * 
  * @author masanao
  * 
  */
 public class QualificationSnapperChain_A {
 
 	/**
 	 * Target file is latest file in current directory or args[0].
 	 * 
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		if (args.length != 1) {
 			System.out.println(""usage: > java <ProgramName> <TargetDir>"");
 			System.exit(1);
 		}
 		// Search File
 		File dir = new File(args[0]);
 		File[] fs = dir.listFiles(new FilenameFilter() {
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.endsWith("".in.txt"");
 			}
 		});
 		Arrays.sort(fs, new Comparator<File>() {
 			@Override
 			public int compare(File o1, File o2) {
 				return (int) (o2.lastModified() - o1.lastModified());
 			}
 		});
 		// In-filename to Out-filename
 		try {
 			QualificationSnapperChain_A dt = new QualificationSnapperChain_A(
 					new FileInputStream(fs[0]), new FileOutputStream(new File(
 							dir, fs[0].getName()
 									.replaceAll(""\\.in\\."", "".out.""))));
 			dt.doAll();
 		} catch (FileNotFoundException e) {
 			// No
 			e.printStackTrace();
 			System.exit(1);
 		} catch (IOException e) {
 			// Unexpected
 			e.printStackTrace();
 			System.exit(1);
 		}
 		// Copy Program
 	}
 
 	public QualificationSnapperChain_A(InputStream in, OutputStream out) {
 		input = new BufferedReader(new InputStreamReader(in));
 		output = new PrintStream(new BufferedOutputStream(out));
 	}
 
 	public void doAll() throws IOException {
 		readFirst();
 		prepare();
 		for (int t = 0; t < T; t++) {
 			casenum = t + 1;
 			readCase();
 			solve();
 			write();
 		}
 		close();
 	}
 
 	private void prepare() {
 	}
 
 	/**
 	 * Read first line and prepare detecting resource.
 	 * 
 	 * @throws IOException
 	 */
 	public void readFirst() throws IOException {
 		// First line
 		String t = input.readLine();
 		T = Integer.valueOf(t);
 	}
 
 	public void readCase() throws IOException {
 		// First line of Test case
 		target = input.readLine();
 	}
 
 	private void solve() {
 		String[] casedata = target.split("" "");
 		int bit = Integer.valueOf(casedata[0]);
 		BigInteger value = BigInteger.valueOf(Long.valueOf(casedata[1]));
 		BigInteger digitmax = BigInteger.ONE.shiftLeft(bit);
 		result = value.mod(digitmax).equals(digitmax.subtract(BigInteger.ONE)) ? ""ON""
 				: ""OFF"";
 	}
 
 	public void write() throws IOException {
 		// output.printf(""Case #%d: %04d\n"", casenum, counter);
 		output.printf(""Case #%d: %s\n"", casenum, result);
 		output.flush();
 	}
 
 	public void close() {
 		output.flush();
 		output.close();
 	}
 
 	private BufferedReader input;
 	private PrintStream output;
 	private int T;
 	private int casenum;
 	private String result;
 	private String target;
 	private int[] nums;
 	private int[] yanums;
 }
","package com.google.code.jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class B {
 	public static int Case,M,N;
 	public static int[][] lawn = new int[102][102];
 	public static String[] Judge = {""YES"",""NO""};
 
 //	public static final String inputfileName = ""B-small-attempt1.in"";
 //	public static final String outputfileName = ""B-small-attempt1.out"";
 //	public static final String inputfileName = ""B-practice.in"";
 //	public static final String outputfileName = ""B-practice.out"";
 	public static final String inputfileName = ""B-small-attempt0.in"";
 	public static final String outputfileName = ""B-small-attempt0.out"";
 //	public static final String inputfileName = ""B-large.in"";
 //	public static final String outputfileName = ""B-large.out"";
 	
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		Scanner s = null;
 		PrintWriter outputStream = null;
 		try{
 			s = new Scanner(new BufferedReader(
 					new FileReader(inputfileName)));
 			outputStream = new PrintWriter(
     				new BufferedWriter(new FileWriter(outputfileName)));
 			
 			Case = s.nextInt();
 			for(int i=0;i<Case;i++){
 				N = s.nextInt();
 				M = s.nextInt(); 
 				//populate the lawn
 				for(int j=0;j<N;j++){
 					for(int k=0;k<M;k++){
 						lawn[j][k] = s.nextInt();
 						//System.out.format(""%d "", lawn[j][k]);
 					}
 					//System.out.println();
 				}
 				//System.out.println();
 				int rst = solve();
 				System.out.format(""Case #%d: %s\n"" , i+1, Judge[rst]);
 				outputStream.format(""Case #%d: %s\n"" , i+1, Judge[rst]);	
 			}
 		}finally{
 			if (s != null) {
                 s.close();
             }
             if (outputStream != null) {
             	outputStream.close();
             }	
 		}
 	}
 
 	private static int solve() {
 		// TODO Auto-generated method stub
 		boolean row_ok,col_ok;
 		for(int i=0;i<N;i++){
 			for(int j=0;j<M;j++){
 				row_ok = true;
 				for(int k=1;k<M;k++){
 					if(lawn[i][j]<lawn[i][(j+k)%M]){
 						row_ok = false;
 					}
 				}
 				col_ok = true;
 				for(int k=1;k<N;k++){
 					if(lawn[i][j]<lawn[(i+k)%N][j]){
 						col_ok = false;
 					}
 				}
 				if( !row_ok && !col_ok ){
 					return 1;
 				}
 			}
 		}
 		return 0;
 	}
 }
",0
125,12600,"import java.util.Scanner;
 /*
  * CodeJam 2012 Round 1A
  * Coder: Tommy Ludwig
  * Problem A: Password Problem
  */
 
 
 public class A {
 	
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		int T, A, B;	//A = chars typed; B = total chars in pwd
 		T = in.nextInt();
 		
 		for (int i = 1; i <= T; i++) {
 			A = in.nextInt();
 			B = in.nextInt();
 			double [] p = new double[A];
 			
 			for (int j = 0; j < A; j++)
 				p[j] = in.nextDouble();
 			
 			//keep trying
 			double p_try;
 			double correct = 1;
 			for (int j = 0; j < A; j++)
 				correct *= p[j];
 			p_try = correct * (B-A+1);
 			p_try += (1 - correct) * (B-A+1+B+1);
 			
 			//enter right away
 			int p_enter = B + 2;
 			
 			//backspace __ times
 			double [] p_back = new double[A];
 			if (A == 1)
 				p_back[0] = p_enter;
 			if (A == 2) {
 				double percent1 = p[0] * (1 - p[1]);
 				double percent2 = 1 - (correct + percent1);
 				p_back[0] = (correct + percent1) * (B-A+2+1) + (percent2) * (B-A+2+1+B+1);
 				p_back[1] = p_enter + 1;
 			}
 			if (A == 3) {
 				double percent1 = (p[0] * (1 - p[2]) * p[1]);
 				double percent2 = 1 - (correct + percent1);
 				p_back[0] = (correct + percent1) * (B-A+2+1) + (percent2) * (B-A+2+1+B+1);
 				percent1 = correct + (p[0] * (1 - p[1]) * (1 - p[2])) + (p[0] * (1 - p[1]) * p[2]) + (p[0] * p[1] * (1 - p[2]));
 				percent2 = 1 - percent1;
 				p_back[1] = percent1 * (B-A+4+1) + (percent2) * (B-A+4+1+B+1);
 				p_back[2] = 3 + B + 1;
 			}
 			double min_back = p_back[0];
 			for (int j = 1; j < A; j++) {
 				if (p_back[j] < min_back)
 					min_back = p_back[j];
 			}
 			
 			double min = Math.min(min_back, p_enter);
 			
 			double y = Math.min(min, p_try);
 		
 			System.out.printf(""Case #%d: %f\n"", i, y);	//y = expected # of keystrokes using optimal strat
 		}
 	}
 
 }
","import java.util.Scanner;
 /*
  * CodeJam 2012 Round 1A
  * Coder: Tommy Ludwig
  * Problem A: Password Problem
  */
 
 
 public class A {
 	
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		int T, A, B;	//A = chars typed; B = total chars in pwd
 		T = in.nextInt();
 		
 		for (int i = 1; i <= T; i++) {
 			A = in.nextInt();
 			B = in.nextInt();
 			double [] p = new double[A];
 			
 			for (int j = 0; j < A; j++)
 				p[j] = in.nextDouble();
 			
 			//keep trying
 			double p_try;
 			double correct = 1;
 			for (int j = 0; j < A; j++)
 				correct *= p[j];
 			p_try = correct * (B-A+1);
 			p_try += (1 - correct) * (B-A+1+B+1);
 			
 			//enter right away
 			int p_enter = B + 2;
 			
 			//backspace __ times
 			double [] p_back = new double[A];
 			if (A == 1)
 				p_back[0] = p_enter;
 			if (A == 2) {
 				double percent1 = p[0] * (1 - p[1]);
 				double percent2 = 1 - (correct + percent1);
 				p_back[0] = (correct + percent1) * (B-A+2+1) + (percent2) * (B-A+2+1+B+1);
 				p_back[1] = p_enter + 1;
 			}
 			if (A == 3) {
 				double percent1 = (p[0] * (1 - p[2]) * p[1]);
 				double percent2 = 1 - (correct + percent1);
 				p_back[0] = (correct + percent1) * (B-A+2+1) + (percent2) * (B-A+2+1+B+1);
 				percent1 = correct + (p[0] * (1 - p[1]) * (1 - p[2])) + (p[0] * (1 - p[1]) * p[2]) + (p[0] * p[1] * (1 - p[2]));
 				percent2 = 1 - percent1;
 				p_back[1] = percent1 * (B-A+4+1) + (percent2) * (B-A+4+1+B+1);
 				p_back[2] = 3 + B + 1;
 			}
 			double min_back = p_back[0];
 			for (int j = 1; j < A; j++) {
 				if (p_back[j] < min_back)
 					min_back = p_back[j];
 			}
 			
 			double min = Math.min(min_back, p_enter);
 			
 			double y = Math.min(min, p_try);
 		
 			System.out.printf(""Case #%d: %f\n"", i, y);	//y = expected # of keystrokes using optimal strat
 		}
 	}
 
 }
",1
126,3831,"import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /**
  * Compiled with Oracle Java 8 (jdk1.8.0) on Mac OS X 10.9.2 (Intel).
  *
  * Problem statement:
  * https://code.google.com/codejam/contest/2994486/dashboard#s=p1
  *
  * @author magnetar <magnetar.fields@gmail.com>
  */
 public class NewLotteryGame {
 
     /** CONSTANTS ***********************************************************/
     public static final boolean DEBUG = true;
     public static final String FILENAME = ""B-small-0"";
 
     //region Class Members -----------------------------------------------------------/
 
     //endregion
 
     //region Boilerplate -------------------------------------------------------------/
     private File inputfile = new File(""/Users/codejam/source/"" + FILENAME + "".in"");
     private File outfile = new File(""/Users/codejam/source/"" + FILENAME + "".out"");
     private BufferedWriter writer = null;
 
     public static void main(String[] args) {
         new NewLotteryGame();
     }
 
     public NewLotteryGame() {
         System.out.println(""New Lottery Game entry by Magnetar <magnetar.fields@gmail.com>"");
         try (Scanner scan = new Scanner(new BufferedReader(new FileReader(inputfile)))) {
             writer = new BufferedWriter(new FileWriter(outfile));
             process(scan);
         } catch (Exception ex) {
             ex.printStackTrace();
         } finally {
             try {
                 if (writer != null)
                     writer.close();
             } catch (IOException ioex) {
                 ioex.printStackTrace();
             }
         }
         System.out.println(""Exit OK"");
     }
 
     public void write() throws Exception {
         writer.newLine();
         if (!DEBUG) {
             System.out.println();
         }
     }
 
     public void write(String str) throws Exception {
         writer.write(str);
         writer.newLine();
         if (!DEBUG) {
             System.out.println(str);
         }
     }
 
     public void write(String str, boolean newline) throws Exception {
         if (newline) {
             writer.write(str);
             writer.newLine();
             if (!DEBUG) {
                 System.out.println(str);
             }
         } else {
             writer.write(str);
             if (!DEBUG) {
                 System.out.print(str);
             }
         }
     }
 
     public void print() {
         if (DEBUG) {
             System.out.println();
         }
     }
 
     public void print(int i) {
         print(Integer.toString(i));
     }
 
     public void print(int i, boolean newline) {
         print(Integer.toString(i), newline);
     }
 
     public void print(double i) {
         print(Double.toString(i));
     }
 
     public void print(double i, boolean newline) {
         print(Double.toString(i), newline);
     }
 
     public void print(String str) {
         if (DEBUG) {
             System.out.println(str);
         }
     }
 
     public void print(String str, boolean newline) {
         if (DEBUG) {
             if (newline)
                 System.out.println(str);
             else
                 System.out.print(str);
         }
     }
     //endregion
 
     /** process() ***********************************************************/
     public void process(Scanner scan) throws Exception {
         int T = scan.nextInt(); // number of test cases
         for (int casen = 1; casen <= T; casen++) {
             print(""Case #"" + casen + "": "");
             //region Parse test case inputs ---------------------------------------------------/
             int A = Integer.parseInt(scan.next());
             int B = Integer.parseInt(scan.next());
             int K = Integer.parseInt(scan.next());
 
             int ab = (int) A * B;
             long[] numbers = new long[ab];
             int n = 0;
             for (long a = 0; a < A; a++) {
             	for (long b = 0; b < B; b++) {
             		numbers[n] = a & b;
             		//print(""numbers["" + n + ""] = "" + numbers[n]);
             	    n++;
             	}
             }
             
             int count = 0;
             for (long k = 0; k < K; k++) {
             	for (int ni = 0; ni < n; ni++) {
             		//print(""comparing "" + numbers[ni] + "" with "" + k);
             		if (numbers[ni] == k) {
             			count++;
             		}
             	}
             }
             
             //endregion
 
             //region Logic loop ------------------------------------------------------/
 
 
             //endregion End logic loop ---------------------------------------------/
             print(count);
             write(""Case #"" + casen + "": "" + count);
             print(""-----------------------------"");
         }
     }
 }
","import java.io.*;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /**
  * Compiled with Oracle Java 8 (jdk1.8.0) on Mac OS X 10.9.2 (Intel).
  *
  * Problem statement:
  * https://code.google.com/codejam/contest/2994486/dashboard#s=p0
  *
  * @author magnetar <magnetar.fields@gmail.com>
  */
 public class TheRepeater {
 
     /** CONSTANTS ***********************************************************/
     public static final boolean DEBUG = true;
     public static final String FILENAME = ""A-large-0"";
 
     //region Class Members -----------------------------------------------------------/
 
     //endregion
 
     //region Boilerplate -------------------------------------------------------------/
     private File inputfile = new File(""/Users/codejam/source/"" + FILENAME + "".in"");
     private File outfile = new File(""/Users/codejam/source/"" + FILENAME + "".out"");
     private BufferedWriter writer = null;
 
     public static void main(String[] args) {
         new TheRepeater();
     }
 
     public TheRepeater() {
         System.out.println(""The Repeater entry by Magnetar <magnetar.fields@gmail.com>"");
         try (Scanner scan = new Scanner(new BufferedReader(new FileReader(inputfile)))) {
             writer = new BufferedWriter(new FileWriter(outfile));
             process(scan);
         } catch (Exception ex) {
             ex.printStackTrace();
         } finally {
             try {
                 if (writer != null)
                     writer.close();
             } catch (IOException ioex) {
                 ioex.printStackTrace();
             }
         }
         System.out.println(""Exit OK"");
     }
 
     public void write() throws Exception {
         writer.newLine();
         if (!DEBUG) {
             System.out.println();
         }
     }
 
     public void write(String str) throws Exception {
         writer.write(str);
         writer.newLine();
         if (!DEBUG) {
             System.out.println(str);
         }
     }
 
     public void write(String str, boolean newline) throws Exception {
         if (newline) {
             writer.write(str);
             writer.newLine();
             if (!DEBUG) {
                 System.out.println(str);
             }
         } else {
             writer.write(str);
             if (!DEBUG) {
                 System.out.print(str);
             }
         }
     }
 
     public void print() {
         if (DEBUG) {
             System.out.println();
         }
     }
 
     public void print(int i) {
         print(Integer.toString(i));
     }
 
     public void print(int i, boolean newline) {
         print(Integer.toString(i), newline);
     }
 
     public void print(double i) {
         print(Double.toString(i));
     }
 
     public void print(double i, boolean newline) {
         print(Double.toString(i), newline);
     }
 
     public void print(String str) {
         if (DEBUG) {
             System.out.println(str);
         }
     }
 
     public void print(String str, boolean newline) {
         if (DEBUG) {
             if (newline)
                 System.out.println(str);
             else
                 System.out.print(str);
         }
     }
     //endregion
 
     /** process() ***********************************************************/
     public void process(Scanner scan) throws Exception {
         int T = scan.nextInt(); // number of test cases
         for (int casen = 1; casen <= T; casen++) {
             print(""Case #"" + casen + "": "");
             //region Parse test case inputs ---------------------------------------------------/
             int N = scan.nextInt();
             
             List<String> words = new ArrayList<>();
             for (int i = 0; i < N; i++) {
             	words.add(scan.next());
             }
             
             
             int[] unicount = new int[N];
             Set<Character> dic = new HashSet<>();
             Set<Character> tempdic = new HashSet<>();
             for (int w = 0; w < N; w++) {
             	print(""["" + words.get(w) + ""]"");
             	for (int i = 0; i < words.get(w).length(); i++) {
             		dic.add(words.get(w).charAt(i));
             		tempdic.add(words.get(w).charAt(i));
             	}
             	unicount[w] = tempdic.size();
             	tempdic.clear();
             }
             
             //print(""Dic is ["", false);
             //for (Character c : dic) {
             //	print(c.toString(), false);
             //}
             //print(""]"");
 
             //region Logic loop ------------------------------------------------------/
             // find biggie
             int biggie = -1;
             int biggie_index = -1;
             String biggie_word = null;
             /*
             for (int i = 0; i < N; i++) {
             	if (unicount[i] > biggie) {
             		biggie = unicount[i];
             		biggie_index = i;
             		biggie_word = words.get(i);
             	}
             }
             */
             
             String big_pattern_str = """";
             int groups = 0;
             int closest_index = -1;
             //print(""biggie_word is ["" + biggie_word + ""]"");
             for (int w = 0; w < N ; w++) {
             	String miword = words.get(w);
 	            StringBuffer big_pattern_trial = new StringBuffer();
 	            char last = '0';
 	            int groups_trial = 0;
 	            for (int i = 0; i < miword.length(); i++) {
 	            	char mychar = miword.charAt(i);
 	            	if (mychar != last) {
 	            		big_pattern_trial.append(""(["" + mychar + ""]+)"");
 	            		last = mychar;
 	            		groups_trial++;
 	            	}
 	            }
 	            if (big_pattern_trial.toString().length() > big_pattern_str.length()) {
 	            	big_pattern_str = big_pattern_trial.toString();
 	            	groups = groups_trial;
 	            	biggie_word = miword;
 	            	closest_index = w;
 	            }
             }
             
             print(""big_pattern is exactly "" + big_pattern_str);
             //print(""groups is "" + groups);
             Pattern pattern = Pattern.compile(big_pattern_str, Pattern.CASE_INSENSITIVE);
             
             boolean fegla_wins = false;
             for (String word: words) {
                 Matcher matcher = pattern.matcher(word);
                 if (matcher.find()) {
                 	//print(""["" + word + ""] MATCHED!!!!"");
                 	continue;
                 } else {
                 	//print (""NO MATCH for "" + word);
                 	fegla_wins = true;
                 	break;
                 }
             }
            
             String result = null;
             if (fegla_wins) {
             	result = ""Fegla Won"";
             } else {
             	// find average length
             	/*
             	double sum = 0;
             	for (String word : words) {
             		sum += word.length();
             	}
             	double average = sum / ((double) N);
             	int ave = (int) Math.round(average);
             	print(""ave is "" + ave);
             	
             	// find word closest to average
             	int closest = Integer.MAX_VALUE;
             	int closest_index = -1;
             	
             	for (int i = 0; i < N; i++) {
             		if (Math.abs(words.get(i).length() - ave) < closest) {
             			closest = Math.abs(words.get(i).length() - ave);
             			closest_index = i;
             		}
             	}
             	print(""closest is "" + closest + "", and closest_index is "" + closest_index); 
             	*/
             	
             	/*
             	int[] big_groups = new int[groups+1];
 
             	for (int i = 0; i < groups; i++) {
             		big_groups[i] = matcher.group(i).length();
             	}
             	*/
             	Matcher matcher = pattern.matcher(biggie_word);
             	matcher.find();
 
             	int moves = 0;
         		int m = 0;
         		int grower = 0;
         		int trimmer = 0;
             	for (int i = 0; i < N; i++) {
             		if (i != closest_index) {
             			Matcher matcher2 = pattern.matcher(words.get(i));
             			matcher2.find();
             			print(""grops = "" + groups);
             			for (int j = 1; j <= groups; j++) {
             				print("" grouping ("" + matcher2.group(j) + "") and ("" + matcher.group(j) + "")"");
             				m += Math.abs(matcher2.group(j).length() - matcher.group(j).length());
             			}  
             		}            		
                	}
             	
         		/* now attempt grower algo */
             	int[] max_groups = new int[groups+1];
             	for (int i = 0; i < N; i++) {
         			Matcher matcher3 = pattern.matcher(words.get(i));
         			matcher3.find();
         			for (int j = 1; j <= groups; j++) {
         				if (matcher3.group(j).length() > max_groups[j])
         					max_groups[j] = matcher3.group(j).length();
         			}  
             	}            		
                	            	
 	        	for (int i = 0; i < N; i++) {
 	    			Matcher matcher4 = pattern.matcher(words.get(i));
 	    			matcher4.find();
 	    			for (int j = 1; j <= groups; j++) {
 	    				if (matcher4.group(j).length() < max_groups[j])
 	    					grower += max_groups[j] - matcher4.group(j).length();
 	    			}  
 	    		}            	
 	        	print (""grower is "" + grower );
             
 	        	/* trimmer algo */
             	int[] min_groups = new int[groups+1];
             	for (int i = 0; i < groups+1; i++) {
             		min_groups[i] = Integer.MAX_VALUE;
             	}
             	for (int i = 0; i < N; i++) {
         			Matcher matcher4 = pattern.matcher(words.get(i));
         			matcher4.find();
         			for (int j = 1; j <= groups; j++) {
         				if (matcher4.group(j).length() < min_groups[j])
         					min_groups[j] = matcher4.group(j).length();
         			}  
             	}   
             	for (int i = 0; i < groups+1; i++) {
             		//print(""min_groups["" + i + ""] = "" + min_groups[i]);
             	}
                	            	
 	        	for (int i = 0; i < N; i++) {
 	    			Matcher matcher4 = pattern.matcher(words.get(i));
 	    			matcher4.find();
 	    			for (int j = 1; j <= groups; j++) {
 	    				if (matcher4.group(j).length() > min_groups[j])
 	    					trimmer += matcher4.group(j).length() - min_groups[j];
 	    			}  
 	    		}            	
 	        	print (""trimmer is "" + trimmer );
    
             	if (grower < m && grower < trimmer) {
             		moves += grower;
             	} else if (trimmer < m) {
             		moves += trimmer;
             	} else {
             		moves += m;
             	}
             	
             	/*
             	boolean biggie_reduce = false;
             	for (int i = 0; i < N; i++) {
             		int m = 0;
             		if (i != closest_index) {
             			m = Math.abs(words.get(i).length() - words.get(closest_index).length());
             		
 	            		if (m == 0 && !words.get(i).equals(words.get(closest_index))) {
 	            			m = Math.abs(words.get(i).length() - dic.size());
 	            			biggie_reduce = true;
 	            			break;
 	            		}
             		}
             		
             		moves += m;
             	}
             	
             	if (biggie_reduce) {
             		moves = 0;
                 	for (int i = 0; i < N; i++) {
                 		moves += Math.abs(words.get(i).length() - dic.size());
                 	}
             	}
             	*/
             	
             	result = Integer.toString(moves);
             }
             
             //endregion End logic loop ---------------------------------------------/
 
             print(""Result is "" + result);
             write(""Case #"" + casen + "": "" + result);
             print(""-----------------------------------------"");
         }
     }
 }
",1
127,234,"package Round1A;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class ProblemA {
 
 	static BufferedWriter out;
 	static int switches;
 	static int best;
 
 	public static void solve(Scanner sc) throws IOException {
 		int N = sc.nextInt();
 		int L = sc.nextInt();
 		String[] flow = new String[N];
 		int[] ones = new int[L];
 		for (int i = 0; i < N; i++) {
 			flow[i] = sc.next();
 			for (int j = 0; j < flow[i].length(); j++) {
 				ones[j] += (flow[i].charAt(j) == '1' ? 1 : 0);
 			}
 		}
 		String[] needed = new String[N];
 		int[] onesNeeded = new int[L];
 		for (int i = 0; i < N; i++) {
 			needed[i] = sc.next();
 			for (int j = 0; j < needed[i].length(); j++) {
 				onesNeeded[j] += (needed[i].charAt(j) == '1' ? 1 : 0);
 			}
 		}
 		switches = 0;
 		best = L;
 		boolean possible = true;
 		char[][] flowChars = new char[N][L];
 		for (int i = 0; i < flowChars.length; i++) {
 			flowChars[i] = flow[i].toCharArray();
 		}
 		boolean[] possSw = new boolean[L];
 		for (int i = 0; i < onesNeeded.length; i++) {
 			if (ones[i] != onesNeeded[i]) {
 				if (ones[i] != N - onesNeeded[i]) {
 					possible = false;
 				} else {
 					switches++;
 					sw(flowChars, i);
 				}
 			} else {
 				if (ones[i] == N - onesNeeded[i]) {
 					// possible switch
 					possSw[i] = true;
 				}
 			}
 		}
 		// backTrack solution
 		char[][] neededChars = new char[N][L];
 		for (int i = 0; i < neededChars.length; i++) {
 			neededChars[i] = needed[i].toCharArray();
 		}
 		if (possible) {
 			possible = rec(flowChars, neededChars, possSw, 0);
 		}
 
 		if (possible) {
 			System.out.println(best);
 			out.write(best + ""\n"");
 		} else {
 			System.out.println(""NOT POSSIBLE"");
 			out.write(""NOT POSSIBLE"" + ""\n"");
 		}
 	}
 
 	public static boolean rec(char[][] flowChars, char[][] neededChars,
 			boolean[] possSw, final int pos) {
 
 		Arrays.sort(flowChars, new Comparator<char[]>() {
 			@Override
 			public int compare(char[] o1, char[] o2) {
 				for (int i = 0; i < pos; i++) {
 					if (o1[i] != o2[i]) {
 						return o2[i] - o1[i];
 					}
 				}
 				return 0;
 			}
 		});
 		Arrays.sort(neededChars, new Comparator<char[]>() {
 			@Override
 			public int compare(char[] o1, char[] o2) {
 				for (int i = 0; i < pos; i++) {
 					if (o1[i] != o2[i]) {
 						return o2[i] - o1[i];
 					}
 				}
 				return 0;
 			}
 		});
 		for (int i = 0; i < flowChars.length; i++) {
 			for (int j = 0; j < pos; j++) {
 				if (!(flowChars[i][j] == neededChars[i][j])) {
 					return false;
 				}
 			}
 		}
 		if (pos < possSw.length) {
 			boolean ret = rec(flowChars, neededChars, possSw, pos + 1);
 			if (possSw[pos]) {
 				sw(flowChars, pos);
 				switches++;
 				boolean ret2 = rec(flowChars, neededChars, possSw, pos + 1) || ret;
 				switches--;
 				sw(flowChars, pos);
 				return ret2;
 			}
 			return ret;
 		}
 		best = Math.min(best, switches);
 		return true;
 	}
 
 	public static void sw(char[][] flowChars, int s) {
 		for (int j = 0; j < flowChars.length; j++) {
 			flowChars[j][s] = (flowChars[j][s] == '1' ? '0' : '1');
 		}
 	}
 
 	public static void main(String[] args) throws IOException {
 //		 String name = ""A-practice"";
 //		String name = ""A-small-attempt5"";
 		 String name = ""A-large"";
 		Scanner sc = new Scanner(new File(name + "".in""));
 		sc.useLocale(Locale.US);
 
 		FileWriter fstream = new FileWriter(name + "".out"");
 		out = new BufferedWriter(fstream);
 
 		int cases = sc.nextInt();
 
 		for (int i = 1; i <= cases; i++) {
 			System.out.format(Locale.US, ""Case #%d: "", i);
 			out.write(""Case #"" + i + "": "");
 			solve(sc);
 		}
 		sc.close();
 		out.close();
 	}
 }
","package Round2;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 
 /** Class for buffered reading int and double values */
 class Reader {
     static BufferedReader reader;
     static StringTokenizer tokenizer;
 
     /** call this method to initialize reader for InputStream */
     static void init(InputStream input) {
         reader = new BufferedReader(
                      new InputStreamReader(input) );
         tokenizer = new StringTokenizer("""");
     }
 
     /** get next word */
     static String next() throws IOException {
         while ( ! tokenizer.hasMoreTokens() ) {
             //TODO add check for eof if necessary
             tokenizer = new StringTokenizer(
                    reader.readLine() );
         }
         return tokenizer.nextToken();
     }
 
     static int nextInt() throws IOException {
         return Integer.parseInt( next() );
     }
     
     static long nextLong() throws IOException {
         return Long.parseLong( next() );
     }
 	
     static double nextDouble() throws IOException {
         return Double.parseDouble( next() );
     }
 }",1
128,5210,"package codejam2013.qr;
 
 import codejam.common.CodeHelper;
 
 import java.util.*;
 
 /**
  * @author Chen Ling
  */
 public class ProblemB {
 
     private static String SMALL_IN_FILE_NAME = ""/codejam2013/qr/B-small.in"";
     private static String SMALL_OUT_FILE_NAME = ""/codejam2013/qr/B-small.out"";
 
     private static String LARGE_IN_FILE_NAME = ""/codejam2013/qr/B-large.in"";
     private static String LARGE_OUT_FILE_NAME = ""/codejam2013/qr/B-large.out"";
 
     public static String solve(int[][] cases) {
         List<Integer> heights = getAllHeights(cases);
         int maxHeight = heights.get(0);
         int[][] initCases = new int[cases.length][];
         for (int i = 0; i < initCases.length; i++) {
             initCases[i] = new int[cases[i].length];
             for (int j = 0; j < initCases[i].length; j++) {
                 initCases[i][j] = maxHeight;
             }
         }
 
         for (Integer height : heights) {
             List<Cell> indexes = getHeightIndexes(cases, height);
             for (Cell index : indexes) {
                 boolean canDo = canDo(index, cases, initCases, height);
                 if (!canDo) {
                     return ""NO"";
                 }
                 boolean same = compare(initCases, cases);
                 if (same) {
                     return ""YES"";
                 }
             }
         }
 
         return ""NO"";
     }
 
     private static boolean canDo(Cell index, int[][] cases, int[][] initCases, int height) {
         boolean colCan = true;
         boolean rowCan = true;
         for (int i = 0; i < cases.length; i++) {
             if (cases[i][index.getJ()] > height) {
                 colCan = false;
             }
         }
         for (int j = 0; j < cases[index.getI()].length; j++) {
             if (cases[index.getI()][j] > height) {
                 rowCan = false;
             }
         }
         if (!rowCan && !colCan) {
             return false;
         }
         if (colCan) {
             for (int i = 0; i < initCases.length; i++) {
                 initCases[i][index.getJ()] = height;
             }
         }
         if (rowCan) {
             for (int j = 0; j < initCases[index.getI()].length; j++) {
                 initCases[index.getI()][j] = height;
             }
         }
         return true;
     }
 
     private static boolean compare(int[][] initCases, int[][] cases) {
         for (int i = 0; i < initCases.length; i++) {
             for (int j = 0; j < initCases[i].length; j++) {
                 if (cases[i][j] != initCases[i][j]) {
                     return false;
                 }
             }
         }
         return true;
     }
 
     private static List<Integer> getAllHeights(int[][] cases) {
         Set<Integer> heights = new TreeSet<Integer>();
         for (int i = 0; i < cases.length; i++) {
             for (int j = 0; j < cases[i].length; j++) {
                 heights.add(cases[i][j]);
             }
         }
         List<Integer> results = new ArrayList<Integer>();
         results.addAll(heights);
         Collections.reverse(results);
         return results;
     }
 
     private static List<Cell> getHeightIndexes(int[][] cases, int height) {
         List<Cell> indexes = new ArrayList<Cell>();
         for (int i = 0; i < cases.length; i++) {
             for (int j = 0; j < cases[i].length; j++) {
                 if (cases[i][j] == height) {
                     indexes.add(new Cell(i, j));
                 }
             }
         }
         return indexes;
     }
 
     private static class Cell {
         private int i;
         private int j;
 
         private Cell(int i, int j) {
             this.i = i;
             this.j = j;
         }
 
         public int getI() {
             return i;
         }
 
         public void setI(int i) {
             this.i = i;
         }
 
         public int getJ() {
             return j;
         }
 
         public void setJ(int j) {
             this.j = j;
         }
     }
 
     public static void main(String[] args) {
         List<String> in = CodeHelper.loadInputLines(ProblemB.LARGE_IN_FILE_NAME);
         List<int[][]> casesList = new ArrayList<int[][]>();
 
         int[][] cases = null;
         int caseN = 0;
         int lastIndexN = 1;
         for (int i = 1; i < in.size(); i++) {
             String row = in.get(i);
             String[] cols = row.split(""\\s"");
 
             if ((lastIndexN + caseN) == i) {
                 caseN = Integer.parseInt(cols[0]);
                 lastIndexN = i + 1;
                 cases = new int[caseN][Integer.parseInt(cols[1])];
                 casesList.add(cases);
                 continue;
             }
             for (int j = 0; j < cols.length; j++) {
                 cases[i - lastIndexN][j] = Integer.parseInt(cols[j]);
             }
         }
         //int lineNum=Integer.parseInt(in.get(0));
         List<String> out = new ArrayList<String>();
         int index = 1;
         for (int[][] inits : casesList) {
             String result = ProblemB.solve(inits);
             result = ""Case #"" + index++ + "": "" + result;
             out.add(result);
         }
         CodeHelper.writeOutputs(ProblemB.LARGE_OUT_FILE_NAME, out);
     }
 }
","package codejam2014.qr;
 
 import codejam.common.CodeHelper;
 
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Chen Ling
  */
 public class ProblemB {
 
     private static String SMALL_IN_FILE_NAME = ""/codejam2014/qr/B-small.in"";
     private static String SMALL_OUT_FILE_NAME = ""/codejam2014/qr/B-small.out"";
 
     private static String LARGE_IN_FILE_NAME = ""/codejam2014/qr/B-large.in"";
     private static String LARGE_OUT_FILE_NAME = ""/codejam2014/qr/B-large.out"";
 
 
     public static BigDecimal solve(BigDecimal c, BigDecimal f, BigDecimal x) {
         BigDecimal currentf = new BigDecimal(2.0);
         BigDecimal totalTime = BigDecimal.ZERO;
         BigDecimal result = trSolve(c, f, x, totalTime, currentf);
         result = result.setScale(7, BigDecimal.ROUND_HALF_UP);
 
         return result;
     }
 
     private static BigDecimal trSolve(BigDecimal c, BigDecimal f, BigDecimal x, BigDecimal totalTime, BigDecimal currentf) {
         BigDecimal xTime = x.divide(currentf, 10, BigDecimal.ROUND_HALF_UP);
         BigDecimal cTime = c.divide(currentf, 10, BigDecimal.ROUND_HALF_UP);
         BigDecimal nextCurrentf = currentf.add(f);
         BigDecimal nextxTime = x.divide(nextCurrentf, 10, BigDecimal.ROUND_HALF_UP);
         BigDecimal nextcTime = cTime.add(nextxTime);
         if (nextcTime.compareTo(xTime) > 0) {
             return xTime.add(totalTime);
         } else {
             return trSolve(c, f, x, totalTime.add(cTime), nextCurrentf);
         }
     }
 
 
     public static void main(String[] args) {
         List<String> in = CodeHelper.loadInputLines(ProblemB.SMALL_IN_FILE_NAME);
         List<String> out = new ArrayList<String>();
         for (int i = 1; i < in.size(); i++) {
             String[] parameters = in.get(i).split("" "");
             BigDecimal result = solve(new BigDecimal(parameters[0]), new BigDecimal(parameters[1]), new BigDecimal(parameters[2]));
             out.add(""Case #"" + i + "": "" + result);
         }
 
         CodeHelper.writeOutputs(ProblemB.SMALL_OUT_FILE_NAME, out);
     }
 }
",1
129,14486,"import java.util.Scanner;
 
 
 public class C {
 
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 	    int t = sc.nextInt();
 	    for (int i = 1; i <= t; i++) {
 	      int r = sc.nextInt();
 	      int k = sc.nextInt();
 	      int n = sc.nextInt();
 	      int[] groups = new int[n];
 	      for (int j = 0; j < n; j++) {
 	    	  groups[j] = sc.nextInt();
 	      }
 	      int totalMoney = 0;
 	      boolean[] beenHere = new boolean[n];
 	      
 	      
 	      int next = 0;
 	      while (!beenHere[next]) {
 	    	  beenHere[next] = true;
 	    	  int sum = 0;
 	    	  int groupSize = 0;
 	    	  while (sum + groups[next] <= k && groupSize < n) {
 	    		  sum += groups[next];
 	    		  next++;
 	    		  next %= n;
 	    		  groupSize++;
 	    	  }
 	      }
 	      int startOfRep = next;
 	      next = 0;
 	      
 	      
 	      int moneyUntilRep = 0;
 	      int ridesSoFar = 0;
 	      while (next != startOfRep && ridesSoFar <= r) {
 	    	  int sum = 0;
 	    	  int groupSize = 0;
 	    	  while (sum + groups[next] <= k && groupSize < n) {
 	    		  sum += groups[next];
 	    		  next++;
 	    		  next %= n;
 	    		  groupSize++;
 	    	  }
 	    	  moneyUntilRep += sum;
 	    	  ridesSoFar++;
 	      }
 	      totalMoney += moneyUntilRep;
 	      if (ridesSoFar == r) {
 	    	  System.out.printf(""Case #%d: %s\n"", i, totalMoney);
 	    	  continue;
 	      }
 	      
 	      
 	      int moneyDuringRep = 0;
 	      int ridesDuringRep = 0;
 	      do {
 	    	  int sum = 0;
 	    	  int groupSize = 0;
 	    	  while (sum + groups[next] <= k && groupSize < n) {
 	    		  sum += groups[next];
 	    		  next++;
 	    		  next %= n;
 	    		  groupSize++;
 	    	  }
 	    	  moneyDuringRep += sum;
 	    	  ridesDuringRep++;
 	      } while (next != startOfRep);
 	      
 	      totalMoney += moneyDuringRep * ((r - ridesSoFar) / ridesDuringRep);
 	      ridesSoFar = r - (r - ridesSoFar) % ridesDuringRep;
 	      
 	      while (ridesSoFar < r) {
 	    	  int sum = 0;
 	    	  int groupSize = 0;
 	    	  while (sum + groups[next] <= k && groupSize < n) {
 	    		  sum += groups[next];
 	    		  next++;
 	    		  next %= n;
 	    		  groupSize++;
 	    	  }
 	    	  totalMoney += sum;
 	    	  ridesSoFar++;
 	      }
 	      
 	      System.out.printf(""Case #%d: %s\n"", i, totalMoney);
 	    }
 	}
 }
 
","package round1b;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 
 public class NewLotteryGameSmall {
 
 	public static void main(String[] args) throws Exception {
 		String baseDir = ""C:\\Users\\sampatk\\workspace\\GCJ2014\\src\\round1b\\"";
 		String inFileName = baseDir + ""B-small-attempt0.in"";
 		String outFileName = baseDir + ""output.txt"";
 		
 		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(inFileName)));
 		BufferedWriter bw = new BufferedWriter(new FileWriter(outFileName));
 		
 		int nt = Integer.parseInt(br.readLine());
 		for(int i=0; i<nt; i++) {
 			String strs[] = br.readLine().split(""\\s+"");
 			int A = Integer.parseInt(strs[0]);
 			int B = Integer.parseInt(strs[1]);
 			int K = Integer.parseInt(strs[2]);
 
 			long count = 0;
 			for(int j=0; j<A; j++) {
 				for(int k=0; k<B; k++) {
 					if((j&k) < K) count++;
 				}
 			}
 
 			String output = ""Case #"" + (i+1) + "": "" + count;
 			System.out.println(output);
 			bw.write(output + System.lineSeparator());			
 		}
 		
 		bw.close();
 		br.close();
 	}	
 
 }
",0
130,1992,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class A {
 	static String fName = ""A-large"",
 			inName = ""C:\\Users\\s096397\\Downloads/"" + fName + "".in"",
 			outName = ""output/"" + fName + "".out"";
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scan;
 		scan = new Scanner(new File(inName));
 		//scan=new Scanner(System.in);
 		PrintWriter out = new PrintWriter(new File(outName));
 
 		int numCases = scan.nextInt();
 		scan.nextLine();
 		for (int i = 1; i <= numCases; i++) {
 			out.println(""Case #"" + i + "": "" + solve(scan));
 		}
 
 		out.close();
 		scan.close();
 	}
 
 	private static String solve(Scanner scan) {
 		String[] input=scan.nextLine().split("" "");
 
 		int N = Integer.valueOf(input[0]);
 		int[] R = new int[N];
 		int[] P = new int[N];
 		for (int i = 0; i < N; i++){
 			R[i] = input[2 * i + 1].charAt(0)=='O'?1:0;
 			P[i] = Integer.valueOf(input[2*i+2]);
 		}
 
 		int last=R[0];
 		int[] pos={1,1};
 		int[] time={0,0};
 		for(int i=0;i<N;i++){
 			int ro=R[i];
 			time[ro]=max(time[ro] + abs(pos[ro] - P[i]), time[last])+1;
 			pos[ro]=P[i];
 			last=ro;
 		}
 		return """"+max(time[0],time[1]);
 	}
 
 	private static int max(int i, int i1) {
 		return i>i1?i:i1;
 	}
 
 	private static int abs(int i) {
 		return i>0?i:-i;
 	}
 }
","import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.lang.Math;
 import java.util.HashMap;
 import java.util.Scanner;
 
 public class A {
 	public static void main(String[] args) throws FileNotFoundException {
 		InputStream in = System.in;
 		if(args.length>0)
 			in = new FileInputStream(args[0]);
 		PrintStream out = System.out;
 		if(args.length>1)
 			out = new PrintStream(args[1]);
 
 		Solver s = new Solver(new Scanner(in),out);
 		//Multiple case input
 		s.cases();
 		//Single case input
 		//s.go();
 	}
 }
 
 class Solver {
 	Scanner in;
 	PrintStream out;
 	public Solver(Scanner scanner, PrintStream printStream) {
 		in = scanner;
 		out = printStream;
 	}
 
 	public void cases() {
 		int numCases = in.nextInt();
 		in.nextLine();
 		for(int i=0;i<numCases;i++) {
 			out.print(""Case #""+(i+1)+"": "");
 			go();
 		}
 	}
 	
 	int N,D;
 	int[] d,l;
 	public void go() {
 		N = in.nextInt();
 		d = new int[N];
 		l = new int[N];
 		for(int i = 0; i < N; i++) {
 			d[i] = in.nextInt();
 			l[i] = in.nextInt();
 		}
 		D = in.nextInt();
 
 		int[] r = new int[N];
 		r[0]=d[0];
 
 		for(int i=0;i<N;i++)
 			for(int j=i+1;j<N;j++)
 				if(d[i]+r[i]>=d[j])
 					r[j] = Math.max(r[j], Math.min(l[j], d[j] - d[i]));
 
 		boolean reached = false;
 		for(int i=0;i<N;i++)
 			if(r[i]+d[i]>=D)
 				reached = true;
 		out.println(reached?""YES"":""NO"");
 	}
 }",1
131,10997,"package googlecodejam2012.round2.swingingwild;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.util.TreeMap;
 
 public class SwingingWild {
 	public static void main(String[] args) throws IOException {
 		String lineSep = System.getProperty(""line.separator"");
 		BufferedReader br = new BufferedReader(
 				args.length > 0 ? new FileReader(args[0])
 						: new InputStreamReader(System.in));
 		try {
 			Writer out = new BufferedWriter(args.length > 1 ? new FileWriter(
 					args[1]) : new OutputStreamWriter(System.out));
 			try {
 				int numLines = Integer.parseInt(br.readLine().trim());
 				for (int i = 1; i <= numLines; ++i) {
 					String line = br.readLine();
 					int n = Integer.parseInt(line);
 					int[] ds = new int[n], ls = new int[n];
 					for (int j = 0; j < n; ++j) {
 						String l = br.readLine();
 						String[] parts = l.split("" +"");
 						ds[j] = Integer.parseInt(parts[0]);
 						ls[j] = Integer.parseInt(parts[1]);
 					}
 					line = br.readLine();
 					int d = Integer.parseInt(line);
 					out.write(""Case #"" + i + "": ""
 							+ (isPossible(ds, ls, d) ? ""YES"" : ""NO"") + lineSep);
 				}
 			} finally {
 				out.close();
 			}
 		} finally {
 			br.close();
 		}
 	}
 
 	private static boolean isPossible(int[] ds, int[] ls, int d) {
 		TreeMap<Integer, Integer> reachable = new TreeMap<Integer, Integer>();
 		reachable.put(Integer.valueOf(0),
 				Integer.valueOf(Math.min(ds[0], ls[0])));
 		while (!reachable.isEmpty()) {
 			Integer next = reachable.firstKey();
 			int n = next.intValue();
 			int nextMax = reachable.get(next).intValue();
 			reachable.remove(next);
 			if (d <= ds[n] + Math.min(ls[n], nextMax)) {
 				return true;
 			}
 			for (int i = n + 1; i < ds.length; ++i) {
 				if (ds[i] <= ds[n] + Math.min(ls[n], nextMax)) {
 					if (reachable.containsKey(i)) {
 						reachable.put(
 								i,
 								Math.max(reachable.get(i),
 										Math.min(ds[i] - ds[n], nextMax)));
 					} else
 						reachable.put(i, Math.min(ds[i] - ds[n], nextMax));
 				}
 			}
 		}
 		return false;
 	}
 }
","package gcj2012.r1b;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Comparator;
 import java.util.LinkedList;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Scanner;
 
 public class B {
 
 	final boolean DEBUG = false;
 	final boolean isSmall = false;
 	final String PACKAGE = ""gcj2012/r1b"";
 	final String PROBLEM = ""B"";
 	
 	int[][][] dist;
 	int INF = 1<<29;
 	void run(){
 		if(!DEBUG){
 			try {
 				if(isSmall)System.setIn(new FileInputStream(new File(""./src/""+PACKAGE+""/""+PROBLEM+""-small.in"")));
 				else System.setIn(new FileInputStream(new File(""./src/""+PACKAGE+""/""+PROBLEM+""-large.in"")));
 				if(isSmall)System.setOut(new PrintStream(new File(""./src/""+PACKAGE+""/""+PROBLEM+""-small_out.txt"")));
 				else System.setOut(new PrintStream(new File(""./src/""+PACKAGE+""/""+PROBLEM+""-large_out.txt"")));
 			} catch (FileNotFoundException e) {
 				e.printStackTrace();
 			}
 		}
 		Scanner sc = new Scanner(System.in);
 		int T = sc.nextInt();
 		int[][] d = {{-1,0},{0,1},{1,0},{0,-1}};
 		for(int CASE=1;CASE<=T;CASE++){
 			int H = sc.nextInt(), h = sc.nextInt(), w = sc.nextInt();
 			int[][] ceil = new int[h][w], floor = new int[h][w];
 			for(int i=0;i<h;i++)for(int j=0;j<w;j++)ceil[i][j]=sc.nextInt();
 			for(int i=0;i<h;i++)for(int j=0;j<w;j++)floor[i][j]=sc.nextInt();
 			boolean[][] canReach = new boolean[h][w];
 			canReach[0][0] = true;
 			Queue<int[]> l = new LinkedList<int[]>();
 			l.add(new int[]{0, 0});
 			while(!l.isEmpty()){
 				int[] V = l.poll();
 				int pi = V[0], pj = V[1];
 				for(int k=0;k<4;k++){
 					int ni = pi+d[k][0], nj = pj+d[k][1];
 					if(!(0<=ni&&ni<h&&0<=nj&&nj<w))continue;
 					if(canReach[ni][nj])continue;
 					int myF = Math.max(floor[pi][pj], H);
 					int opF = Math.max(floor[ni][nj], H);
 					if(myF<=ceil[ni][nj]-50&&opF<=ceil[ni][nj]-50&&opF<=ceil[pi][pj]-50){
 						canReach[ni][nj] = true; l.add(new int[]{ni, nj});
 					}
 				}
 			}
 			dist = new int[h][w][H+1];
 			for(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<=H;k++)dist[i][j][k]=INF;
 			PriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {
 				public int compare(int[] o1, int[] o2) {
 					return dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];
 				}
 			});
 			for(int i=0;i<h;i++)for(int j=0;j<w;j++)if(canReach[i][j]){
 				dist[i][j][H]=0;
 //				System.out.println(""i:""+i+"" j:""+j);
 				q.add(new int[]{i, j, H});
 			}
 			while(!q.isEmpty()){
 				int V[] = q.poll();
 				int pi = V[0], pj = V[1], waterLevel = V[2], nowCost = dist[pi][pj][waterLevel];
 				//stay here
 				if(0<waterLevel&&nowCost+1<dist[pi][pj][waterLevel-1]){
 					dist[pi][pj][waterLevel-1] = nowCost+1;
 					q.add(new int[]{pi, pj, waterLevel-1});
 				}
 				int myF = Math.max(floor[pi][pj], waterLevel), restWater = Math.max(0, waterLevel-floor[pi][pj]);
 				for(int k=0;k<4;k++){
 					int ni = pi+d[k][0], nj = pj+d[k][1];
 					if(!(0<=ni&&ni<h&&0<=nj&&nj<w))continue;
 					int opF = Math.max(floor[ni][nj], waterLevel);
 					if(myF<=ceil[ni][nj]-50&&opF<=ceil[ni][nj]-50&&opF<=ceil[pi][pj]-50){
 						int W = nowCost;
 						boolean speedy = 20<=restWater;
 						if(speedy)W+=10;
 						else W+=100;
 						int nh = Math.max(0, waterLevel-(speedy?10:100));
 						if(W < dist[ni][nj][nh]){
 							dist[ni][nj][nh] = W;
 							q.add(new int[]{ni, nj, nh});
 						}
 					}
 				}
 			}
 			double min = INF;
 			for(int i=0;i<=H;i++)min = Math.min(min, dist[h-1][w-1][i]/10.0);
 			System.out.print(""Case #""+CASE+"": "");
 			System.out.printf(""%.6f\n"", min);
 		}
 	}
 	
 	public static void main(String[] args) {
 		new B().run();
 	}
 }
",0
132,14666,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
 
 public class Main {
 	public static void main(String[] argv) throws IOException{
 		Map<Character, Character> mappings = new HashMap<Character, Character>();
 		mkMap(mappings, ""zaq"", ""qyz"");
 		mkMap(mappings, ""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand"");
 		mkMap(mappings, ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""there are twenty six factorial possibilities"");
 		mkMap(mappings, ""de kr kd eoya kw aej tysr re ujdr lkgc jv"", ""so it is okay if you want to just give up"");
 		
 		
 		//System.out.println("""" + mappings.size());
 		
 		String alpha = ""abcdefghijklmnopqrstuvwxyz"";
 		for(int i = 0; i < alpha.length(); i++){
 			if(! mappings.containsKey(alpha.charAt(i))){
 				System.out.println(""mi "" + Character.toString(alpha.charAt(i)));
 			}
 		}
 		
 		for(int i = 0; i < alpha.length(); i++){
 			if(! mappings.values().contains(alpha.charAt(i))){
 				System.out.println(""val "" + alpha.charAt(i));
 			}
 		}
 		
 		
 		BufferedReader br = new BufferedReader(new FileReader(argv[0]));
 		br.readLine();
 		int c = 1;
 		for(String s = br.readLine(); s != null ;s = br.readLine()){
 			StringBuffer sb = new StringBuffer();
 			for(int i = 0; i < s.length(); i++){
 				sb.append(mappings.get(s.charAt(i)));
 			}
 			
 			System.out.println(""Case #"" + c + "": "" +sb.toString());
 			c++;
 		}
 		
 	}
 	
 	private static void mkMap(Map<Character, Character> mappings, String a, String b){
 		for(int i = 0; i < a.length(); i++){
 			if(mappings.containsKey(a.charAt(i)) && !mappings.get(a.charAt(i)).equals(b.charAt(i))){
 				System.out.println("""" + a.charAt(i) + b.charAt(i) + "" "" + mappings.get(a.charAt(i)) + "" "" + a.substring(i));
 			}
 			mappings.put(a.charAt(i), b.charAt(i));
 		}
 	}
 }
","
 /*************************
  * Maczko Istvan         *
  * Google Code Jam 2010  *
  * Qualification Round C *
  * 10/05/08              *
  *************************/
 
 import java.io.*;
 import java.util.*;
 
 class C
 {
   
   
   public static String input = ""C-small-attempt0.in"";
   public static String output = ""C-small-attempt0.out"";
   
   public static BufferedReader be;
   public static BufferedWriter ki;
   
   public static String sor;
   public static StringTokenizer token;
   
   
   public static int T;
   public static int R;
   public static int k;
   public static int N;
   
   public static int[] g;
   
   public static int mutato;
   public static int aktk;
   public static long kimenet;
   public static int seged;
   
   public static void main(String[] args) throws FileNotFoundException, IOException
   {
     
     be = new BufferedReader(new FileReader(input));
     ki = new BufferedWriter(new FileWriter(output));
     
     int i, j;
     
     g = new int[1000];
     
     T = Integer.parseInt(be.readLine());
     
     for(i = 1; i <= T; i++)
     {
       
       sor = be.readLine();
       token = new StringTokenizer(sor);
       
       R = Integer.parseInt(token.nextToken());
       k = Integer.parseInt(token.nextToken());
       N = Integer.parseInt(token.nextToken());
       
       sor = be.readLine();
       token = new StringTokenizer(sor);
       
       for(j = 0; j < N; j++)
       {
         g[j] = Integer.parseInt(token.nextToken());
       } // for j g[j]
       
       mutato = 0;
       kimenet = 0;
       
       for(j = 1; j <= R; j++)
       {
         aktk = k;
         seged = N;
         while( (aktk - g[mutato] >= 0) && (seged > 0) )
         {
           kimenet += (long) g[mutato];
           aktk -= g[mutato];
           mutato = (mutato + 1) % N;
           seged--;
         } // while befer a kov csapat
         
       } // for j menetek szama..
       
       ki.write(""Case #"");
       ki.write("""" + i);
       ki.write("": "");
       ki.write("""" + kimenet);
       ki.write(""\n"");
       
       
       
       
     } // for i tesztesetek
     
     
     be.close();
     ki.flush();
     ki.close();
     
   } // main
   
 } // class
 
",0
133,964,"package org.nos.gcj;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.Calendar;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class GCJ_1C_01 {
 	static final String path = ""F:/GCJ/GCJ_1C_01/Small"";
 //	static final String path = ""F:/GCJ/GCJ_1C_01/Large"";
 	
 	class TestCase
 	{
 		int [][] inh;
 		
 		Object[][] cache;
 	}
 	
 	public TestCase readTestCase(BufferedReader br) throws Exception
 	{
 		TestCase tc = new TestCase();
 		
 		String line = br.readLine();
 		StringTokenizer st = new StringTokenizer(line);
 		int size = Integer.valueOf(st.nextToken());
 		tc.inh = new int[size][];
 		tc.cache = new Object[size][size];
 		for (int i=0; i<tc.inh.length; i++)
 		{
 			line = br.readLine();
 			st = new StringTokenizer(line);
 			int sz = Integer.valueOf(st.nextToken());
 			if (sz == 0)
 				continue;
 			tc.inh[i] = new int[sz];
 			for (int j=0; j<tc.inh[i].length; j++)
 				tc.inh[i][j] = Integer.valueOf(st.nextToken());
 		}
 		
 		return tc;
 	}
 	
 	Set<String> getPaths(TestCase tc, int a, int b)
 	{
 		if (a == b)
 		{
 			String s = b+""_"";
 			Set<String> hs = new HashSet<String>();
 			hs.add(s);
 			return hs;
 		}
 		
 		if (tc.cache[a][b] != null)
 			return (Set<String>)tc.cache[a][b];
 		
 		Set<String> newPaths = new HashSet<String>();
 		if (tc.inh[a] != null)
 		for (int i=0; i<tc.inh[a].length; i++)
 		{
 			Set<String> paths = getPaths(tc,tc.inh[a][i]-1,b);
 			for (String path : paths) 
 				newPaths.add(a+""_""+path);
 		}
 		tc.cache[a][b] = newPaths;
 //		System.out.println(""[""+a+"",""+b+""]:""+newPaths);
 		return newPaths;
 	}
 	
 	boolean hasDiamond(TestCase tc, int a, int b)
 	{
 		Set<String> set = getPaths(tc, a, b);
 		if (set.size() > 1)
 			System.out.println(""\n[""+a+"",""+b+""]:""+set);
 		return (set.size() > 1);
 	}
 	
 	public void writeTestResult(BufferedWriter bw, TestCase tc) throws Exception
 	{
 		for (int i=0; i<tc.inh.length; i++)
 			for (int j=0; j<tc.inh.length; j++)
 				if (hasDiamond(tc,i,j))
 				{
 					bw.write(""Yes"");
 					return;
 				}
 		bw.write(""No"");
 	}
 	
 	public void solve() throws Exception
 	{
 		BufferedReader br = new BufferedReader(new FileReader(path+""/input.in""));
 		BufferedWriter bw = new BufferedWriter(new FileWriter(path+""/output.out""));
 		int testCases = new Integer(br.readLine());
 		for (int i=0; i<testCases; i++)
 		{
 			System.out.print(""Test case ""+(i+1)+"": "");
 			long time = Calendar.getInstance().getTimeInMillis();
 			TestCase testCase = readTestCase(br);
 			System.out.print("" read in ""+(Calendar.getInstance().getTimeInMillis()-time)+""ms, "");
 			time = Calendar.getInstance().getTimeInMillis();
 			bw.write(""Case #""+(i+1)+"": "");
 			writeTestResult(bw, testCase);
 			bw.write(""\n"");
 			System.out.println(""solved in ""+(Calendar.getInstance().getTimeInMillis()-time)+""ms"");
 		}
 		bw.flush();
 		bw.close();
 		br.close();
 	}
 	public static void main(String[] args) throws Exception 
 	{
 		GCJ_1C_01 jam = new GCJ_1C_01();
 		jam.solve();
 	}
 
 }
","package org.sergii.codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.List;
 
 public class GCJ_Magicka {
 	
 	class TestCase
 	{
 		char[][] combine = new char[8][8];
 		boolean[][] oppose = new boolean[8][8];
 		int seqLength = 0;
 		String seq = null;
 	}
 	
 	static String stub = ""F:/GCJ/"";
 	static String problem = ""2"";
 	int testCases = 0;
 	
 	private int c2i(char a)
 	{
 		switch (a)
 		{
 		case 'Q': return 0;
 		case 'W': return 1;
 		case 'E': return 2;
 		case 'R': return 3;
 		case 'A': return 4;
 		case 'S': return 5;
 		case 'D': return 6;
 		case 'F': return 7;
 		default: return -1;
 		}
 	}
 	
 	public TestCase readTestCase(BufferedReader br) throws Exception
 	{
 		TestCase tc = new TestCase();
 		String line = br.readLine();
 		System.out.print(""\""""+line+""\"""");
 		String[] pieces = line.split(""\\s+"");
 		List<String> pl = new ArrayList<String>();
 		pl.addAll(Arrays.asList(pieces));
 		int combTotal = new Integer(pl.remove(0));
 		for (int i=0; i<combTotal; i++)
 		{
 			String comb = pl.remove(0);
 			int c1 = c2i(comb.charAt(0));
 			int c2 = c2i(comb.charAt(1));
 			char c3 = comb.charAt(2);
 			tc.combine[c1][c2] = tc.combine[c2][c1] =c3;
 		}
 		int oppTotal = new Integer(pl.remove(0));
 		for (int i=0; i<oppTotal; i++)
 		{
 			String opp = pl.remove(0);
 			int c1 = c2i(opp.charAt(0));
 			int c2 = c2i(opp.charAt(1));
 			tc.oppose[c1][c2] = tc.oppose[c2][c1] = true;
 		}
 		tc.seqLength = new Integer(pl.remove(0));
 		tc.seq = pl.remove(0);
 		return tc;
 	}
 	
 	public void writeTestResult(BufferedWriter bw, TestCase tc) throws Exception
 	{
 		boolean[] oppMapOld = new boolean[8];
 		boolean[] oppMap = new boolean[8];
 		List<Character> outSequence = new ArrayList<Character>();
 		int lastCharI = -1;
 		for (int i=0; i<tc.seqLength; i++)
 		{
 			char currChar = tc.seq.charAt(i);
 			int currCharI = c2i(currChar);
 			
 			if (lastCharI != -1)
 			{
 				 char candidate = 0;
 				 
 				 if (tc.combine[lastCharI][currCharI] != 0)
 					 candidate = tc.combine[lastCharI][currCharI];
 				 else
 				 if (tc.combine[currCharI][lastCharI] != 0)	 
 					 candidate = tc.combine[currCharI][lastCharI];
 				 
 				 if (candidate != 0)
 				 {
 					 lastCharI = -1;
 					 outSequence.remove(outSequence.size()-1);
 					 Arrays.fill(oppMap, false);
 					 outSequence.add(candidate);
 					 continue;
 				 }
 			}
 			if (oppMapOld[currCharI] || oppMap[currCharI])
 			{
 				lastCharI = -1;
 				outSequence.clear();
 				Arrays.fill(oppMapOld, false);
 				Arrays.fill(oppMap, false);
 				continue;
 			}
 			
 			outSequence.add(currChar);
 			lastCharI = currCharI;
 			
 			for (int j=0; j<8; j++)
 			{
 				oppMapOld[j] = oppMapOld[j] || oppMap[j]; 
 				oppMap[j] = (tc.oppose[currCharI][j] || tc.oppose[j][currCharI]);
 			}
 			
 		}	
 		bw.write(outSequence.toString());
 	}
 	
 	public void solve() throws Exception
 	{
 		BufferedReader br = new BufferedReader(new FileReader(stub+problem+""/input.in""));
 		BufferedWriter bw = new BufferedWriter(new FileWriter(stub+problem+""/output.out""));
 		testCases = new Integer(br.readLine());
 		for (int i=0; i<testCases; i++)
 		{
 			System.out.print(""Test case ""+(i+1)+"": "");
 			long time = Calendar.getInstance().getTimeInMillis();
 			TestCase testCase = readTestCase(br);
 			System.out.print("" read in ""+(Calendar.getInstance().getTimeInMillis()-time)+""ms, "");
 			time = Calendar.getInstance().getTimeInMillis();
 			bw.write(""Case #""+(i+1)+"": "");
 			writeTestResult(bw, testCase);
 			bw.write(""\n"");
 			System.out.println(""solved in ""+(Calendar.getInstance().getTimeInMillis()-time)+""ms"");
 		}
 		bw.flush();
 		bw.close();
 		br.close();
 	}
 	public static void main(String[] args) throws Exception 
 	{
 		GCJ_Magicka jam = new GCJ_Magicka();
 		jam.solve();
 	}
 
 }
",1
134,1928,"import java.util.*;
 import java.io.*;
 import java.lang.reflect.Array;
 import static java.lang.Math.*;
 
 public class C implements Runnable {
 	private void solution() throws IOException {
 		int numberOfTests = in.nextInt();
 		long globalStartTime = System.currentTimeMillis();
 		for (int testCase = 1; testCase <= numberOfTests; ++testCase) {
 			long localStartTime = System.currentTimeMillis();
 			//
 			out.printf(""Case #%d: "", testCase);
 			Object res = solve();
 			out.println();
 			//
 			System.err.println(""Test "" + testCase + "" is done. Time = "" + (System.currentTimeMillis() - localStartTime) / 1000.0);
 		}
 		System.err.println(""Total time = "" + (System.currentTimeMillis() - globalStartTime) / 1000.0);
 	}
 
 	private Object solve() throws IOException {
 		int n = in.nextInt();
 		int[] max = in.nextInts(n - 1);
 		int[] h = new int[n];
 		Random rm = new Random(31);
 		boolean ok = false;
 		int fact = fact(n);
 		for (int it = 0; it < fact * 10; ++it) {
 			for (int i = 0; i < n; ++i) {
 				h[i] = rm.nextInt(1000000);
 			}
 			if (check(h, max)) {
 				ok = true;
 				break;
 			}
 		}
 		if (ok) {
 			output(h);
 		} else {
 			out.print(""Impossible"");
 		}
 		return null;
 	}
 
 	private int fact(int n) {
 		int res = 1;
 		for (int i = 1; i <= n; ++i) {
 			res *= i;
 		}
 		return res;
 	}
 
 	private boolean check(int[] h, int[] max) {
 		for (int i = 0; i < max.length; ++i) {
 			int dx = 1;
 			int dh = h[i + 1] - h[i];
 			for (int j = i + 2; j < h.length; ++j) {
 				int cdx = j - i;
 				int cdh = h[j] - h[i];
 				if (dh * cdx < dx * cdh) {
 					dx = cdx;
 					dh = cdh;
 				}
 			}
 			if (max[i] != 1 + i + dx) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	public void run() {
 		try {
 			try {
 				String fileName = ""C-small-attempt0"";
 				in = new Scanner(new FileReader(fileName + "".in""));
 				out = new PrintWriter(fileName + "".out"");
 			} catch (Exception e) {
 			}
 			solution();
 			in.reader.close();
 			out.close();
 		} catch (Throwable e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 
 	private void output(Object o) {
 		try {
 			int length = Array.getLength(o);
 			for (int i = 0; i < length; ++i) {
 				if (i != 0) {
 					out.print(' ');
 				}
 				Object cur = Array.get(o, i);
 				if (cur instanceof Double) {
 					out.printf(Locale.US, ""%.9f"", cur);
 				} else {
 					out.print(cur);
 				}
 			}
 			out.println();
 		} catch (Exception e) {
 			if (o instanceof Double) {
 				out.printf(Locale.US, ""%.9f\n"", o);
 			} else {
 				out.println(o);
 			}
 		}
 	}
 
 	private static class Scanner {
 		private BufferedReader reader;
 		private StringTokenizer tokenizer;
 
 		public Scanner(Reader reader) {
 			this.reader = new BufferedReader(reader);
 			this.tokenizer = new StringTokenizer("""");
 		}
 
 		public boolean hasNext() throws IOException {
 			while (!tokenizer.hasMoreTokens()) {
 				String line = reader.readLine();
 				if (line == null) {
 					return false;
 				}
 				tokenizer = new StringTokenizer(line);
 			}
 			return true;
 		}
 
 		public String next() throws IOException {
 			hasNext();
 			return tokenizer.nextToken();
 		}
 
 		public int nextInt() throws IOException {
 			return Integer.parseInt(next());
 		}
 
 		public double nextDouble() throws IOException {
 			return Double.parseDouble(next());
 		}
 
 		private long nextLong() throws IOException {
 			return Long.parseLong(next());
 		}
 
 		public String nextLine() throws IOException {
 			tokenizer = new StringTokenizer("""");
 			return reader.readLine();
 		}
 
 		public int[] nextInts(int n) throws IOException {
 			int[] res = new int[n];
 			for (int i = 0; i < n; ++i) {
 				res[i] = nextInt();
 			}
 			return res;
 		}
 
 		public long[] nextLongs(int n) throws IOException {
 			long[] res = new long[n];
 			for (int i = 0; i < n; ++i) {
 				res[i] = nextLong();
 			}
 			return res;
 		}
 
 		public double[] nextDoubles(int n) throws IOException {
 			double[] res = new double[n];
 			for (int i = 0; i < n; ++i) {
 				res[i] = nextDouble();
 			}
 			return res;
 		}
 
 		public String[] nextStrings(int n) throws IOException {
 			String[] res = new String[n];
 			for (int i = 0; i < n; ++i) {
 				res[i] = next();
 			}
 			return res;
 		}
 	}
 
 	public static void main(String[] args) {
 		new Thread(null, new C(), ""Main"", 1 << 28).start();
 	}
 
 	private Scanner in = new Scanner(new InputStreamReader(System.in));
 	private PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 }
","import java.io.*;
 import java.lang.reflect.Array;
 import java.util.*;
 
 public class A implements Runnable {
 	String fileName = ""A-large"";
 
 	private void solution() throws IOException {
 		int ts = in.nextInt();
 		for (int cas = 1; cas <= ts; ++cas) {
 			out.printf(""Case #%d: %s\n"", cas, solve());
 		}
 	}
 
 	private String solve() throws IOException {
 		int n = in.nextInt();
 		int k = in.nextInt();
 		if ((k & ((1 << n) - 1)) == (1 << n) - 1) {
 			return ""ON"";
 		} else {
 			return ""OFF"";
 		}
 	}
 
 	private String toString(Object ob) {
 		StringBuilder builder = new StringBuilder();
 		try {
 			int size = Array.getLength(ob);
 			for (int i = 0; i < size; ++i) {
 				if (i != 0) {
 					builder.append("" "");
 				}
 				builder.append(Array.get(ob, i));
 			}
 		} catch (Exception e) {
 			builder.append(ob);
 		}
 		return builder.toString();
 	}
 
 	public void run() {
 		try {
 			in = new Scanner(new FileReader(fileName + "".in""));
 			out = new PrintWriter(fileName + "".out"");
 			solution();
 			in.reader.close();
 			out.close();
 		} catch (Throwable e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 
 	private class Scanner {
 		private BufferedReader reader;
 		private StringTokenizer tokenizer;
 
 		public Scanner(Reader reader) {
 			this.reader = new BufferedReader(reader);
 			this.tokenizer = new StringTokenizer("""");
 		}
 
 		public boolean hasNext() throws IOException {
 			while (!tokenizer.hasMoreTokens()) {
 				String next = reader.readLine();
 				if (next == null) {
 					return false;
 				}
 				tokenizer = new StringTokenizer(next);
 			}
 			return true;
 		}
 
 		public String next() throws IOException {
 			hasNext();
 			return tokenizer.nextToken();
 		}
 
 		public int nextInt() throws IOException {
 			return Integer.parseInt(next());
 		}
 
 		public double nextDouble() throws IOException {
 			return Double.parseDouble(next());
 		}
 
 		public long nextLong() throws IOException {
 			return Long.parseLong(next());
 		}
 
 		public String nextLine() throws IOException {
 			tokenizer = new StringTokenizer("""");
 			return reader.readLine();
 		}
 	}
 
 	public static void main(String[] args) throws IOException {
 		new Thread(null, new A(), """", 1 << 28).start();
 	}
 	PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 	Scanner in = new Scanner(new InputStreamReader(System.in));
 }
",1
135,19424,"package com.codejam.solution;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 public class TicTacToeTomek {
 	
 	static char whoWon(char[][] boardPositions){
 		int[][] ewXCount = new int[4][4];
 		int[][] nsXCount = new int[4][4];
 		int[][] nwseXCount = new int[4][4];
 		int[][] neswXCount = new int[4][4];
 		
 		int[][] ewOCount = new int[4][4];
 		int[][] nsOCount = new int[4][4];
 		int[][] nwseOCount = new int[4][4];
 		int[][] neswOCount = new int[4][4];
 		
 		int maxX=0;
 		int maxO=0;
 		
 //		first col
 		for(int i=0;i<4;i++){
 			int j=0;
 			char currentString = boardPositions[i][j];
 			if(currentString == 'X'){
 				ewXCount[i][j] = 1;
 				nwseXCount[i][j]=1;
 			}else if(currentString == 'O'){
 				ewOCount[i][j] = 1;
 				nwseOCount[i][j]=1;
 			}else if(currentString == 'T'){
 				ewOCount[i][j] = 1;
 				nwseOCount[i][j]=1;
 				
 				ewXCount[i][j] = 1;
 				nwseXCount[i][j]=1;
 			}
 			
 		}
 		
 		//top row
 		for(int j=0;j<4;j++){
 			int i=0;
 			char currentString = boardPositions[i][j];
 			if(currentString == 'X'){
 				nsXCount[i][j] = 1;
 				nwseXCount[i][j]=1;
 			}else if(currentString == 'O'){
 				nsOCount[i][j] = 1;
 				nwseOCount[i][j]=1;
 			}
 			else if(currentString == 'T'){
 				nsOCount[i][j] = 1;
 				nwseOCount[i][j]=1;
 				
 				nsXCount[i][j] = 1;
 				nwseXCount[i][j]=1;
 			}
 		}
 		//last col
 		for(int i=0; i<4;i++){
 			int j=3;
 			char currentString = boardPositions[i][j];
 			if(currentString == 'X'){
 				neswXCount[i][j] = 1;
 			}else if(currentString == 'O'){
 				neswOCount[i][j] = 1;
 			}
 			else if(currentString == 'T'){
 				neswXCount[i][j] = 1;
 				neswOCount[i][j] = 1;
 			}
 		}
 		
 		
 		//process ew for first row
 		for(int j=1;j<4;j++){
 			int i=0;
 			char currentString = boardPositions[i][j];
 			if(currentString == 'X'){
 				ewXCount[i][j] = ewXCount[i][j-1]+1;
 				maxX = Math.max(maxX, ewXCount[i][j]);
 				if(maxX >= 4){
 					return 'X';
 				}
 			}else if(currentString == 'O'){
 				ewOCount[i][j] = ewOCount[i][j-1]+1;
 				maxO = Math.max(maxO, ewOCount[i][j]);
 				if(maxO >= 4){
 					return 'O';
 				}
 			}else if(currentString == 'T'){
 				ewXCount[i][j] = ewXCount[i][j-1]+1;
 				maxX = Math.max(maxX, ewXCount[i][j]);
 				if(maxX >= 4){
 					return 'X';
 				}
 				
 				ewOCount[i][j] = ewOCount[i][j-1]+1;
 				maxO = Math.max(maxO, ewOCount[i][j]);
 				if(maxO >= 4){
 					return 'O';
 				}
 			}
 		}
 		
 		//process NS for first col
 		for(int i=1;i<4;i++){
 			int j=0;
 			char currentString = boardPositions[i][j];
 			if(currentString == 'X'){
 				nsXCount[i][j] = nsXCount[i-1][j]+1;
 				maxX = Math.max(maxX, nsXCount[i][j]);
 				if(maxX >= 4){
 					return 'X';
 				}
 			}else if(currentString == 'O'){
 				nsOCount[i][j] = nsOCount[i-1][j]+1;
 				maxO = Math.max(maxO, nsOCount[i][j]);
 				if(maxO >= 4){
 					return 'O';
 				}
 			}else if(currentString == 'T'){
 				nsOCount[i][j] = nsOCount[i-1][j]+1;
 				maxO = Math.max(maxO, nsOCount[i][j]);
 				if(maxO >= 4){
 					return 'O';
 				}
 				
 				nsXCount[i][j] = nsXCount[i-1][j]+1;
 				maxX = Math.max(maxX, nsXCount[i][j]);
 				if(maxX >= 4){
 					return 'X';
 				}
 			}
 		}
 		
 		
 		for(int i=1;i<4;i++){
 			for(int j=1;j<4;j++){
 				char currentString = boardPositions[i][j];
 				if(currentString == 'X'){
 					ewXCount[i][j]=ewXCount[i][j-1]+1;
 					maxX = Math.max(maxX, ewXCount[i][j]);
 					nsXCount[i][j] = nsXCount[i-1][j]+1;
 					maxX = Math.max(maxX, nsXCount[i][j]);
 					nwseXCount[i][j] = nwseXCount[i-1][j-1]+1;
 					maxX = Math.max(maxX, nwseXCount[i][j]);
 					if(maxX >= 4){
 						return 'X';
 					}
 				}else if(currentString == 'O'){
 					ewOCount[i][j]=ewOCount[i][j-1]+1;
 					maxO = Math.max(maxO, ewOCount[i][j]);
 					nsOCount[i][j] = nsOCount[i-1][j]+1;
 					maxO = Math.max(maxO, nsOCount[i][j]);
 					nwseOCount[i][j] = nwseOCount[i-1][j-1]+1;
 					maxO = Math.max(maxO, nwseOCount[i][j]);
 					if(maxO >= 4){
 						return 'O';
 					}
 				}else if(currentString == 'T'){
 					ewXCount[i][j]=ewXCount[i][j-1]+1;
 					maxX = Math.max(maxX, ewXCount[i][j]);
 					nsXCount[i][j] = nsXCount[i-1][j]+1;
 					maxX = Math.max(maxX, nsXCount[i][j]);
 					nwseXCount[i][j] = nwseXCount[i-1][j-1]+1;
 					maxX = Math.max(maxX, nwseXCount[i][j]);
 					if(maxX >= 4){
 						return 'X';
 					}
 					
 					ewOCount[i][j]=ewOCount[i][j-1]+1;
 					maxO = Math.max(maxO, ewOCount[i][j]);
 					nsOCount[i][j] = nsOCount[i-1][j]+1;
 					maxO = Math.max(maxO, nsOCount[i][j]);
 					nwseOCount[i][j] = nwseOCount[i-1][j-1]+1;
 					maxO = Math.max(maxO, nwseOCount[i][j]);
 					if(maxO >= 4){
 						return 'O';
 					}
 				}
 			}
 		}
 		
 		//process nesw if nobody won
 		for(int i=1; i<4; i++){
 			for(int j=2; j>=0; j--){
 				char currentString = boardPositions[i][j];
 				if(currentString == 'X'){
 					neswXCount[i][j] = neswXCount[i-1][j+1]+1;
 					maxX = Math.max(maxX, neswXCount[i][j]);
 					if(maxX >= 4){
 						return 'X';
 					}
 				}else if(currentString == 'O'){
 					neswOCount[i][j] = neswOCount[i-1][j+1]+1;
 					maxO = Math.max(maxO, neswOCount[i][j]);
 					if(maxO >= 4){
 						return 'O';
 					}
 				}else if(currentString == 'T'){
 					neswOCount[i][j] = neswOCount[i-1][j+1]+1;
 					maxO = Math.max(maxO, neswOCount[i][j]);
 					if(maxO >= 4){
 						return 'O';
 					}
 					
 					neswXCount[i][j] = neswXCount[i-1][j+1]+1;
 					maxX = Math.max(maxX, neswXCount[i][j]);
 					if(maxX >= 4){
 						return 'X';
 					}
 				}
 			}
 		}
 		//if none yet, we check for incomplete
 		for(int i=0;i<4;i++){
 			for(int j=0;j<4;j++){
 				if(boardPositions[i][j]== '.'){
 					return '.';
 				}
 			}
 		}
 		
 		return ' ';
 	}
 	
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader fileReader = new BufferedReader(
 				new InputStreamReader(new FileInputStream(System.getProperty(""user.home"")+File.separator+""input.txt"")));
 		int cases = Integer.parseInt(fileReader.readLine());
 		for(int t=0;t<cases;t++){
 			char[][] boardPositions = new char[4][4];
 			for(int i=0;i<4;i++){
 				String row = fileReader.readLine();
 				for(int j=0;j<4;j++){
 					boardPositions[i][j]=row.charAt(j);
 				}
 			}
 			char won = whoWon(boardPositions);
 			if(won == 'X'){
 				System.out.println(""Case #""+(t+1)+"": ""+won+"" won"");
 			}else if(won == 'O'){
 				System.out.println(""Case #""+(t+1)+"": ""+won+"" won"");
 			}else if(won == ' '){
 				System.out.println(""Case #""+(t+1)+"": Draw"");
 			}else{
 				System.out.println(""Case #""+(t+1)+"": Game has not completed"");
 			}
 			fileReader.readLine();
 		}
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 import javax.swing.RowFilter;
 
 
 public class ProblemB {
 	public static void main(String[] args) throws FileNotFoundException {
 //		Scanner sc = new Scanner(new File(""B-small-attempt1.in""));
 		Scanner sc = new Scanner(new File(""B-large.in""));
 //		Scanner sc = new Scanner(new File(""B.in""));
 		int cases = sc.nextInt();
 		int count = 1;
 		
 		while(cases --> 0) {
 			int n = sc.nextInt();
 			int m = sc.nextInt();
 			int maxHeight = 0;
 			
 			int[][] board = new int[n][m];
 			
 			for(int i = 0; i<n; i++) {
 				for(int j = 0; j<m; j++) {
 					board[i][j] = sc.nextInt();
 				}
 			}
 			
 			String result = solve(board, n, m);
 			System.out.println(""Case #"" + count + "": "" + result);
 			count++;
 		}
 	}
 	
 	public static String solve(int[][] board, int n, int m) {
 		int[] rowMax = new int[n];
 		int[] columnMax = new int[m];
 		
 		for(int i = 0; i<n; i++) {
 			for(int j = 0; j<m; j++) {
 				if(board[i][j] > rowMax[i])
 					rowMax[i] = board[i][j];
 				if(board[i][j] > columnMax[j])
 					columnMax[j] = board[i][j];
 			}
 		}
 		
 		for(int i = 0; i<n; i++) {
 			for(int j = 0; j<m; j++) {
 				if(rowMax[i] > board[i][j] && columnMax[j] > board[i][j])
 					return ""NO"";
 			}
 		}
 		
 		return ""YES"";
 	}
 
 }
",0
136,12215,"import java.io.*;
 import java.util.*;
 
 public class Problem2 
 {
 	public static void main(String[] args) throws IOException, FileNotFoundException
 	{
 		int i, j, k;
 		BufferedReader input = new BufferedReader (new FileReader(""B-small-attempt0.in""));
 		BufferedWriter output = new BufferedWriter (new FileWriter(""Output_B_small.out""));
 		
 		int totalEntries = Integer.parseInt(input.readLine());
 		
 		for (int index=0; index<totalEntries; index++)
 		{
 			String str[] = input.readLine().split("" "");
 			int no = Integer.parseInt(str[0]);
 			int minChicks = Integer.parseInt(str[1]);
 			int totdist = Integer.parseInt(str[2]);
 			int tottime = Integer.parseInt(str[3]);
 
 			int[] chickDist = new int[no];
 			int[] chickSpeed = new int[no];
 			String strDist[] = input.readLine().split("" "");
 			String strSpeed[] = input.readLine().split("" "");
 
 			for ( i=0; i<no; i++)
 			{
 				chickDist[i] = Integer.parseInt(strDist[i]);
 				chickSpeed[i] = Integer.parseInt(strSpeed[i]);
 			}
 
 			//System.out.println(no + "" "" + minChicks + "" "" + totdist + "" "" + tottime);
 			for (i=0; i<no; i++)
 			{
 				System.out.print(chickDist[i] + "" "" + chickSpeed[i]);
 				//System.out.println();
 			}
 
 			// Logic
 			int tot=0;
 			int chicks = 0;
 
 			for ( int time=0; time<tottime && chicks<minChicks; time++)
 			{
 				for (i = no-1; i>=0; i--)
 				{
 					chickDist[i] += chickSpeed[i];
 					if (chickDist[i] >= totdist) chicks++;
 				}
 				for (j = no -1; j>0 && chicks<minChicks; j--)
 				{
 					if (chickDist[j] <= chickDist[j-1] && chickSpeed[j-1]>chickSpeed[j])
 						tot++;
 				}
 			}
 			//System.out.println(""chicks : "" + chicks + "", tot = "" + tot);
 
 			// output
 			if (chicks>=minChicks)
 				output.write(""Case #""+ (index+1) + "": "" + tot);
 			else
 				output.write(""Case #""+ (index+1) + "": "" + ""IMPOSSIBLE"");
 			output.newLine();
 		}
 		input.close();
 		output.close();
 	}
 }","import java.io.*;
 import java.util.*;
 
 public class Problem1 
 {
 	public static void main(String[] args) throws IOException, FileNotFoundException
 	{
 		int i, j, k;
 		BufferedReader input = new BufferedReader (new FileReader(""A-large.in""));
 		BufferedWriter output = new BufferedWriter (new FileWriter(""Output_Large.out""));
 		
 		int totalEntries = Integer.parseInt(input.readLine());
 		
 		for (i=0; i<totalEntries; i++)
 		{
 			String str[] = input.readLine().split("" "");
 			int noDirExist = Integer.parseInt(str[0]);
 			int noDirNew = Integer.parseInt(str[1]);
 			
 			HashSet<String> dirExist = new HashSet<String>();
 			HashSet<String> dirNew = new HashSet<String>();
 
 			for ( j=0; j<noDirExist; j++)
 			{
 				dirExist.add (input.readLine());
 			}
 			for ( j=0; j<noDirNew; j++)
 			{
 				dirNew.add (input.readLine());
 			}
 
 			//System.out.println(dirExist);
 			//System.out.println(dirNew);
 
 			int result = find(dirExist, dirNew);
 
 			output.write(""Case #""+ (i+1) + "": "" + result);
 			output.newLine();
 			//System.out.println(i);
 		}
 		input.close();
 		output.close();
 	}
 
 	public static int find (HashSet dirExist, HashSet dirNew)
 	{
 		int tot = 0;
 		Iterator<String> iterator = dirNew.iterator();
 		while (iterator.hasNext())
 		{
 			String str = iterator.next();
 			//System.out.println(str);
 
 			while ( ! dirExist.contains(str))
 			{
 				tot++;
 				dirExist.add(str);
 
 				if ( str.lastIndexOf('/') == 0) break;
 				str = str.substring(0, str.lastIndexOf('/'));
 				//System.out.println(str);
 			}			
 		}
 		//System.out.println(tot);
 		return tot;
 	}
 }",1
137,431,"package gcj.r1a;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Buulseye {
 
     /**
      * @param args
      */
     public static void main(String[] args) throws Exception {
         String inPath = ""C:\\himanshu\\personal\\work\\ds-algo-lib\\gcj\\A-small-attempt0.in"";
         String outPath = ""C:\\himanshu\\personal\\work\\ds-algo-lib\\gcj\\out.txt"";
         
         Scanner scanner = new Scanner(new File(inPath));
         PrintWriter out = pw(outPath);
         //PrintWriter out = pw(null);
                 
         int N = Integer.parseInt(scanner.nextLine().trim());
         for(int c = 1; c <= N; c++) {
             String[] tmp = scanner.nextLine().trim().split(""\\s+"");
             out.println(""Case #"" + c + "": "" + count(Long.parseLong(tmp[0]),Long.parseLong(tmp[1])));
         }
         
         scanner.close();
         out.close();
     }
 
     private static long count(long r, long t) {
         long n = 0;
         while(true) {
             long tmp = 2*r + 4*n + 1;
             if(t >= tmp) {
                 n++;
                 t  = t - tmp;
             } else {
                 break;
             }
         }
         return n;
     }
     private static PrintWriter pw(String file) throws Exception {
         if(file == null) {
             return new PrintWriter(System.out);
         } else {
             return new PrintWriter(new BufferedOutputStream(new FileOutputStream(file)));
         }
     }
 }
 
 
","import java.util.Scanner;
 import java.lang.*;
 
  
 class Program4
 {
    public static void main(String args[]){
 	int noOfTestCases; 
 	Scanner in = new Scanner(System.in);
 	noOfTestCases = Integer.parseInt(in.nextLine());
 	String str[] = new String [noOfTestCases];
 	for(int i=0;i<noOfTestCases;i++){
 		str[i]= new String();
 		str[i]=in.nextLine();
 	} 
 	for(int i=0;i<noOfTestCases;i++){
 		String []temp = null;
 		temp = str[i].split("" "");
 		int start = Integer.parseInt(temp[0]);
 		int end = Integer.parseInt(temp[1]);
 		int count=0;
 		for(int j=start;j<=end;j++){
 			if(j>9 && j<=99){
 				count+=lastOne(j,end,10,0,10);		
 			}
 
 			else if(j>99 && j<=999){
 				count+=lastOne(j,end,100,0,10);		
 				count+=lastOne(j,end,10,0,100);
 			}
 			else if(j>999&& j<=9999){
 				count+=lastOne(j,end,1000,0,10);		
 				count+=lastOne(j,end,100,9,100);
 				count+=lastOne(j,end,10,99,100);
 			}
 			
 
 		}		
 	System.out.println(""Case #""+(i+1)+"": ""+count);
 	}
  
 	}
 static int lastOne(int j,int end,int digits,int chk,int mul){
 	int count=0;
 	int rem = j%mul;
 	int quo = j/mul;
 	if(rem!=0 && rem !=quo & rem >chk){
 		int no = (rem*digits)+quo;			
 		if(no<end && no>j)
 			count++;			
 		}		
 return count;
 }
 static int lasttwo(int j,int end,int digits,int chk,int mul){
 	int count=0;
 	int rem = j%mul;
 	int quo = j/mul;
 	if(rem!=0 & rem !=quo & rem >chk){
 		int no = (rem*digits)+quo;			
 		if(no<end && no>j)
 			count++;			
 		}		
 return count;
 }
 
 }
",0
138,16074,"package gcj;
 
 import java.util.Scanner;
 import java.util.StringTokenizer;
 public class BotTrust1{
 	public static void main(String args[]){
 		Scanner sin=new Scanner(System.in);
 		
 		int t=sin.nextInt();
 		int tVal=t;
 		sin.nextLine();
 		while(t>0){
 			//System.out.println(""test case:""+t);
 			t--;
 			
 			String str=sin.nextLine();
 			//System.out.println(str);
 			StringTokenizer stz=new StringTokenizer(str);
 			
 			String readStr;
 			
 			int numOfPairs=Integer.parseInt(stz.nextToken());
 			String presColor=stz.nextToken();
 			int aLoc[]={1,1};int aNos[]={0,0};
 			int index=0;
 			int des,nos,pNos=0;
 			String temp;
 			int tTime=0;boolean changed=true;
 			while(stz.hasMoreTokens()){
 				
 				des=Integer.parseInt(stz.nextToken());
 				
 				nos=Math.abs(des-aLoc[index]);
 				
 				if(changed){
 					int tt=aNos[(index+1)%2];
 					if(tt>=nos)
 						nos=0;
 					else 
 						nos=nos-tt;
 					nos++;
 					aNos[index]=nos;
 				}
 				else{
 					nos++;
 					aNos[index]=aNos[index]+nos;
 				}
 					
 				
 				
 				tTime=tTime+nos;
 				//System.out.println(nos);
 				aLoc[index]=des;
 				numOfPairs--;
 				if(numOfPairs>0)
 					temp=stz.nextToken();
 				else
 					continue;
 				if(!presColor.equals(temp)){
 					index++;
 					index=index%2;
 					changed=true;
 				}
 				else
 					changed=false;
 				presColor=temp;
 			}
 			System.out.println(""Case #""+(tVal-t)+"": ""+tTime);		
 			//System.exit(0);
 		}
 	}
 }
","package gcj;
 
 import java.util.Scanner;
 import java.util.StringTokenizer;
 public class BotTrust1{
 	public static void main(String args[]){
 		Scanner sin=new Scanner(System.in);
 		
 		int t=sin.nextInt();
 		int tVal=t;
 		sin.nextLine();
 		while(t>0){
 			//System.out.println(""test case:""+t);
 			t--;
 			
 			String str=sin.nextLine();
 			//System.out.println(str);
 			StringTokenizer stz=new StringTokenizer(str);
 			
 			String readStr;
 			
 			int numOfPairs=Integer.parseInt(stz.nextToken());
 			String presColor=stz.nextToken();
 			int aLoc[]={1,1};int aNos[]={0,0};
 			int index=0;
 			int des,nos,pNos=0;
 			String temp;
 			int tTime=0;boolean changed=true;
 			while(stz.hasMoreTokens()){
 				
 				des=Integer.parseInt(stz.nextToken());
 				
 				nos=Math.abs(des-aLoc[index]);
 				
 				if(changed){
 					int tt=aNos[(index+1)%2];
 					if(tt>=nos)
 						nos=0;
 					else 
 						nos=nos-tt;
 					nos++;
 					aNos[index]=nos;
 				}
 				else{
 					nos++;
 					aNos[index]=aNos[index]+nos;
 				}
 					
 				
 				
 				tTime=tTime+nos;
 				//System.out.println(nos);
 				aLoc[index]=des;
 				numOfPairs--;
 				if(numOfPairs>0)
 					temp=stz.nextToken();
 				else
 					continue;
 				if(!presColor.equals(temp)){
 					index++;
 					index=index%2;
 					changed=true;
 				}
 				else
 					changed=false;
 				presColor=temp;
 			}
 			System.out.println(""Case #""+(tVal-t)+"": ""+tTime);		
 			//System.exit(0);
 		}
 	}
 }
",1
139,20335,"import java.io.File;
 import java.util.Scanner;
 
 
 public class C {
 
     static Scanner in;
     
     static int[] GROUPSSIZE = new int[1024];
     
     public static void main(String[] args) throws Throwable {
 //        in = new Scanner(new File(""C-large.in""));
         in = new Scanner(new File(""C-small-attempt0.in""));
         
         int T = readInt();
         for (int casenum = 1; casenum <= T; casenum++) {
             System.out.printf(""Case #%d: "", casenum);
             System.out.println(solve());
         }
     }
     
 //    private static int solve() throws Throwable {
 //        int R = readInt();
 //        int k = readInt();
 //        int N = readInt();
 //        
 //        for (int i = 0; i < N; i++) {
 //            GROUPSSIZE[i] = readInt();
 //        }
 //        
 //        int euros = 0;
 //        int curGroup = 0;
 //        
 //        for (int r = 0; r < R; r++) {
 //            int group = curGroup;
 //            int people = 0;
 //            do {
 //                people += GROUPSSIZE[group];
 //                group = (group+1) % N;
 //            } while (group != curGroup && (people + GROUPSSIZE[group]) <= k);
 //            
 //            euros += people;
 //            curGroup = group;
 //        }
 //        
 //        return euros;
 //    }
     
     private static int solve() throws Throwable {
         int R = readInt();
         int k = readInt();
         int N = readInt();
         
         int[] RESULTS_SUM = new int[1024];
         int[] RESULTS_SELF = new int[1024];
         int[] RESULTS_RUN = new int[1024];
         int[] RESULTS_NEXT = new int[1024];
         
         for (int i = 0; i < N; i++) {
             GROUPSSIZE[i] = readInt();
         }
         
         int euros = 0;
         int curGroup = 0;
         
         for (int r = 0; r < R; r++) {
             if (RESULTS_SELF[curGroup] > 0) {
                 int runsMade = (r - RESULTS_RUN[curGroup]);
                 int blocks = (R-r) / runsMade;
                 int blockEuros = euros - (RESULTS_SUM[curGroup] - RESULTS_SELF[curGroup]);
                 
                 euros += (blocks * blockEuros);
                 r += (blocks * runsMade);
                 
                 while (r < R) {
                     euros += RESULTS_SELF[curGroup];
                     curGroup = RESULTS_NEXT[curGroup];
                     r++;
                 }
                 
                 break;
             }
             
             int group = curGroup;
             int people = 0;
             do {
                 people += GROUPSSIZE[group];
                 group = (group+1) % N;
             } while (group != curGroup && (people + GROUPSSIZE[group]) <= k);
             
             euros += people;
             
             RESULTS_RUN[curGroup] = r;
             RESULTS_SUM[curGroup] = euros;
             RESULTS_SELF[curGroup] = people;
             RESULTS_NEXT[curGroup] = group;
             
             curGroup = group;
         }
         
         return euros;
     }
 
     static int readInt() throws Throwable {
         return in.nextInt();
     }
 
     static long readLong() throws Throwable {
         return in.nextLong();
     }
     
 }
","import java.io.*;
 import java.util.*;
 
 public class A {
     public final static String FILE_IN = ""A-small-attempt3.in"";
     public final static String FILE_OUT = ""A-small-attempt3.out"";
 
     public static class Case {
         public int a;
         public int[] m;
 
         public String toString() {
             return """" + a + "":"" + Arrays.toString(m);
         }
     }
 
     public static Case readCase(BufferedReader r) throws IOException {
         Case c = new Case();
 
         String[] tk = r.readLine().split("" "");
         c.a = Integer.parseInt(tk[0]);
 
         int n = Integer.parseInt(tk[1]);
         c.m = new int[n];
         tk = r.readLine().split("" "");
         for (int j=0; j<n; j++) {
             c.m[j] = Integer.parseInt(tk[j]);
         }
 
         Arrays.sort(c.m);
 
         return c;
     }
 
 
     public static void solveCase(Case c, BufferedWriter w, int index) throws IOException {
         int x = c.a;
         int op = 0;
         for (int i=0; i<c.m.length; i++) {
             if (x > c.m[i]) {
                 x += c.m[i];
             }
             else {
                 int aa = 0;
                 while (x <= c.m[i] && aa < c.m.length - i) {
                     x = x + x - 1;
                     aa++;
                 }
 
                 op += aa;
                 if (x <= c.m[i]) {
                     break;
                 }
                 else {
                     x += c.m[i];
                 }
             }
         }
 
         w.write(""Case #"" + (index+1) + "": "" + op);
         w.newLine();
     }
 
     public static void main(String[] args) throws Exception {
         BufferedReader r = new BufferedReader(new FileReader(FILE_IN));
         BufferedWriter w = new BufferedWriter(new FileWriter(FILE_OUT));
         int num = Integer.parseInt(r.readLine());
         for (int i=0; i<num; i++) {
             Case c = readCase(r);
             solveCase(c, w, i);
         }
 
         w.close();
         r.close();
     }
 }",0
140,15137,"import java.util.*;
 /**
  *
  * @author Izhari Ishak Aksa
  */
 public class CandySplitting {
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int T = sc.nextInt();
         for (int t = 1; t <= T; t++) {
             int n = sc.nextInt();
             //int[] c = new int[n];
             int total = 0;
             String[] bit = new String[n];
             int ans = Integer.MAX_VALUE;
             int maxLen = 0;
             for (int i = 0; i < n; i++) {
                 int x = sc.nextInt();
                 ans = Math.min(ans, x);
                 total += x;
                 bit[i] = Integer.toBinaryString(x);
                 maxLen = Math.max(maxLen, bit[i].length());
             }
             for (int i = 0; i < n; i++) {
                 int dif = maxLen - bit[i].length();
                 for (int j = 0; j < dif; j++)
                     bit[i] = ""0"" + bit[i];
             }
             boolean bisa = true;
             for (int i = 0; i < maxLen; i++) {
                 int count = 0;
                 for (int j = 0; j < n; j++) {
                     if (bit[j].charAt(i) == '1')
                         count++;
                 }
                 if (count % 2 == 1) {
                     bisa = false;
                     break;
                 }
             }
             System.out.print(""Case #"" + t + "": "");
             if (bisa)
                 System.out.println(total - ans);
             else
                 System.out.println(""NO"");
         }
     }
 
 }
","import java.util.*;
 import java.io.*;
 public class B {
 	public static void main(String[]args) throws IOException {
 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 		int T = Integer.parseInt(in.readLine());
 		for(int x=1;x<T+1;x++) {
 			StringTokenizer st = new StringTokenizer(in.readLine());
 			int n = Integer.parseInt(st.nextToken());
 			int s = Integer.parseInt(st.nextToken());
 			int p = Integer.parseInt(st.nextToken());
 			int[] scores = new int[n];
 			for(int i=0;i<n;i++)
 				scores[i]=Integer.parseInt(st.nextToken());
 			int cases = 0;
 			for(int score : scores) {
 				int base = score/3;
 				switch(score%3) {
 					case 0:
 						if(base>=p) {
 							cases++;
 						}
 						else 
 							if (s > 0 && base > 0 && base + 1 >= p) {
 								cases++;
 								s--;
 							}
 						break;
 					case 1:
 						if(base+1>=p) {
 							cases++;
 						}
 						else 
 							if (s > 0 && base + 1 >= p) {
 								cases++;
 								s--;
 							}
 						break;
 					case 2:
 						if(base+1>=p) {
 							cases++;
 						}
 						else 
 							if (s > 0 && base + 2 >= p) {
 								cases++;
 								s--;
 							}
 						break;
 				}
 			}
 			System.out.println(""Case #""+x+"": ""+cases);
 		}
 	}
 }",0
141,14465,"import java.io.*;
 
 public class ThemePark {
 
 	static int T;
 	static long R;
 	static long K;
 	static int N;
 	static long current;
 	static long[] myVector;
 	static long[] myResult;
 	static int value;
 	static int currCase;
 	static FileWriter fw;
 	
 	static void readInput(String file) throws IOException {
 		FileReader fr=new FileReader(file);
 		BufferedReader br=new BufferedReader(fr);
 		T=Integer.parseInt(br.readLine());
 		String[] splitted=null;
 		for (int i=1; i<=T; i++)
 		{
 			splitted=br.readLine().split("" "");
 			R=Long.parseLong(splitted[0]);
 			K=Long.parseLong(splitted[1]); 
 			N=Integer.parseInt(splitted[2]);
 
 			myVector=new long[N];
 			splitted=br.readLine().split("" "");
 			for (int index=0; index<splitted.length; index++)
 			{
 				myVector[index]=Long.parseLong(splitted[index]);
 			}
 			solve();
 		}
 		fr.close();
 	}
 	static void solve() throws IOException {
 
 		myResult=new long[N];
 		current=0;
 		
 		for (int i=0; i<R; i++)
 		{
 			int incr=0;
 			while (myVector.length>incr && (current+myVector[incr])<=K)
 			{
 				myResult[incr]=myVector[incr];
 				value+=myResult[incr];
 				current+=myVector[incr];
 				incr++;
 			}
 			
 			{
 				long[] tmp=new long[N];
 				int idx=0;
 				for (int j=incr; j<N; j++)
 					tmp[idx++]=myVector[j];
 				System.arraycopy(myResult, 0, tmp, idx, N-idx);
 				myVector=tmp.clone();
 				myResult=new long[N];
 				current=0;
 			}
 		}
 		writeOutput(value);
 		value=0;
 	}
 	static void writeOutput(long value) throws IOException {
 		String s=""Case #""+(++currCase)+"": ""+value+""\n"";
 		fw.write(s);
 		
 	}
 	public static void main(String[] args) throws IOException {
 		
 		String inFile=""C-small-attempt0.IN"";
 		String outFile=""C-small-attempt0.OUT"";
 		fw=new FileWriter(outFile);
 		readInput(inFile);
 		fw.close();
 	}
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package gcj;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  *
  * @author Ashish Grover
  */
 public class GCJ {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         A a = new A();
         try {
             a.run();
         } catch (IOException ex) {
             Logger.getLogger(GCJ.class.getName()).log(Level.SEVERE, null, ex);
             a.closeReaderWriter();
         }
     }
 }
",0
142,18278,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 /**
  *
  * @author XpGG
  */
 public class Magicka {
 
     public static String scan ( int C, int D, int N, String CS [], String DS [], String NS ){
         String res = """"; 
         for( int i = 0; i < N; i ++ ){
             res += NS.charAt( i );
             // check combination
             for( int j = 0; j < C; j ++ ) {
                 char [] three = CS[j].toCharArray();
                 if( res.endsWith( """" + three [0] + three[1]) ||
                         res.endsWith( """" + three [1] + three[0]) ){
                     res = res.substring(0, res.length() - 2);
                     res += three[2];
                     res = scan( C, D, res.length(), CS, DS, res );
                 }
             } 
             // check oppose
             for( int j = 0; j < D; j ++ ) {
                 char [] two = DS[j].toCharArray();
                 if( res.contains("""" + two[0]) && res.contains("""" + two[1]) ){
                     res = """";
                 }
             } 
         }
         return res;
     }
     
     public static String toList( String input ){
         String res = ""["";
         if( input.length() < 2 ){
             return res + input + ""]"";
         }
         res += input.charAt(0);
         for( int i = 1; i < input.length(); i ++ ){
             res += "", "" + input.charAt(i);
             
         }
         return res + ""]"";
     }  
     
     public static void solve() throws FileNotFoundException {
         int T, C, D, N;
         String CS [], DS [], NS;
         Scanner scanner = new Scanner(new File(""B-large.in""));
         T = scanner.nextInt();
         for (int i = 0; i < T; i++) {
             if ((C = scanner.nextInt()) != 0) {
                 CS = new String [C] ;
                 for( int j = 0; j < C ; j ++ ){
                     CS [j] = scanner.next();
                 }
             } else {
                 CS = new String [0];
             }
             if ((D = scanner.nextInt()) != 0) {
                 DS = new String [D] ;
                 for( int j = 0; j < D ; j ++ ){
                     DS [j] = scanner.next();
                 }
             } else {
                 DS = new String [0];
             }
             if ((N = scanner.nextInt()) != 0) {
                 NS = scanner.next();
             } else {
                 NS = """";
             }
             System.out.println(""Case #"" + (i + 1) + "": "" + toList( scan( C, D, N, CS, DS, NS ) ));
         }        
         scanner.close();
     }
 }
","package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 /**
  *
  * @author XpGG
  */
 public class BotTrust {
 
     public static void solve() throws FileNotFoundException {
         Scanner scanner = new Scanner(new File(""A-large.in""));
         int T = scanner.nextInt();
         int N;
         for (int i = 0; i < T; i++) {
             N = scanner.nextInt();
             LinkedList<Action> list = new <Action> LinkedList();
             for (int j = 0; j < N; j++) {
                 Action a = new Action(scanner.next().charAt(0), scanner.nextInt());
                 list.add(a);
             }
             // positions of O and B
             int PO = 1, PB = 1;
             int timeline = 0, pt = 0, pasttime = 0;
             int t;
             char pn = 'O';
 
             while (!list.isEmpty()) {
                 Action a = list.getFirst();
                 if (a.NAME == 'O') {
                     // time to button
                     t = Math.abs( a.BUTTON - PO );
                     PO = a.BUTTON;
                     pasttime = 1;
 
                     if (pn == 'O') {
                         pasttime += t;
                         pt += pasttime;
                     } else {
                         // if move action can not be finished before the other one 
                         // to finish his task
                         if (t > pt) {
                             pasttime += t - pt;
                         }
                         pt = pasttime; //reset the clock
                     }
                     timeline += pasttime;
                     pn = 'O';
                 } else {
                     // time to button
                     t = Math.abs( a.BUTTON - PB );
                     PB = a.BUTTON;
                     pasttime = 1;
 
                     if ( pn == 'B' ) {
                         pasttime += t;
                         pt += pasttime;
                     } else {
                         // if move action can not be finished before the other one 
                         // to finish his task
                         if (t > pt) {
                             pasttime += t - pt;
                         }
                         pt = pasttime; //reset the clock
                     }
                     timeline += pasttime;
                     pn = 'B';
                 }
                 list.remove();
             }
             System.out.println(""Case #"" + (i + 1) + "": "" + timeline);
         }
         scanner.close();
     }
 }
 
 class Action {
 
     public char NAME;
     public int BUTTON;
 
     public Action(char name, int button) {
         NAME = name;
         BUTTON = button;
     }
 
     @Override
     public String toString() {
         return ""Name: "" + NAME + "" Button: "" + BUTTON;
 
     }
 }
",1
143,982,"package at.jaki.round1A.C;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Comparator;
 
 public class C {
 
     //private static final String INPUT = ""C-large.in"";
     private static final String INPUT = ""C-small-attempt1.in"";
     //private static final String INPUT = ""C-test.in"";
     //private static final String INPUT = ""C-large.out"";
     private static final String OUTPUT = ""C-small-attempt1.out"";
     //private static final String OUTPUT = ""C-test.out"";
 
     public static void main(String[] args) throws IOException {
         BufferedReader br = new BufferedReader(new FileReader(INPUT));
         PrintWriter pw = new PrintWriter(OUTPUT);
         int totalTests = Integer.parseInt(br.readLine());
 
 
         int[][] x = new int[totalTests][2];
         for (int testNo = 1; testNo <= totalTests; testNo++) {
             int n = Integer.parseInt(br.readLine());
             int[] t = new int[n];
             String[] temp = br.readLine().split("" "");
             for (int i = 0; i < n; i++) {
                 t[i] = Integer.parseInt(temp[i]);
             }
             int sum1 = 0;
             int sum2 = 0;
             for (int i = 0; i < n / 2; i++) {
                 sum1 += t[i];
             }
             for (int i = n / 2; i < n; i++) {
                 sum2 += t[i];
             }
             x[testNo - 1][1] = Math.abs(sum2 - sum1);
             x[testNo - 1][0] = testNo;
             //pw.print(""Case #"" + testNo + "": "");
         }
         Arrays.sort(x, new Comparator<int[]>() {
             @Override
             public int compare(int[] a, int[] b) {
                 return a[1] - b[1];
             }
         });
 
         System.out.println(""goods:"");
         String[] results = new String[totalTests + 1];
         for (int i = 0; i < totalTests / 2; i++) {
             int index = x[i][0];
             System.out.println(x[i][1]);
             results[index] = ""GOOD"";
         }
         System.out.println(""bads:"");
         for (int i = totalTests / 2; i < totalTests; i++) {
             int index = x[i][0];
             System.out.println(x[i][1]);
             results[index] = ""BAD"";
         }
 
         for (int i = 1; i <= totalTests; i++) {
             if (results[i] == null) {
                 results[i] = ""BAD"";
                 System.out.println(""Something is wrong"");
             }
             pw.println(""Case #"" + i + "": "" + results[i]);
         }
 
         pw.flush();
         pw.close();
 
     }
 }
","package at.jaki.round1A.A;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 
 public class A2 {
 
     //private static final String INPUT = ""A-large.in"";
     private static final String INPUT = ""A-small-attempt2.in"";
     //private static final String INPUT = ""A-test.in"";
     //private static final String INPUT = ""A-large.out"";
     private static final String OUTPUT = ""A-small-attempt2.out"";
     //private static final String OUTPUT = ""A-test.out"";
 
     public static void main(String[] args) throws IOException {
         BufferedReader br = new BufferedReader(new FileReader(INPUT));
         PrintWriter pw = new PrintWriter(OUTPUT);
         int totalTests = Integer.parseInt(br.readLine());
         for (int testNo = 1; testNo <= totalTests; testNo++) {
             String[] temp = br.readLine().split("" "");
             int n = Integer.parseInt(temp[0]);
             int l = Integer.parseInt(temp[1]);
             String[] have = br.readLine().split("" "");
             String[] need = br.readLine().split("" "");
 
             int res = -1;
             for (String need1 : need) {
                 String tr = transform(have[0], need1);
                 String[] haveTr = transformAll(have, tr);
                 int x = validate(haveTr, need) ? count(tr) : -1;
                 if (x != -1) {
                     if (res == -1 || x < res) {
                         res = x;
                     }
                 }
             }
 
             pw.print(""Case #"" + testNo + "": "");
             if (res == -1) {
                 pw.println(""NOT POSSIBLE"");
             } else {
                 pw.println(res);
             }
         }
 
         pw.flush();
         pw.close();
     }
 
     private static String[] transformAll(String[] have, String tr) {
         String[] res = new String[have.length];
         for (int i = 0; i < have.length; i++) {
             StringBuilder sb = new StringBuilder();
             for (int j = 0; j < have[i].length(); j++) {
                 if (tr.charAt(j) == '0' && have[i].charAt(j) == '0') {
                     sb.append('0');
                 } else if (tr.charAt(j) == '1' && have[i].charAt(j) == '1') {
                     sb.append('0');
                 } else {
                     sb.append('1');
                 }
             }
             res[i] = sb.toString();
         }
         return res;
     }
 
     private static String transform(String s, String need1) {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < s.length(); i++) {
             if (s.charAt(i) == need1.charAt(i)) {
                 sb.append('0');
             } else {
                 sb.append('1');
             }
         }
         return sb.toString();
     }
 
     private static int count(String tr) {
         int c = 0;
         for (char ch : tr.toCharArray()) {
             if (ch == '1') c++;
         }
         return c;
     }
 
     private static boolean validate(String[] a, String[] b) {
         String[] a2 = Arrays.copyOf(a, a.length);
         String[] b2 = Arrays.copyOf(b, a.length);
         Arrays.sort(a2);
         Arrays.sort(b2);
         for (int i = 0; i < a2.length; i++) {
             if (!a2[i].equals(b2[i])) {
                 return false;
             }
         }
         return true;
     }
 
 
 }
",1
144,11295,"package gcjarchive;
 
 import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 public class Round1C2 {
 
 public static void main(String args[]) throws Exception
 {
     BufferedReader br=new BufferedReader(new FileReader(""C:/Documents and Settings/kartik/My Documents/NetBeansProjects/PreperationsGCJ/src/gcjarchive/in.txt""));
     BufferedWriter bw=new BufferedWriter(new FileWriter(""C:/Documents and Settings/kartik/My Documents/NetBeansProjects/PreperationsGCJ/src/gcjarchive/out.txt""));
     int zz=Integer.parseInt(br.readLine());
     int z=1;
     String s,s2[];
     while(z<=zz)
     { 
       s=br.readLine();
       s2=s.split("" "");
       long l=Long.parseLong(s2[0]);
       long t=Long.parseLong(s2[1]);
       long n=Long.parseLong(s2[2]);
       int c=Integer.parseInt(s2[3]);
       long[] arr=new long[c];
       double[] time=new double[c];
       for(int i=0;i<c;i++)
       {
           arr[i]=Integer.parseInt(s2[4+i]);
       }
             System.out.println();
       long[] dist=new long[(int)n];
       for(int i=0;i<n;i++)
       {
           dist[i]=arr[(i)%c];
       }
     long timetaken=0;
     int i=0;
     int flag=0;
      while(t>timetaken+dist[i]*2)
      {   
          timetaken+=dist[i]*2;
          i++;
          if(i>=n)
          {  flag=1;
              break;
           
          }
      }
   if(flag==0)
   {
    long temp=timetaken;
    timetaken+=(t-timetaken);
    dist[i]=dist[i]-(t-temp)/2;
      System.out.println(timetaken+"" ""+i);
      for(int a=i;a<n;a++)
          System.out.print(dist[a]+"" "");
      System.out.println();
    while(l>0)
    {
   long max=dist[i];
   long maxidx=i;
   long need=i;
    while(maxidx<n)
     {
        if(dist[(int)maxidx]>max)
        {
            need=maxidx;
            max=dist[(int)maxidx];
        }
                maxidx++;
     }
   timetaken+=dist[(int)need];
   dist[(int)need]=-1;
    l--;
    }
    for(int e=i;e<n;e++)
    {
        if(dist[e]!=-1)
            timetaken+=dist[e]*2;
    }
   }
      bw.write(""\nCase #""+z+"": ""+timetaken);
    z++;
     }
     bw.close();
 }
 
 }
","package gcjarchive;
 
 import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 public class Round1C3 {
 
 public static void main(String args[]) throws Exception
 {
     BufferedReader br=new BufferedReader(new FileReader(""C:/Documents and Settings/kartik/My Documents/NetBeansProjects/PreperationsGCJ/src/gcjarchive/in.txt""));
     BufferedWriter bw=new BufferedWriter(new FileWriter(""C:/Documents and Settings/kartik/My Documents/NetBeansProjects/PreperationsGCJ/src/gcjarchive/out.txt""));
     int zz=Integer.parseInt(br.readLine());
     int z=1;
     String s,s2[];
     while(z<=zz)
     { 
       s=br.readLine();
       s2=s.split("" "");
       long n=Integer.parseInt(s2[0]);
       long l=Integer.parseInt(s2[1]);
       long h=Integer.parseInt(s2[2]);
       long arr[]=new long[(int)n];
       s=br.readLine();
       s2=s.split("" "");
       for(int i=0;i<n;i++)
       {
           arr[i]=Long.parseLong(s2[i]);
       }
       long flag=0;
       long i,j=0;
        for(j=l;j<=h;j++) 
       {
           flag=0;
          for(i=0;i<n;i++)
           { 
             
               
               if(j%arr[(int)i]==0||arr[(int)i]%j==0)
               {
                  flag=1; 
               }
               else
               { flag=0;
                   break;
               }
                 
           }
           if(flag==1)
              break;
       }
       if(flag==1)
       {
            bw.write(""\nCase #""+z+"": ""+j);
       }
       else
            bw.write(""\nCase #""+z+"": NO"");
    z++;
     }
     bw.close();
 }
 
 }
",1
145,3265,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.Scanner;
 
 public class test6 {
 
 	private static int numberOfCase = 0;
 
 	public static void WriteFile(String str) throws IOException {
 
 		File f = new File(""textfile1.txt"");
 		FileOutputStream fop = new FileOutputStream(f, true);
 
 		fop.write(str.getBytes());
 		fop.write(""\n"".getBytes());
 		fop.flush();
 		fop.close();
 	}
 
 	public static long calcNumOfK(int n)
 	{
 		if(n==1) return 1L;
 		else return 2*calcNumOfK(n-1)+1;
 		
 	}
 	public static String printOnOFF(Long K, int N) {
 		
 		if(K==0) return ""OFF"";
 		
 		long res=calcNumOfK(N);
 		
 		if (res>K) return ""OFF"";
 		
 		if(N==1)
 		{
 			if(K%2==1) return ""ON"";
 			else return ""OFF"";
 		}
 		long tmp=K%(res+1);
 		
 		if(tmp==res) 
 		{
 			return ""ON"";
 		}
 		
 		return ""OFF"";
 
 	}
 
 	public static void printRow(int Case, long K, int N) {
 
 		try {
 			WriteFile(""Case #"" + (Case + 1) + "": "" + printOnOFF(K, N));
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 
 	}
 
 	public String print(String[] sb) {
 		String s = """";
 		for (int i = 0; i < sb.length; i++)
 			s += sb[i] + "" "";
 		return s;
 	}
 
 	public static void readFile() throws FileNotFoundException {
 		FileReader fin = new FileReader(""A-small-attempt8.in"");
 
 		Scanner src = new Scanner(fin);
 
 		numberOfCase = Integer.parseInt(src.nextLine());
 		int N = 0;
 		long K = 0;
 		String line = """";
 		String[] nums = null;
 
 		for (int i = 0; i < numberOfCase; i++) {
 
 			line = src.nextLine();
 			nums = line.split("" "");
 			N = Integer.parseInt(nums[0]);
 			K = Long.parseLong(nums[1]);
 
 			printRow(i, K, N);
 		}
 
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 			readFile();
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.Scanner;
 
 public class test8 {
 
 	private static int numberOfCase = 0;
 
 	public static void WriteFile(String str) throws IOException {
 
 		File f = new File(""textfile2.txt"");
 		FileOutputStream fop = new FileOutputStream(f, true);
 
 		fop.write(str.getBytes());
 		fop.write(""\n"".getBytes());
 		fop.flush();
 		fop.close();
 	}
 
 	public static int needTobeAdd(ArrayList<String[]> dirList,String[] allDirNeed)
 	{
 		int res=0;
 		int max=0;
 		int count=0;
 		
 		
 				
 		for(int i=0;i<dirList.size();i++)
 		{
 		  String[] currentPath=dirList.get(i);
 		  count=0;
 		  
 		  for(int k=1;k<allDirNeed.length;k++)
 		  {
 			  if (k<currentPath.length&&allDirNeed[k].equals(currentPath[k])) count++;
 			  else break;
 		  }
 		  if(count>max) max=count;
 		}
 		
 	
 	   return (allDirNeed.length-max-1);
 	}
 	
 	public static long numberOfMkdirctory(String[] dirs, String[] newDirs) 
 	{
 		if(newDirs==null) return 0;
 		String newDir="""";
 		
 		long res=0;
 		ArrayList<String[]> dirList=new ArrayList<String[]>();
 		
 		if(dirs!=null)
 		{
 			for(int i=0;i<dirs.length;i++)
 			{
 				dirList.add(dirs[i].split(""/""));
 			}
 		}
 		
 		
 		for(int i=0;i<newDirs.length;i++)
 		{
 			newDir=newDirs[i];
 			
 			String[] allDirNeed=newDir.split(""/"");
 	    
 			res+=needTobeAdd(dirList,newDir.split(""/""));
 			
 			dirList.add(newDir.split(""/""));
 		}
 	
 		
 		
 	    return res;
 	}
 
 	public static void printRow(int Case, String[] dirs, String[] newDirs) {
 
 		try {
 			WriteFile(""Case #"" + (Case + 1) + "": "" + numberOfMkdirctory(dirs, newDirs));
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 
 	}
 
 	public String print(String[] sb) {
 		String s = """";
 		for (int i = 0; i < sb.length; i++)
 			s += sb[i] + "" "";
 		return s;
 	}
 
 	public static void readFile() throws FileNotFoundException {
 		FileReader fin = new FileReader(""textfile1.txt"");
 
 		Scanner src = new Scanner(fin);
 		String [] dirs=null ;
 		String [] newDirs=null ;
 		
 		numberOfCase = Integer.parseInt(src.nextLine());
 		int N = 0;
 		int M = 0;
 		String line = """";
 		String[] nums = null;
 
 		for (int i = 0; i < numberOfCase; i++) {
 
 			line = src.nextLine();
 			nums = line.split("" "");
 			N = Integer.parseInt(nums[0]);
 			M = Integer.parseInt(nums[1]);
 			if(N!=0) dirs=new String[N];
 			if(M!=0) newDirs=new String[M];
 
 			for(int k=0;k<N;k++)
 			{
 				dirs[k]=src.nextLine();
 			}
 			
 			for(int k=0;k<M;k++)
 			{
 				newDirs[k]=src.nextLine();
 			}
 			
 			printRow(i, dirs, newDirs);
 		}
 
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 			readFile();
 	}
 }
",1
146,16544,"
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 /**
  *
  * @author Anuj
  */
 public class Robot {
 
     int cases, buttons;
     int oPos, bPos;
     int om, bm, op, bp, os, bs;
     int bT,oT;
     String[] temp;
 
     public Robot() {
         cases = 0;
         buttons = 0;
         om = bm = op = bp = os = bs = 0;
         oPos = 1;
         bPos = 1;
         bT = oT = 0;
     }
 
     public void go() {
         try {
             int i;
             BufferedReader br = new BufferedReader(new FileReader(""A-small-attempt0.in""));
             BufferedWriter bw = new BufferedWriter(new FileWriter(""out.txt""));
 
             cases = Integer.parseInt(br.readLine());
             //System.out.println(cases);
 
             for (i = 0; i < cases; i++) {
                 temp = br.readLine().split("" "");
 
                 buttons = Integer.parseInt(temp[0]);
                 //System.out.println(""but:""+buttons);
 
                 om = bm = op = bp = os = bs = 0;
                 oPos = 1;
                 bPos = 1;
                 bT = oT = 0;
 
                 for( int j = 1; j <= buttons * 2;) {
                     //System.out.println(""j"" + j);
                     //System.out.println(temp[j]);
                     if(temp[j].equals(""B"")) {
                         bm += Math.abs(Integer.parseInt(temp[++j]) - bPos);
                         bPos = Integer.parseInt(temp[j]);
                         bs += (om + op + os - bm - bs - bp)<0?0:(om + op + os - bm - bs - bp);
                         bp++;
                         //System.out.println(temp[j-1] + "":"" + bm + "":"" + bp + "":"" + bs);
                         continue;
                     }
                     if(temp[j].equals(""O"")) {
                         om += Math.abs(Integer.parseInt(temp[++j]) - oPos);
                         oPos = Integer.parseInt(temp[j]);                        
                         os += (bm + bp + bs - om - os - op)<0?0:(bm + bp + bs - om - os - op);
                         op++;
                         //System.out.println(temp[j-1] + "":"" + om + "":"" + op + "":"" + os);
                         continue;
                     }
                     j++;
                 }
                 bT = bm + bp + bs;
                 oT = om + op + os;
 
                 int total = (bT + oT + Math.abs(bT - oT)) / 2;
                 //System.out.println(total);
                 bw.write(""Case #"" + (i + 1) + "": "" + total);
                 bw.newLine();
 
             }
 
             br.close();
             bw.close();
         } catch (java.io.FileNotFoundException e) {
         } catch (java.io.IOException e) {
         }
 
     }
 
     public static void main(String args[]) {
         Robot snap = new Robot();
         snap.go();
     }
 }
","package codejam2014;
 import java.util.*;
 import java.io.*;
 /*
  * Auther : dibakar.nandi@gmail.com
  */
 
 public class DibakarNandiQD {
     final static String PROBLEM_NAME = ""D-small-attempt1"";//QD"";//
     final static String WORK_DIR = ""E:\\CodeJam\\""+PROBLEM_NAME;
 
     void solve(Scanner sc, PrintWriter pw) {
         int n = sc.nextInt();
         double naomiBrick[]=new double[n];
         double kenBrick[]=new double[n];
         double tempKenBrick[]=new double[n];
         
         
         for(int i=0;i<n;i++){
         	naomiBrick[i]=sc.nextDouble();
         }
         shorting(naomiBrick);
         for(int i=0;i<n;i++){
         	System.out.print(naomiBrick[i]+"" "");
         }
         
         System.out.print(""\n"");
         for(int i=0;i<n;i++){
         	kenBrick[i]=sc.nextDouble();
         }
         shorting(kenBrick);
         for(int i=0;i<n;i++){
         	System.out.print(kenBrick[i]+"" "");
         	tempKenBrick[i]=kenBrick[i];
         }
         System.out.print(""\n"");
         
         
         int warPoint=0;
         for(int i=0;i<n;i++){
         	 boolean kenWin=false;
         	 for(int j=0;j<n;j++){
         		 if(tempKenBrick[j]>naomiBrick[i]){
       //  			 System.out.println(naomiBrick[i]+"" ""+kenBrick[j]+"" ""+""Key Win"");
         			 kenWin=true;
         			 tempKenBrick[j]=-1;
         			 break;
         		 }
              	
              }
         	 if(!kenWin)
         		 warPoint++;
         }
         //System.out.println(warPoint);
         
         
         int deceitfulWarPoint=0;
         int kenMax=n;
         int kenMin=0;
         
         for(int i=0;i<n;i++){
         		boolean naomiMaxHave=false;
         		for(int j=0;j<n;j++){
         			if(naomiBrick[j]>kenBrick[i]){
         				naomiMaxHave=true;
         				naomiBrick[j]=-1;
         				break;
         			}
         		}
         		if(naomiMaxHave)
         			deceitfulWarPoint++;
         }
         System.out.println(deceitfulWarPoint+"" ""+warPoint);
         pw.print(deceitfulWarPoint+"" ""+warPoint);
         
         
     }
     
     public void shorting(double pos[])
     {
 	    	for(int j=0;j<pos.length;j++)
 	    	{
 	    		int tpos=j;
 	    		for(int k=j;k<pos.length;k++)
 	    		{
 	    		  if(pos[k]<pos[tpos])
 	    			  tpos=k;
 	    		}
 	    		double tmp=0;
 	    		
 	    		tmp=pos[j];
 	    		pos[j]=pos[tpos];
 	    		pos[tpos]=tmp;
 	 			
     	}
 
     }
     public String Round(double rval) {
     	String output=""""+Round(rval, 7);
     	
     	String dec=output.substring(output.indexOf("".""));
     	//System.out.println(dec);
     	if(dec.length()>=8)
     		return output;
     	else
     		for(int i=dec.length();i<8;i++){
     			output+=""0"";
     		}
     	//System.out.println(rval.substring(0,rval.indexOf("".""))+dec);
     	return output;
     }
     public double Round(double Rval, int Rpl) {
     	double p = (double)Math.pow(10,Rpl);
         Rval = Rval * p;
         double tmp = Math.round(Rval);
         return (double)tmp/p;
     }
     public static void main(String[] args) throws Exception {
         Scanner sc = new Scanner(new FileReader(WORK_DIR + "".in""));
         PrintWriter pw = new PrintWriter(new FileWriter(WORK_DIR + "".out""));
         int caseCnt = sc.nextInt();
 
         for (int caseNum=0; caseNum<caseCnt; caseNum++) {
             System.out.println(""Processing test case "" + (caseNum + 1));
             pw.print(""Case #"" + (caseNum+1) + "": "");
             new DibakarNandiQD().solve(sc, pw);
             if(caseNum+1<caseCnt)
             	pw.print(""\n"");
         }
         pw.flush();
         pw.close();
         sc.close();
     }
 }
",0
147,8996,"import java.util.*;
 
 public class CodeJam3
 {
 	public static void main(String[] args)
 	{
 		Scanner sc= new Scanner(System.in);
 		int tt = sc.nextInt();
 		int[] n = new int[1001];
 		n[1] = 1;
 		for(int i=2;i<1001;i++)
 		{
 			if(square(i))
 			{
 				int a = (int) Math.sqrt(i);
 				if(pal(a) && pal(i))
 					n[i] = n[i-1] +1;
 				else
 					n[i] = n[i-1];
 			}
 			else
 				n[i] = n[i-1];
 		}
 		for(int kk=1;kk<=tt;kk++)
 		{
 			int a = sc.nextInt();
 			int b = sc.nextInt();
 			System.out.printf(""Case #%d: %d\n"",kk,n[b] - n[a-1]);
 		}
 	}
 	public static boolean square(int n)
 	{
 		long tst = (long)(Math.sqrt(n) + 0.5);
 		return tst*tst == n;
 	}
 	public static boolean pal(int n)
 	{
 		String a = n+"""";
 		String b = new StringBuffer(a).reverse().toString();
 		return (a.equals(b));
 	}
 }","import java.util.*;
 
 public class CodeJam3
 {
 	public static void main(String[] args)
 	{
 		Scanner sc= new Scanner(System.in);
 		int tt = sc.nextInt();
 		int[] n = new int[1001];
 		n[1] = 1;
 		// ArrayList<Long> arr = new ArrayList<Long>();
 		long[] arr = {1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,100020001,102030201,104060401,121242121,
 						123454321,125686521,400080004,404090404,10000200001l,10221412201l,12102420121l,12345654321l,40000800004l,
 						1000002000001l,1002003002001l,1004006004001l,1020304030201l,1022325232201l,1024348434201l,1210024200121l,
 						1212225222121l,1214428244121l,1232346432321l,1234567654321l,4000008000004l,4004009004004l};
 		// for(long i=1;i<10000001;i++)
 		// {
 			// if(pal(i))
 			// {
 				// long a = i*i;
 				// if(pal(a))
 				// {
 					// arr.add(a);
 					// System.out.println(a);
 				// }
 			// }
 		// }
 		for(int kk=1;kk<=tt;kk++)
 		{
 			long a = Long.parseLong(sc.next());
 			long b = Long.parseLong(sc.next());
 			int c = binarySearch(arr,a-1,0,38);
 			int d = binarySearch(arr,b,0,38);
 			System.out.printf(""Case #%d: %d\n"",kk,d-c);
 		}
 	}
 	public static boolean square(long n)
 	{
 		long tst = (long)(Math.sqrt(n) + 0.5);
 		return tst*tst == n;
 	}
 	public static boolean pal(long n)
 	{
 		String a = n+"""";
 		String b = new StringBuffer(a).reverse().toString();
 		return (a.equals(b));
 	}
 	private static int binarySearch(long[] arr, long searchValue, int left, int right) 
 	{
 		if (right < left) {
 				return left - 1;
 		}
 		int mid = (left + right) >>> 1;
 		if (searchValue > arr[mid]) {
 				return binarySearch(arr, searchValue, mid + 1, right);
 		} else if (searchValue < arr[mid]) {
 				return binarySearch(arr, searchValue, left, mid - 1);
 		} else {
 				return mid;
 		}               
     }
 }",1
148,9334,"package pkg;
 
 import java.math.BigInteger;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 
 public class Solution {
     public static List<String> read(String fileName) {
     	List<String> ret = new ArrayList<String>();
         FileReader f = null;
         BufferedReader b = null;
     	try{
             f = new FileReader(fileName);
             b = new BufferedReader(f);
             String s;
             while((s = b.readLine())!=null) {
                 ret.add(s);
             }
         } catch(Exception e) {
         	e.printStackTrace();
         } finally {
         	try {
         		if (b != null) {
         			b.close();
         		}
         	} catch (Exception e) {
         		e.printStackTrace();
         	}
         	try {
         		if (f != null) {
         			f.close();
         		}
         	} catch (Exception e) {
         		e.printStackTrace();
         	}
 
         }
         return ret;
     }
     public static void write(String fileName, List<String> data) {
         FileWriter f = null;
         try{
         	File outF = new File(fileName);
             f = new FileWriter(outF);
             for(int n = 0; n < data.size(); n++) {
             	f.write(data.get(n));
             	f.write(""\r\n"");
             }
         }catch(Exception e){
         	e.printStackTrace();
         } finally {
         	try {
         		if (f != null) {
         			f.close();
         		}
         	} catch (Exception e) {
         		e.printStackTrace();
         	}
         }
     }
 
 	public static void main(String arg[]) {
 		List<String> data = read(arg[0]);
 		String tmp = data.get(0);
 		int times = Integer.parseInt(tmp);
 		List<String> outData = new ArrayList<String>();
 		int m = 1;
 		String maxMoteStr = ""1000000"";
 		for (int n = 0; n < times; n++) {
 			String names = data.get(m);
 			m++;
 			String baseName = names.split("" "")[0];
 			BigInteger nLn = new BigInteger(names.split("" "")[1]);
 			
 			char baseNameArr[] = baseName.toCharArray();
 			
 			int result = 0;
 			
 			for (int h = 0; h < baseNameArr.length; h++) {
 				for (int t = baseNameArr.length; t > h; t--) {
 					String sbstr = baseName.substring(h, t);
 //					System.out.print(sbstr + "":"");
 					boolean ok = chk(sbstr, nLn);
 					if (ok) {
 						result++;
 					}
 				}
 			}
 //			System.out.println();
 			
 			StringBuffer out = new StringBuffer();
 			int c = n + 1;
 			out.append(""Case #"" + c + "": "" + result);
 			System.out.println(out.toString());
 			outData.add(out.toString());
 		}
 		write(arg[1], outData);
 	}
 
 	public static boolean chk(String str, BigInteger n) {
 		BigInteger strLen = new BigInteger(new Integer(str.length()).toString());
 		if (strLen.compareTo(n) < 0) return false;
 		boolean ret = false;
 		BigInteger combo = BigInteger.ZERO;
 		char s[] = str.toCharArray();
 		for (int h = 0; h < s.length; h++) {
 			if (s[h] != 'a' && s[h] != 'i' && s[h] != 'u' && s[h] != 'e' && s[h] != 'o') {
 				if (combo.compareTo(n) >= 0) {
 					return true;
 				}
 				combo = combo.add(BigInteger.ONE);
 			} else {
 				if (combo.compareTo(n) >= 0) {
 					return true;
 				} else {
 					combo = BigInteger.ZERO;
 				}
 			}
 		}
 		if (combo.compareTo(n) >= 0) {
 			return true;
 		} else {
 			return false;
 		}
 	}
 }
","package pkg;
 
 
 import java.util.ArrayList;
 import java.util.List;
 import java.math.BigDecimal;
 
 public class Solution {
 	public static void main(String arg[]) {
 		List<String> data = FileInput.read(arg[0]);
 		String tmp = data.get(0);
 		int times = Integer.parseInt(tmp);
 		int cnt = 1;
 		List<String> outData = new ArrayList<String>();
 		for (int n = 0; n < times; n++) {
 			int okCount = 0;
 			int m = n + 1;
 			String size = data.get(cnt);
 			cnt++;
 			String sizeMinS = size.split("" "")[0];
 			String sizeMaxS = size.split("" "")[1];
 			BigDecimal min = new BigDecimal(sizeMinS);
 			BigDecimal max = new BigDecimal(sizeMaxS);
 			System.out.println(m + "":"" + min + "":"" + max);
 			
 			double minsqrt = Math.sqrt(min.doubleValue());
 			double maxsqrt = Math.sqrt(max.doubleValue());
 
 			System.out.println(minsqrt + ""::"" + maxsqrt + ""::"");
 			for (int tsqrt = (int) Math.floor(minsqrt);tsqrt <= maxsqrt; tsqrt++) {
 				if (!formatCheck(new BigDecimal(tsqrt))) {
 					continue;
 				}
 				BigDecimal t = new BigDecimal(tsqrt * tsqrt);
 				// form
 				if (min.compareTo(t) <= 0 && t.compareTo(max) <= 0 && formatCheck(t)) {
 					okCount++;
 				}
 			}
 			System.out.println();
 //			for (BigDecimal t = min; t.compareTo(max) <= 0; t = t.add(BigDecimal.ONE)) {
 //				// sqrt
 //				double sqrt = Math.sqrt(t.doubleValue());
 //				int sqrti = (int) sqrt;
 //				if (sqrti != sqrt) {
 //					continue;
 //				}
 //				
 //				// form
 //				if (formatCheck(t.toString()) && formatCheck(String.valueOf(sqrti))) {
 //					okCount++;
 //				}
 //			}
 			String out;
 			out = ""Case #"" + m + "": "" + okCount;
 			outData.add(out);
 		}
 		FileOutput.write(arg[1], outData);
 	}
 	
 	private static boolean formatCheck(BigDecimal num) {
 		String number = num.toString();
 		char nmbrC[] = number.toCharArray();
 		int center = nmbrC.length/2;
 		boolean formed = true;
 		if (nmbrC.length > 1) {
 			for (int c = 0; c <= center; c++) {
 				if (nmbrC[c] != nmbrC[nmbrC.length - 1 - c]) {
 					formed = false;
 					break;
 				}
 			}
 		}
 		return formed;
 	}
 }
",1
149,15174,"import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 
 public class Main2 {
 	private static final String IN_FILE = ""in.txt"";
 	private static final String OUT_FILE = ""out.txt"";
 	
 	private static List<Xxx> parseFile() throws IOException  {
 		BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(IN_FILE)));
 		
 		int count = Integer.parseInt(r.readLine());
 		List<Xxx> res = new ArrayList<Xxx>();
 		for(int i = 0; i < count; i++){
 			String line = r.readLine();
 			String[] tupel = line.split("" "");
 			Xxx d = new Xxx();
 			d.min = Integer.parseInt(tupel[0]);
 			d.max = Integer.parseInt(tupel[1]);
 			
 			res.add(d);
 		}
 		r.close();
 		
 		return res;
 	}
 	
 	private static List<Integer> process(List<Xxx> dl){
 		List<Integer> res = new ArrayList<Integer>();
 		
 		for(Xxx d : dl){
 			int count = 0;
 			
 //			System.out.println(""-----------------------------------------"");
 			List<String> xxx = new ArrayList<String>();
 			for(int x = d.min; x < d.max; x++){
 				String sx_orig = String.valueOf(x);
 				int len = sx_orig.length();
 				String sy = null;
 				xxx.clear();
 				
 				if(len > 1){
 					for(int y = x + 1; y <= d.max && (sy = String.valueOf(y)).length() == len; y++){
 						String sx = sx_orig;
 						
 						for(int i = 1; i < sx.length(); i++){
 							char c = sx.charAt(sx.length()-1);
 							sx = c  + sx.substring(0, sx.length() - 1);
 							
 							if(sx.equals(sy)){
 								
 								if(!xxx.contains(sx)){
 									xxx.add(sx);
 //									System.out.println(sx_orig +""\t"" +sx);
 									count++;
 									continue;
 								}
 							}
 						}
 					}
 				}
 			}
 			
 			res.add(count);
 		}
 		
 		return res;
 	}
 	
 	private static void writeOutput(List<Integer> data) throws IOException {
 		BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(OUT_FILE)));
 		
 		for(int i = 0; i < data.size(); i++){
 			if(i > 0){
 				w.write(""\n"");
 			}
 			
 			String s = ""Case #"" +(i+1) +"": "" +data.get(i);
 			w.write(s);
 		}
 		w.close();
 	}
 	
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		List<Xxx> l = parseFile();
 		List<Integer> r = process(l);
 		writeOutput(r);
 		
 		System.out.println(""Done"");
 	}
 	
 	private static class Xxx {
 		public int min;
 		public int max;
 	}
 }","package Q3;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Qualification {
 
 	public class CicularLinkedList {
 		private Group header;
 		private Group tail;
 		private int size;
 
 		public CicularLinkedList(Group g) {
 			// Auto-generated constructor stub
 			this.header = g;
 			this.tail = g;
 			this.tail.next = this.header;
 			this.size = 1;
 		}
 
 		public CicularLinkedList() {
 			// TODO Auto-generated constructor stub
 		}
 
 		public Group getHeader() {
 			return header;
 		}
 
 		public void setHeader(Group header) {
 			this.header = header;
 		}
 
 		public Group getTail() {
 			return tail;
 		}
 
 		public void setTail(Group tail) {
 			this.tail = tail;
 		}
 
 		public int getSize() {
 			return size;
 		}
 
 		public void setSize(int size) {
 			this.size = size;
 		}
 
 		public void append(Group group) {
 
 			this.tail.next = group;
 			this.tail = group;
 			this.tail.next = this.header;
 			++this.size;
 		}
 
 		public void print() {
 			System.out.println(""Content of d linked list"");
 			Group tmp = this.header;
 			while (tmp != null) {
 				tmp.print();
 				tmp = tmp.next;
 			}
 			System.out.println();
 		}
 
 		public void init(Group g) {
 			// TODO Auto-generated method stub
 			this.header = g;
 			this.tail = g;
 			this.tail.next = this.header;
 			this.size = 1;
 		}
 
 	}
 
 	public class Group {
 
 		private int num;
 
 		private Group next = null;
 
 		public int getNum() {
 			return num;
 		}
 
 		public void setNum(int num) {
 			this.num = num;
 		}
 
 		public Group getNext() {
 			return next;
 		}
 
 		public void setNext(Group next) {
 			this.next = next;
 		}
 
 		public void print() {
 			System.out.println(this.toString());
 		}
 
 		public Group(int num) {
 			this.num = num;
 		}
 	}
 
 	public class Roller {
 		private int totalround;
 		private int capacity;
 
 		public int getTotalround() {
 			return totalround;
 		}
 
 		public void setTotalround(int totalround) {
 			this.totalround = totalround;
 		}
 
 		public int getCapacity() {
 			return capacity;
 		}
 
 		public void setCapacity(int capacity) {
 			this.capacity = capacity;
 		}
 	}
 
 	public Qualification() {
 
 	}
 
 	public String ReadFileAndProcess(String filepath) {
 		StringBuilder sb = new StringBuilder();
 		int caseIndex = 1;
 
 		try {
 			// Open the file that is the first
 			// command line parameter
 			FileInputStream fstream = new FileInputStream(filepath);
 			// Get the object of DataInputStream
 			DataInputStream in = new DataInputStream(fstream);
 			BufferedReader br = new BufferedReader(new InputStreamReader(in));
 			String strLine;
 
 			br.readLine();// skip the first line
 
 			// Read File Line By Line
 			while ((strLine = br.readLine()) != null) {
 				CicularLinkedList cl = new CicularLinkedList();
 				Roller rl = new Roller();
 				ParseRLLine(strLine, rl);
 				strLine = br.readLine();
 				ParseCLLine(strLine, cl);
 				sb.append(Process(rl, cl, caseIndex));
 				++caseIndex;
 			}
 			// Close the input stream
 			in.close();
 		} catch (Exception e) {// Catch exception if any
 			System.err.println(""Error: "" + e.getMessage());
 		}
 
 		return sb.toString();
 	}
 
 	private String Process(Roller rl, CicularLinkedList cl, int caseindex) {
 		// TODO Auto-generated method stub
 		int total = 0;
 		int roundindex = 1;
 		Group marker = cl.header;
 		while (roundindex <= rl.totalround) {
 			int tmp = 0;
 			int count = 0;
 			while ((tmp + marker.getNum()) <= rl.capacity) {
 				++count;
 				tmp += marker.getNum();
 				marker = marker.getNext();// mark always fall 1 behind good
 				if (count == cl.size)
 					break;
 			}
 			total += tmp;
 			roundindex++;
 		}
 		return ""Case #"" + caseindex + "": "" + String.valueOf(total) + ""\n"";
 	}
 
 	private void ParseCLLine(String strLine, CicularLinkedList cl) {
 		// TODO Auto-generated method stub
 		String clArray[] = strLine.split("" "");
 		Group tmp = new Group(Integer.parseInt(clArray[0]));
 		cl.init(tmp);
 		for (int i = 1; i < clArray.length; ++i) {
 			cl.append(new Group(Integer.parseInt(clArray[i])));
 		}
 	}
 
 	private void ParseRLLine(String strLine, Roller rl) {
 		// TODO Auto-generated method stub
 		String clArray[] = strLine.split("" "");
 		rl.setTotalround(Integer.parseInt(clArray[0]));
 		rl.setCapacity(Integer.parseInt(clArray[1]));
 
 	}
 
 	static public void setContents(String filepath, String aContents)
 			throws FileNotFoundException, IOException {
 
 		File aFile = new File(filepath);
 		if (aFile == null) {
 			throw new IllegalArgumentException(""File should not be null."");
 		}
 		if (!aFile.exists()) {
 			throw new FileNotFoundException(""File does not exist: "" + aFile);
 		}
 		if (!aFile.isFile()) {
 			throw new IllegalArgumentException(""Should not be a directory: ""
 					+ aFile);
 		}
 		if (!aFile.canWrite()) {
 			throw new IllegalArgumentException(""File cannot be written: ""
 					+ aFile);
 		}
 
 		// use buffering
 		Writer output = new BufferedWriter(new FileWriter(aFile));
 		try {
 			// FileWriter always assumes default encoding is OK!
 			output.write(aContents);
 		} finally {
 			output.close();
 		}
 	}
 
 	public static void main(String[] args) {
 
 		//String filepath = ""C:\\Users\\Administrator\\Desktop\\input.txt"";
 		//String output = ""C:\\Users\\Administrator\\Desktop\\output.txt"";
 		
 		String filepath = ""/home/flash/Desktop/C-small.in"";
 		String output = ""/home/flash/Desktop/output.txt"";
 		
 		
 		Qualification q = new Qualification();
 		String out = q.ReadFileAndProcess(filepath);
 		try {
 			setContents(output, out);
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 
 }
",0
150,18352,"import static java.lang.System.*;
 import java.util.*;
 import java.io.*;
 
 
 class CodeJamRound1 {
 	public static String d(String b){
 		if(b.equals(""0"")){
 			return ""0"";
 		}
 		int x=Integer.parseInt(b);
 		int t=100;
 		for(int c=2;c<=x;c++){
 			if(x%c==0&&t%c==0){
 				t/=c;
 				x/=c;
 				c=1;
 			}
 		}
 		return Integer.toString(t);
 	}
 	public static boolean greaterThan(String a, String b){
 		if(a.length()>b.length()){
 			return true;
 		}
 		else if(a.length()<b.length()){
 			return false;
 		}
 		else{
 			for(int x=0;x<a.length();x++){
 				String s=a.substring(x,x+1);
 				String t=b.substring(x,x+1);
 				int c=Integer.parseInt(s);
 				int d=Integer.parseInt(t);
 				if(c>d){
 					return true;
 				}
 				else if(c<d){
 					return false;
 				}
 			}
 		}
 		return false;
 	}
 	public static String solve(Scanner keyb){
 		String s="""";
 		String a[]=keyb.nextLine().split("" "");
 		if(greaterThan(d(a[1]),a[0])){
 			return ""Broken"";
 		}
 		if(!a[2].equals(""100"")&&!a[2].equals(""0"")){
 			return ""Possible"";
 		}
 		else if(a[2].equals(""100"")&&a[1].equals(""100"")){
 			return ""Possible"";
 		}
 		else if(a[2].equals(""0"")&&a[1].equals(""0"")){
 			return ""Possible"";
 		}
 		
 		
 		
 		
 		
 		
 		
 		return ""Broken"";
 	}
 	
 	
 	
 	
 	
 public static void main(String[]args)throws IOException{
 	Scanner keyb=new Scanner(new File(""A-large.in""));	
 	BufferedWriter t=new BufferedWriter(new FileWriter(new File(""output.txt"")));
 	int xx=Integer.parseInt(keyb.nextLine());
 	for(int yy=1;yy<=xx;yy++){
 		System.out.printf(""Case #%d: "",yy);
 		String a=solve(keyb);
 		System.out.println(a);
 		t.write(""Case #""+yy+"": ""+a);
 		if(yy!=xx)
 		t.newLine();
 	}t.flush();
 	t.close();
 }
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 import java.util.TreeSet;
 
 public class HelloWorld {
     
     public static void main(String[] args) {
         try {
 //            BufferedReader br = new BufferedReader(new FileReader(""D:/codejam/a.txt""));
 //            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
             
             BufferedReader br = new BufferedReader(new FileReader(""D:/codejam/D-small-attempt0.in""));
             BufferedWriter bw = new BufferedWriter(new FileWriter(""D:/codejam/D-small-result.txt""));
 //            BufferedReader br = new BufferedReader(new FileReader(""D:/codejam/B-small-attempt1.in""));
 //            
 //            BufferedReader br = new BufferedReader(new FileReader(""D:/codejam/A-large.in""));
 //            BufferedWriter bw = new BufferedWriter(new FileWriter(""D:/codejam/A-large-result.txt""));
 
             String line;
 
             line = br.readLine();
             int T = Integer.parseInt(line);
             
             for (int cas = 1; cas <= T; cas++) {
                 line = br.readLine();
                 String[] strs = line.split("" "");
                 int m = Integer.parseInt(strs[0]);
                 int n = Integer.parseInt(strs[1]);
                 String[] st = new String[m];
                 for (int i = 0; i < m; i++) {
                     st[i] = br.readLine();
                 }
                 
                 int ret = 0;
                 int ret2 = 1;
                 if (n == 1) {
                     ArrayList<String> list = new ArrayList<String>();
                     for (int i = 0; i < m; i++) list.add(st[i]);
                     ret = solve(list);
                 } else {
                     int all = (int) Math.pow(n, m);
                     for (int set = 0; set < all; set++) {
                         ArrayList<ArrayList<String>> lists = new ArrayList<ArrayList<String>>();
                         for (int i = 0; i < n;i++) lists.add(new ArrayList<String>());
                         
                         int tmpSet = set;
                         for (int i = 0; i < m; i++) {
                             int index = tmpSet % n;
                             lists.get(index).add(st[i]);
                             tmpSet /= n;
                         }
                         int tmp = 0;
                         for (int i = 0; i < n; i++) {
                             tmp += solve(lists.get(i));
                         }
                         if (tmp > ret) {
                             ret = tmp;
                             ret2= 1;
                         } else if (tmp == ret) {
                             ret2++;
                         }
                     }
                 }
                 
                 bw.write(""Case #"" + cas + "": "" + ret + "" "" + ret2);
                 bw.newLine();
                 bw.flush();
             }
             
             br.close();
             bw.close();
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 
     private static int solve(ArrayList<String> list) {
         Set<String> set = new TreeSet<String>();
         for (int i = 0; i < list.size(); i++) {
             for (int j = 0; j < list.get(i).length(); j++) {
                 set.add(list.get(i).substring(0, j+1));
             }
         }
         if (set.size() == 0) return 0;
         else return set.size() + 1;
     }
 
 }
",0
151,3272,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 import java.io.*;
 import java.util.*;
 
 /**
  *
  * @author Tareq
  */
 public class magicka {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         String line;
         StringTokenizer st;
         int T,C,D,N;
         String invoke,result;
         ArrayList<String> opposers;
         try{
             BufferedReader reader = new BufferedReader(new FileReader(""B-large.in""));
             PrintWriter pw = new PrintWriter(new FileOutputStream(""magickaLarge.out""));
             T = Integer.parseInt(reader.readLine());
             for(int k=1;k<=T;k++)
             {
                 st = new StringTokenizer(reader.readLine());
                 C = Integer.parseInt(st.nextToken());
                 HashMap hm = new HashMap();
                 for(int i=0;i<C;i++)
                 {
                     String s = st.nextToken();
                     hm.put(s.substring(0, 2),s.substring(2));
                 }
 
                 D = Integer.parseInt(st.nextToken());
                 opposers = new ArrayList();
                 for(int i=0;i<D;i++)
                 {
                     opposers.add(st.nextToken());
                 }
 
                 N = Integer.parseInt(st.nextToken());
                 invoke = st.nextToken();
                 result = """";
                 for(int i=0;i<N;i++)
                 {
                     result = result+invoke.charAt(i);
                     if(result.length()>1)
                     {
                         String lastTwo = (""""+result.charAt(result.length()-2))+(result.charAt(result.length()-1)+"""");
                         String lastTwo2 = (""""+result.charAt(result.length()-1))+(result.charAt(result.length()-2)+"""");
                         if(hm.containsKey(lastTwo))
                         { 
                             result = result.replaceFirst(lastTwo, (String)hm.get(lastTwo));
                         }
                         if(hm.containsKey(lastTwo2))
                         { 
                             result = result.replaceFirst(lastTwo, (String)hm.get(lastTwo2));
                           
                         }
 
                         for(int j=0;j<opposers.size();j++)
                         {
                             String op = opposers.get(j);
                             if(result.contains(op.charAt(0)+"""") && result.contains(op.charAt(1)+""""))
                             {
                                 result = """";
                                 break;
                             }
                         }
                     }
                 }
                 System.out.print(""Case #""+k+"": ["");
                 pw.print(""Case #""+k+"": ["");
                 String tmp = """";
                 for(int j=0;j<result.length();j++)
                 {
                     tmp +=(tmp.equals("""")?"""":"", "")+result.charAt(j);
                 }
                 System.out.println(tmp+""]"");
                 pw.println(tmp+""]"");
             }
             pw.close();
         }catch(Exception e){System.out.println(""hmm""+e);}            
     }
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 import java.io.*;
 import java.util.*;
 import java.math.*;
 
 
 /**
  *
  * @author Tareq
  */
 public class FairWarning {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         String line;
         StringTokenizer st;
         int c,n;
         ArrayList<BigInteger> events;
         BigInteger y,T;
         try{
             BufferedReader reader = new BufferedReader(new FileReader(""B-small-attempt0.in""));
             PrintWriter pw = new PrintWriter(new FileOutputStream(""FairWarning1.out""));
             c = Integer.parseInt(reader.readLine());
             for(int i=1;i<=c;i++)
             {
                 st = new StringTokenizer(reader.readLine());
                 n = Integer.parseInt(st.nextToken());
                 events = new ArrayList<BigInteger>();
                 for(int j=0;j<n;j++)
                     events.add(new BigInteger(st.nextToken()));
                 Collections.sort(events);
                 T = events.get(1).subtract(events.get(0));
                 for(int j=2;j<events.size();j++)
                     T = T.gcd(events.get(j).subtract(events.get(0)));
                 if(events.get(0).mod(T).equals(BigInteger.ZERO))
                     y = BigInteger.ZERO;
                 else
                     y = T.subtract(events.get(0).mod(T));
                 
                 pw.println(""Case #""+i+"": ""+y.toString());
                 
             }
             pw.close();
             reader.close();
         }catch(Exception e){System.out.println(""hmm""+e);}            
     }
 }
",1
152,18311,"import java.util.*;
 import java.io.*;
 
 public class MagicTrick
 {
    public static void main(String[] args) throws Exception
    {
       BufferedReader inputer = new BufferedReader(new FileReader(""A-small-attempt0.in""));
       PrintWriter outputer = new PrintWriter(new BufferedWriter(new FileWriter(""MagicTrick.out"")));
       
       int T = Integer.parseInt(inputer.readLine());
       StringTokenizer st;
       for(int i = 0; i < T; i++)
       {
          int row1 = Integer.parseInt(inputer.readLine());
          int num1s[] = new int[4];
          for(int j = 1; j <= 4; j++)
          {
             String temp = inputer.readLine();
             if(j == row1)
             {
                st = new StringTokenizer(temp);
                for(int k = 0; k < 4; k++)
                   num1s[k] = Integer.parseInt(st.nextToken());
             }
          }
          
          int row2 = Integer.parseInt(inputer.readLine());
          int num2s[] = new int[4];
          for(int j = 1; j <= 4; j++)
          {
             String temp = inputer.readLine();
             if(j == row2)
             {
                st = new StringTokenizer(temp);
                for(int k = 0; k < 4; k++)
                   num2s[k] = Integer.parseInt(st.nextToken());
             }
          }
          
          int match = -1;
          int j;
          for(j = 0; j < num1s.length; j++)
          {
             int k;
             for(k = 0; k < num2s.length; k++)
             {
                if(num1s[j] == num2s[k])
                {
                   if(match == -1)
                      match = num1s[j];
                   else
                      break;
                }
             }
             
             if(k < num2s.length)
                break;
          }
          
          outputer.print(""Case #"" + (i + 1) + "": "");
          if(j < num2s.length)
             outputer.println(""Bad magician!"");
          else if(match == -1)
             outputer.println(""Volunteer cheated!"");
          else
             outputer.println(match);
       }
       
       outputer.close();
       inputer.close();
    }
 }","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 public class RopeIntranet {
 	int noOfTests;
 	int noOfRopess;
 	List<Rope> ropes;
 	long ans;
 	
 	BufferedReader in;
 	BufferedWriter out;
 	
 	public static void main(String[] args) throws Exception {
 		new RopeIntranet(args[0]);
     }
 	
 	public RopeIntranet(String fn) throws Exception {
 		in = new BufferedReader(new FileReader(fn+"".in""));
 		out = new BufferedWriter(new FileWriter(fn + "".out""));
 		readInput();
 		out.flush();
         out.close();
 	}
 	
 	public void readInput() throws Exception {
         String line = null;
         line = in.readLine();
         noOfTests = Integer.parseInt(line.trim());
         
         for(int i=0; i<noOfTests; i++) {
             line = in.readLine().trim();
             noOfRopess = Integer.parseInt(line);
             ropes = new ArrayList<Rope>(noOfRopess);
             
             for(int j=0;j<noOfRopess;j++) {
             	line = in.readLine();
             	String[] parts = line.split("" "");
             	
             	Rope temp = new Rope();
             	temp.leftHeight = Long.parseLong(parts[0].trim());
             	temp.rightHeight = Long.parseLong(parts[1].trim());
             	ropes.add(temp);
             }
             
             Collections.sort(ropes);
             ans = 0;
             for(int j=0;j<ropes.size();j++) {
             	Rope rope = ropes.get(j);
             	for(int k=j+1;k<ropes.size();k++) {
             		if( rope.rightHeight > ropes.get(k).rightHeight )
             			ans++;
             	}
             }
             
         	writeOutput(i+1);
         }
     }
 	
 	public void writeOutput(long inputNumber) throws Exception {
         String str = String.format(""Case #%s: %s\n"", inputNumber, ans);
         out.write(str);
     }
 	
 	public static class Rope implements Comparable<Rope> {
 		long leftHeight;
 		long rightHeight;
 		Set<Rope> rightBelowRopes = new HashSet<Rope>();
 		
 		public int compareTo(Rope rope) {
 			if( this.leftHeight < rope.leftHeight )
 				return -1;
 			else if (this.leftHeight == rope.leftHeight )
 				return 0;
 			else
 				return 1;
 		}
 	}
 }
",0
153,19869,"import java.util.*;
 import java.io.*;
 public class A
 {
   public static String small(String temp)
   {
     int x=0;
     while(x<temp.length()-1)
     {
       if(temp.charAt(x)==temp.charAt(x+1))
       {
         temp=temp.replaceFirst(""""+temp.charAt(x)+temp.charAt(x),temp.charAt(x)+"""");
       }
       else
         x++;
     }
     return temp;
   }
   public static int median(ArrayList<Integer> numbers)
   {
     if(numbers.size()%2==0)
     {
       return (numbers.get(numbers.size()/2-1)+numbers.get(numbers.size()/2))/2;
     }
     else
       return numbers.get(numbers.size()/2);
   }
   public static int[] breakdownString(String temp,int size)
   {
     int [] lolz=new int[size];
     int x=0;
     int y=0;
     int z=1;
     while(y<size)
     {
       if(x==temp.length()-1)
       {
         lolz[size-1]=z;
         break;
       }
       else if(temp.charAt(x)==temp.charAt(x+1))
       {
         temp=temp.replaceFirst(""""+temp.charAt(x)+temp.charAt(x),temp.charAt(x)+"""");
         z++;
       }
       else
       {
         lolz[y]=z;
         z=1;
         x++;
         y++;
       }
     }
     //output(lolz);
     return lolz;
   }
   public static int total(int size,ArrayList<int[]>numbers)
   {
     int y=0;
     for(int x=0;x<size;x++)
     {
       ArrayList<Integer>numbers2=new ArrayList<Integer>();
       for(int z=0;z<numbers.size();z++)
       {
         numbers2.add(numbers.get(z)[x]);
       }
       Collections.sort(numbers2);
       //System.out.println(numbers2);
       int median=median(numbers2);
       //System.out.println(median);
       for(int z=0;z<numbers2.size();z++)
       {
         y+=Math.abs(numbers2.get(z)-median);
       }
     }
     return y;
   }
   public static void output(int[]temp)
   {
     for(int x=0;x<temp.length;x++)
     {
       System.out.print(temp[x]+"" "");
     }
     System.out.println();
   }
   public static void main(String[]args)throws IOException
   {
     Scanner in=new Scanner(new FileReader(""A-large.in""));
     PrintWriter out=new PrintWriter(new FileWriter(""A.out""));
     int num=in.nextInt();
     for(int asd=1;asd<=num;asd++)
     {
       out.print(""Case #""+asd+"": "");
       ArrayList<int[]> strings=new ArrayList<int[]>();
       int nums=in.nextInt();
       String tempz=in.next();
       String smallest=small(tempz);
       strings.add(breakdownString(tempz,smallest.length()));
       boolean good=true;
       
       for(int x=0;x<nums-1;x++)
       {
         String temp=in.next();
         if(!small(temp).equals(smallest)&&good)
         {
           good=false;
           out.println(""Fegla Won"");
         }
         else
         {
           strings.add(breakdownString(temp,smallest.length()));
         }
         //System.out.println(temp);
         //System.out.println(small(temp));
       }
       if(good)
       {
         //System.out.println(numbers);
         out.println(total(smallest.length(),strings));
       }
     }
     in.close();
     out.close();
   }
 }","package y2010.round3.d;
 
 import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Scanner;
 
 public class D {
 	
 	Scanner in;
 	private int[] arr;	
 	
 	public D() {	
 		
 		int CASE = 1;
 		
 		String[] name = {""sample"", ""small"", ""large""};		
 		System.setIn(this.getClass().getResourceAsStream(name[CASE]+"".in""));			
 		in = new Scanner(System.in);
 				
 		
 		int _t = in.nextInt();
 		for(int _l=1;_l<=_t;_l++){
 			
 			long n = in.nextLong();
 			long t = n;
 			int b = in.nextInt();
 			
 			arr = new int[(b-1)*b/2+1];
 			//System.out.println(arr.length);
 			arr[0] = 1;
 			for(int i=1;i<arr.length;i++){
 				for(int j=arr.length-1;j>=i;j--){
 					arr[j] += arr[j-i];
 				}				
 			}
 			
 			ArrayList<Integer> list = new ArrayList<Integer>();
 			while(t!=0){
 				list.add((int)(t%b));
 				t /= b;
 			}
 			Collections.reverse(list);
 			
 			long[][] dp = new long[list.size()][b];
 			for(int i=1;i<=list.get(0);i++){
 				dp[0][i] = arr[i];
 			}
 		
 			for(int i=1;i<list.size();i++){
 				for(int j=0;j<b;j++){
 					for(int k=j;k<arr.length;k+=b){
 						if(k==0)
 							dp[i][j] = (dp[i][j]+dp[i-1][k/b]*arr[k])%1000000007;
 						else
 							dp[i][j] = (dp[i][j]+dp[i-1][k/b]*arr[k]*2)%1000000007;
 					}
 				}
 			}
 			
 			//System.out.println(dp[list.size()-1][(int)(n%b)]);
 			
 			
 			long ans = dp[list.size()-1][(int)(n%b)];
 			System.out.printf(""Case #%d: %s\n"", _l, ans);		
 		}
 		
 	}
 
 	public static void main(String[] args) {
 		new D();
 	}
 
 }
",0
154,15578,"package com.google.codejam.problemac;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 
 public class ProblemaC {
 
 	private static final String FROM_FILE_PATH = ""D:\\hobbies & work\\programing\\CodeJamTextFiles\\2013\\C-small-attempt0.in"";
 	private static final String TO_FILE_PATH = ""D:\\hobbies & work\\programing\\CodeJamTextFiles\\2013\\C-small-attempt0.out"";
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		long fromtime = System.currentTimeMillis();
 		System.out.println(""Problem C start"");
 		
 		try {
 
 			FileInputStream fstream = new FileInputStream(FROM_FILE_PATH);
 
 			DataInputStream in = new DataInputStream(fstream);
 			BufferedReader br = new BufferedReader(new InputStreamReader(in));
 			
 			FileWriter fstreamout = new FileWriter(TO_FILE_PATH);
 			BufferedWriter out = new BufferedWriter(fstreamout);
 			
 			String strLine;
 			boolean firstLine = true;
 			int i = 0;
 			
 			char [][] matrix = new char [4][4];
 			int caseIndex = 1;
 			while ((strLine = br.readLine()) != null) 
 			{
 				if (!firstLine)
 				{
 					String ans = ""Case #"" + caseIndex + "": "" + ansForLine(strLine) + ""\n"";
 					System.out.println(ans);
 					out.write(ans);
 					caseIndex++;
 				}
 				else
 				{
 					System.out.println(""Number of tests: "" + strLine);
 					firstLine = false;
 				}
 			}
 			out.close();
 			in.close();
 		} catch (Exception e) {
 			System.err.println(""Error: "" + e.getMessage());
 		}
 		
 		System.out.println(""Problem C end took: "" + (System.currentTimeMillis() - fromtime) + "" ms"");
 	}
 
 	private static long ansForLine(String strLine) {
 		long ans = 0;
 		
 		String[] splited = strLine.split("" "");
 		
 		long from = Long.parseLong(splited[0]);
 		long to = Long.parseLong(splited[1]);
 		
 		for (long i = from; i <= to; i++)
 		{
 			double sqr = Math.sqrt(i);
 			
 			if (sqr == (long) sqr && isPalindrome((long) sqr) && isPalindrome(i))
 			{
 				System.out.println(""Found: "" + i);
 
 				ans ++;
 			}
 				
 		}
 		
 		return ans;
 	}
 
 	private static boolean isPalindrome(long i) {
 		
 		boolean ans = true;
 		
 		String pal = Long.toString(i);
 		char [] palc = pal.toCharArray();
 		for (int j = 0; j < pal.length() / 2; j++)
 		{
 			if (palc[j] != palc[palc.length - j - 1])
 			{
 				ans = false;
 				break;
 			}
 		}
 		
 		return ans;
 	}
 
 
 }
","package y2011.q;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.List;
 import java.util.Scanner;
 
 import com.google.common.collect.Lists;
 
 public class BotTrust {
 
 	private static class Button {
 		char color;
 		int pos;
 		
 		@Override
 		public String toString() {
 			return String.format(""Button [color=%s, pos=%s]"", color, pos);
 		}
 	}
 	
 	
 
 	private static int solve(List<Button> buttonSequence) {
 		int posBlue = 1;
 		int posOrange = 1;
 		int stepsBlue = 0;
 		int stepsOrange = 0;
 		
 		for(Button button : buttonSequence) {
 			switch(button.color) {
 			case 'O':
 				stepsOrange += Math.abs(posOrange - button.pos);
 				stepsOrange = Math.max(stepsOrange,stepsBlue);
 				stepsOrange++;
 				posOrange = button.pos;
 				break;
 			case 'B':
 				stepsBlue += Math.abs(posBlue - button.pos);
 				stepsBlue = Math.max(stepsBlue,stepsOrange);
 				stepsBlue++;
 				posBlue = button.pos;
 				break;
 			}
 		}
 
 		
 		return Math.max(stepsOrange,stepsBlue);
 	}
 	
 	
 	
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new File(""A-large.in""),""ASCII"");
 		
 		BufferedWriter writer = new BufferedWriter(new FileWriter(""A-large.out""));
 		
 		int t = sc.nextInt();
 		List<Button> buttonSequence = Lists.newArrayListWithCapacity(t);
 		for(int i=0;i<t;i++) {
 			buttonSequence.clear();
 			int n = sc.nextInt();
 			for(int j=0;j<n;j++) {
 				Button button = new Button();
 				button.color = sc.next().trim().charAt(0);
 				button.pos = sc.nextInt();
 				buttonSequence.add(button);
 			}
 			int s = solve(buttonSequence);
 			String result = String.format(""Case #%d: %d"",i+1,s);
 			writer.write(result+""\n"");
 			System.out.println(result);
 		}
 		writer.flush();
 		writer.close();
 		
 	}
 
 	
 }
",0
155,2210,"import java.util.*;
 
 public class FairAndSquare {
 
     private static final NavigableSet<Integer> palindromes = new TreeSet<Integer>();
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         int num = scanner.nextInt();
         initialize();
         for (int i = 1; i < num + 1; i++) {
             long a = scanner.nextLong();
             long b = scanner.nextLong();
             System.out.println(""Case #"" + i + "": "" + count(a, b));
         }
 //        System.out.println(palindromes);
     }
 
     private static int count(long a, long b) {
         int count = 0;
         for (int i : palindromes.subSet((int) Math.sqrt(a), true, (int) Math.sqrt(b), true)) {
             long num = i * i;
             if (isPalindrome(num) && num >= a && num <= b)
                 count++;
         }
         return count;
     }
 
     private static boolean isPalindrome(long num) {
         if (num < 10)
             return true;
         String string = String.valueOf(num);
         int length = string.length();
         for (int i = 0; i < length / 2; i++) {
             if (string.charAt(i) != string.charAt(length - i - 1))
                 return false;
         }
         return true;
     }
 
     private static void initialize() {
         // we shall aim for first large dataset
         for (int i = 1; i < 10; i++)
             palindromes.add(i);
         for (int i = 11; i < 100; i+=11)
             palindromes.add(i);
         for (int i = 1; i < 6; i++) { // 9,999,999 -- 5 digits in between
             int start = (int) Math.pow(10, i - 1);
             int end = start * 10;
             int multiplier = (int) Math.pow(10, i + 1);
             Set<Integer> copy = new TreeSet<Integer>(palindromes.subSet(start, end));
             for (int num : copy) {
                 for (int j = 1; j < 10; j++)
                     palindromes.add(j * multiplier + num * 10 + j);
             }
             // special case -- 0
             for (int j = 1; j < 10; j++)
                 palindromes.add(j * multiplier + j);
         }
     }
 }
","package question;
 
 import java.util.HashMap;
 
 import utils.FileTools;
 
 public class Qualification2013A1 {
 	public static void main(String[] args) {
 		try {
 			FileTools ft = new FileTools(""A-small-attempt1.in"");
 			int T = Integer.parseInt(ft.in.readLine());
 			String line;
 			int l = 0;
 
 			for (int i = 0; i < T; i++) {
 				boolean b[] = { true, true, true, true, true, true, true, true,
 						true, true, true };
 				int c[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
 				int t[][] = { { -1, -1, -1, -1 }, { -1, -1, -1, -1 },
 						{ -1, -1, -1, -1 }, { -1, -1, -1, -1 } };
 				for (int j = 0; j < 4; j++) {
 					line = ft.in.readLine();
 					String[] p = line.split("""");
 					for (int k = 0; k < 4; k++) {
 						if (p[k + 1].equals(""X"")) {
 							t[j][k] = 1;
 						} else if (p[k + 1].equals(""T"")) {
 							t[j][k] = 0;
 						} else if (p[k + 1].equals(""O"")) {
 							t[j][k] = 2;
 						} else
 							b[10] = false;// 
 
 						if (c[k] == -1 || c[k] == 0) {
 							c[k] = t[j][k];
 						}
 						if (c[4 + j] == -1 || c[4 + j] == 0) {
 							c[4 + j] = t[j][k];
 						}
 						if (k == j) {
 							if (c[8] == -1 || c[8] == 0)
 								c[8] = t[j][k];
 						}
 						if (k + j == 3) {
 							if (c[9] == -1 || c[9] == 0)
 								c[9] = t[j][k];
 						}
 						// 
 						if (b[k]
 								&& (c[k] != 0 && t[j][k] != 0 && c[k] != t[j][k])
 								|| c[k] < 0) {
 							b[k] = false;
 						}
 						// б
 						if (k == j) {
 							if (b[8]
 									&& (c[8] != 0 && t[j][k] != 0 && c[8] != t[j][k])
 									|| c[8] < 0) {
 								b[8] = false;
 							}
 						}
 						if (k + j == 3) {
 							if (b[9]
 									&& (c[9] != 0 && t[j][k] != 0 && c[9] != t[j][k])
 									|| c[9] < 0) {
 								b[9] = false;
 							}
 						}
 						if (b[4 + j]
 								&& (c[4 + j] != 0 && t[j][k] != 0 && c[4 + j] != t[j][k])
 								|| c[4 + j] < 0) {
 							b[4 + j] = false;
 						}
 					}
 				}
 				String res = """";
 				for (int m = 0; m < 11; m++) {
 					if (b[m]) {
 						if (m < 10) {
 							if (c[m] == 1) {
 								res = (""X won"");
 							}
 							if (c[m] == 2) {
 								res = (""O won"");
 							}
 						} else if (m == 10) {
 							res = ""Draw"";
 						}
 						break;
 					}
 				}
 				if (res == """") {
 					res = ""Game has not completed"";
 				}
 				ft.out.write(""Case #"" + (i + 1) + "": "" + res);
 
 				System.out.println(""Case #"" + (i + 1) + "": "" + res);
 				ft.out.newLine();
 				ft.in.readLine();
 			}
 
 			ft.out.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 }",0
156,13979,"package gcj.TwelveThirteen.oneA;
 
 import java.io.BufferedReader;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 
 public class Bullseye {
 	
 	
 	public static void main(String [] args){
 		try{
 		  FileInputStream fstream = new FileInputStream(""res/A-small-attempt1.in"");
 		  DataInputStream in = new DataInputStream(fstream);
 		  BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		  String strLine;
 		  strLine = br.readLine();
 		  int T = Integer.valueOf(strLine);
 		  //System.out.println(""T: ""+T);
 		  int i=1;
 		  while ((strLine = br.readLine()) != null)   {
 //		  System.out.println (strLine);
 			  String [] str = strLine.split("" "");
 //			  double r = Double.valueOf(str[0].trim() );
 //			  double t = Double.valueOf(str[1].trim() );
 			  
 			  long r = Long.valueOf(str[0].trim() );
 			  long t = Long.valueOf(str[1].trim() );
 			  
 			  
 			  long count= getBlackRingCount(r,t);
 			  System.out.println (""Case #""+i++ +"": ""+count);
 		  }
 		  in.close();
 		}catch (Exception e){//Catch exception if any
 			  System.err.println(""Error: "" + e.getMessage());
 			  e.printStackTrace();
 		}
 	} //end of main
 	
 	
 	public static long getBlackRingCount(long r, long t){
 		long count =0;
 		long req=0;
 		for(long i=0;t>=0;i++){
 			req=2*r + 4*i + 1;
 			t=t-req;
 			count=i;
 		}
 		//System.out.print(""t: ""+t+"" ""+req);
 		
 		return count;
 	}
 	
 	
 
 }
","import java.util.Arrays;
 import java.util.Scanner;
 
 public class Lawnmower {
   public static void main(String[] args) {
     Scanner sc = new Scanner(System.in);
     int T = sc.nextInt();
     for (int t = 1; t <= T; ++t) {
       int N = sc.nextInt(), M = sc.nextInt();
       int[][] lawn = new int[N][M];
       for (int r = 0; r < N; ++r)
         for (int c = 0; c < M; ++c)
           lawn[r][c] = sc.nextInt();
       System.out.printf(""Case #%d: %s\n"", t, possible(lawn) ? ""YES"" : ""NO"");
     }
   }
 
   private static boolean possible(int[][] target) {
     int[][] lawn = new int[target.length][target[0].length];
     for (int[] row : lawn)
       Arrays.fill(row, 100);
 
     for (int r = 0; r < target.length; ++r) {
       int targetMax = 0;
       for (int c = 0; c < target[r].length; ++c)
         targetMax = Math.max(targetMax, target[r][c]);
       for (int c = 0; c < target[r].length; ++c)
         lawn[r][c] = Math.min(lawn[r][c], targetMax);
     }
 
     for (int c = 0; c < target[0].length; ++c) {
       int targetMax = 0;
       for (int r = 0; r < target.length; ++r)
         targetMax = Math.max(targetMax, target[r][c]);
       for (int r = 0; r < target.length; ++r)
         lawn[r][c] = Math.min(lawn[r][c], targetMax);
     }
 
     return Arrays.deepEquals(lawn, target);
   }
 }
",0
157,268,"import java.io.FileInputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Main {
 
     static final String EXAMPLE_INPUT = ""example.txt"";
     static final String SMALL_INPUT = ""A-small-attempt0.in"";
     static final String LARGE_INPUT = ""A-large.in"";
     static final String OUTPUT = ""output.txt"";
 
     public static void main(String[] args) throws Exception {
         startProcessing();
     }
 
     static void startProcessing() throws Exception {
         try(FileInputStream stream = new FileInputStream(SMALL_INPUT);
             Scanner scanner = new Scanner(stream);
             PrintWriter writer = new PrintWriter(OUTPUT))
         {
             int T = Integer.valueOf(scanner.nextLine());
             for (int caseNum = 1; caseNum <= T; ++caseNum) {
                 long caseRes = solveCase(scanner);
                 writer.println(""Case #"" + caseNum + "": "" + caseRes);
             }
         }
     }
 
     static long solveCase(Scanner scanner) {
         String line = scanner.nextLine();
         String[] parts = line.split("" "");
         String name = parts[0];
         int n = Integer.valueOf(parts[1]);
 
         int nameLen = name.length();
         long counter = 0;
         for (int subLen = nameLen; subLen >= n; --subLen) {
             long levels = 0;
             for (int begin = 0; begin <= (nameLen - subLen); ++begin) {
                 int res = containsN(name, n, begin, subLen);
                 counter += res;
                 levels += res;
             }
             if (levels == 0) {
                 break;
             }
         }
         return counter;
     }
 
     static int containsN(String name, int n, int begin, int subLen) {
         int cons = 0;
         String vovels = ""aeiou"";
         for (int index = begin; index < (begin + subLen); ++index) {
             String aChar = name.substring(index, index + 1);
             if (vovels.contains(aChar)) {
                 cons = 0;
             } else {
                 cons += 1;
             }
             if (cons >= n) {
                 return 1;
             }
         }
         return 0;
     }
 }
","package recyclednumbers.util;
 
 import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 
 public class IOUtil {
 
     public static List<String> readLines(String filename) {
 
         List<String> lines = new ArrayList<String>();
 
         try {
 
             InputStream is = IOUtil.class.getResourceAsStream(""/META-INF/"" + filename);
 
             BufferedReader br = new BufferedReader(new InputStreamReader(is));
             String line = null;
             while ((line = br.readLine()) != null) {
                 lines.add(line);
             }
 
             br.close();
             is.close();
 
             return lines;
 
         } catch (Exception e) {
             e.printStackTrace();
             return null;
         }
 
     }
 
     public static void writeLines(String filename, List<String> lines) {
 
         try {
 
             File file = new File(""src/META-INF/"" + filename);
 
             FileWriter fileWriter = new FileWriter(file);
 
             for (int i = 0; i < lines.size(); i++) {
                 fileWriter.write(""Case #"" + (i + 1) + "": "" + lines.get(i) + ""\n"");
             }
 
             fileWriter.close();
 
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 }",0
158,10810,"package round1c;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Arrays;
 import java.util.Scanner;
 
 //import static java.lang.Math.*;
 
 public class A {
 	// public final static String inputFile = ""input.in"";
 	public final static String inputFile = ""A-large.in"";
 	public final static String outputFile = ""output.out"";
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new FileInputStream(inputFile));
 		PrintStream out = new PrintStream(outputFile);
 
 		int numCases = in.nextInt();
 		for (int caseNum = 1; caseNum <= numCases; caseNum++) {
 			int r = in.nextInt();
 			int c = in.nextInt();
 			char[][] tiles = new char[r][c];
 			for (int ir = 0; ir < r; ir++) {
 				String line = in.next();
 				for (int ic = 0; ic < c; ic++) {
 					char v = line.charAt(ic);
 					if (v == '#') {
 						if (ir == 0 && ic == 0) {
 							tiles[ir][ic] = 'q';
 						} else if (ir == 0) {
 							if (tiles[ir][ic - 1] == 'q') {
 								tiles[ir][ic] = 'w';
 							} else {
 								tiles[ir][ic] = 'q';
 							}
 						} else if (ic == 0) {
 							if (tiles[ir - 1][ic] == 'q') {
 								tiles[ir][ic] = 'a';
 							} else {
 								tiles[ir][ic] = 'q';
 							}
 						} else if (tiles[ir][ic - 1] == 'q') {
 							tiles[ir][ic] = 'w';
 						} else if (tiles[ir][ic - 1] == 'a') {
 							tiles[ir][ic] = 's';
 						} else if (tiles[ir - 1][ic] == 'q') {
 							tiles[ir][ic] = 'a';
 						} else if (tiles[ir - 1][ic] == 'w') {
 							tiles[ir][ic] = 's';
 						} else if (tiles[ir][ic - 1] == 'w') {
 							tiles[ir][ic] = 'q';
 						} else if (tiles[ir][ic - 1] == 's') {
 							if (tiles[ir - 1][ic] == '.' || tiles[ir][ic-1] == 's'){
 								tiles[ir][ic] = 'q';
 							} else if (tiles[ir - 1][ic] == 'q') {
 								tiles[ir][ic] = 's';
 							} else {
 								tiles[ir][ic] = v;
 							}
 						} else if (tiles[ir - 1][ic] == 'a') {
 							if (tiles[ir][ic - 1] == '.') {
 								tiles[ir][ic] = 'q';
 							} else {
 								tiles[ir][ic] = 'w';
 							}
 						} else if (tiles[ir - 1][ic] == 's') {
 							if (tiles[ir][ic - 1] == '.') {
 								tiles[ir][ic] = 'q';
 							} else {
 								tiles[ir][ic] = 'w';
 							}
 						} else if (tiles[ir][ic - 1] == '.' && tiles[ir - 1][ic - 1] == '.') {
 							tiles[ir][ic] = 'q';
 						} else {
 							tiles[ir][ic] = v;
 						}
 					} else {
 						tiles[ir][ic] = v;
 					}
 				}
 			}
 			boolean possible = true;
 			System.out.println(caseNum);
 			for (int ir = 0; ir < r; ir++) {
 				System.out.println(Arrays.toString(tiles[ir]));
 				for (int ic = 0; ic < c; ic++) {
 					if (tiles[ir][ic] == 'q') {
 						if (ir == r - 1 || ic == c - 1) {
 							possible = false;
 							break;
 						} else if (tiles[ir][ic + 1] != 'w') {
 							possible = false;
 							break;
 						} else if (tiles[ir + 1][ic] != 'a') {
 							possible = false;
 							break;
 						} else if (tiles[ir + 1][ic + 1] != 's') {
 							possible = false;
 							break;
 						}
 					}
 				}
 			}
 			out.print(""Case #"" + caseNum + "": "");
 			if (possible) {
 				for (int ir = 0; ir < r; ir++) {
 					out.println();
 					for (int ic = 0; ic < c; ic++) {
 						if (tiles[ir][ic] == 'q' || tiles[ir][ic] == 's') {
 							out.print('/');
 						} else if (tiles[ir][ic] == 'w' || tiles[ir][ic] == 'a') {
 							out.print('\\');
 						} else {
 							out.print('.');
 						}
 					}
 				}
 				out.println();
 			} else {
 				out.println();
 				out.println(""Impossible"");
 			}
 		}
 		out.close();
 	}
 }
","package magicka;
 
 import input.InputParse;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Stack;
 import java.util.TreeSet;
 
 public class ElementList {
 
 	ArrayList<String> baseElements = new ArrayList<String>();
 	HashMap<String, String> combinations = new HashMap<String, String>();
 	HashMap<String, TreeSet<String>> oppositions = new HashMap<String, TreeSet<String>>();
 	Stack<String> result = new Stack<String>();
 
 	void addCombination(String c) {
 		String e1 = c.charAt(0) + """";
 		String e2 = c.charAt(1) + """";
 		String result = c.charAt(2) + """";
 		combinations.put(e1 + e2, result);
 		combinations.put(e2 + e1, result);
 	}
 
 	String getCombination(String c1, String c2) {
 		return combinations.get(c1 + c2);
 	}
 
 	void addOpposition(String o) {
 		String e1 = o.charAt(0) + """";
 		String e2 = o.charAt(1) + """";
 
 		if (!oppositions.containsKey(e1)) {
 			oppositions.put(e1, new TreeSet<String>());
 		}
 		oppositions.get(e1).add(e2);
 
 		if (!oppositions.containsKey(e2)) {
 			oppositions.put(e2, new TreeSet<String>());
 		}
 		oppositions.get(e2).add(e1);
 	}
 
 	boolean containsOpposition(String e) {
 		if (oppositions.containsKey(e)) {
 			for (String opp : oppositions.get(e)) {
 				if (result.contains(opp)) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	void invoke(String e) {
 		if(result.empty()){
 			result.push(e);
 			return;
 		}
 		
 		String c = getCombination(result.peek(), e);
 		if (c != null) {
 			result.pop();
 			result.push(c);
 			return;
 		}
 
 		if (containsOpposition(e)) {
 			result = new Stack<String>();
 			return;
 		}
 
 		result.push(e);
 	}
 
 	/**
 	 * @param args
 	 * @throws IOException
 	 */
 	public static void main(String[] args) throws IOException {
 		BufferedReader br = null;
 		try {
 			br = new BufferedReader(new FileReader(""B-large.in""));
 		} catch (FileNotFoundException e) {
 			// wrong file name
 			e.printStackTrace();
 			return;
 		}
 		String line1 = br.readLine().trim();
 		int numCases = Integer.parseInt(line1);
 		ArrayList<String> input = InputParse.fileToArrayList(br);
 
 		for (int caseNum = 1; caseNum <= numCases; caseNum++) {
 			ElementList elementList = new ElementList();
 			LinkedList<String> tokens = InputParse.splitLine(input.remove(0));
 
 			int numCombinations = Integer.parseInt(tokens.remove());
 			for (int i = 0; i < numCombinations; i++) {
 				elementList.addCombination(tokens.remove());
 			}
 
 			int numOppositions = Integer.parseInt(tokens.remove());
 			for (int i = 0; i < numOppositions; i++) {
 				elementList.addOpposition(tokens.remove());
 			}
 
 			int numInvokes = Integer.parseInt(tokens.remove());
 			String invokes = tokens.remove();
 			for (int i = 0; i < numInvokes; i++) {
 				elementList.invoke(invokes.charAt(i) + """");
 			}
 
 			System.out.println(""Case #"" + caseNum + "": "" + elementList.result);
 		}
 	}
 }
",1
159,18765,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class CookieClicker {
 
 	static int caseNum = 1;
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		File file = new File(""C:\\Users\\Tim Snyder\\Downloads\\B-large.in"");
 		Scanner scan = new Scanner(file);
 		int iterrations = scan.nextInt();
 		for(int i = 0;i<iterrations;i++){
 			click(scan.nextDouble(), scan.nextDouble(), scan.nextDouble());
 			caseNum++;
 		}
 	}
 	
 	private static void click(double cost, double rate,
 			double win) {
 
 		double genRate = 2.0;
 		double seconds = 0.0;
 		while(win/genRate>win/(genRate+rate)+cost/genRate){
 			seconds+= cost/genRate;
 			genRate+=rate;
 		}
 		seconds+=win/genRate;
 		System.out.println(""Case #""+caseNum+"": ""+seconds);
 	}
 
 }
","package qualificationround;
 
 import java.io.*;
 import java.util.*;
  
 
 public class A {
 
 	private class Robot {
 		//Robot state from {1....100} move, stay, push 
 		//holds position in [2, n] massive, first column for orange, next for blue
 		int currentbutton = 1; 
 		int nextbutton;
 		
 		private void findFirstNextButton(Integer [] hallway, int countOfSteps) {
 			currentbutton = 1;
 			findNextButton(hallway, countOfSteps, 0);
 		}
 		
 		private void findNextButton(Integer [] hallway, int countOfSteps, int fromStep) {
 			for ( ; fromStep < countOfSteps; fromStep++) {
 				if (hallway[fromStep] != null) {
 					nextbutton = hallway[fromStep];
 					break;
 				} else {
 					nextbutton = -1;
 				}
 			}
 		}
 	}
 
 	Robot orangeRobot = new Robot(); 
 	Robot blueRobot = new Robot(); 
 
 	private void run() {
 		
 		try {
 			BufferedReader in = new BufferedReader(new FileReader(new File(""A-small-attempt0.in"")));
 			PrintWriter out = new PrintWriter(new File(""A.txt"")); 
 		
 			int lineNumber = Integer.parseInt(in.readLine().trim()); 
 			
 			for (int lineCount = 0; lineCount < lineNumber; lineCount++) {
 				int timer = 0;
 				
 				StringTokenizer st = new StringTokenizer(in.readLine().trim()); 
 				
 				int countOfSteps = Integer.parseInt(st.nextToken()); 
 		
 				Integer [] orangeHallway = new Integer[countOfSteps];
 				Integer [] blueHallway = new Integer[countOfSteps]; 
 				
 				//fill the hallways
 				for (int i = 0; i < countOfSteps; i++) {
 					if (st.nextToken().toLowerCase().equals(""o"")) {
 						orangeHallway[i] = Integer.parseInt(st.nextToken());
 					} else {
 						blueHallway[i] = Integer.parseInt(st.nextToken());
 					}
 				}
 				
 				//find first nextbutton for orangeHallway
 				orangeRobot.findFirstNextButton(orangeHallway, countOfSteps);
 				blueRobot.findFirstNextButton(blueHallway, countOfSteps);
 				
 				for (int i = 0; i < countOfSteps; ) {
 					if (orangeHallway[i] != null) { //orange step
 						if (orangeRobot.nextbutton != -1) {
 							if (orangeRobot.currentbutton == orangeRobot.nextbutton) { //push
 								orangeRobot.findNextButton(orangeHallway, countOfSteps, i+1);
 								i++; //take next step
 							} else if (orangeRobot.currentbutton < orangeRobot.nextbutton) { //move
 								orangeRobot.currentbutton++;	
 							} else if (orangeRobot.currentbutton > orangeRobot.nextbutton) { //move
 								orangeRobot.currentbutton--;
 							}		
 						} //else stay
 						if (blueRobot.nextbutton != -1) {
 							if (blueRobot.currentbutton < blueRobot.nextbutton) { //move
 								blueRobot.currentbutton++;	
 							} else if (blueRobot.currentbutton > blueRobot.nextbutton) { //move
 								blueRobot.currentbutton--;
 							} //else stay
 						} //else stay
 					} else { //blue step, can move, stay or push
 						if (blueRobot.nextbutton != -1) {
 							if (blueRobot.currentbutton == blueRobot.nextbutton) { //push
 								blueRobot.findNextButton(blueHallway, countOfSteps, i+1); 
 								i++; //take next step
 							} else if (blueRobot.currentbutton < blueRobot.nextbutton) { //move
 								blueRobot.currentbutton++;	
 							} else if (blueRobot.currentbutton > blueRobot.nextbutton) { //move
 								blueRobot.currentbutton--;
 							}		
 						} //else stay
 						if (orangeRobot.nextbutton != -1) {
 							if (orangeRobot.currentbutton < orangeRobot.nextbutton) { //move
 								orangeRobot.currentbutton++;	
 							} else if (orangeRobot.currentbutton > orangeRobot.nextbutton) { //move
 								orangeRobot.currentbutton--;
 							} //else stay
 						} //else stay
 					}
 					timer++;
 				}
 				out.println(""Case #"" + (lineCount+1) + "": "" + timer);
 			}
 		out.close();
 		
 		} catch (Exception e) {
 			e.printStackTrace();
 		} 
 	}
 	
 	public static void main(String[] args) {
 		new A().run();
 	}
 	
 } ",0
160,6713,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Scanner;
 
 public class ProblemD {
     private static final String INPUT_FILENAME = ""D-small-attempt0.in"";
     private static final String OUTPUT_FILENAME = ""D-small-attempt0.out"";
 
 	public static void main(String[] args) throws Exception {
 		Scanner input = new Scanner(new FileReader(INPUT_FILENAME));
         PrintWriter output = new PrintWriter(new FileWriter(OUTPUT_FILENAME));
             
         int numberOfTestCase = input.nextInt();
         for (int caseNum=1; caseNum<=numberOfTestCase; caseNum++) {
         	int M = input.nextInt();
         	int N = input.nextInt();
         	String[] S = new String[M];
         	ArrayList<?>[] nodes = new ArrayList<?>[M];
         	for (int i=0; i<M; i++) {
         		S[i] = input.next();
         		ArrayList<String> subsets = new ArrayList<String>();
         		for (int j=0; j<S[i].length()+1; j++) {
         			subsets.add(S[i].substring(0, j));
         		}
         		nodes[i] = subsets;
         	}
         	
         	HashSet<?>[] servers = new HashSet<?>[N];
         	for (int i=0; i<N; i++) {
         		servers[i] = new HashSet<String>();
         	}
 
         	int worst = -1;
         	int c = 0;
         	int s, sIdx, sum;
         	HashSet<String> sv;
         	int lim = (int) Math.pow(N, M);
         	for (int i=0; i<lim; i++) {
         		for (int j=0; j<N; j++) {
             		servers[j].clear();
             	}
         		
         		s = i;
         		for (int j=0; j<M; j++) {
         			 sIdx = s % N;
         			 s = s / N;
         			 sv = (HashSet<String>) servers[sIdx];
         			 for(Object node : nodes[j]) {
         				 sv.add((String) node);
         			 }
         		}
 
         		sum = 0;
         		for (int j=0; j<N; j++) {
             		sum += servers[j].size();
             	}
         		
         		if (sum > worst) {
         			worst = sum;
         			c = 1;
         		} else if (sum == worst) {
         			c++;
         		}
         	}
 
         	output.format(""Case #%d: %d %d\n"", caseNum, worst, c);
         }
         
         input.close();
         output.close();
 	}
 }
","package jam10;
 import java.io.*;
 import java.util.*;
 
 // Marian G Olteanu
 public class R2_C
 {
 	public static void main(String[] args)
 	throws Exception
 	{
 		BufferedReader inputFile = new BufferedReader(new InputStreamReader(new FileInputStream(args[0])));
 		int cases = Integer.parseInt(inputFile.readLine());
 		
 		PrintStream outFile = new PrintStream(new FileOutputStream(args[1]));
 		for (int caseNo = 1; caseNo <= cases; caseNo++)
 		{
 			int r = Integer.parseInt(inputFile.readLine());
 			
 			boolean[][] used = new boolean[101][101];
 			
 			for (int i = 0; i < r; i++)
 			{
 				String[] t = tokenize(inputFile.readLine());
 				
 				fill(used , Integer.parseInt(t[0]) , Integer.parseInt(t[1]) , Integer.parseInt(t[2]) , Integer.parseInt(t[3]));
 			}
 			
 			int iter = 0;
 			while (!empty(used))
 			{
 				iter++;
 				second(used);
 			}
 			
 			
 			outFile.println(""Case #"" + caseNo + "": "" + iter);
 		}
 		
 		
 		outFile.close();
 		inputFile.close();
 	}
 	
 	private static boolean empty(boolean[][] used)
 	{
 		for (int i = 0; i < used.length; i++)
 			for (int j = 0; j < used[i].length; j++)
 				if (used[i][j])
 					return false;
 		return true;
 	}
 	
 	private static void second(boolean[][] used)
 	{
 		for (int i = used.length - 1; i > 0 ; i--)
 			for (int j = used[i].length - 1; j > 0 ;j--)
 			{
 				if (used[i - 1][j] && used[i][j - 1])
 					used[i][j] = true;
 				if (!used[i - 1][j] && !used[i][j - 1])
 					used[i][j] = false;
 			}
 	}
 	
 	private static void fill(boolean[][] used, int x1, int y1, int x2, int y2)
 	{
 		//x1--;x2--;y1--;y2--;
 		for (int i = x1; i <= x2; i++)
 			for (int j = y1; j <= y2; j++)
 				used[i][j] = true;
 	}
 	
 	
 	public static String[] tokenize(String input)
 	{
 		StringTokenizer st = new StringTokenizer(input);
 		String[] k = new String[st.countTokens()];
 		for (int i = 0; i < k.length; i++)
 			k[i] = st.nextToken();
 		return k;
 	}
 	public static String[] tokenize(String input, String sep)
 	{
 		StringTokenizer st = new StringTokenizer(input , sep);
 		String[] k = new String[st.countTokens()];
 		for (int i = 0; i < k.length; i++)
 			k[i] = st.nextToken();
 		return k;
 	}
 }
",0
161,17469,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.util.Scanner;
 
 
 public class themepark {
 	public static void main(String[] args) {
 		
 		if(args.length < 2) throw new IllegalArgumentException(""Give me more arguments!"");
 		
 		Scanner scanner = null;
 		try {
 			scanner = new Scanner(new File(args[0]));
 		} catch (FileNotFoundException e1) {
 			throw new IllegalArgumentException(""Bad file for input!"");
 		}
 		
 		BufferedWriter writer;
 		
 		try {
 			writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(args[1]))));
 		} catch (FileNotFoundException e) {
 			throw new IllegalArgumentException(""Bad file for output!"");
 		}
 		
 		int test_num = scanner.nextInt();
 		
 		int R, k, N;
 		int queue[];
 		
 		for(int i = 0; i < test_num; i++) {
 			R = scanner.nextInt();
 			k = scanner.nextInt();
 			N = scanner.nextInt();
 			
 			queue = new int[N];
 			
 			for(int j = 0; j < N; j++) {
 				queue[j] = scanner.nextInt();				
 			}
 			
 			int summ = 0;
 			int ntimes = 0;
 			
 			int firstGroupToBoard = 0;
 			int groupsSize = queue[0];
 			
 			int ost = 0;
 			int j = 1;
 			while(true) {
 				for(; j < N; j++) {
 					if(ost+groupsSize+queue[j] <= k && j != firstGroupToBoard) {
 						groupsSize += queue[j];
 					} else {
 						ntimes++;
 						summ += groupsSize+ost;
 						groupsSize = queue[j];
 						if(ntimes == R) break;
 						ost = 0;
 						firstGroupToBoard = j%N;
 						//if(ntimes == R) break;
 					}
 				}
 				
 				j = 0;
 				
 				if(groupsSize != 0) {
 					ost = groupsSize;
 					groupsSize = 0;
 				}
 				if(ntimes == R) break;
 			}
 			
 			try {
 				writer.write(""Case #""+(i+1)+"": ""+summ+""\n"");
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 
 		}
 		
 		try {
 			writer.flush();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 }
","package com.yaji.bottrust;
 
 import java.util.ArrayList;
 
 import com.yaji.util.Util;
 
 public class BotTrust {
 
     // public static final String FILENAME_IN = ""C:\\java\\BotTrust\\A-small-attempt0.in"";
     // public static final String FILENAME_OUT = ""C:\\java\\BotTrust\\A-small-attempt0.out"";
     public static final String FILENAME_IN = ""C:\\java\\BotTrust\\A-large.in"";
     public static final String FILENAME_OUT = ""C:\\java\\BotTrust\\A-large.out"";
 
     public static final String ORANGE = ""O"";
     public static final String BLUE = ""B"";
 
     public static void main(String[] args) {
         java.util.List<String> answerList = new ArrayList<String>();
 
         java.util.List<String> inList = Util.file2StringList(FILENAME_IN);
         int numOfCases = Integer.parseInt(inList.get(0));
 
         for (int i = 1; i <= numOfCases; i++) {
             String[] chars = inList.get(i).split("" "");
             int numOfButtons = Integer.parseInt(chars[0]);
             String[] robotList = new String[numOfButtons];
             int[] posList = new int[numOfButtons];
             for (int j = 0; j < numOfButtons; j++) {
                 robotList[j] = chars[2 * j + 1];
                 posList[j] = Integer.parseInt(chars[2 * j + 2]);
             }
 
             System.out.println(""Case #"" + i + "" Started."");
             
             int time = 1;
             int oPos = 1;
             int bPos = 1;
             int btIndex = 0;
             while (true) {
                 String targetRobot = robotList[btIndex];
 
                 // If current target is ORANGE.
                 if (targetRobot.equals(ORANGE)) {
                     // Orange
                     if (oPos == posList[btIndex]) {
                         System.out.println(""Time: "" + time + "",  ORANGE: Push button "" + oPos);
                         btIndex++;
                     }
                     else if (oPos < posList[btIndex]){
                         oPos++;
                         System.out.println(""Time: "" + time + "",  ORANGE: Move to "" + oPos);
                     }
                     else if (oPos > posList[btIndex]){
                         oPos--;
                         System.out.println(""Time: "" + time + "",  ORANGE: Move to "" + oPos);
                     }
                     
                     // Blue
                     int nextBlueBtTarget = 0;
                     for (int m = btIndex; m < numOfButtons; m++) {
                         if (robotList[m].equals(BLUE)) {
                             nextBlueBtTarget = posList[m];
                             break;
                         }
                     }
                     
                     if (nextBlueBtTarget == 0) {
                         System.out.println(""  Time: "" + time + "",  BLUE: Stay at button "" + bPos);
                     }
                     else if (bPos < nextBlueBtTarget) {
                         bPos++;
                         System.out.println(""  Time: "" + time + "",  BLUE: Move to "" + bPos);
                     }
                     else if (bPos > nextBlueBtTarget) {
                         bPos--;
                         System.out.println(""  Time: "" + time + "",  BLUE: Move to "" + bPos);
                     }
                     else if (bPos == nextBlueBtTarget) {
                         System.out.println(""  Time: "" + time + "",  BLUE: Stay at button "" + bPos);
                     }
                 }
                 else { // Current target is BLUE.
                     // Blue
                     if (bPos == posList[btIndex]) {
                         System.out.println(""Time: "" + time + "",  BLUE: Push button "" + bPos);
                         btIndex++;
                     }
                     else if (bPos < posList[btIndex]) {
                         bPos++;
                         System.out.println(""Time: "" + time + "",  BLUE: Move to "" + bPos);
                     }
                     else if (bPos > posList[btIndex]) {
                         bPos--;
                         System.out.println(""Time: "" + time + "",  BLUE: Move to "" + bPos);
                     }
                     
                     // Orange
                     int nextOrangeBtTarget = 0;
                     for (int m = btIndex; m < numOfButtons; m++) {
                         if (robotList[m].equals(ORANGE)) {
                             nextOrangeBtTarget = posList[m];
                             break;
                         }
                     }
                     
                     if (nextOrangeBtTarget == 0) {
                         System.out.println(""  Time: "" + time + "",  ORANGE: Stay at button "" + oPos);
                     }
                     else if (oPos < nextOrangeBtTarget) {
                         oPos++;
                         System.out.println(""  Time: "" + time + "",  ORANGE: Move to "" + oPos);
                     }
                     else if (oPos > nextOrangeBtTarget) {
                         oPos--;
                         System.out.println(""  Time: "" + time + "",  ORANGE: Move to "" + oPos);
                     }
                     else if (bPos == nextOrangeBtTarget) {
                         System.out.println(""  Time: "" + time + "",  ORANGE: Stay at button "" + oPos);
                     }
                 }
                 
                 // Finish?
                 if (btIndex == numOfButtons) {
                     System.out.println(""Case #"" + i + "" Finished, time:"" + time);
                     answerList.add(""Case #"" + i + "": "" + time);
                     break;
                 }
                 else {
                     time++;
                 }
             }
         }
 
         Util.stringList2File(answerList, FILENAME_OUT);
     }
 }
",0
162,9274,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 public class codeJam1 {
 	public static void main(String[] args) throws IOException {
 		BufferedReader reader = new BufferedReader(new FileReader(new File(
 				""C:/Users/girish/Desktop/input.txt"")));
 
 		int t = Integer.parseInt(reader.readLine());
 		for(int i=1;i<=t;i++) {
 			String input = reader.readLine(); 
 			int n = Integer.parseInt(input);
 //			int m = Integer.parseInt(input[1]);
 			String[] mat = new String[n];
 			int[][] tWP = new int[n][2];
 			float[] tOWP = new float[n];
 			float[] tOOWP = new float[n];
 			float[] RPI = new float[n];
 			for(int z = 0;z<n;z++){
 				mat[z] = reader.readLine();
 			}
 			tWP = getTeamWP(mat);
 			tOWP = getTeamOWP(mat,tWP);
 			tOOWP = getTeamOOWP(mat,tOWP);
 			RPI = getRPI(tWP,tOWP,tOOWP);
 			
 			
 			System.out.println(""Case #""+i+"":"");
 			for(int d = 0;d< RPI.length;d++){
 	            System.out.println(RPI[d]);
 				
 			}
 		}
 	}
 
 	private static float[] getRPI(int[][] twp, float[] towp, float[] toowp) {
 		// TODO Auto-generated method stub
 		
 		float[] RPI = new float[twp.length];
 		for(int s = 0; s < twp.length;s++ ){
 			float wp = (twp[s][0]*1.0f)/(twp[s][1]*1.0f);
 			float OWP = towp[s];
 			float OOWP = toowp[s];
 			RPI[s] = (float) (0.25 * wp + 0.50 * OWP + 0.25 * OOWP);
 		}
 		return RPI;
 	}
 
 	private static float[] getTeamOOWP(String[] mat, float[] towp) {
 		// TODO Auto-generated method stub
 		float[] tOOWP = new float[mat.length];
 		for(int h = 0;h < mat.length ; h++){
 			String team = mat[h];
 			int playedCount = 0;
 			float avgOWP = 0.0f;
 			for(int x =0;x < team.length();x++){
 				if(team.charAt(x)== '0' || team.charAt(x) == '1'){
 					playedCount++;
 					avgOWP += towp[x];
 				}
 			}
 			tOOWP[h] = avgOWP/(playedCount*1.0f);
 		}
 		return tOOWP;
 	}
 
 	private static float[] getTeamOWP(String[] mat, int[][] twp) {
 		// TODO Auto-generated method stub
 		float[] OWP =  new float[mat.length];
 		for(int g = 0;g < mat.length;g++){
 			String team = mat[g];
 			int playedCount = 0;
 			float avgWP = 0.0f;
 			for(int h =0; h< team.length();h++){
 				if(team.charAt(h) == '1'){
 					avgWP += ((twp[h][0])*1.0f)/((twp[h][1]-1)*1.0f);
 					playedCount++;
 				}
 				else if(team.charAt(h)== '0'){
 					avgWP += ((twp[h][0]-1)*1.0f)/((twp[h][1]-1)*1.0f);
 					playedCount++;
 				}
 			}
 			
 			OWP[g] = avgWP/(playedCount*1.0f);
 		}
 		return OWP;
 	}
 
 	private static int[][] getTeamWP(String[] mat) {
 		// TODO Auto-generated method stub
 		int[][] wp = new int[mat.length][2];
 		for(int g = 0 ;g<mat.length;g++){
 			String team = mat[g];
 			int oneCount = 0;
 			int zeroCount = 0;
 			for(int x = 0; x< team.length();x++){
 				if(team.charAt(x) == '1')
 					oneCount++;
 				else if(team.charAt(x)=='0')
 					zeroCount++;
 			}
 			wp[g][0] = oneCount;
 			wp[g][1] = oneCount + zeroCount;
 		}
 		return wp;
 	}
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.math.BigInteger;
 
 public class CodeJam1 {
     
     
     
     public static void main(String[] args) throws IOException {
 
         BufferedReader reader = new BufferedReader(new FileReader(new File(
                  ""/home/girish/Desktop/coding/codejam/input"")));
          int t = Integer.parseInt(reader.readLine());
          for (int i = 1; i <= t; i++) {
              String input  = reader.readLine();
              String[] tokens = input.split("" "");
              long r = Long.parseLong(tokens[0]);
              long T = Long.parseLong(tokens[1]);
              
             // System.out.println(""radius ""+r);
              //System.out.println("" liter ""+ T);
              
            //  System.out.println(r );
             // System.out.println(T);
              long start = 1;
              long end = 1500000000; 
              long expectedAns = T;
              long finalAns = 1;
              while(start <= end){
 
                  if(start == end)
                      break;
                  long mid = (start+end)/2;
                  
                  BigInteger midObj = new BigInteger(String.valueOf(mid));
                  BigInteger midObj1 = new BigInteger(String.valueOf(mid+1));
                  BigInteger rObj = new BigInteger (String.valueOf(r));
                  BigInteger ansBig = getAns(midObj,rObj);
                 // BigInteger ansBig = getAns(midObj1, rObj);
                  if(ansBig.toString().length() > 18)
                  {
                      end = mid;
                      continue;
                  }
                  BigInteger ans2Big = getAns(midObj1, rObj);
                  long ans1 = ansBig.longValue();
                  long ans2 = ans2Big.longValue();
                  if(ans1 == expectedAns){
                    //  System.out.println(""break1"");
                      finalAns = mid;
                      break;
                  }
                  
                  if( (ans1 < expectedAns) && (ans2 > expectedAns) ){
                     // System.out.println("" radius ""+r);
                     // System.out.println(ans1 +"" and expected ans"" + expectedAns);
                     // System.out.println(""break2"");
                      finalAns = mid;
                      break;
                  }
                  
                  if(ans2 == expectedAns)
                  {
                     // System.out.println(""break3"");
                      finalAns = mid+1;
                      break;
                  }
                  
                  if(ans1 > expectedAns)
                      end = mid;
                  else
                      start = mid;
                  
                  
              }
              
              System.out.print(""Case #"" + i + "": "");
              System.out.println(finalAns);    
          }
     }
 
     private static BigInteger getAns(BigInteger n,BigInteger r) {
         BigInteger n2 = n.multiply(new BigInteger(""2""));
         BigInteger r2 = r.multiply(new BigInteger(""2""));
         BigInteger nr2 = n2.add(r2);
         BigInteger sunr2= nr2.subtract(new BigInteger(""1""));
         return n.multiply(sunr2);
         //return n*(2*n+2*r-1);
     }
 }
 
",1
163,10795,"package round1A;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 
 public class CodeJamA {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         CodeJamA jam = new CodeJamA();
         jam.solve(""round1A/A-small-attempt0.in"");
     }
 
     public void solve(String file) throws FileNotFoundException, IOException {
         File f = new File(file);
         FileReader fin = new FileReader(f);
         BufferedReader in = new BufferedReader(fin);
         int cases = Integer.parseInt(in.readLine());
         File outF = new File(""resultsA.txt"");
         PrintStream out = new PrintStream(outF);
         for (int i = 1; i <= cases; i++) {
             String line = in.readLine();
             int o = Integer.parseInt(line.split("" "")[0]);
             int l = Integer.parseInt(line.split("" "")[1]);
             ArrayList<String> outs = new ArrayList();
             ArrayList<String> devs = new ArrayList();
             outs.addAll(Arrays.asList(in.readLine().split("" "")));
             devs.addAll(Arrays.asList(in.readLine().split("" "")));
             ArrayList<boolean[]> switched = new ArrayList();
             boolean[] cur = new boolean[l];
             for (int j = 0; j < l; j++) {
                 cur[j] = false;
             }
             getCombinations(switched, 0, cur);
             int min = l + 1;
             for (boolean[] switchRotation : switched) {
                 boolean valid = true;
                 for (String s : devs) {
                     char[] curs = s.toCharArray();
                     for (int j = 0; j < l; j++) {
                         if(switchRotation[j]) {
                             curs[j] = curs[j] == '1' ? '0' : '1';
                         }
                     }
                     if (!outs.contains(new String(curs))) {
                         valid = false;
                     }
                 }
                 if (valid) {
                     int curl = 0;
                     for (boolean b : switchRotation) {
                         if (b) {
                             curl++;
                         }
                     }
                     if (curl < min) {
                         min = curl;
                     }
                 }
             }
             out.print(""Case #"" + i + "": "");
             if (min == l + 1) {
                 out.print(""NOT POSSIBLE\n"");
             } else {
                 out.print(min + ""\n"");
             }
         }
     }
 
     public void getCombinations(ArrayList<boolean[]> combs, int depth, boolean[] cur) {
         boolean[] case1 = cur.clone();
         boolean[] case2 = cur.clone();
         case2[depth] = true;
         if (depth == cur.length - 1) {
             combs.add(case1);
             combs.add(case2);
         } else {
             getCombinations(combs, depth + 1, case1);
             getCombinations(combs, depth + 1, case2);
         }
     }
     
 }
","package round1A;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 
 public class CodeJamA {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         CodeJamA jam = new CodeJamA();
         jam.solve(""round1A/A-small-attempt0.in"");
     }
 
     public void solve(String file) throws FileNotFoundException, IOException {
         File f = new File(file);
         FileReader fin = new FileReader(f);
         BufferedReader in = new BufferedReader(fin);
         int cases = Integer.parseInt(in.readLine());
         File outF = new File(""resultsA.txt"");
         PrintStream out = new PrintStream(outF);
         for (int i = 1; i <= cases; i++) {
             String line = in.readLine();
             int o = Integer.parseInt(line.split("" "")[0]);
             int l = Integer.parseInt(line.split("" "")[1]);
             ArrayList<String> outs = new ArrayList();
             ArrayList<String> devs = new ArrayList();
             outs.addAll(Arrays.asList(in.readLine().split("" "")));
             devs.addAll(Arrays.asList(in.readLine().split("" "")));
             ArrayList<boolean[]> switched = new ArrayList();
             boolean[] cur = new boolean[l];
             for (int j = 0; j < l; j++) {
                 cur[j] = false;
             }
             getCombinations(switched, 0, cur);
             int min = l + 1;
             for (boolean[] switchRotation : switched) {
                 boolean valid = true;
                 for (String s : devs) {
                     char[] curs = s.toCharArray();
                     for (int j = 0; j < l; j++) {
                         if(switchRotation[j]) {
                             curs[j] = curs[j] == '1' ? '0' : '1';
                         }
                     }
                     if (!outs.contains(new String(curs))) {
                         valid = false;
                     }
                 }
                 if (valid) {
                     int curl = 0;
                     for (boolean b : switchRotation) {
                         if (b) {
                             curl++;
                         }
                     }
                     if (curl < min) {
                         min = curl;
                     }
                 }
             }
             out.print(""Case #"" + i + "": "");
             if (min == l + 1) {
                 out.print(""NOT POSSIBLE\n"");
             } else {
                 out.print(min + ""\n"");
             }
         }
     }
 
     public void getCombinations(ArrayList<boolean[]> combs, int depth, boolean[] cur) {
         boolean[] case1 = cur.clone();
         boolean[] case2 = cur.clone();
         case2[depth] = true;
         if (depth == cur.length - 1) {
             combs.add(case1);
             combs.add(case2);
         } else {
             getCombinations(combs, depth + 1, case1);
             getCombinations(combs, depth + 1, case2);
         }
     }
     
 }
",1
164,962,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Hashtable;
 import java.util.StringTokenizer;
 import java.util.TreeSet;
 
 public class TaskA implements Runnable {
 
 	private static final int STATUS = 2;
 	private static final String SMALL_INPUT_FILE_NAME = ""A-small-attempt1.in"";
 	private static final String LARGE_INPUT_FILE_NAME = ""A-large.in"";
 	private static final String OUTPUT_FILE_NAME = ""output.txt"";
 	private static final String STATUS_ERROR_MESSAGE = ""Wrong STATUS"";
 	
 	private static final int MOD = 1000002013;
 	
 	private class QueueInfo implements Comparable<QueueInfo> {
 
 		public QueueInfo(int enterStation, int cnt) {
 			this.enterStation = enterStation;
 			this.cnt = cnt;
 		}
 		
 		@Override
 		public int compareTo(QueueInfo other) {
 			int ds = other.getEnterStation() - enterStation;
 			return ds != 0 ? ds : other.getCnt() - cnt;
 		}
 		
 		public int getEnterStation() {
 			return enterStation;
 		}
 		public void setEnterStation(int enterStation) {
 			this.enterStation = enterStation;
 		}
 		public int getCnt() {
 			return cnt;
 		}
 		public void setCnt(int cnt) {
 			this.cnt = cnt;
 		}
 
 		private int enterStation;
 		private int cnt;
 	}
 	
 	private class EnterExitInfo implements Comparable<EnterExitInfo> {
 		
 		public EnterExitInfo(boolean enter, int stationId) {
 			this.enter = enter;
 			this.stationId = stationId;
 		}
 	
 		@Override
 		public int compareTo(EnterExitInfo other) {
 			int ds = stationId - other.getStationId();
 			return ds != 0 ? ds : enter == other.isEnter() ? 0 : enter ? -1 : 1;
 		}
 
 		public boolean isEnter() {
 			return enter;
 		}
 
 		public void setEnter(boolean enter) {
 			this.enter = enter;
 		}
 
 		public int getStationId() {
 			return stationId;
 		}
 
 		public void setStationId(int stationId) {
 			this.stationId = stationId;
 		}
 		
 		private boolean enter;
 		private int stationId;
 	}
 	
 	private long getCost(long d) {
 		return (n*d - (d-1)*d/2)%MOD;
 	}
 	
 	private int addToTotalCost(int o, int e, int cnt, int tc) {
 		return (int)((tc + getCost(e-o)*cnt)%MOD);
 	}
 	
 	private Hashtable<Integer, Integer> enter;
 	private Hashtable<Integer, Integer> exit;
 	
 	private void readData() {
 		n = in.readInt();
 		m = in.readInt();
 		q.clear();
 		totalCost = 0;
 		enter.clear();
 		exit.clear();
 		for (int i = 0; i < m; ++i) {
 			int o = in.readInt();
 			int e = in.readInt();
 			int p = in.readInt();
 			totalCost = addToTotalCost(o, e, p, totalCost);
 			q.add(new EnterExitInfo(true, o));
 			Integer cnt = enter.get(o);
 			if (cnt == null) {
 				cnt = p;
 			}
 			else {
 				cnt += p;
 			}
 			enter.put(o, cnt);
 			q.add(new EnterExitInfo(false, e));
 			cnt = exit.get(e);
 			if (cnt == null) {
 				cnt = p;
 			}
 			else {
 				cnt += p;
 			}
 			exit.put(e, cnt);
 		}
 	}
 	
 	private int totalCost;
 	private int n;
 	private int m;
 	private TreeSet<EnterExitInfo> q;
 	private TreeSet<QueueInfo> t;
 	
 	private int solve() {
 		t.clear();
 		int cost = 0;
 //		while (!q.isEmpty()) {
 //			EnterExitInfo top = q.pollFirst();
 //			System.out.println(top.isEnter() + "" "" + top.getStationId());
 //		}
 //		System.out.println();
 		while (!q.isEmpty()) {
 			EnterExitInfo top = q.pollFirst();
 			if (top.isEnter()) {
 				t.add(new QueueInfo(top.getStationId(), enter.get(top.getStationId())));
 			}
 			else {
 				int enterCount = exit.get(top.getStationId());
 				int station = top.getStationId();
 //				System.out.println(t.size() + "" "" + enterCount);
 				while (enterCount > 0) {
 					QueueInfo pas = t.pollFirst();
 					if (pas.getCnt() > enterCount) {
 						int rem = pas.getCnt() - enterCount;
 						t.add(new QueueInfo(pas.getEnterStation(), rem));
 						cost = addToTotalCost(pas.getEnterStation(), station, enterCount, cost);
 						break;
 					}
 					else {
 						enterCount -= pas.getCnt();
 						cost = addToTotalCost(pas.getEnterStation(), station, pas.getCnt(), cost);
 					}
 				}
 			}
 		}
 //		System.out.println();
 		return ((totalCost - cost)%MOD + MOD)%MOD;
 	}
 	
 	public InputStream getInputStream() throws FileNotFoundException {
 		switch (STATUS) {
 			case 0: 
 				return System.in;
 			case 1: 
 				return new FileInputStream(new File(SMALL_INPUT_FILE_NAME));
 			case 2: 
 				return new FileInputStream(new File(LARGE_INPUT_FILE_NAME));
 			default: 
 				throw new IllegalArgumentException(STATUS_ERROR_MESSAGE);
 		}
 	}
 	
 	public OutputStream getOutputStream() throws FileNotFoundException {
 		switch (STATUS) {
 			case 0: 
 				return System.out;
 			case 1: 
 			case 2: 
 				return new FileOutputStream(new File(OUTPUT_FILE_NAME));
 			default: 
 				throw new IllegalArgumentException(STATUS_ERROR_MESSAGE);
 		}		
 	}
 	
 	private void init() throws FileNotFoundException {
 		in = new InputReader(getInputStream());
 		out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(getOutputStream())));
 		q = new TreeSet<EnterExitInfo>();
 		t = new TreeSet<QueueInfo>();
 		enter = new Hashtable<Integer, Integer>();
 		exit = new Hashtable<Integer, Integer>();
 	}
 	
 	private void finish() {
 		out.flush();
 	}
 	
 	private InputReader in;
 	private PrintWriter out;
 	
 	@Override
 	public void run() {
 		try {
 			init();
 			int nt = in.readInt();
 			for (int testId = 1; testId <= nt; ++testId) {
 				readData();
 				out.println(""Case #"" + testId + "": "" + solve());
 			}
 			finish();
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 			throw new RuntimeException(e);
 		}
 	}
 	
 	public static void main(String[] args) {
 		new TaskA().run();
 	}
 	
 	private class InputReader {
 		
 	    public BufferedReader reader;
 	    public StringTokenizer tokenizer;
 
 	    public InputReader(InputStream stream) {
 	        reader = new BufferedReader(new InputStreamReader(stream));
 	        tokenizer = null;
 	    }
 
 	    public String next() {
 	        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
 	            try {
 	                tokenizer = new StringTokenizer(reader.readLine());
 	            } catch (IOException e) {
 	                throw new RuntimeException(e);
 	            }
 	        }
 	        return tokenizer.nextToken();
 	    }
 	    
 	    public int readInt() {
 	    	return Integer.parseInt(next());
 	    }
 	    
 	    
 	}
 
 }
","/*
    The Repeater
    @author gary https://plus.google.com/110619450313015458698
 */
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class TheRepeater
 {
    static public void main(String[] args)
    {
       Scanner fin;
       PrintWriter fout;
       try
       {
          fin = new Scanner(new File(""TheRepeater2.in""));
          fout = new PrintWriter(new File(""TheRepeater2.out""));
       }
       catch(FileNotFoundException fnfe)
       {
          fnfe.printStackTrace(System.err);
          return;
       }
       
       int t;
       t = fin.nextInt();
       for(int x=1; x<=t; x++)
       {
          int n = fin.nextInt();
          String[] strings = new String[n];
          
          for(int i=0; i<n; i++)
             strings[i] = fin.next();
          
          String[] alphabets = new String[n];
          int[][] alphcount = new int[n][];
          for(int i=0; i<n; i++)
             alphabets[i] = strings[i].substring(0,1);
          for(int i=0; i<n; i++)
          {
             int strIndex=0;
             int alpIndex=0;
             while(strIndex<strings[i].length())
             {
                while( strIndex<strings[i].length() &&
                       alpIndex<alphabets[i].length() &&
                   (alphabets[i].charAt(alpIndex)==strings[i].charAt(strIndex)) )
                      strIndex++;
                if(strIndex<strings[i].length())
                {
                   alphabets[i] = alphabets[i] + strings[i].charAt(strIndex);
                   alpIndex++;
                }
             }
             alphcount[i] = new int[alphabets[i].length()];
             strIndex=0;
             alpIndex=0;
             while(strIndex<strings[i].length())
             {
                while( strIndex<strings[i].length() &&
                       alpIndex<alphabets[i].length() &&
                   (alphabets[i].charAt(alpIndex)==strings[i].charAt(strIndex)) )
                {
                      alphcount[i][alpIndex]++;
                      strIndex++;
                }
                if(alpIndex<alphabets[i].length())
                   alpIndex++;
             }
          }
          
          
          fout.print(""Case #""+x+"": "");
          boolean sofarsogood = true;
          for(int i=1; i<n; i++)
             if(alphabets[i-1].length()!=alphabets[i].length() )
             {
                sofarsogood=false;
                break;
             }
          if(!sofarsogood)
          {
             fout.println(""Fegla Won"");
             continue;
          }
         
          
          int[] movesvector = new int[alphabets[0].length()];
          int moves = 0;
          for(int chI=0; chI<alphabets[0].length(); chI++)
          {
             int[] countvector = new int[n];
             for(int i=0; i<n; i++)
             {
                countvector[i] = alphcount[i][chI];
             }
             if(n==2)
             {
                if(alphabets[0].charAt(chI) != alphabets[1].charAt(chI))
                {
                   sofarsogood = false;
                   break;
                }
                movesvector[chI] = (int) Math.abs(countvector[1]-countvector[0]);
                moves += movesvector[chI];
             }
             
          }
          
          if(!sofarsogood)
          {
             fout.println(""Fegla Won"");
             continue;
          }
          else
             fout.println(moves);
          
          
       }
       fin.close();
       fout.close();
    }
 }
",0
165,10326,"
 package javaapplication8;
 
 import java.io.*;
 import java.util.*;
 
 public class JavaApplication8 {
 String s="""";
 int T,N,C[],No[][],i,j,k,flag=0;
 StringTokenizer st;
    public JavaApplication8(){
        FileInputStream fis=null;
        FileOutputStream fos=null;
        try{
            fis=new FileInputStream(""A-small-attempt0.in"");
            DataInputStream ds=new DataInputStream(fis);
            fos=new FileOutputStream(""A-small-attempt0.out"");
            DataOutputStream  dos=new DataOutputStream(fos);
            T=Integer.parseInt(ds.readLine());
            for(i=1;i<=T;i++)
            {
                N=Integer.parseInt(ds.readLine());
                C=new int[N];
                No=new int[N][N*N*N];
 //               System.out.println(""Loop"");
                for(j=0;j<N;j++)
                {
                    st=new StringTokenizer(ds.readLine());
                    C[j]=Integer.parseInt(st.nextToken());
 //                   System.out.println(C[j]);
                    if(C[j]>0)
                    {
                        for(k=0;k<C[j];k++)
                        {
                            No[j][k]=Integer.parseInt(st.nextToken());
                        }
                    }
                    else
                    {                       
                        No[j][0]=j+1;
                        C[j]=1;
                    }
                }
                
                for(int l=0;l<N;l++)
                {
                    for(j=0;j<N;j++)
                    {
                        for(k=0;k<C[j];k++)
                        {
                            if(C[No[j][k]-1]==1)
                            {
                                No[j][k]=No[No[j][k]-1][0];
                            }
 //                           System.out.print(No[j][k]+"" "");
                        }
 //                       System.out.println();
                    }
                } 
                for(j=0;j<N;j++)
                {
                    if(C[j]>1)
                    {
                        int sum=0,pos=0;
                        for(k=0;k<C[j];k++)
                        {
                            sum+=C[No[j][k]-1];
                        }
                        int[] a=new int[sum];
                        for(k=0;k<C[j];k++)
                        {
                           for(int l=0;l<C[No[j][k]-1];l++)
                           {
                               a[pos++]=No[No[j][k]-1][l];
                           }
                        }
                        C[j]=sum;
                        for(k=0;k<pos;k++)
                        {
 //                           System.out.print(a[k]+""--->"");
                            No[j][k]=a[k];
                        }
                    }
 //                   System.out.println();
                }
                for(int l=0;l<N;l++)
                {
                    if(C[l]>1)
                    {   
                        for(j=0;j<C[l]-1;j++)
                        {
                            for(k=j+1;k<C[l];k++)
                            {
                                if(No[l][j]==No[l][k])
                                {
                                    flag=1;
                                    break;
                                }
                            }
                            if(flag==1)
                            {
                                break;
                            }
                        }
                    }
                    if(flag==1)
                    {
                        break;
                    }                   
                }  
                s+=""Case #""+i+"": "";
                if(flag==1)
                {
                    System.out.println(i+""Yes"");
                    s+=""Yes"";
                    flag=0;
                }
                else
                {
                    System.out.println(i+""No"");
                    s+=""No"";
                }
                if(i!=T)
                    s+=""\n"";
            }
            dos.writeBytes(s);
            dos.close();
            ds.close();
        }catch(Exception ex)
        {
            System.out.println(ex);
        }
    }
     public static void main(String[] args) {
         // TODO code application logic here
         new JavaApplication8();
     }
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class C {
 	static String[] dict;
 	static char[] str;
 	static int[][] dp;
 
 	public static void main(String[] args) throws IOException {
 		BufferedReader br = new BufferedReader(
 				new FileReader(
 						""L:\\Work Space\\Eclipse WorkSpace\\Code Jam\\src\\garbled_email_dictionary.txt""));
 		dict = new String[521196];
 		String s;
 		int A = 0;
 		while ((s = br.readLine()) != null) {
 			dict[A++] = s;
 		}
 		Scanner in = new Scanner(System.in);
 		int T = in.nextInt();
 		for (int I = 1; I <= T; I++) {
 			str = in.next().toCharArray();
 			dp = new int[str.length][str.length + 200];
 			for (int i = 0; i < dp.length; i++)
 				Arrays.fill(dp[i], -1);
 
 			int min = solve(0, -100);
 			System.out.printf(""Case #%d: %d\n"", I, min);
 		}
 	}
 
 	private static int solve(int idx, int last) {
 		if (idx == str.length)
 			return 0;
 		if (dp[idx][last + 100] != -1)
 			return dp[idx][last + 100];
 		else {
 			int min = 1 << 25;
 			Loop: for (int j = 0; j < dict.length; j++) {
 				String s = dict[j];
 				if (s.length() + idx <= str.length) {
 					int L = last, cnt = 0;
 					for (int i = 0; i < s.length(); i++)
 						if (s.charAt(i) != str[idx + i]) {
 							if ((idx + i) - L < 5)
 								continue Loop;
 							cnt++;
 							L = idx + i;
 						}
 
 					min = Math.min(min, cnt + solve(idx + s.length(), L));
 				}
 			}
 			return dp[idx][last + 100] = min;
 		}
 	}
 }
",0
166,2679,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 
 public class P2javasol {
 
 	public static void main(String[] args){
 		BufferedReader inputStream = null;
 		PrintWriter outputStream = null;
 
 		File inputfile = new File(""C:/users/Kevin/Desktop/B-small-attempt1.in"");
 		File outputFile = new File (""C:/users/Kevin/Desktop/P2.txt"");
 		try{
 			inputStream = new BufferedReader(new FileReader(inputfile));
 			outputStream = new PrintWriter(new FileWriter(outputFile));
 
 			int num_cases = Integer.valueOf(inputStream.readLine()); //Grabs the # on the first line.
 			for (int i=1; i<=num_cases; i++){
 				StringBuffer sb = new StringBuffer(""Case #"" + i + "": "");
 				String[] x_y = inputStream.readLine().split("" "");
 				Coordinate c = new Coordinate(Integer.valueOf(x_y[0]), Integer.valueOf(x_y[1]));
 				String outcome = findSolution(c);
 				int x = 0;
 				int y = 0;
 				int dist = 1;
 				for (int j=0; j < outcome.length(); j++){
 					if (outcome.charAt(j) == 'E')
 						x += dist;
 					else if (outcome.charAt(j) == 'W')
 						x -= dist;
 					else if (outcome.charAt(j) == 'N')
 						y += dist;
 					else if (outcome.charAt(j) == 'S')
 						y -= dist;
 					dist++;
 				}
 				System.out.println(Integer.valueOf(x_y[0]) + "" "" + Integer.valueOf(x_y[1]) + "" Directions: "" + outcome + "" x = "" + x + "" y = "" + y);
 				sb.append(outcome + ""\n"");
 				outputStream.write(sb.toString());
 			}	
 		}catch (Exception e){
 			e.printStackTrace();
 		}finally{
 			try {
 				inputStream.close();
 				outputStream.close();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}	
 		}
 	}
 	public static String findSolution(Coordinate c){
 		int x = 0;
 		int y = 0;
 		int dist = 1;
 		
 		StringBuffer directions = new StringBuffer("""");
 		//Start with x;
 		while (x != c.x){
 			int d = c.x - x;
 			if (Math.abs(d) < dist){
 				directions.append(delta(d, 'x'));
 				dist += 2 * Math.abs(d);
 				break;
 			} else {
 				if (d > 0){
 					x += dist;
 					directions.append(""E"");
 				}
 				else{
 					x -= dist;
 					directions.append(""W"");
 				}
 				dist++;
 			}
 		}
 		while (y != c.y){
 			System.out.println(""y="" + y);
 			int d = c.y - y;
 			if (Math.abs(d) < dist){
 				directions.append(delta(d, 'y'));
 				dist += 2 * Math.abs(d);
 				break;
 			} else {
 				if (d > 0){
 					y += dist;
 					directions.append(""N"");
 				}
 				else{
 					y -= dist;
 					directions.append(""S"");
 				}
 			}
 			dist++;
 		}
 		return directions.toString();
 	}
 	public static String delta(int d, char direction){
 		// if d > 0, we need to go east (or north) d units.
 		// if d < 0, we need to go west (or south) d units.
 		StringBuffer directions = new StringBuffer("""");
 		if (d > 0){
 			for (int i=0; i<Math.abs(d);i++){
 				if (direction == 'x')
 					directions.append(""WE"");
 				else
 					directions.append(""SN"");
 			}
 		} else {
 			for (int i=0; i<Math.abs(d);i++){
 				if (direction == 'x')
 					directions.append(""EW"");
 				else
 					directions.append(""NS"");
 			}
 		}
 		return directions.toString();
 	}
 	
 }
","package candy;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Main {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new FileInputStream(""C-small.in""));
 		PrintWriter out = new PrintWriter(new FileOutputStream(""C-small.out""));
 		int T = in.nextInt();
 		for (int t = 1; t <= T; t++) {
 			Solver solver = new Solver(in);
 			out.println(""Case #"" + t + "": "" + solver.getResult());
 		}
 		out.close();
 		System.out.println(""finished"");
 	}
 }
",0
167,11231,"import java.io.File;
 import java.io.FileWriter;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 
 public class G_B {
 	public static void main(String[] args) throws Exception{
 		Scanner sc = new Scanner(new File(""B-large.in"")); 
 //		Scanner sc = new Scanner(System.in);
 		FileWriter fw = new FileWriter(""B-large.out"");
 		int keis = sc.nextInt();
 		for (int kei = 1; kei <= keis; kei++) {
 			HashMap<String,String> hm = new HashMap<String,String>();
 			HashSet<String> hs = new HashSet<String>();
 			int c = sc.nextInt();
 			String[] combo = new String[c];
 			for (int i = 0; i < c; i++) {
 				combo[i]=sc.next();
 				String a = """"+combo[i].charAt(0);
 				String b = """"+combo[i].charAt(1);
 				String d = """"+combo[i].charAt(2);
 				hm.put(a+b, d);
 				hm.put(b+a, d);
 			}
 			int d= sc.nextInt();
 			String[] breaker = new String[d];
 			for (int i = 0; i < d; i++) {
 				breaker[i]=sc.next();
 				String a= """"+breaker[i].charAt(0);
 				String b = """"+breaker[i].charAt(1);
 				hs.add(a+b);
 				hs.add(b+a);
 			}
 			int n = sc.nextInt();
 			String invoke = sc.next();
 			LinkedList<String> ls = new LinkedList<String>();
 			for (int i = 0; i < invoke.length(); i++) {
 				ls.addLast(""""+invoke.charAt(i));
 				//check for last 2
 				if(ls.size()>=2){
 					String l2 = ls.pollLast();
 					String l1 = ls.pollLast();
 					String l = l1+l2;
 					if(hm.containsKey(l)){
 						ls.addLast(hm.get(l));
 						continue;
 					}
 					ls.addLast(l1);
 					boolean meron = false;
 					for (String l3 : ls) {
 						String brk = l3+l2;
 						if(hs.contains(brk)){
 							meron = true;
 							break;
 						}
 					}
 					if(meron){
 						ls.clear();
 						continue;
 					}
 					ls.addLast(l2);
 				}
 			}
 			fw.write(""Case #""+ kei+"": ""+ls.toString()+""\n"");
 		}
 		fw.close();
 	}
 }
","import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class R2_A {
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 
 		int keis = sc.nextInt();
 
 		for (int kei = 1; kei <=keis; kei++) {
 			int r = sc.nextInt();
 			int c = sc.nextInt();
 			char[][] ar = new char[r][c];
 			for (int i = 0; i < ar.length; i++) {
 				ar[i] = sc.next().toCharArray();
 			}
 			boolean fail = false;
 			
 			loop:
 			for (int i = 0; i < ar.length-1; i++) {
 				for (int j = 0; j < ar[i].length-1; j++) {
 					char orig = ar[i][j];
 					if(orig == '.')continue;
 					if(orig=='/' || orig=='\\')continue;
 					
 					if(ar[i][j]=='#'){
 						ar[i][j]='/';
 						if(ar[i][j+1]=='#')ar[i][j+1]='\\';
 						else {
 							fail = true;
 							break loop;
 						}
 						if(ar[i+1][j]=='#')ar[i+1][j]='\\';
 						else {
 							fail = true;
 							break loop;
 						}
 						if(ar[i+1][j+1]=='#')ar[i+1][j+1]='/';
 						else {
 							fail = true;
 							break loop;
 						}
 					}
 				}
 				
 			}
 			loop2:
 			for (int i = 0; i < ar.length; i++) {
 				for (int j = 0; j < ar[i].length; j++) {
 					if(ar[i][j]=='#'){
 						fail=true;
 						break loop2;
 					}
 				}
 			}
 			
 			if(fail){
 				System.out.println(""Case #""+kei+"":\nImpossible"");
 			}else{
 				System.out.println(""Case #""+kei+"":"");
 				for (int i = 0; i < ar.length; i++) {
 					String s = """";
 					for (int j = 0; j < ar[i].length; j++) {
 						s=s+ar[i][j];
 					}
 					System.out.println(s);
 				}
 			}
 		}
 	}
 }",1
168,17598,"package RoundA;
 
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class ProblemB {
 
 	public static void main(String[] args) {
 		Scanner input = new Scanner(System.in);
 		int cases = input.nextInt();
 		for (int c = 0; c < cases; c++) {
 			int E = input.nextInt();
 			int R = input.nextInt();
 			int N = input.nextInt();
 			int gained = 0;
 			int[] values = new int[N];
 			int sum = 0;
 			for (int i = 0; i < N; i++) {
 				values[i] = input.nextInt();
 				sum += values[i];
 			}
 			if (R > E)
 				R = E;
 
 			gained += R * sum;
 
 			Arrays.sort(values);
 			int maximum = values[values.length - 1];
 			gained += (E - R) * maximum;
 
 			System.out.format(""Case #%d: %s\n"", c + 1, gained);
 		}
 	}
 
 }
","package codejam;
 
 import java.io.*;
 import java.util.Set;
 import java.util.HashSet;
 
 
 public class FileFix {
 
     public static void main(String args[]){
 
         String input = ""d:\\A-small-attempt0.in"";
         String output = ""d:\\A-small-attempt0.out"";
         File input_file = null;
         File output_file = null;
         BufferedReader br = null;
         BufferedWriter bw = null;
 
         try{
 
             input_file = new File(input);
             br = new BufferedReader(new FileReader(input_file));
 
             output_file = new File(output);
             bw = new BufferedWriter(new FileWriter(output_file));
 
             int case_count = Integer.parseInt(br.readLine());
             String[] constants = null;
             for(int i=1 ; i<=case_count ; i++){
                 constants = br.readLine().split("" "");
                 int n = Integer.parseInt(constants[0]);
                 int m = Integer.parseInt(constants[1]);
                 String olds[] = new String[n];
                 String news[] = new String[m];
                 for(int j=0 ; j<n ; j++){
                     olds[j] = br.readLine();
                 }
                 for(int j=0 ; j<m ; j++){
                     news[j] = br.readLine();
                 }
 
                 int command = process(olds,news);
                 bw.write(""Case #""+i+"": ""+command+""\n"");
             }
 
             br.close();
             bw.close();
 
         }catch(Exception e){
             e.printStackTrace();
         }
     }
 
 
     public static int process(String olds[], String news[]){
         int command = 0;
         HashSet names = new HashSet();
         names.add(""/"");
         for(int i=0; i<olds.length ; i++){
             String paths[] = olds[i].split(""/"");
             String path = """";
             for(int j=0 ; j<paths.length ; j++){
                 path = path+""/""+paths[j];
                 names.add(path);
             }
         }
 
 
         for(int i=0; i<news.length ; i++){
             String paths[] = news[i].split(""/"");
             String path = """";
             for(int j=0 ; j<paths.length ; j++){
                 path = path+""/""+paths[j];
                 if(!names.contains(path)){
                     command++;
                     names.add(path);
                 }
             }
         }
 
         return command;
     }
 
 }
",0
169,437,"
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.Arrays;
 import java.util.Formatter;
 import java.util.Locale;
 import java.util.Scanner;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  *
  * @author edemairy
  */
 public class Main {
 
     private final static Logger logger = Logger.getLogger(Main.class.getName());
     private static int nbTC;
     private static StringBuilder result = new StringBuilder();
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws IOException {
         logger.setLevel(Level.OFF);
         Scanner scanner = new Scanner(System.in);
 //        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
         nbTC = scanner.nextInt();
 //        scanner.nextLine();
         for (int tc = 1; tc <= nbTC; ++tc) {
             result.append(""Case #""+tc+"": "");
             result.append(oneTestCase(scanner));
             result.append('\n');
         }
         System.out.print(result);
     }
 
     private static double[] p = new double[100010];
     private static StringBuilder oneTestCase(Scanner scanner)  throws IOException {
         Formatter formatter = new Formatter(Locale.ENGLISH);
         StringBuilder result = new StringBuilder();
         int A = scanner.nextInt();
         int B = scanner.nextInt();
         double sumpi = 0;
         double prod1mpi = 1;
         double prod1bp = 1;
         double prod2bp = 1;
         for (int i=1; i<=A; ++i) {
             p[i] = Double.parseDouble(scanner.next());
             sumpi += p[i];
             
             prod1mpi *= p[i];
             if (i<A) {
                 prod1bp *= p[i];
             } else {
                 prod1bp *= (1-p[i]);
             }
             if (i<(A-1)) {
                 prod2bp *= p[i];
             } else {
                 prod2bp *= (1-p[i]);
             }
         }
         double es1 = prod1mpi*(B-A+1) + (1-prod1mpi)*(2*B-A+2);
         double es2 = prod1mpi*(B-A+3) + prod1bp*(B-A+3) + (1-prod1mpi-prod1bp)*(2*B-A+4);
         double es3;
         if (A>1) {
             es3 = prod1mpi*(B-A+5) + (prod2bp)*(B-A+5) + (1-prod1mpi-prod2bp)*(2*B-A+6);
         } else {
             es3 = prod1mpi*(B-A+4) + prod2bp*(B-A+4) + (1-prod1mpi-prod2bp)*(2*B-A+5);;
         }
         
         double es4 = (B+2);
         
         double r = Math.min(es1, Math.min(es2, Math.min(es3, es4)));
         formatter.format(""%.6f"",r);
 //        for (int i = 0; i < 5; ++i) {
 //            formatter.format(""%3d"", n[i]);
 //        }
         result.append(formatter.out());
         return result;
     }
 
     private static int readInt(BufferedReader reader) throws IOException {
         int result = 0;
         boolean positive = true;
         char currentChar = (char) reader.read();
 
         while ((currentChar == ' ') || (currentChar == '\n')) {
             currentChar = (char) reader.read();
         }
         if (currentChar == (char) -1) {
             throw new IOException(""end of stream"");
         }
         if (currentChar == '-') {
             positive = false;
             currentChar = (char) reader.read();
         }
         while ((currentChar >= '0') && (currentChar <= '9')) {
             result = result * 10 + currentChar - '0';
             currentChar = (char) reader.read();
         }
         if (positive) {
             return result;
         } else {
             return -result;
         }
     }
 
     private static char readChar(BufferedReader reader) throws IOException {
         return (char) reader.read();
     }
 }
","
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.Formatter;
 import java.util.Locale;
 import java.util.TreeSet;
 
 /**
  *
  * @author edemairy
  */
 public class Main {
 
     private int nbTC;
     private StringBuilder result = new StringBuilder();
 
     private static class EndException extends RuntimeException {
     }
 
     public void run() throws IOException {
         //        Scanner scanner = new Scanner(System.in);
         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
         nbTC = readInt(reader);
 //         nbTC = Integer.MAX_VALUE;
 //        scanner.nextLine();
         try {
             for (int tc = 1; tc <= nbTC; ++tc) {
                 result.append(""Case #"" + tc + "": "");
                 result.append(oneTestCase(reader));
                 result.append('\n');
             }
         } catch (EndException e) {
         }
         System.out.print(result);
     }
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws IOException {
         Main main = new Main();
         main.run();
     }
 
     private StringBuilder oneTestCase(BufferedReader reader) throws IOException {
         Formatter formatter = new Formatter(Locale.ENGLISH);
         StringBuilder output = new StringBuilder();
 //        for (int i = 0; i < 5; ++i) {
 //            formatter.format(""%3d"", n[i]);
 //        }
         TreeSet<Integer> cards = new TreeSet<Integer>();
         int row = readInt(reader);
         int card = -1;
         for (int r = 0; r < 4; r++) {
             for (int c = 0; c < 4; c++) {
                 card = readInt(reader);
                 if (row == r + 1) {
                     cards.add(card);
                 }
             }
         }
         TreeSet<Integer> sol = new TreeSet<Integer>();
         row = readInt(reader);
         for (int r = 0; r < 4; r++) {
             for (int c = 0; c < 4; c++) {
                 card = readInt(reader);
                 if (row == r + 1) {
                     if (cards.contains(card)) {
                         sol.add(card);
                     }
                 }
             }
         }
 
         if (sol.size() == 0) {
             formatter.format(""Volunteer cheated!"");
         } else if (sol.size() == 1) {
             formatter.format(""%d"", sol.first());
         } else {
             formatter.format(""Bad magician!"");
         }
 
         output.append(formatter.out());
         return output;
     }
 
     private int readInt(BufferedReader reader) throws IOException {
         int r = 0;
         boolean positive = true;
         char currentChar = (char) reader.read();
 
         while ((currentChar == ' ') || (currentChar == '\n')) {
             currentChar = (char) reader.read();
         }
         if (currentChar == (char) -1) {
             throw new IOException(""end of stream"");
         }
         if (currentChar == '-') {
             positive = false;
             currentChar = (char) reader.read();
         }
         while ((currentChar >= '0') && (currentChar <= '9')) {
             r = r * 10 + currentChar - '0';
             currentChar = (char) reader.read();
         }
         if (positive) {
             return r;
         } else {
             return -r;
         }
     }
 
     private long readLong(BufferedReader reader) throws IOException {
         long r = 0;
         boolean positive = true;
         char currentChar = (char) reader.read();
 
         while ((currentChar == ' ') || (currentChar == '\n')) {
             currentChar = (char) reader.read();
         }
         if (currentChar == (char) -1) {
             throw new IOException(""end of stream"");
         }
         if (currentChar == '-') {
             positive = false;
             currentChar = (char) reader.read();
         }
         while ((currentChar >= '0') && (currentChar <= '9')) {
             r = r * 10 + currentChar - '0';
             currentChar = (char) reader.read();
         }
         if (positive) {
             return r;
         } else {
             return -r;
         }
     }
 
     private char readChar(BufferedReader reader) throws IOException {
         return (char) reader.read();
     }
 }
",1
170,5459,"import java.io.*;
 
 class speaking
 {
 	public static void main(String args[]) throws Exception
 	{
 		BufferedReader br=new BufferedReader(new FileReader(""inputA.in""));
 		BufferedWriter bw=new BufferedWriter(new FileWriter(""outputA.txt""));
 		int T;
 		String s;
 		char c[],translate[]={'y','h','e','s','o','c','v','x','d','u','i','g','l','b','k','r','z','t','n','w','j','p','f','m','a','q'};
 		s=br.readLine();
 		T=Integer.parseInt(s);
 		for(int i=0;i<T;i++)
 		{
 			s=br.readLine();
 			c=new char[s.length()];
 			for(int j=0;j<s.length();j++)
 			{
 				
 				if(s.charAt(j)==' ')
 				c[j]=' ';
 				else
 				c[j]=translate[(int)(s.charAt(j)-'a')];
 			}
 			s=new String(c);
 			bw.write(""Case #""+(i+1)+"": ""+s);
 			if(i!=T-1)
 			bw.write(""\n"");
 		}
 		br.close();
 		bw.close();
 	}
 }","
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 public class mye {
 
     public static void main(String args[]) throws Exception {
 	BufferedReader br = new BufferedReader(new FileReader(""myefinal.in""));
 	PrintWriter pw = new PrintWriter(""myefinal.out"");
 	String s;
 	StringTokenizer st;
 	int T, E, R, N, v[], profit;
 	s = br.readLine();
 	T = Integer.parseInt(s);
 	for (int i = 0; i < T; i++) {
 	    profit = 0;
 	    s = br.readLine();
 	    st = new StringTokenizer(s, "" "");
 	    E = Integer.parseInt(st.nextToken());
 	    R = Integer.parseInt(st.nextToken());
 	    N = Integer.parseInt(st.nextToken());
 	    v = new int[N];
 	    s = br.readLine();
 	    st = new StringTokenizer(s, "" "");
 	    for (int j = 0; j < N; j++) {
 		v[j] = Integer.parseInt(st.nextToken());
 	    }
 	    Arrays.sort(v);
 	    if (E >= R) {
 		for (int j = N - 1; j >= 0; j--) {
 		    profit = profit + E * v[j];
 		    //System.out.println(profit + ""="" + profit + ""+"" + E + ""*"" + v[j]);
 		    E = R;
 		    
 		}
 	    } else {
 		for (int j = 0; j < N; j++) {
 		    profit = profit + E * v[j];
 		    //System.out.println(profit + ""="" + profit + ""+"" + E + ""*"" + v[j]);
 		    
 		}
 	    }
 	    //System.out.println();
 	    if(E>=R){
 		 pw.println(""Case #"" + (i + 1) + "": "" + (profit));
 	    }else{
 		pw.println(""Case #"" + (i + 1) + "": "" + (profit));
 	    }
 	    
 
 	}
 	pw.close();
     }
 }",1
171,20334,"package repeater;
 
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
 public class Repeater {
 
 	public static void main(String[] args) throws Exception {
 
 		String fileName = ""A-small-attempt0.in"";
 
 		Path mainDir = Paths.get(System.getProperty(""user.dir"") + ""/CodeJam2014/""
 				+ Repeater.class.getPackage().getName());
 
 		Path inputFilePath = mainDir.resolve(fileName);
 		Path outputFilePath = mainDir.resolve(fileName + "".out"");
 
 		List<String> inputLines = Files.readAllLines(inputFilePath, StandardCharsets.UTF_8);
 
 		List<String> outputLines = new ArrayList<String>();
 
 		long start = System.currentTimeMillis();
 
 		int numCases = Integer.parseInt(inputLines.get(0));
 
 		int firstLine = 1;
 		for (int i = 0; i < numCases; i++) {
 
 			int n = Integer.parseInt(inputLines.get(firstLine));
 
 			System.out.println(""n:"" + n);
 
 			String[] strings = new String[n];
 			for (int j = 0; j < strings.length; j++) {
 				strings[j] = inputLines.get(firstLine + j + 1);
 				// System.out.println(""w"" + j + "": "" + strings[j]);
 			}
 
 			int min = getMinMoves(strings);
 
 			String result = min < 0 ? ""Fegla Won"" : """" + min;
 
 			String caseResult = ""Case #"" + (i + 1) + "": "" + result;
 			outputLines.add(caseResult);
 			System.out.println(caseResult);
 			System.out.println(""------------"");
 
 			firstLine += n + 1;
 
 		}
 		System.out.println(""Completed: "" + (System.currentTimeMillis() - start) / 1000d + "" s"");
 
 		StandardOpenOption option;
 		if (!Files.exists(outputFilePath)) {
 			option = StandardOpenOption.CREATE_NEW;
 		} else {
 			option = StandardOpenOption.TRUNCATE_EXISTING;
 		}
 		Files.write(outputFilePath, outputLines, option);
 
 	}
 
 	private static int getMinMoves(String[] strings) {
 
 		List<String> common = getLetters(strings[0]);
 
 		for (int i = 1; i < strings.length; i++) {
 			List<String> lett = getLetters(strings[i]);
 			if (common.size() != lett.size())
 				return -1;
 			for (int j = 0; j < lett.size(); j++) {
 				if (!common.get(j).equals(lett.get(j))) {
 					return -1;
 				}
 			}
 		}
 
 		// commonsub
 		int[] minSig = getSig(strings[0], common.size());
 		for (int i = 1; i < strings.length; i++) {
 			int[] sig = getSig(strings[i], common.size());
 			for (int j = 0; j < sig.length; j++) {
 				if (sig[j] < minSig[j]) {
 					minSig[j] = sig[j];
 				}
 			}
 		}
 
 		String com = """";
 		for (int i = 0; i < minSig.length; i++) {
 			for (int j = 0; j < minSig[i]; j++) {
 				com += common.get(i);
 			}
 		}
 		// List<String> a = new ArrayList<String>();
 		// for (int i = 0; i < strings.length; i++) {
 		// a.add(strings[i]);
 		// }
 		// a.add(com);
 		// strings = a.toArray(strings);
 		// System.out.println(com);
 
 		// diff
 		int[][] diffs = new int[strings.length][strings.length];
 		int addDiff = 0;
 		for (int i = 0; i < diffs.length; i++) {
 			addDiff += getDiff(strings[i], com, common);
 			for (int j = 0; j < diffs.length; j++) {
 				if (i != j) {
 					diffs[i][j] = getDiff(strings[i], strings[j], common);
 					// System.out.println(""diff: "" + strings[i] + "", "" +
 					// strings[j] + ""="" + diffs[i][j]);
 				} else {
 					diffs[i][j] = 0;
 				}
 			}
 		}
 
 		int min = Integer.MAX_VALUE;
 		for (int i = 0; i < diffs.length; i++) {
 			int sum = 0;
 			for (int j = 0; j < diffs.length; j++) {
 				sum += diffs[i][j];
 			}
 			if (sum < min)
 				min = sum;
 		}
 
 		return Math.min(min, addDiff);
 	}
 
 	private static int[] getSig(String s, int n) {
 		if (s.length() == 0)
 			return null;
 		int[] sig = new int[n];
 		char f = s.charAt(0);
 		sig[0] = 1;
 		int i = 0;
 		for (int j = 1; j < s.length(); j++) {
 			if (s.charAt(j) == f) {
 				sig[i]++;
 			} else {
 				sig[++i]++;
 				f = s.charAt(j);
 			}
 		}
 		return sig;
 	}
 
 	private static int getDiff(String string, String string2, List<String> common) {
 
 		int[] s1 = getSig(string, common.size());
 		int[] s2 = getSig(string2, common.size());
 		// int last1 = 0;
 		// int last2 = 0;
 		//
 		// for (int i = 0; i < common.size(); i++) {
 		// int c1 = 0;
 		// int c2 = 0;
 		// while (string.length() > last1 &&
 		// common.get(i).equals(string.charAt(last1) + """")) {
 		// c1++;
 		// last1++;
 		// }
 		// s1[i] = c1;
 		//
 		// while (string2.length() > last2 &&
 		// common.get(i).equals(string2.charAt(last2) + """")) {
 		// c2++;
 		// last2++;
 		// }
 		// s2[i] = c2;
 		// }
 		// System.out.print(""s1:"" + string);
 		// for (int i = 0; i < s2.length; i++) {
 		// System.out.print(s1[i] + "","");
 		// }
 		// System.out.println();
 		//
 		// System.out.print(""s2:"" + string2);
 		// for (int i = 0; i < s2.length; i++) {
 		// System.out.print(s2[i] + "","");
 		// }
 		// System.out.println();
 
 		int diff = 0;
 		for (int i = 0; i < s2.length; i++) {
 			diff += Math.abs(s1[i] - s2[i]);
 		}
 		return diff;
 	}
 
 	private static List<String> getLetters(String str) {
 		ArrayList<String> commonLetters = new ArrayList<String>();
 
 		if (str.length() > 0) {
 			char firstChar = str.charAt(0);
 			commonLetters.add(firstChar + """");
 			for (int j = 1; j < str.length(); j++) {
 				char currentChar = str.charAt(j);
 				if (currentChar != firstChar) {
 					commonLetters.add(currentChar + """");
 					firstChar = currentChar;
 				}
 			}
 		}
 
 		return commonLetters;
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class answer {
 
 	public static int solve(int N, int S, int P, int[] googler) {
 		int greater = 0;
 		int score;
 
 		for (int i = 0; i < N; i++) {
 
 			score = googler[i];
 
 			if (score / 3 >= P) {
 				greater++;
 			} else {
 				if (score % 3 == 0 && score != 0) {
 
 					if ( score / 3 + 1 >= P && S > 0) {
 						S--;
 						greater++;
 					}
 				} else if (score != 0) {
 					if ( score / 3 + 1 >= P) {
 						greater++;
 					} else if ( score / 3 < P && score / 3 + 2 >= P && S > 0) {
 						S--;
 						greater++;
 					}
 				} else if (P == 0) {
 					greater++;
 				}
 			}
 		}
 		return greater;
 	}
 
 	public static void main(String[] args) throws Exception {
 
 		Scanner in = new Scanner(new File(""B-large.in""));
 		PrintWriter out = new PrintWriter(""output.out"");
 
 		int[] googler = new int[100];
 		int testCases = Integer.parseInt(in.next());
 		int count = 0;
 		while (in.hasNext()) {
 			count++;
 			int N = Integer.parseInt(in.next());
 			int S = Integer.parseInt(in.next());
 			int P = Integer.parseInt(in.next());
 
 			for (int i = 0; i < N; i++) {
 				googler[i] = Integer.parseInt(in.next());
 			}
 			int greater = solve(N, S, P, googler);
 			out.printf(""Case #%d: %d\n"", count, greater);
 
 		}
 
 		out.close();
 		in.close();
 	}
 }
",0
172,10399,"package yr2013.qround.qA;
 
 import java.io.*;
 import java.util.*;
 import java.lang.Math;
 
 public class A{
 
 	// User Defined Variable
 	String[] L; 
 	
 	/*
 	Input
 
 	The first line of the input gives the number of test cases, T. 
 	T test cases follow. 
 	Each test case consists of 4 lines with 4 characters each, 
 	with each character being 'X', 'O', '.' or 'T' (quotes for clarity only). 
 	Each test case is followed by an empty line.
 	
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 	
 	*/
 	
 	void readParam(){
 		L = new String[4];
 		for(int i=0; i<4; i++){
 			L[i] = in.next();
 		}
 		//in.nextLine();
 	}
 	
 	void solve(){
 		boolean xWin=false;
 		boolean oWin=false;
 		if (chkV('X') || chkH('X') || chkD('X')) xWin=true;
 		if (chkV('O') || chkH('O') || chkD('O')) oWin=true;
 		
 		
 		if (xWin && oWin){
 			out.printf(""Draw\n"");
 		}else if (xWin){
 			out.printf(""X won\n"");
 		}else if (oWin){
 			out.printf(""O won\n"");
 		}else if (!chkF()){
 			out.printf(""Game has not completed\n"");
 		}else{
 			out.printf(""Draw\n"");
 		}
 		
 	}
 	
 	boolean chkV(char ch){
 		for(int j=0; j<4; j++){
 			int cnt = 0;
 			for(int i=0; i<4; i++){
 				if (L[i].charAt(j)==ch || L[i].charAt(j)=='T'){
 					cnt++;
 				}
 			}
 			if (cnt==4) return true;
 		}
 		return false;
 	}
 
 	boolean chkH(char ch){
 		for(int i=0; i<4; i++){
 			int cnt = 0;
 			for(int j=0; j<4; j++){
 				if (L[i].charAt(j)==ch || L[i].charAt(j)=='T'){
 					cnt++;
 				}
 			}
 			if (cnt==4) return true;
 		}
 		return false;
 	}
 
 	boolean chkD(char ch){
 		int cnt = 0;
 		for(int i=0; i<4; i++){
 			if (L[i].charAt(i)==ch || L[i].charAt(i)=='T'){
 				cnt++;
 			}
 		}
 		if (cnt==4) return true;
 		cnt = 0;
 		for(int i=0; i<4; i++){
 			if (L[4-i-1].charAt(i)==ch || L[4-i-1].charAt(i)=='T'){
 				cnt++;
 			}
 		}
 		if (cnt==4) return true;
 		
 		return false;
 	}
 	
 	boolean chkF(){
 		for(int i=0; i<4; i++){
 			for(int j=0; j<4; j++){
 				if (L[i].charAt(j)=='.'){
 					return false;
 				}
 			}
 		}
 		return true;
 	}
 	
 	// -----------------------------No Need To Amend Below---------------------------
 	// Common
 	static String DATA_SET = ""Default"";
 	int NUM_OF_CASE = 0;
 	Scanner in;
 	PrintStream out;
 
 	
 	void setFile() throws Exception{
 		File inFile = new File(DATA_SET+"".in"");
 		File outFile = new File(DATA_SET+"".out"");
 		in = new Scanner(inFile);
 		out = new PrintStream(outFile);
 	}
 	
 	void run() throws Exception{
 		setFile();
 		NUM_OF_CASE = in.nextInt();
 		for(int c = 1; c <= NUM_OF_CASE; c++){
 			readParam();
 			out.printf(""Case #%d: "", c);
 			solve();
 		}
 	}
 	
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws Exception {
 		if (args.length>0) DATA_SET = args[0];
 		(new A()).run();
 	}
 
 }
","package round1b;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.text.DecimalFormat;
 
 public class A {
 
 	public static void main(String[] args) throws Exception {
 		//String fileName = ""test.in"";
 		String fileName = ""A-small-attempt0.in"";
 		//String fileName = ""A-large.in"";
 		String input = System.getProperty(""user.home"") + ""/Downloads/"" + fileName;
 		String output = System.getProperty(""user.home"") + ""/Downloads/codejam/"" + fileName + "".result"";
 		
 		BufferedReader br = new BufferedReader(new FileReader(input));
 		BufferedWriter bw = new BufferedWriter(new FileWriter(output));
 		String line = null;
 		line = br.readLine();
 		int caseNum = 1;
 		while ((line = br.readLine()) != null) {
 			bw.write(""Case #"" + caseNum + "":""); bw.newLine();
 			int N = Integer.valueOf(line);
 			int[][] schedule = new int[N][N];
 			int[] ooTotal = new int[N];
 			for (int i = 0; i < N; i++) {
 				String s = br.readLine();
 				for (int j = 0; j < N; j++) {
 					switch(s.charAt(j)) {
 					case '1':
 						ooTotal[i]++;
 						schedule[i][j] = 1;
 						break;
 					case '0':
 						ooTotal[i]++;
 						schedule[i][j] = 0;
 						break;
 					default:
 						schedule[i][j] = -1;
 						break;
 					}
 				}
 			}
 			
 			int[] total = new int[N];
 			int[] win = new int[N];
 			double[] owps = new double[N];
 			double[] oowps = new double[N];
 			for (int i = 0; i < N; i++) {
 				for (int j = 0; j < N; j++) {
 					if (schedule[i][j] == 0) {
 						total[i]++; 
 					} else if (schedule[i][j] > 0) {
 						total[i]++; win[i]++;
 					}
 				}
 			}
 			
 			int count[] = new int[N];
 			for (int i = 0; i < N; i++) {
 				count[i] = 0;
 				double wpsTotal = 0;;
 				for (int j = 0; j < N; j++) {
 					if (j == i) continue;
 					int total1 = total[j];
 					int win1 = win[j];
 					if (schedule[j][i] == 0) {
 						total1--; count[i]++;
 						wpsTotal += ((double) win1) / total1;
 					} else if (schedule[j][i] > 0) {
 						total1--; win1--; count[i]++;
 						wpsTotal += ((double) win1) / total1;
 					}
 				}
 				
 				owps[i] = wpsTotal / count[i];
 			}
 			
 			for (int i = 0; i < N; i++) {
 				double owps1 = 0;;
 				for (int j = 0; j < N; j++) {
 					if (schedule[i][j] >= 0)
 						owps1 += owps[j];
 				}
 
 				double result = 0.25 * win[i] / total[i] + 0.5 * owps[i] + 0.25 * owps1 / count[i];
 				bw.write(result + """"); bw.newLine();
 			}
 			
 			caseNum++;
 		}
 		
 		bw.flush();
 		bw.close();
 	}
 
 }
",0
173,15340,"import java.math.BigInteger;
 import java.util.Scanner;
 
 public class FairWarning
 {
 
 	public static void main(String[] args)
 	{
 		Scanner s = new Scanner(System.in);
 		int C = s.nextInt();
 		for (int i = 1; i <= C; i++)
 		{
 			int N = s.nextInt();
 			BigInteger[] t = new BigInteger[N];
 			for (int j = 0; j < t.length; j++)
 			{
 				t[j] = s.nextBigInteger();
 			}
 			System.out.println(""Case #""+ i + "": "" +  func(N,t));
 			
 		}
 	}
 
 	private static BigInteger func(int N, BigInteger[] r)
 	{
 		BigInteger[] t = new BigInteger[(N*(N-1))/2];
 		BigInteger min = r[0];
 		int k = 0;
 		for (int i = 0; i < r.length; i++)
 		{
 			min = r[i].min(min);
 			for (int j= i+1; j< r.length; j++)
 			{
 				t[k++] = (r[i].subtract(r[j])).abs();
 			}
 			
 		}
 		
 		BigInteger gcd = t[0].gcd(t[0]);
 		for (int i = 1; i < t.length; i++)
 		{
 			gcd = t[i].gcd(gcd);			
 		}
 		
 		BigInteger p = min.mod(gcd);
 		if (p.equals(BigInteger.ZERO))
 		{
 			return p;
 		}
 		else
 		{
 			return gcd.subtract(p);
 		}
 	}
 
 }
","import java.math.BigInteger;
 import java.util.Scanner;
 
 public class SnapperChain
 {
 
 	private static String isLightOn(long n, long k)
 	{
 		long h = (long) Math.pow(2, n);
 		if ((k % h) == (h - 1))
 		{
 			return ""ON"";
 		}
 		else
 		{
 			return ""OFF"";
 		}
 	}
 
 	public static void main(String[] args)
 	{
 		Scanner sc = new Scanner(System.in);
 		int t = sc.nextInt();
 		for (int i = 0; i < t; i++)
 		{
 			int n = sc.nextInt();
 			int k = sc.nextInt();
 			System.out.println(""Case #"" + (i+1) + "": "" + isLightOn(n, k));
 		}
 		
 	}
 
 }
",1
174,19516,"package codejam;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class TicTacToe {
 
     /**
      * @param args
      * @throws IOException
      */
     public static void main(String[] args) throws IOException {
         new TicTacToe(args);
     }
 
     public TicTacToe(String[] args) throws IOException {
 
         Scanner sc = null;
         BufferedWriter out = new BufferedWriter(new FileWriter(
                 new File(""output"")));
 
         try {
             sc = new Scanner(new File(args[0]));
         } catch (FileNotFoundException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
         int n = sc.nextInt();
 
         for (int i = 0; i < n; i++) {
 
             Boolean containsEmpty = false;
             char[][] a = new char[4][4];
             int xT = -1, yT = -1;
 
             for (int j = 0; j < 4; j++) {
                 String str = sc.next();
 
                 if (str.contains("".""))
                     containsEmpty = true;
 
                 int searchT = str.indexOf('T');
                 if (searchT != -1) {
                     xT = j;
                     yT = searchT;
                 }
 
                 for (int k = 0; k < 4; k++)
                     a[j][k] = str.charAt(k);
             }
 
 //            for (int j = 0; j < 4; j++) {
 //                for (int k = 0; k < 4; k++)
 //                    out.write(a[j][k]);
 //                out.newLine();
 //            }
 
             out.write(""Case #"" + (i + 1) + "": ""
                     + checkResult(a, containsEmpty, xT, yT));
             out.newLine();
         }
 
         out.close();
     }
 
     private String checkResult(char[][] a, boolean containsEmpty,
             int xT, int yT) {
 
         int maxEqual = 0;
         String res = ""no result"";
 
         if (xT != -1 && yT != -1) {
 
             a[xT][yT] = 'X';
             res = checkWinner(a);
             if (res.length() < 9) {
                 return res;
             }
 
             a[xT][yT] = 'O';
             res = checkWinner(a);
             if (res.length() < 9) {
                 return res;
             }
         }
 
         res = checkWinner(a);
         if (res.length() < 9) {
             return res;
         }
 
         if (res.equals(""no result"")) {
             if (containsEmpty == false)
                 return ""Draw"";
             if (containsEmpty == true)
                 return ""Game has not completed"";
         }
 
         return ""Invalid"";
 
     }
 
     private String checkWinner(char[][] a) {
         for (int i = 0; i < 4; i++) {
             // check horizontal
             if (checkEqual(a[i][0], a[i][1], a[i][2], a[i][3])) {
                 return a[i][0] + "" won"";
             }
             // check vertical
             if (checkEqual(a[0][i], a[1][i], a[2][i], a[3][i])) {
                 return a[0][i] + "" won"";
             }
         }
 
         if (checkEqual(a[0][0], a[1][1], a[2][2], a[3][3])) {
             return a[0][0] + "" won"";
         }
         if (checkEqual(a[0][3], a[1][2], a[2][1], a[3][0])) {
             return a[0][3] + "" won"";
         }
 
         return ""no result"";
     }
 
     private boolean checkEqual(char c, char d, char e, char f) {
         return ((c != '.') && (c == d) && (d == e) && (e == f));
     }
 }
","package codejam;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class TicTacToe {
 
     /**
      * @param args
      * @throws IOException
      */
     public static void main(String[] args) throws IOException {
         new TicTacToe(args);
     }
 
     public TicTacToe(String[] args) throws IOException {
 
         Scanner sc = null;
         BufferedWriter out = new BufferedWriter(new FileWriter(
                 new File(""output"")));
 
         try {
             sc = new Scanner(new File(args[0]));
         } catch (FileNotFoundException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
         int n = sc.nextInt();
 
         for (int i = 0; i < n; i++) {
 
             Boolean containsEmpty = false;
             char[][] a = new char[4][4];
             int xT = -1, yT = -1;
 
             for (int j = 0; j < 4; j++) {
                 String str = sc.next();
 
                 if (str.contains("".""))
                     containsEmpty = true;
 
                 int searchT = str.indexOf('T');
                 if (searchT != -1) {
                     xT = j;
                     yT = searchT;
                 }
 
                 for (int k = 0; k < 4; k++)
                     a[j][k] = str.charAt(k);
             }
 
 //            for (int j = 0; j < 4; j++) {
 //                for (int k = 0; k < 4; k++)
 //                    out.write(a[j][k]);
 //                out.newLine();
 //            }
 
             out.write(""Case #"" + (i + 1) + "": ""
                     + checkResult(a, containsEmpty, xT, yT));
             out.newLine();
         }
 
         out.close();
     }
 
     private String checkResult(char[][] a, boolean containsEmpty,
             int xT, int yT) {
 
         int maxEqual = 0;
         String res = ""no result"";
 
         if (xT != -1 && yT != -1) {
 
             a[xT][yT] = 'X';
             res = checkWinner(a);
             if (res.length() < 9) {
                 return res;
             }
 
             a[xT][yT] = 'O';
             res = checkWinner(a);
             if (res.length() < 9) {
                 return res;
             }
         }
 
         res = checkWinner(a);
         if (res.length() < 9) {
             return res;
         }
 
         if (res.equals(""no result"")) {
             if (containsEmpty == false)
                 return ""Draw"";
             if (containsEmpty == true)
                 return ""Game has not completed"";
         }
 
         return ""Invalid"";
 
     }
 
     private String checkWinner(char[][] a) {
         for (int i = 0; i < 4; i++) {
             // check horizontal
             if (checkEqual(a[i][0], a[i][1], a[i][2], a[i][3])) {
                 return a[i][0] + "" won"";
             }
             // check vertical
             if (checkEqual(a[0][i], a[1][i], a[2][i], a[3][i])) {
                 return a[0][i] + "" won"";
             }
         }
 
         if (checkEqual(a[0][0], a[1][1], a[2][2], a[3][3])) {
             return a[0][0] + "" won"";
         }
         if (checkEqual(a[0][3], a[1][2], a[2][1], a[3][0])) {
             return a[0][3] + "" won"";
         }
 
         return ""no result"";
     }
 
     private boolean checkEqual(char c, char d, char e, char f) {
         return ((c != '.') && (c == d) && (d == e) && (e == f));
     }
 }
",1
175,4173,"package kingdomrush;
 
 import java.util.ArrayList;
 
 
 public class KingdomRush2 {
 
     static SimpleReader reader;
     static SimpleWriter writer;
     
     static int levels;
     static int[] hard;
     static int[] easy;
     static int[] starsGained;
 
     public static void main(String[] args) {
         if (args.length != 1) {
             reader = new SimpleReader();
             writer = new SimpleWriter();
         } else {
             reader = new SimpleReader(args[0]);
             writer = new SimpleWriter(args[1]);
         }
         int cases = reader.readInt();
         for (int i = 0; i < cases; i++) {
             levels = reader.readInt();
             hard = new int[levels];
             easy = new int[levels];
             starsGained = new int[levels];
             int[] read;
             for (int j = 0; j < levels; j++) {
                 read = reader.readIntArray();
                 easy[j] = read[0];
                 hard[j] = read[1];
                 starsGained[j] = 0;
             }
             
             solve(i + 1);
             System.out.println(""Case "" + (i + 1) + "" done"");
         }
         writer.flush();
         System.out.println(""Done"");
     }
     
     private static void solve(int caseNo) {
         int stars = 0;
         int played = 0;
         while (notDone()) {
 //            System.out.println(stars);
 //            System.out.println(played);
 //            printArray(easy);
 //            printArray(hard);
             ArrayList<Integer> easyLevels = getAllEasy(stars);
             ArrayList<Integer> hardLevels = getAllHard(stars);
             if (easyLevels.size() == 0 && hardLevels.size() == 0) {
                 writer.writeLine(""Case #"" + caseNo + "": Too Bad"");
                 return;
             }
             if (hardLevels.size() == 0) { // doing an easy one
                 // find the easy level with a corresponding hard that's highest
                 int max = -1;
                 int maxLevel = -1;
                 for (Integer level : easyLevels) {
                     if (hard[level] > max) {
                         max = hard[level];
                         maxLevel = level;
                     }
                 }
                 stars += 1;
                 played += 1;
                 starsGained[maxLevel] += 1;
                 easy[maxLevel] = Integer.MAX_VALUE;
             } else {
                 // find the hard level with 2 stars available
                 boolean found = false;
                 for (Integer level : hardLevels) {
                     if (starsGained[level] == 0) {
                         stars += 2;
                         played += 1;
                         starsGained[level] = 2;
                         found = true;
                         easy[level] = Integer.MAX_VALUE;
                         hard[level] = Integer.MAX_VALUE;
                         break;
                     }
                 }
                 if (!found) {
                     int level = hardLevels.get(0);
                     stars += 1;
                     played += 1;
                     starsGained[level] = 2;
                     easy[level] = Integer.MAX_VALUE;
                     hard[level] = Integer.MAX_VALUE;
                 }
             }
         }
         
         writer.writeLine(""Case #"" + caseNo + "": "" + played);
     }
     
     private static ArrayList<Integer> getAllHard(int stars) {
         ArrayList<Integer> list = new ArrayList<>();
         for (int i = 0; i < levels; i++) {
             if (hard[i] <= stars) {
                 list.add(i);
             }
         }
         return list;
     }
 
     private static ArrayList<Integer> getAllEasy(int stars) {
         ArrayList<Integer> list = new ArrayList<>();
         for (int i = 0; i < levels; i++) {
             if (easy[i] <= stars) {
                 list.add(i);
             }
         }
         return list;
     }
 
     private static void printArray(int[] array) {
         System.out.print(""["");
         for (int i = 0; i < array.length; i++) {
             System.out.print(array[i] + "" "");
         }
         System.out.println(""]"");
     }
     
     private static void sortAscending(int[] array) {
         if (array == null) {
             return;
         }
         int a = array.length;
         int value;
         for (int outer = 1; outer < a; outer++) {
             value = array[outer] % 10000;
             for (int inner = outer - 1; inner >= 0; inner--) {
                 if (value < array[inner] % 10000) {
                     swap(array, inner, inner + 1);
                 }
             }
         }
     }
     
     private static void sortDescending(int[] array) {
         if (array == null) {
             return;
         }
         int a = array.length;
         int value;
         for (int outer = 1; outer < a; outer++) {
             value = array[outer] % 10000;
             for (int inner = outer - 1; inner >= 0; inner--) {
                 if (value > array[inner] % 10000) {
                     swap(array, inner, inner + 1);
                 }
             }
         }
     }
     
     private static void swap(int[] array, int i, int j) {
         int temp = array[i];
         array[i] = array[j];
         array[j] = temp;
     }
     
     private static boolean notDone() {
         for (int i = 0; i < levels; i++) {
             if (hard[i] != Integer.MAX_VALUE) {
                 return true;
             }
         }
         return false;
     }
 }
","package equalsums;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 
 public class SimpleReader {
 
 	private BufferedReader br;
 	private int line = 0;
 	
 	public SimpleReader() {
 		String filename = prompt();
 		setReader(filename);
 	}
 	
 	public SimpleReader(String filename) {
 		setReader(filename);
 	}
 	
 	private String prompt() {
 		System.out.println(""Input file: "");
 		BufferedReader bufr = new BufferedReader(
 									new InputStreamReader(System.in));
 		String filename = null;
 		try {
 			filename = bufr.readLine();
 		} catch (IOException e) {
 			System.err.println(""At prompt: "" + e.getMessage());
 		}
 		return filename;
 	}
 	
 	private void setReader(String filename) {
 		try {
 			br = new BufferedReader(new FileReader(filename));
 		} catch (IOException e) {
 			System.err.println(e.getMessage());
 		}
 	}
 	
 	public String readLine() {
 		try {
 			line++;
 			return br.readLine();
 		} catch (IOException e) {
 			System.err.println(""Line "" + (line - 1) + "": "" + e.getMessage());
 			return null;
 		}
 	}
 	
 	public int readInt() {
 		return Integer.parseInt(readLine());
 	}
 	
 	public int[] readIntArray() {
 		String[] tokens = readLine().split("" "");
 		int[] ret = new int[tokens.length];
 		for (int i = 0; i < tokens.length; i++) {
 			ret[i] = Integer.parseInt(tokens[i]);
 		}
 		return ret;
 	}
 	
 	public String[] readStringArray() {
 		return readLine().split("" "");
 	}
 }
",1
176,2643,"import java.io.*;
 import java.util.*;
 
 public class Chicks
 {
     public static void main(String[] args)throws IOException
     {
         BufferedReader in = new BufferedReader(new FileReader(""B-small-attempt2.in""));
         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""B-small.out"")));
         int tt = Integer.parseInt(in.readLine());
         for(int c = 1; c <= tt; ++c)
         {
             int ans = 0;
             StringTokenizer st = new StringTokenizer(in.readLine());
             int n = Integer.parseInt(st.nextToken());
             int k = Integer.parseInt(st.nextToken());
             int b = Integer.parseInt(st.nextToken()); // barn
             int t = Integer.parseInt(st.nextToken()); // time
             int chicksX[] = new int[n];
             int chicksV[] = new int[n];
             
             boolean[] validChicks = new boolean[n];
             
             st = new StringTokenizer(in.readLine());
             StringTokenizer st2 = new StringTokenizer(in.readLine());
             for(int i = 0 ; i < n; ++i)
             {
                 chicksX[i] = Integer.parseInt(st.nextToken());
                 chicksV[i] = Integer.parseInt(st2.nextToken());
                 validChicks[i] = (chicksV[i]*t +chicksX[i] >= b);
                 if(validChicks[i])
                     k--;
             }
             int index = 0;
    //         System.out.println(Arrays.toString(validChicks));
             if(k>0){
                 out.printf(""Case #%d: %s%n"",c,(""IMPOSSIBLE""));
                 continue;
             }
             while(k<0)
             {
                 if(validChicks[index])
                 {
                     validChicks[index]=false;
                     k++;
                 }
                 index++;
             }
             for(int i = n-1 ; i >= 0; i--)
             {
                 if(validChicks[i])
                 {
                     for(int j = i+1; j < n; j++)
                     {
                         if(!validChicks[j])
                             ans++;
                     }
                 }
             }
             
             out.printf(""Case #%d: %s%n"",c,(k<=0?ans+"""":""IMPOSSIBLE""));
         }
         out.close();
     }
     public static void swap(int[] a, int b[], boolean[] c, int x, int y)
     {
         int temp = a[x];
         a[x] = a[y];
         a[y] = temp;
         temp = b[x];
         b[x] = b[y];
         b[y] = temp;
         boolean tempc = c[x];
         c[x] = c[y];
         c[y] = c[x];
     }
 }","import java.io.*;
 import java.util.*;
 
 public class DancingWithTheGooglers{
     public static void main(String[] args) throws Exception{
         BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
         PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
         
         int n = Integer.parseInt(in.readLine());
         
         for(int i = 0; i < n; ++i){
             StringTokenizer st = new StringTokenizer(in.readLine());
             int T = Integer.parseInt(st.nextToken());
             int S = Integer.parseInt(st.nextToken());
             int p = Integer.parseInt(st.nextToken());
             int[] normal = new int[T];
             int[] surprising = new int[T];
             for(int j = 0; j < T; ++j){
                 int sum = Integer.parseInt(st.nextToken());
                 if(sum%3 == 2){
                     normal[j] = sum/3+1;
                     if(sum/3+2 <= 10)
                         surprising[j] = sum/3+2;
                     else
                         surprising[j] = sum/3+1;
                 }else if(sum%3 == 1){
                     normal[j] = sum/3+1;
                     surprising[j] = sum/3+1;
                 }else{
                     normal[j] = sum/3;
                     if(sum/3 - 1 >= 0 && sum/3+1 <= 10)
                         surprising[j] = sum/3+1;
                     else
                         surprising[j] = sum/3;
                 }
             }
             int ans = 0;
             for(int j = 0; j < T; ++j){
                 if(S > 0 && normal[j] < p && surprising[j] >= p){
                     --S;
                     ++ans;
                 }else if(normal[j] >= p){
                     ++ans;
                 }
             }
             out.println(""Case #""+(i+1)+"": ""+ans);
         }
         out.close();
     }
 }
 
     ",1
177,18290,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package qualificationRound2012;
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  *
  * @author AHMED
  */
 public class DancingWithGooglers2 {
     
     public static void main(String[] args) throws Exception{
         DancingWithGooglers2 a = new DancingWithGooglers2();
     }
     
     private final int SURPRISING_INDEX = 0;
     private final int ALLOWED_INDEX = 1;
     public DancingWithGooglers2() throws Exception{
         Scanner in = new Scanner(new File(""B-small-attempt3.in""));
         PrintWriter out = new PrintWriter(new File(""B-small-attempt3.out""));
         int T,N,S,P;
         int result;
         int[] scores;
         int maxGooglers;
         T = Integer.parseInt(in.nextLine());
         
         for(int testCaseIndex = 1 ; testCaseIndex <= T ; testCaseIndex++){
             N = in.nextInt();
             S = in.nextInt();
             P = in.nextInt();
             scores = new int[N];
             for(int dancerIndex = 0 ; dancerIndex < N ; dancerIndex++){
                 scores[dancerIndex] = in.nextInt();
             }
             
             result = getResult(N, S, P, scores);                                                                                                                                                    
             
            // maxGooglers = solve(result , S);
             maxGooglers =  getResult(N, S, P, scores);
             out.print(""Case #""+testCaseIndex+"": ""+maxGooglers);
             if(testCaseIndex!=T)out.print(""\n"");
         }//testCaseIndec-loop
         out.close();
         in.close();
     }//constructor
     
     
     private int getResult (int n, int s, int p, int[] scores) throws Exception{
 //        int[] grades = new int[3];
 //        int surprisingCount = 0;
         int statues;
         boolean[][] result = new boolean[scores.length][2];
 //        PrintWriter temp = new PrintWriter(new File(""temp.out""));
         for(int i = 0 ; i < result.length ; i++)
         Arrays.fill(result[i], false);
         
         for(int scoresIndex = 0 ; scoresIndex<scores.length ; scoresIndex++){
             //construct possible triplets
             for(int judge1=0;judge1<=10;judge1++){
                 
                 for(int judge2=judge1;judge2<=10;judge2++){
                     
                     for(int judge3=judge2;judge3<=10;judge3++){
                         if((judge1+judge2+judge3) == scores[scoresIndex]){
                             statues = isAllowedTriplet(judge1,judge2,judge3, p);
                             if(statues == 1){
 //                                temp.println(judge1+"" ""+judge2+"" ""+judge3);
                                 result[scoresIndex][SURPRISING_INDEX]=true;
                                 //judge1=11;judge2=11;judge3=11;
                             }
                             else if(statues == 2){
 //                                temp.println(judge1+"" ""+judge2+"" ""+judge3); 
                                 result[scoresIndex][ALLOWED_INDEX]=true;
                                 //judge1=11;judge2=11;judge3=11;
                             }
                         }
                     }
                 }
             }
         }//scoresIndex-loop
 //       
 //        
 //        for(int i = 0 ; i < result.length ; i++){
 //            for(int j = 0 ; j < result[i].length ; j++){
 //                temp.print(result[i][j]+"" "");
 //            }
 //            temp.println();
 //        }
 //         temp.close();
         return solve(result ,s);
     }
     
     private int solve(boolean[][] list , int s){
         int sum = 0;
         
         //search for surprising only.
         for(int i = 0 ; i < list.length ; i++){
             if(s > 0){
                 if(list[i][SURPRISING_INDEX] && !list[i][ALLOWED_INDEX]){
                     s--;
                     sum++;
                 }
             }
         }
         
         //search for remaining surprising.
         for(int i = 0 ; i < list.length ; i++){
             if(s > 0){
                 if(list[i][SURPRISING_INDEX]){
                     list[i][ALLOWED_INDEX] = false;
                     s--;
                     sum++;
                 }
             }
         }
         
         //search for not surprising
         for(int i = 0 ; i < list.length ; i++)
             if(list[i][ALLOWED_INDEX])sum++;
         
         return sum;
     }
     
     private int isAllowedTriplet(int a, int b, int c, int max){
     //return 0 if rejected, 1 if surprising, 2 if not surprising.
 
     //check if one of the scores is less than the max.
     if( (a < max) && (b < max) && (c < max))return 0;
     
     //check if not happend
     if( (a-b) > 2)return 0;
     if( (a-c) > 2)return 0;
     if( (b-c) > 2)return 0;
     if( (b-a) > 2)return 0;
     if( (c-a) > 2)return 0;
     if( (c-b) > 2)return 0;
     //check if surprising
     if( (a-b) == 2)return 1;
     if( (a-c) == 2)return 1;
     if( (b-c) == 2)return 1;
     if( (b-a) == 2)return 1;
     if( (c-a) == 2)return 1;
     if( (c-b) == 2)return 1;
     //it must be not suprising
     return 2;
 }
 
 }//end_of_class
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package qualificationRound2012;
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author AHMED
  */
 public class RecycledNumbers {
     public static void main(String[] args)throws Exception{
         RecycledNumbers r = new RecycledNumbers();
         //System.out.println(isRecycledPair(12345 , 51234));
         //System.out.println(""0123456"".substring(2,6));
         //414144414
         //441414441        
     }
     
     public RecycledNumbers() throws Exception{
         Scanner sc = new Scanner(new File(""C-small-attempt0.in""));
         PrintWriter pin = new PrintWriter(new File(""C-small-attempt0.out""));
         int T = Integer.parseInt(sc.nextLine());
         int A,B;
         int counter = 0;
         int x = 0;
         for(int testCaseIndex = 1 ; testCaseIndex <=T ; testCaseIndex++){
             A = sc.nextInt();
             B = sc.nextInt();
             //System.out.println(A+"" ""+B);
             for(int n = A ; n <= B ;n++){
                 for(int m = (n+1) ; m<=B ;m++){
                     //pin.print(n+"" ""+m);
                     if(isRecycledPair(n,m))counter++;  
                 }
             }
             pin.print(""Case #""+testCaseIndex+"": ""+counter);
             if(testCaseIndex!=T)pin.print(""\n"");
             counter = 0;
         }
         pin.close();
         sc.close();
     }
     
     private static boolean isRecycledPair(int n, int m){
         if(n<10 && m<10)return false;//all digits < 10 cannto be recycled.
         
         String nString = Integer.toString(n);
         String mString = Integer.toString(m);
         int length = nString.length();
         int starting_mIndex = 0;
         String temp;
         
         for(int index = 0 ; index < length ; index++){
             for(starting_mIndex = 0 ; starting_mIndex < length ; starting_mIndex++){
                 temp = mString.substring(starting_mIndex);
                 temp+=mString.substring(0, starting_mIndex);
                 if(temp.equals(nString))return true;
             }
         }
         
         return false;
         /*
         String nString = Integer.toString(n);
         String mString = Integer.toString(m);
         int length = mString.length();
         int nStringIndex;
         int mStrinIndex = mString.indexOf(nString.charAt(0)+"""");//starting index
         
         //System.out.println(mStrinIndex);
         
         if(mStrinIndex == -1)return false;
         
         for(nStringIndex = 0 ; nStringIndex < length ; nStringIndex++){
             if(nString.charAt(nStringIndex)!=mString.charAt(mStrinIndex))return false;
             mStrinIndex = (mStrinIndex+1)%length;
         }
         
         return true;*/
     }
 }
",1
178,18674,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.HashMap;
 import java.util.Map;
 
 
 public class ThemePark {
 	
 	public static int[] preCompute(long k, long[] group, long[] sumResult){
 		int[] result = new int[group.length];
 		for(int i = 0; i < group.length; i++){
 			long total = group[i];
 			if(total > k){
 				result[i] = -1;
 				continue;
 			}else if(group.length == 1){
 				result[i] = i;
 				sumResult[i] = total;
 				continue;
 			}else{
 				boolean flag = true;
 				for(int j = ((i+1)%group.length); j!=i; j=((j+1)%group.length)){
 					total += group[j];
 					if(total > k){
 						flag = false;
 						sumResult[i] = total - group[j];
 						result[i] = j;
 						break;
 					}
 				}
 				if(flag){
 					sumResult[i] = total;
 					result[i] = i;
 				}
 			}
 		}
 		return result;
 	}
 	
 	
 	public static void deal(String file) throws Exception{
 		String line;
 		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file),""utf8""));
 		line = reader.readLine();
 		int T = Integer.parseInt(line);
 		for(int no = 1; no <= T; no++){
 			String[] opts = reader.readLine().split(""\\s+"");
 			int R = Integer.parseInt(opts[0]);
 			int k = Integer.parseInt(opts[1]);
 			int N = Integer.parseInt(opts[2]);
 			String[] groups = reader.readLine().split(""\\s+"");
 			long[] group = new long[N];
 			for(int i = 0; i < N; i++){
 				group[i] = Long.parseLong(groups[i]);
 			}
 			long sumResult[] = new long[N];
 			int maxEnd[] = preCompute(k,group,sumResult);
 			int times = R;
 			long total = 0;
 			int index = 0;
 			while(times>0){
 				times--;
 				if(maxEnd[index]!=-1){
 					total += sumResult[index];
 					index = maxEnd[index];
 				}else{
 					break;
 				}
 			}
 			out.println(""Case #""+no+"": ""+total);
 		}
 		//out.close();		
 	}
 	
 	
 	static PrintWriter out; 
 	public static void main(String[] args) throws Exception{
 		// TODO Auto-generated method stub
 		out = new PrintWriter(new File(""result-out.txt""));
 		deal(""C-small-attempt1.in"");
 		//deal(""test.txt"");
 		out.close();
 		
 	}
 
 }
","import java.util.Scanner;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.ArrayList;
 import java.io.PrintStream;
 import java.io.OutputStream;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.io.FileInputStream;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""D-small-attempt0.in"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""gcj4.out"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		Scanner in = new Scanner(inputStream);
 		PrintWriter out = new PrintWriter(outputStream);
 		GCJ4 solver = new GCJ4();
 		solver.solve(1, in, out);
 		out.close();
 	}
 }
 
 class GCJ4 {
     int[] DX = {1,1,-1,-1};
     int[] DY = {1,-1,1,-1};
     double EPS = 1e-9;
 	public void solve(int testNumber, Scanner in, PrintWriter out) {
         int cases = in.nextInt();
         for(int caseNum =0;caseNum<cases;caseNum++) {
             int res = 0;
             int I = in.nextInt();
             int J = in.nextInt();
             int D = in.nextInt();
             int SX = -1;
             int SY = -1;
             in.nextLine();
             String[] m = new String[I];
             for(int i=0;i<I;i++) {
                 m[i] = in.nextLine();
                 for(int j=0;j<J;j++) {
                     if(m[i].charAt(j)=='X') {
                         SX = j;
                         SY = i;
                     }
                 }
             }
             for(int y=0;y<=50;y++) {
                 for(int x=0;x<=50;x++) {
                     next_try: for(int k=0;k<4;k++) {
                         if(x==0 && y==0)continue;
                         if(IntLib.gcd(x,y)>1)continue;
                         int dx = DX[k];
                         int dy = DY[k];
                         if(dx==-1 && x==0 || dy==-1 && y==0)continue;
                         if(x==0)dx=0;
                         if(y==0)dy=0;
                         double dist = 0;
                         int curX = SX;
                         int curY = SY;
                         int ddx = 0;
                         int ddy = 0;
                         //debug(""NEXT"",x,y);
                         while(ddx*ddx+ddy*ddy<=D*D) {
                             //if(x==3 && y==7)debug(ddx,ddy);
                             boolean goRight = false;
                             boolean goUp = false;
                             if(y==0)goRight = true;
                             else if(x==0)goUp = true;
                             else {
                                 int minAnchor = Math.min(ddx/x,ddy/y);
                                 int fromAnchorX = ddx-x*minAnchor;
                                 int fromAnchorY = ddy-y*minAnchor;
                                 if(x%2==1 && y%2==1 && fromAnchorX==(x+1)/2-1 && fromAnchorY==(y+1)/2-1) {
                                     goRight = goUp = true;
                                 }
                                 else {
                                     if(GeomLib.cross2D(0.,0.,x,y,ddx+.5,ddy+.5)>0) {
                                         goRight = true;
                                     }
                                     else goUp = true;
                                 }
                             }
                             int nextX = curX;
                             int nextY = curY;
                             if(goRight) {
                                 nextX+=dx;
                             }
                             if(goUp) {
                                 nextY+=dy;
                             }
                             if(m[nextY].charAt(nextX)=='#') {
                                 if(goUp && goRight) {
                                     if(m[curY].charAt(nextX)=='#' && m[nextY].charAt(curX)=='#') {
                                         int ma = Math.min(ddx/x,ddy/y);
                                         double fx = x*ma;
                                         double fy = y*ma;
                                         double smx = x*.5;
                                         double smy = y*.5;
                                         if(Math.sqrt(fx*fx+fy*fy)+Math.sqrt(smx*smx+smy*smy)-EPS<D*.5) {
                                             //debug(""CORNER"",x*DX[k],y*DY[k],curX,curY);
                                             res++;
                                         }
                                         continue next_try;
                                     }
                                     else if(m[curY].charAt(nextX)=='#') {
                                         nextX -=dx;
                                         dx=-dx;
                                     }
                                     else if(m[nextY].charAt(curX)=='#') {
                                         nextY -= dy;
                                         dy=-dy;
                                     }
                                     else continue next_try;//lost ray
                                 }
                                 else if (goUp) {
                                     if(x==0) {
                                         if(Math.abs(SY-nextY)*2-1<=D) {
                                             //debug(""VER REFLECT"",x*DX[k],y*DY[k]);
                                             res++;
                                         }
                                         continue next_try;
                                     }
                                     nextY-=dy;
                                     dy=-dy;
                                 }
                                 else if (goRight) {
                                     if(y==0) {
                                         if(Math.abs(SX-nextX)*2-1<=D) {
                                             //debug(""HOR REFLECT"",x*DX[k],y*DY[k]);
                                             res++;
                                         }
                                         continue next_try;
                                     }
                                     nextX-=dx;
                                     dx=-dx;
                                 }
                                 else throw new RuntimeException();
                             }
 
                             if(goRight) {
                                 ddx++;
                             }
                             if(goUp) {
                                 ddy++;
                             }
 
                             if(nextY == SY && nextX == SX) {
                                 int ma = Math.min(ddx/x,ddy/y);
                                 if(ddx==ma*x && ddy==ma*y) {
                                     if(ddx*ddx +ddy*ddy <=D*D) {
                                         //debug(""BOUNCY"",x*DX[k],y*DY[k]);
                                         res++;
                                     }
                                     continue next_try;
                                 }
                             }
                             curX = nextX;
                             curY = nextY;
                         }
                     }
                 }
             }
             
             out.println(""Case #""+(caseNum+1)+"": ""+res);
             debug(""Case #""+(caseNum+1)+"": "",m);
         }
 	}
     void debug(Object...os) {
     // BEGIN CUT HERE
         System.out.println(Arrays.deepToString(os));
     // END CUT HERE
     }
 }
 
 class IntLib {
     public static int gcd(int a, int b) {
         if(b==0)return a;
         else return gcd(b,a%b);
     }
     }
 
 class GeomLib {
     public static double cross2D(double ax, double ay, double bx, double by, double cx, double cy) {
         double abx = bx-ax;
         double aby = by-ay;
         double acx = cx-bx;
         double acy = cy-by;
         return abx*acy - aby*acx;
     }
 }
 
",0
179,11755,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class FairAndSquare {
 
 	public static void main(String[] args) throws IOException {
 		File inputFile = new File(""E:\\Code-Jam\\FairAndSquare\\C-small-attempt0.in"");
 		File outputFile = new File(""E:\\Code-Jam\\FairAndSquare\\C-small-attempt0.out"");
 		BufferedReader reader = new BufferedReader(new FileReader(inputFile));
 		BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
 		// For small value range, keep 1000
 		int[] numberRange = new int[1001];
 		for (int i = 0; i < 1001; i++) {
 			numberRange[i] = 0;
 		}
 		int number = 1;
 		while (number * number <= 1000) {
 			if (checkIfPallindrome(number) && checkIfPallindrome(number * number)) {
 				numberRange[number * number] = 1;
 			}
 			number++;
 		}
 		int noOfTestCases = Integer.parseInt(reader.readLine());
 		for (int i = 1; i <= noOfTestCases; i++) {
 			String[] range = reader.readLine().split("" "");
 			int minVal = Integer.parseInt(range[0]);
 			int maxVal = Integer.parseInt(range[1]);
 			int sum = 0;
 			for(int j=minVal; j<=maxVal; j++) {
 				if(numberRange[j] == 1) {
 					sum++;
 				}
 			}
 			String line = ""Case #"" + i + "": "" + sum + ""\n"";
 			writer.write(line);
 		}
 		reader.close();
 		writer.close();
 	}
 
 	private static boolean checkIfPallindrome(int i) {
 		String number = Integer.toString(i);
 		int x = 0;
 		int y = number.length() - 1;
 		while (x < y) {
 			if(number.charAt(x) != number.charAt(y)){
 				return false;
 			}
 			x++;
 			y--;
 		}
 		return true;
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class FairAndSquare {
 
 	public static void main(String[] args) throws IOException {
 		File inputFile = new File(""E:\\Code-Jam\\FairAndSquare\\C-small-attempt0.in"");
 		File outputFile = new File(""E:\\Code-Jam\\FairAndSquare\\C-small-attempt0.out"");
 		BufferedReader reader = new BufferedReader(new FileReader(inputFile));
 		BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
 		// For small value range, keep 1000
 		int[] numberRange = new int[1001];
 		for (int i = 0; i < 1001; i++) {
 			numberRange[i] = 0;
 		}
 		int number = 1;
 		while (number * number <= 1000) {
 			if (checkIfPallindrome(number) && checkIfPallindrome(number * number)) {
 				numberRange[number * number] = 1;
 			}
 			number++;
 		}
 		int noOfTestCases = Integer.parseInt(reader.readLine());
 		for (int i = 1; i <= noOfTestCases; i++) {
 			String[] range = reader.readLine().split("" "");
 			int minVal = Integer.parseInt(range[0]);
 			int maxVal = Integer.parseInt(range[1]);
 			int sum = 0;
 			for(int j=minVal; j<=maxVal; j++) {
 				if(numberRange[j] == 1) {
 					sum++;
 				}
 			}
 			String line = ""Case #"" + i + "": "" + sum + ""\n"";
 			writer.write(line);
 		}
 		reader.close();
 		writer.close();
 	}
 
 	private static boolean checkIfPallindrome(int i) {
 		String number = Integer.toString(i);
 		int x = 0;
 		int y = number.length() - 1;
 		while (x < y) {
 			if(number.charAt(x) != number.charAt(y)){
 				return false;
 			}
 			x++;
 			y--;
 		}
 		return true;
 	}
 
 }
",1
180,8335,"package codejam.round.one.b;
 
 import java.io.File;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.concurrent.Future;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
 
 public class B {
 	
 	
 	private static final String FILE_IN = ""resources/B-small-attempt0.in"";
 	private static final String FILE_OUT = ""resources/B-small-attempt0.out"";
 	
 	private long allStart;
 	
 	private static final String OUT_FORMAT = ""Case #%d: %s"";
 	
 	
 	private SortedMap<Integer, String> outputLines = Collections.synchronizedSortedMap(new TreeMap<Integer, String>());
 
     private ThreadPoolExecutor executor = new ThreadPoolExecutor(8, 8, 5, TimeUnit.DAYS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
         @Override
         public Thread newThread(Runnable r) {
             Thread thread = new Thread(r);
             thread.setDaemon(true);
             return thread;
         }
     });
 	
 	
 	public static void main(String[] args) throws Exception {
 		Scanner in = new Scanner ( new File ( FILE_IN ) );
 		
 		int testCount = in.nextInt();
 		List<InputData> inputDataList = new ArrayList<>();
 		for ( int test = 0; test < testCount; ++test ) {
 			InputData inputData = new InputData(in);
 			inputDataList.add(inputData);
 		}
 		in.close();
 		B template = new B();
 		template.run(inputDataList);
 	}
 	
 	
 	private void run(List<InputData> inputDataList) throws Exception {
 		allStart = System.currentTimeMillis();
 		
 		Path outPath = Paths.get(FILE_OUT);
 		Charset charset = Charset.forName(""US-ASCII"");
 
 		List<Future<?>> tasks = new ArrayList<>(inputDataList.size());
 		int i = 0;
 		for (final InputData inputData : inputDataList){
 			final int fi = i++;
 			tasks.add(executor.submit(new Runnable() {
                 @Override
                 public void run() {
                     try {
                         runCase((fi+1), inputData);
                     } catch (Throwable t) {
                         t.printStackTrace();
                     }
                 }
             }));
 		}
 		for (Future<?> task : tasks) {
             task.get();
         }
 		long allEnd = System.currentTimeMillis();
 		
 		System.out.printf ( ""%dms\n"", allEnd-allStart );
 		Files.write(outPath, outputLines.values(), charset, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
 	}
 
 	 public void runCase(int caseNumber, InputData inputData) {
 		 long result = 0;
 		 for (long ai = 0; ai < inputData.a; ai++){
 			 for (long bi = 0; bi < inputData.b; bi++){
 				 long and = ai & bi;
 				 if (and < inputData.k){
 					 result++;
 				 }
 			 }
 		 }
 		 outputLines.put(caseNumber, String.format(Locale.ENGLISH, OUT_FORMAT, caseNumber, result));
 	 }
 
 	private static class InputData {
 		private long a;
 		private long b;
 		private long k;
 		
 		
 		public InputData(Scanner in){
 			a = in.nextLong();
 			b = in.nextLong();
 			k = in.nextLong();
 		}
 
 
 		@Override
 		public String toString() {
 			return ""InputData [a="" + a + "", b="" + b + "", k="" + k + ""]"";
 		}
 	}
 }
 
 
 
 
 
 
 
 
","package codejam.qualification;
 
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.TreeSet;
 
 
 public class War {
 	
 	
 	private static final String FILE_IN = ""resources/D-small-attempt0.in"";
 	private static final String FILE_OUT = ""resources/D-small-attempt0.out"";
 	
 	
 	private static final String OUT_FORMAT = ""Case #%d: %d %d"";
 	
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner ( new File ( FILE_IN ) );
 		Path outPath = Paths.get(FILE_OUT);
 		Charset charset = Charset.forName(""US-ASCII"");
 		List<String> outLines = new ArrayList<>();
 		
 		int testCount = in.nextInt();
 
 		long allStart = System.currentTimeMillis();
 		for ( int test = 0; test < testCount; ++test ) {
 			InputData inputData = new InputData(in);
 			int[] points = calculatePoints(inputData);
 //			System.err.println(""test: "" + (test+1) + ""; "" + inputData + "" ; points: "" + Arrays.toString(points));
 			outLines.add(String.format(Locale.ENGLISH, OUT_FORMAT, (test+1), points[0], points[1]));
 		}
 		in.close();
 		long allEnd = System.currentTimeMillis();
 		
 		System.out.printf ( ""%dms\n"", allEnd-allStart );
 		Files.write(outPath, outLines, charset, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
 	}
 	
 	
 
 
 	private static int[] calculatePoints(InputData inputData) {
 		int wrongWar = calculateWrongWar(inputData);
 		int war = calculateWar(inputData);
 		
 		return new int[]{wrongWar, war};
 	}
 
 
 	
 	
 	private static int calculateWrongWar(InputData inputData) {
 		List<Double> naomies = new ArrayList<>(inputData.naomies);
 		List<Double> kens = new ArrayList<>(inputData.kens);
 		
 		Collections.sort(naomies);
 		Collections.sort(kens);
 		
 //		System.err.println(naomies);
 //		System.err.println(kens);
 		
 		int points = 0;
 		int size = naomies.size();
 		for (int i = 0; i < size; i++){
 			Double nBlock = naomies.get(i);
 			Double kBlock = kens.get(i);
 			if (Double.compare(nBlock, kBlock) > 0){
 				points++;
 			}else{
 				kens.add(i, kens.get(size-1));
 			}
 		}
 		
 		return points;
 	}
 
 
 	private static int calculateWar(InputData inputData) {
 		List<Double> naomies = new ArrayList<>(inputData.naomies);
 		Set<Double> kens = new TreeSet<>(inputData.kens);
 		int points = 0;
 		for (Double nBlock : naomies){
 			boolean struck = false;
 			for (Double kBlock : kens){
 				if (Double.compare(nBlock, kBlock) < 0){
 					kens.remove(kBlock);
 					struck = true;
 					break;
 				}
 			}
 			if (!struck){
 				points++;
 			}
 		}
 		return points;
 	}
 
 
 
 
 
 
 	private static class InputData {
 		private int blocks;
 		private List<Double> naomies;
 		private List<Double> kens;
 		
 		public InputData(Scanner in){
 			naomies = new ArrayList<>();
 			kens = new ArrayList<>();
 			blocks = in.nextInt();	
 			for (int i = 0; i < blocks; i++){
 				naomies.add(Double.valueOf(in.next()));
 			}
 			for (int i = 0; i < blocks; i++){
 				kens.add(Double.valueOf(in.next()));
 			}
 		}
 
 		@Override
 		public String toString() {
 			return ""InputData [blocks="" + blocks + "", naomies="" + naomies
 					+ "", kens="" + kens + ""]"";
 		}
 	}
 }
 
 
 
 
 
 
 
 
",1
181,10106,"import java.io.*;
 import java.util.*;
 
 class Recycled
 {
 	static boolean[] check = new boolean[2000000];
 
 	public static void main (String [] args) throws IOException 
 	{
 		BufferedReader in = new BufferedReader(new FileReader(""C-small-attempt0.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""C-small-attempt0.out"")));
 		
 		StringTokenizer st = new StringTokenizer(in.readLine());
 		int numCases = Integer.parseInt(st.nextToken());
 		
 		for (int caseIndex = 0; caseIndex < numCases; caseIndex++)
 		{
 			out.print(""Case #"" + (caseIndex + 1) + "": "");
 			
 			st = new StringTokenizer(in.readLine());
 			int min = Integer.parseInt(st.nextToken());
 			int max = Integer.parseInt(st.nextToken());
 			
 			// Reset check
 			for (int i = 0; i < 2000000; i++)
 			{
 				check[i] = false;
 			}
 			
 			int result = 0;
 			for (int i = min; i <= max; i++)
 			{
 				result += countRecycledNumbers(i, min, max);
 			}
 			
 			out.print(result);
 			
 			out.println();
 		}
 		
 		out.close();
 	}
 	
 	public static ArrayList<Integer> generateRecycledNumbers(int x)
 	{
 	
 		// Count number of digits
 		int y = x;
 		int numDigits = 0;
 		while (y > 0)
 		{
 			numDigits ++;
 			y /= 10;
 		}
 		
 		// Get the list of digits
 		int[] listDigits = new int[numDigits];
 		int index = numDigits-1;
 		while (x > 0)
 		{
 			listDigits[index] = x%10;
 			x /= 10;
 			index --;
 		}
 		
 		// Generate all possible recycled number from x
 		ArrayList<Integer> result = new ArrayList<Integer>();
 		
 		for (int i = 0; i < numDigits; i++)
 		{
 			if (listDigits[i] == 0)
 				continue;
 			
 			int num = 0;
 			
 			for (int j = 0; j < numDigits; j++)
 			{
 				num = num*10 + listDigits[(i+j)%numDigits];
 			}
 			
 			result.add(num);
 		}
 		
 		return result;
 	}
 	
 	public static int countRecycledNumbers(int x, int min, int max)
 	{
 		if (check[x])
 		{
 			return 0;
 		}
 		else
 		{
 			ArrayList<Integer> recycledNumbers = generateRecycledNumbers(x);
 			Collections.sort(recycledNumbers);
 			
 			int numDistinctNumbers = 0;
 			
 			for (int i = 0; i < recycledNumbers.size(); i++)
 			{
 				check[recycledNumbers.get(i)] = true;
 				
 				if (i > 0 && recycledNumbers.get(i) > recycledNumbers.get(i-1) && recycledNumbers.get(i) >= min && recycledNumbers.get(i) <= max)
 				{
 					numDistinctNumbers++;
 				}
 				else if (i == 0 && recycledNumbers.get(i) >= min && recycledNumbers.get(i) <= max)
 				{
 					numDistinctNumbers++;
 				}
 			}
 			
 			return (numDistinctNumbers*(numDistinctNumbers-1)/2);
 		}
 	}
 }","import java.util.Scanner;
 
 
 public class Chelp {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		/*Scanner sc = new Scanner(System.in);
 		int t = sc.nextInt();
 		
 		int a,b;
 		for (int i = 1; i <= t; i++) {
 			a = sc.nextInt();
 			b = sc.nextInt();
 			for(Integer j = a; j <= b; j++){
 				
 			}
 		}*/
 		String j,k;
 		int sum,t,m;
 		for(Integer i = 1;i<=Math.pow(10, 50);i++){
 			k = i.toString();
 			j = (new StringBuffer(k)).reverse().toString();
 			if(Integer.parseInt(j)-i==0){
 				sum= 0;
 				m=i;
 				for(int n = 0; sum <10 && n  < k.length();n++){
 					//t = Integer.parseInt(k.substring(n, n+1)) ;
 					t = m%10;
 					m=m/10;
 					sum += t*t;
 				}
 				if(sum < 10 ){
 					System.out.print(i+"","");
 				}
 			}
 		}
 	}
 
 }
",0
182,626,"package com.mademoisellegeek.googlecodejam.y2012.qualround;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
 
 public class RecycledNumbers implements Runnable {
 
     BufferedReader in;
     BufferedWriter out;
     static String inputFile = ""C-large.in"";
     static String outputFile = ""2012-qualround-C-large.out"";
 
     public void run() {
 
         try {
             in = new BufferedReader(new FileReader(inputFile));
             out = new BufferedWriter(new FileWriter(outputFile));
             try {
                 String line = in.readLine();
                 int nbCases = Integer.parseInt(line);
                 for (int i=1; i<=nbCases; i++) {
                     line = in.readLine();
                     String [] lineArray = line.split("" "");
                     int min = Integer.parseInt(lineArray[0]);
                     int max = Integer.parseInt(lineArray[1]);
                     out.write(""Case #"" + i + "": "" + solve(min, max) + ""\n"");
                 }
             } finally {
                 in.close();
             }
             out.flush();
         } catch (Exception ex) {
             ex.printStackTrace();
         }
     }
 
     private int solve(int min, int max) {
         HashMap recycled = new HashMap();
         for (int i=min; i<=max; i++) {
             for (int j=1; j< nbDigits(i); j++) {
                 int result = move(i, j);
                 if (result != i && result <= max && result >= min) {
                     int small = Math.min(result, i);
                     int big = Math.max(result, i);
                     if (!recycled.containsKey(small)) {
                         ArrayList empty = new ArrayList();
                         empty.add(big);
                         recycled.put(small,empty);
                     }
                     else {
                         ArrayList list = (ArrayList) recycled.get(small);
                         if (!list.contains(big))
                             list.add(big);
                         recycled.put(small,list);
                     }
                 }
             }
         }
         int result = 0;
         for (Object list : recycled.values()) {
             result += ((ArrayList)list).size();
         }
         return result;
     }
 
     private int move(int i, int j) {
         String whole = String.valueOf(i);
         String suffix = whole.substring(whole.length()-j);
         String prefix = whole.substring(0, whole.length()-j);
         return Integer.parseInt(suffix+prefix);
     }
 
     private int nbDigits(int j) {
         return String.valueOf(j).length();
 
     }
 }
","import java.io.*;
 import java.util.*;
 import static java.lang.System.*;
 
 public class C {
 	static class Node {
 		Node[] next;
 		boolean tag;
 		public Node(){
 			next = new Node[26];
 			tag = false;
 		}
 	}
 	static Node insert(Node curr, String str) {
 		if (curr == null) {
 			curr = new Node();
 		}
 		if (str.length() == 0) {
 			curr.tag = true;
 			return curr;
 		}
 		else {
 			int c = str.charAt(0) - 'a';
 			curr.next[c] = insert(curr.next[c], str.substring(1));
 			return curr;
 		}
 	}
 	static boolean contains(Node curr, String str) {
 		if (curr == null) {
 			return false;
 		}
 		else if (str.length() == 0) {
 			return curr.tag;
 		}
 		else {
 			String kapos = str.substring(1);
 			int c = str.charAt(0);
 			if (c == '.') {
 				for (int i = 0; i < 26; i++) {
 					if (contains(curr.next[i], kapos)) {
 						return true;
 					}
 				}
 				return false;
 			}
 			else {
 				c -= 'a';
 				return contains(curr.next[c], str.substring(1));
 			}
 		}
 	}
 	static int sagot(int l, int pos) {
 		if (l >= str.length()) {
 			return 0;
 		}
 		if (pos < 0) {
 			if (extra[l] < 0) {
 				int min = 1000;
 				for (int len = 1; len <= Math.min(10, str.length()-l); len++) {
 					String curr = str.substring(l, l+len);
 					if (contains(root, curr)) {
 						min = Math.min(min, sagot(l+len, -1));
 					}
 					else {
 						// contains 1
 						for (int i = 0; i < len; i++) {
 							String nu = curr.substring(0,i)+"".""+curr.substring(i+1);
 							if (contains(root, nu)) {
 								min = Math.min(min, 1+sagot(l+len, len-i >=  5 ? -1 : len-i));
 							}
 						}
 						// contains 2
 						for (int j = 0; j < len; j++) {
 							for (int i = j-5; i >= 0; i--) {
 								String nu = curr.substring(0,i)+"".""+curr.substring(i+1,j)+"".""+curr.substring(j+1);
 								if (contains(root, nu)) {
 									min = Math.min(min, 2+sagot(l+len, len-j >= 5 ? -1 : len-j));
 									j = 100;
 									break;
 								}
 							}
 						}
 
 					}
 				}
 				extra[l] = min;
 			}
 			return extra[l];
 		}
 		else {
 			if (dp[l][pos] < 0) {
 				int min = 1000;
 				for (int len = 1; len <= Math.min(10,str.length()-l); len++) {
 					String curr = str.substring(l, l+len);
 					if (contains(root, curr)) {
 						min = Math.min(min, sagot(l+len, len+pos >= 5 ? -1 : pos));
 					}
 					else {
 						// contains 1
 						for (int i = 5-pos; i < len; i++) {
 							String nu = curr.substring(0,i)+"".""+curr.substring(i+1);
 							if (contains(root, nu)) {
 								min = Math.min(min, 1+sagot(l+len, len-i >= 5 ? -1 : len-i));
 							}
 						}
 						// contains 2
 						for (int j = 0; j < len; j++) {
 							for (int i = j-5; i >= 5-pos; i--) {
 								String nu = curr.substring(0,i)+"".""+curr.substring(i+1,j)+"".""+curr.substring(j+1);
 								if (contains(root, nu)) {
 									min = Math.min(min, 2+sagot(l+len, len-j >= 5 ? -1 : len-j));
 									j = 100;
 									break;
 								}
 							}
 						}
 
 					}
 				}
 				dp[l][pos] = min;
 			}
 			return dp[l][pos];
 		}
 	}
 	static int[][] dp = null;
 	static int[] extra = null;
 	static String str = null;
 	static Node root = null;
 	public static void main(String[] args) throws Exception{
 		Scanner s1 = new Scanner(new File(""garbled_email_dictionary.txt""));
 		root = new Node();
 		while (s1.hasNext()) {
 			root = insert(root, s1.next());
 		}
 		Scanner sc = new Scanner(in);
 		int t = sc.nextInt();
 		for (int i = 0; i < t; i++) {
 			str = sc.next();
 			dp = new int[str.length()+1][20];
 			extra = new int[str.length()+1];
 			for (int j = 0; j < str.length()+1; j++) {
 				Arrays.fill(dp[j], -1);
 			}
 			Arrays.fill(extra, -1);
 			out.printf(""Case #%d: %d\n"", i+1, sagot(0, -1));
 		}
 
 
 		// out.println(contains(root,""aaaamau""));
 		// out.println(contains(root,""aaaan""));
 		// out.println(contains(root,""zuebef""));
 		// out.println(contains(root,""yozff""));
 		// out.println(contains(root,""abdomenxi""));
 
 		// out.println(contains(root,""aaacd""));
 		// out.println(contains(root,""aaoen""));
 		// out.println(contains(root,""abdomenxin""));
 		// out.println(contains(root,""aab""));
 	}
 }",0
183,1685,"package kr.javanese.codejam2010qr.a;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.InputStreamReader;
 
 public class Main {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			
 			BufferedReader reader;
 			if (args.length>0) {
 				reader = new BufferedReader(new FileReader(args[0]));
 			} else {
 				reader = new BufferedReader(new InputStreamReader(System.in));				
 			}
 			String line = null;
 			line = reader.readLine();
 			int caseCount = Integer.parseInt(line);
 						
 			long startTime = System.currentTimeMillis();
 
 			for (int i=0; i<caseCount; i++) {
 				line = reader.readLine();
 				String[] nums = line.split("" "");
 				int snapperCount = Integer.parseInt(nums[0]);
 				int snapCount = Integer.parseInt(nums[1]);
 				System.out.print(""Case #"");
 				System.out.print(i+1);
 				System.out.print("": "");
 				if (isLightOn(snapperCount, snapCount)) {
 					System.out.println(""ON"");
 				} else {
 					System.out.println(""OFF"");					
 				}
 			}
 			
 			System.err.println(""Elasped Time : ""+(System.currentTimeMillis()-startTime));
 			reader.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	final static int[] POWER = new int[31];
 	static {
 		for (int i=0; i<POWER.length; i++) {
 			POWER[i] = 1;
 			for (int j=0; j<i; j++) {
 				POWER[i] = POWER[i]<<1 | 1;
 			}
 		}
 	}
 	private static boolean isLightOn(int snapperCount, int snapCount) {
 		if (snapperCount==0) return true;
 		
 		int state = 0;
 		int t = 0;
 		int i, j;
 		for (i=0; i<snapCount; i++) {
 			t = state;
 			for (j=0; j<snapperCount; j++) {
 				if ((t&1)==0) break;
 				t = t>>1;
 			}
 			if (j==snapperCount) {
 				state = 0;
 				i = snapCount - (snapCount%(i+1)) - 1;
 			} else {
 				state = POWER[j] ^ state;
 			}
 		}
 		if (state == POWER[snapperCount-1]) return true;
 		return false;
 	}
 
 }
","package kr.javanese.gcj2011qr.d;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.InputStreamReader;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 public class Main {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 
 			BufferedReader reader;
 			if (args.length > 0) {
 				reader = new BufferedReader(new FileReader(args[0]));
 			} else {
 				reader = new BufferedReader(new InputStreamReader(System.in));
 			}
 			String line = null;
 			line = reader.readLine();
 			int caseCount = Integer.parseInt(line);
 
 			long startTime = System.currentTimeMillis();
 			NumberFormat numberFormat = NumberFormat.getInstance();
 			numberFormat.setMaximumFractionDigits(6);
 			numberFormat.setMinimumFractionDigits(6);
 
 			for (int caseNo = 0; caseNo < caseCount; caseNo++) {
 				line = reader.readLine();
 				int numberCount = Integer.parseInt(line);
 				line = reader.readLine();
 				String[] tokens = line.split("" "");
 				int[] numbers = new int[numberCount];
 				for (int i = 0; i < numberCount; i++) {
 					numbers[i] = Integer.parseInt(tokens[i])-1;
 				}
 
 				double result = calcFinalProb(numbers);
 				System.out.print(""Case #"");
 				System.out.print(caseNo + 1);
 				System.out.print("": "");
 				System.out.println(numberFormat.format(result));
 			}
 
 			System.err.println(""Elasped Time : ""
 					+ (System.currentTimeMillis() - startTime));
 			reader.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	static double[] PROB = new double[1001];
 
 	static {
 		PROB[0] = 0.0;
 		PROB[1] = 0.0;
 		PROB[2] = 2.0;
 		for (int i = 3; i < 1001; i++) {
 			PROB[i] = (double)i;
 			//PROB[i] = calcProb(i);
 			System.err.print(i);
 			System.err.print('\t');
 			System.err.println(PROB[i]);
 			System.err.println();
 		}
 	}
 
 	static int caseN = 0;
 	static int caseTotal = 0;
 	static double sum = 0.0;
 
 	private static double calcProb(int n) {
 		int[] combi = new int[n];
 		boolean[] visited = new boolean[n];
 		caseN = 0;
 		caseTotal = 0;
 		sum = 0.0;
 		combination(0, n, combi, visited);
 		return (sum + (double) caseN) / (double) (caseTotal - caseN);
 	}
 
 	private static void combination(int i, int n, int[] combi, boolean[] visited) {
 		if (i >= n) {
 			caseTotal++;
 			double prob = calcProb(combi);
 			if (prob >= 0) {
 				sum += 1. + prob;
 			}
 //			System.out.print(caseTotal);
 //			System.out.print('\t');
 //			System.out.print(caseN);
 //			System.out.print('\t');
 //			System.out.println(sum);
 		}
 		for (int j = 0; j < n; j++) {
 			if (visited[j])
 				continue;
 			combi[i] = j;
 			visited[j] = true;
 			combination(i + 1, n, combi, visited);
 			visited[j] = false;
 		}
 	}
 
 	private static double calcProb(int[] combi) {
 		int[] groups = new int[combi.length];
 		for (int i = 0; i < groups.length; i++) {
 			groups[i] = -1;
 		}
 		int group = 0;
 		for (int i = 0; i < combi.length; i++) {
 			if (groups[i] >= 0)
 				continue;
 			int p = i;
 			groups[p] = group;
 			while (combi[p] != i) {
 				p = combi[p];
 				groups[p] = group;
 			}
 			group++;
 		}
 		// for (int c : combi) {
 		// System.err.print(c);
 		// System.err.print('\t');
 		// }
 		// System.err.println();
 		// for (int c : groups) {
 		// System.err.print(c);
 		// System.err.print('\t');
 		// }
 		// System.err.println();
 		if (group <= 1) {
 			caseN++;
 			return -1.0;
 		}
 		int[] groupSize = new int[group];
 		for (int i = 0; i < combi.length; i++) {
 			groupSize[groups[i]]++;
 		}
 		double prob = 0.0;
 		for (int i = 0; i < groupSize.length; i++) {
 			prob += PROB[groupSize[i]];
 		}
 		return prob;
 	}
 
 	private static double calcFinalProb(int[] combi) {
 		int[] groups = new int[combi.length];
 		for (int i = 0; i < groups.length; i++) {
 			groups[i] = -1;
 		}
 		int group = 0;
 		for (int i = 0; i < combi.length; i++) {
 			if (groups[i] >= 0)
 				continue;
 			int p = i;
 			groups[p] = group;
 			while (combi[p] != i) {
 				p = combi[p];
 				groups[p] = group;
 			}
 			group++;
 		}
 		for (int c : combi) {
 			System.err.print(c);
 			System.err.print('\t');
 		}
 		System.err.println();
 		for (int c : groups) {
 			System.err.print(c);
 			System.err.print('\t');
 		}
 		System.err.println();
 		int[] groupSize = new int[group];
 		for (int i = 0; i < combi.length; i++) {
 			groupSize[groups[i]]++;
 		}
 		double prob = 0.0;
 		for (int i = 0; i < groupSize.length; i++) {
 			prob += PROB[groupSize[i]];
 		}
 		return prob;
 	}
 }
",1
184,15694,"package codejam2013;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 public class TicTacToe {
 
 	public static char checkDir(String[] board, int startI, int startJ,
 			int stepI, int stepJ) {
 		char checkedChar = 'T';
 		boolean areSame = true;
 		boolean hasEmpty = false;
 		for (int i = startI, j = startJ; i < board.length && j < board.length; i += stepI, j += stepJ) {
 			char currentChar = board[i].charAt(j);
 			if (currentChar == '.') {
 				hasEmpty = true;
 				break;
 			}
 
 			if (currentChar == 'X' || currentChar == 'O') {
 				if (checkedChar == 'T') {
 					checkedChar = currentChar;
 				} else if (currentChar != checkedChar) {
 					areSame = false;
 				}
 			}
 		}
 
 		if (hasEmpty) {
 			return '.';
 		}
 		if (areSame) {
 			return checkedChar;
 		}
 		return 'D';
 	}
 
 	public static String getState(String[] board) {
 		// check rows
 		boolean hasEmpty = false;
 		for (int i = 0; i < board.length; ++i) {
 			char current = checkDir(board, i, 0, 0, 1);
 			if (current == '.') {
 				hasEmpty = true;
 			} else if (current == 'O') {
 				return ""O won"";
 			} else if (current == 'X') {
 				return ""X won"";
 			}
 		}
 
 		// check columns
 		for (int j = 0; j < board.length; ++j) {
 			char current = checkDir(board, 0, j, 1, 0);
 			if (current == '.') {
 				hasEmpty = true;
 			} else if (current == 'O') {
 				return ""O won"";
 			} else if (current == 'X') {
 				return ""X won"";
 			}
 		}
 
 		// check diagonals
 		char current = checkDir(board, 0, 0, 1, 1);
 		if (current == '.') {
 			hasEmpty = true;
 		} else if (current == 'O') {
 			return ""O won"";
 		} else if (current == 'X') {
 			return ""X won"";
 		}
 
 		current = checkDir(board, board.length - 1, 0, -1, 1);
 		if (current == '.') {
 			hasEmpty = true;
 		} else if (current == 'O') {
 			return ""O won"";
 		} else if (current == 'X') {
 			return ""X won"";
 		}
 
 		return hasEmpty ? ""Game has not completed"" : ""Draw"";
 	}
 
 	public static void solve(String fileName, String outputFileName)
 			throws IOException {
 		BufferedReader in = new BufferedReader(new InputStreamReader(
 				new FileInputStream(fileName)));
 		PrintWriter writer = new PrintWriter(outputFileName);
 
 		int size = 4;
 		int testCases = Integer.parseInt(in.readLine());
 		for (int t = 0; t < testCases; ++t) {
 			String[] board = new String[size];
 			for (int i = 0; i < size; ++i) {
 				board[i] = in.readLine();
 			}
 			writer.format(""Case #%d: %s\n"", t + 1, getState(board));
 			in.readLine(); // read empty line
 		}
 		
 		writer.close();
 		in.close();
 	}
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		solve(""A-large.in"", ""out.txt"");
 	}
 
 }
","package codejam2013;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 public class LawnMower {
 
 	public static boolean checkSquare(int[][] lawn, int i, int j) {
 		boolean isFeasibleH = true;
 		// check horizontally
 		for (int k = 0; k < lawn[0].length; ++k) {
 			if (lawn[i][k] > lawn[i][j]) {
 				isFeasibleH = false;
 				break;
 			}
 		}
 
 		boolean isFeasibleV = true;
 		// check vertically
 		for (int k = 0; k < lawn.length; ++k) {
 			if (lawn[k][j] > lawn[i][j]) {
 				isFeasibleV = false;
 				break;
 			}
 		}
 
 		return isFeasibleH || isFeasibleV;
 	}
 
 	public static boolean check(int[][] lawn) {
 		boolean isFeasible = true;
 		outer: for (int i = 0; i < lawn.length; ++i) {
 			for (int j = 0; j < lawn[0].length; ++j) {
 				if (!checkSquare(lawn, i, j)) {
 					isFeasible = false;
 					break outer;
 				}
 			}
 		}
 
 		return isFeasible;
 	}
 
 	public static void solve(String fileName, String outputFileName)
 			throws IOException {
 		BufferedReader reader = new BufferedReader(new InputStreamReader(
 				new FileInputStream(fileName)));
 		PrintWriter writer = new PrintWriter(outputFileName);
 
 		int testCases = Integer.parseInt(reader.readLine());
 		for (int t = 0; t < testCases; ++t) {
 			String[] splits = reader.readLine().split("" "");
 			int N = Integer.parseInt(splits[0]);
 			int M = Integer.parseInt(splits[1]);
 			int[][] lawn = new int[N][M];
 			for (int i = 0; i < N; ++i) {
 				splits = reader.readLine().split("" "");
 				for (int j = 0; j < M; ++j) {
 					lawn[i][j] = Integer.parseInt(splits[j]);
 				}
 			}
 			
 			String result = check(lawn) ? ""YES"" : ""NO"";
 			writer.format(""Case #%d: %s\n"", t + 1, result);
 		}
 
 		writer.close();
 		reader.close();
 	}
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		solve(""B-small-attempt0.in"", ""B.out"");
 	}
 
 }
",1
185,1270,"import java.io.*;
 import java.util.*;
 /**
  *
  * @author ankush
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args)throws IOException {
         // TODO code application logic here
         InputStreamReader isr=new InputStreamReader(System.in);
         BufferedReader br=new BufferedReader(isr);
 
         Scanner sc = new Scanner(new FileReader(""A-small-attempt0(1).in""));
 	PrintWriter pw = new PrintWriter(new FileWriter(""output.txt""));
 
         int t=Integer.parseInt(sc.nextLine());
         int ans[]=new int[t];
         for(int i=0;i<t;i++)
         {
             char c[][]=new char[4][4];
             for(int j=0;j<4;j++)
             {
                 String a=sc.nextLine();
                 for(int k=0;k<4;k++)
                    c[j][k]=a.charAt(k);
             }
             
             int flag=0;
             for(int j=0;j<4;j++)
             {
                 int xcnt=0,ycnt=0;
                 for(int k=0;k<4;k++)
                 {
           
                      if(c[j][k] == 'X' || c[j][k]=='T')
                      {
                          xcnt++;
                          
                      }
                        if(c[j][k] == 'O' || c[j][k]=='T')
                      {
                          ycnt++;
                      }
                        if(c[j][k] == '.')
                      {
                        flag=1;
                      }
                 }
                 if(xcnt==4)
                 {
                     ans[i]=1;
                
                     break;
                 }
                  if(ycnt==4)
                 {
                     ans[i]=2;
                    
                     break;
                 }
                 xcnt=0;ycnt=0;
                 for(int k=0;k<4;k++)
                 {
                    
                      if(c[k][j] == 'X' || c[k][j]=='T')
                      {
                          xcnt++;
                      }
                        if(c[k][j] == 'O' || c[k][j]=='T')
                      {
                          ycnt++;
                      }
                        if(c[k][j] == '.')
                      {
                        flag=1;
                      }
                 }
                 if(xcnt==4)
                 {
                     ans[i]=1;
            
                     break;
                 }
                  if(ycnt==4)
                 {
                     ans[i]=2;
 
                     break;
                 }
             }
                 int xcnt=0,ycnt=0;
                 for(int j=0;j<4;j++)
                 {
                     if(c[j][j] == 'X' || c[j][j]=='T')
                      {
                          xcnt++;
                      }
                       if(c[j][j] == 'O' || c[j][j]=='T')
                      {
                          ycnt++;
                      }
                 }
                 if(xcnt==4)
                 {
                     ans[i]=1;
                }
                  if(ycnt==4)
                 {
                     ans[i]=2;
                  }
                 xcnt=0;ycnt=0;
                 for(int j=0;j<4;j++)
                 {
                     if(c[j][3-j] == 'X' || c[j][3-j]=='T')
                      {
                          xcnt++;
                      }
                       if(c[j][3-j] == 'O' || c[j][3-j]=='T')
                      {
                          ycnt++;
                      }
                 }
                 if(xcnt==4)
                 {
                     ans[i]=1;
                 }
                  if(ycnt==4)
                 {
                     ans[i]=2;
                }
                 if(ans[i]==0 && flag==1)
                 {
                     ans[i]=3;
                 }
                  sc.nextLine();
                 
             }
         for(int i=0;i<t;i++)
         {
             if(ans[i]==1)
                 pw.println(""Case #""+(i+1)+"": X won"");
               if(ans[i]==2)
                 pw.println(""Case #""+(i+1)+"": O won"");
               if(ans[i]==3)
                 pw.println(""Case #""+(i+1)+"": Game has not completed"");
                if(ans[i]==0)
                 pw.println(""Case #""+(i+1)+"": Draw"");
         }
         pw.flush();
         pw.close();
         sc.close();
 
     }
 
 }","package round1c;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class A {
   public static void main(String[] args) throws Exception, IOException {
     String round = ""round1c"";
     String question = ""A"";
     String type = ""small"";
     String attempt = ""0"";
     boolean practice = false;
 
     BufferedReader br;
     PrintWriter out;
     StringTokenizer st;
     if (practice) {
       out = new PrintWriter(new FileWriter(round + ""/"" + question + ""-"" + type + ""-practice.out""));
       br = new BufferedReader(new FileReader(round + ""/"" + question + ""-"" + type + ""-practice.in""));
     } else {
       if (type.equals(""small"")) {
         out = new PrintWriter(new FileWriter(round + ""/"" + question + ""-"" + type + ""-attempt"" + attempt + "".out""));
         br = new BufferedReader(new FileReader(round + ""/"" + question + ""-"" + type + ""-attempt"" + attempt + "".in""));
       } else {
         out = new PrintWriter(new FileWriter(round + ""/"" + question + ""-"" + type + "".out""));
         br = new BufferedReader(new FileReader(round + ""/"" + question + ""-"" + type + "".in""));
       }
     }
 
     int cases = Integer.parseInt(br.readLine());
     for (int zz = 1; zz <= cases; zz++) {
       st = new StringTokenizer(br.readLine().trim().toLowerCase());
       char[] word = st.nextToken().toCharArray();
       int n = Integer.parseInt(st.nextToken());
 
       long ans = 0;
       for (int i = 0; i <= word.length; i++) {
         for (int j = i + 1; j <= word.length; j++) {
           //System.out.print(i+ "" "" + j + "" "");
           if (performTest(word, i, j, n)) {
             ans++;
             //System.out.print(""T"");
           }
           //System.out.println();
         }
       }
 
       out.println(""Case #"" + zz + "": "" + ans);
       //System.out.println();
     }
     out.close();
     br.close();
   }
 
   private static boolean performTest(char[] word, int i, int j, int n) {
     if (j - i < n)
       return false;
 
     for (int zz = i; zz < j; zz++) {
       boolean found = true;
       if (zz + n - 1 > word.length - 1 || j - zz < n)
         continue;
       for (int xx = zz; xx < zz + n && found; xx++) {
         found &= isConsonant(word[xx]);
       }
       if (found)
         return true;
     }
     return false;
   }
 
   private static boolean isConsonant(char c) {
     return !isVowel(c);
   }
 
   private static boolean isVowel(char c) {
     return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
   }
 }
",0
186,9257,"import java.util.*;
 import java.io.*;
 import java.math.BigInteger;
 public class bulls
 {
 	static BigInteger t,r0;
 	static BigInteger two= new BigInteger(2+"""");
 	static long upper, lower;
 	static int T;
 	static BigInteger area(long n)
 	{
 		BigInteger t1= new BigInteger(n+"""");
 		BigInteger temp= new BigInteger(n+"""");
 		BigInteger t2= temp.subtract(BigInteger.ONE);
 		temp= (r0.multiply(temp)).add(temp.multiply(t2));
 		
 		temp= two.multiply( temp).add(t1);
 		return temp;
 	}
 	public static void main(String[] args)throws IOException
 	{
 		Scanner scan= new Scanner(System.in);
 		
 		T= Integer.parseInt(scan.next());
 		for(int x=1; x<=T; x++)
 		{
 			r0= new BigInteger(scan.next());
 			t= new BigInteger(scan.next());
 			upper= (long)Math.pow(10,18);
 			lower= 0;
 			long mid= (upper+lower)/2;
 			BigInteger a= BigInteger.ZERO;
 		//	System.out.println(t.toString()+"" ""+r0.toString());
 			for(int i=0; i<1000; i++)
 			{
 				a=area(mid);
 				if(x==1)
 	//			System.out.println(a.toString()+"" ""+t+""    ""+mid+"" ""+upper+"" ""+lower);
 				if(lower==upper-1)
 				{
 					if(area(upper).compareTo(t)>0)
 					{
 						mid=lower;
 						break;
 					}
 					mid=upper;
 					break;
 				}
 				if(a.compareTo(t)>0)
 					upper=mid;
 				if(a.compareTo(t)==0)
 					break;
 				if(a.compareTo(t)<0)
 					lower=mid;
 				mid=lower+(upper-lower)/2;
 			}
 			System.out.println(""Case #""+x+"": ""+mid);
 		}
 	}
 }","package qualification;
 import java.io.*;
 import java.util.*;
 import java.math.*;
 import java.text.*;
 
 public class FairWarning {
 
 	static DecimalFormat DF = new DecimalFormat(""0.000"",new DecimalFormatSymbols(Locale.ENGLISH));
 	
 	public static void run() throws Exception {
 		
 		init(""B-small-attempt0"");
 		
 		int cases = INT();
 		for(int cc = 1;cc<=cases;cc++) {
 			int N = INT();
 			BigInteger[] list = new BigInteger[N];
 			for(int i = 0;i<list.length;i++)list[i] = BIGINT();
 			BigInteger gcd = list[0].subtract(list[1]).abs();
 			for(int i = 0;i<N;i++) {
 				for(int j = i+1;j<N;j++) {
 					gcd = GCD(gcd,list[i].subtract(list[j]).abs());
 				}
 			}
 						
 			print(""Case #""+cc+"": "");
 			if(list[0].mod(gcd).equals(BigInteger.ZERO))println(0);
 			else {
 				BigInteger diff = gcd.subtract(list[0].mod(gcd));
 				println(diff);
 			}
 			
 		}
 		
 	}
 	
 	public static BigInteger GCD(BigInteger A, BigInteger B) {
 		if(B.equals(BigInteger.ZERO))return A;
 		return GCD(B,A.mod(B));
 	}
 	
 	// *************************************************************************************
 	// *********************************** FRAMEWORK ***************************************
 	// *************************************************************************************
 	
 	public static BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
 	public static boolean isStandardInput = false;
 	
 	public static File input;
 	public static FileReader inputreader;
 	public static BufferedReader in;
 	
 	public static File output;
 	public static FileWriter outputwriter;
 	public static BufferedWriter out;
 	
 	public static StringTokenizer st;
 	
 	public static void main(String[] args) throws Exception {
 		doSTDIN(true);
 		setOutput(""test.out"");
 		run();
 		close();
 	}
 	
 	public static void init(String problemName) throws Exception {
 		doSTDIN(false);
 		setInput(problemName+"".in"");
 		setOutput(problemName+"".out"");
 	}
 	
 	// **************** PRINT METHODS **********************
 	
 	public static void println() throws IOException {
 		out.write(""\n"");
 		System.out.println();
 	}
 	
 	public static void println(Object obj) throws IOException {
 		out.write(obj.toString());
 		out.write(""\n"");
 		System.out.println(obj.toString());
 	}
 	
 	public static void print(Object obj) throws IOException {
 		out.write(obj.toString());
 		System.out.print(obj.toString());
 	}
 	
 	public static void println(long number) throws IOException {
 		out.write(Long.toString(number));
 		out.write(""\n"");
 		System.out.println(number);
 	}
 	
 	public static void print(long number) throws IOException {
 		out.write(Long.toString(number));
 		System.out.print(number);
 	}
 	
 	public static void println(char c) throws IOException {
 		out.write(Character.toString(c));
 		out.write(""\n"");
 		System.out.println(c);
 	}
 	
 	public static void print(char c) throws IOException {
 		out.write(Character.toString(c));
 		System.out.print(c);
 	}
 	
 	public static void println(String line) throws IOException {
 		out.write(line);
 		out.write(""\n"");
 		System.out.println(line);
 	}
 	
 	public static void print(String line) throws IOException {
 		out.write(line);
 		System.out.print(line);
 	}
 	
 	// ******************** INPUT DECLARATION ******************
 	
 	public static void doSTDIN(boolean standard) {
 		isStandardInput = standard;
 	}
 	
 	public static void setInput(String filename) throws IOException {
 		input = new File(filename);
 		inputreader = new FileReader(input);
 		in = new BufferedReader(inputreader);
 	}
 	
 	public static void setOutput(String filename) throws IOException {
 		output = new File(filename);
 		outputwriter = new FileWriter(output);
 		out = new BufferedWriter(outputwriter);
 	}
 	
 	public static void close() throws IOException {
 		if(in!=null)in.close();
 		if(inputreader!=null)inputreader.close();
 		
 		if(out!=null)out.flush();
 		if(out!=null)out.close();
 		if(outputwriter!=null)outputwriter.close();
 	}
 	
 	// ************************** INPUT READING *****************
 	
 	static String LINE() throws IOException { return isStandardInput?stdin.readLine():in.readLine(); }
 	static String TOKEN() throws IOException {
 		while (st == null || !st.hasMoreTokens())st = new StringTokenizer(LINE());
 		return st.nextToken();
 	}
 	static int INT() throws IOException {return Integer.parseInt(TOKEN());}
 	static long LONG() throws IOException {return Long.parseLong(TOKEN());}
 	static double DOUBLE() throws IOException {return Double.parseDouble(TOKEN());}
 	static BigInteger BIGINT() throws IOException {return new BigInteger(TOKEN());}
 	
 }
",0
187,20306,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package googlecodejam2012;
 
 import java.io.*;
 import java.util.*;
 import java.util.Collections;
 
 /**
  *
  * @author Stephen
  */
 class Car {
 
     public Car(int vel, int pos) {
         velocity = vel;
         position = pos;
     }
 
     @Override
     public String toString() {
         return ""Vel: "" + velocity + "" Pos: "" + position;
     }
     public int velocity;
     public double position;
 }
 
 class CarComparator implements Comparator<Car> {
 
     @Override
     public int compare(Car car1, Car car2) {
         return new Double(car1.position).compareTo(car2.position);
     }
 }
 
 public class GoogleCodeJam2012R1N3 {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         try {
             FileInputStream fs = new FileInputStream(""input.txt"");
             DataInputStream in = new DataInputStream(fs);
             BufferedReader br = new BufferedReader(new InputStreamReader(in));
             FileWriter fws = new FileWriter(""output.txt"");
             BufferedWriter out = new BufferedWriter(fws);
             String numLine = br.readLine();
             System.out.println(numLine);
             int numCases = Integer.parseInt(numLine);
             String caseLine;
             for (int i = 1; i <= numCases; i++) {
                 caseLine = br.readLine();
                 System.out.println(""Case #"" + i);
                 int N = Integer.parseInt(caseLine);
                 ArrayList<Car> leftLane = new ArrayList<Car>();
                 ArrayList<Car> rightLane = new ArrayList<Car>();
                 for (int j = 0; j < N; j++) {
                     caseLine = br.readLine();
                     String[] splitted = caseLine.split("" "");
                     if (splitted[0].equals(""L"")) {
                         leftLane.add(new Car(Integer.parseInt(splitted[1]), Integer.parseInt(splitted[2])));
                     } else {
                         rightLane.add(new Car(Integer.parseInt(splitted[1]), Integer.parseInt(splitted[2])));
                     }
                 }
                 CarComparator compare = new CarComparator();
 
                 Collections.sort(leftLane, compare);
                 Collections.sort(rightLane, compare);
 
                 System.out.println(""Left Lane: "" + leftLane);
                 System.out.println(""RightLane: "" + rightLane);
 
                 boolean willCollide = true;
                 double nextCollision = 100000000000.0;
                 boolean leftLaneCollide = false;
                 int guiltyCar = 0;
                 boolean impossible = false;
                 double timeElapsed = 0;
                 double lastCollideTime = 1000;
                 
                 while (willCollide && !impossible) {
                     willCollide = false;
                     nextCollision = 100000000000.0;
                     leftLaneCollide = false;
                     guiltyCar = 0;
                     if (leftLane.size() > 1) {
                         for (int j = 0; j < leftLane.size() - 1; j++) { //Process left lane
                             Car c1 = leftLane.get(j);
                             Car c2 = leftLane.get(j + 1);
                             if (c2.velocity >= c1.velocity) {
                                 continue;
                             }
                             double collideTime = (double) (c2.position - c1.position - 5) / (double) (c1.velocity - c2.velocity);
                             willCollide = true;
                             if (collideTime < nextCollision) {
                                 leftLaneCollide = true;
                                 guiltyCar = j;
                                 nextCollision = collideTime;
                             }
                         }
                     }
                     //System.out.println(rightLane.size());
                     if (rightLane.size() > 1) {
                         for (int j = 0; j < rightLane.size() - 1; j++) { //Process right lane
                             Car c1 = rightLane.get(j);
                             Car c2 = rightLane.get(j + 1);
                             if (c2.velocity >= c1.velocity) {
                                 continue;
                             }
                             double collideTime = (double) (c2.position - c1.position - 5) / (double) (c1.velocity - c2.velocity);
                             willCollide = true;
                             if (collideTime < nextCollision) {
                                 leftLaneCollide = false;
                                 guiltyCar = j;
                                 nextCollision = collideTime;
                             }
                         }
                     }
                     
                     //if(nextCollision < 0.000001) {
                      //   System.out.println(""Something's wrong"");
                      //   timeElapsed+=nextCollision;
                      //   impossible = true;
                     //}
                     
                     System.out.println(""Colliding? "" + willCollide + "" Next Collide: "" + nextCollision + "" Left lane? "" + leftLaneCollide + "" Car: "" + guiltyCar);
 
                     if (willCollide) {
                         timeElapsed+=nextCollision;
                         nextCollision*=0.99999;
                         for(int j = 0; j < leftLane.size(); j++) { // Move left lane
                             Car car = leftLane.get(j);
                             car.position += (double)car.velocity*nextCollision;
                         }
                         for(int j = 0; j < rightLane.size(); j++) { // Move right lane
                             Car car = rightLane.get(j);
                             car.position += (double)car.velocity*nextCollision;
                         }
                         if(leftLaneCollide) {
                             Car offender = leftLane.get(guiltyCar);
                             for(int j = 0; j < rightLane.size(); j++) { // Try to move car.
                                 Car car = rightLane.get(j);
                                 if(Math.abs(offender.position-car.position)<5) { // Can't move, we're screwed
                                     impossible = true;
                                     break;
                                 }
                             }
                             if(impossible) {
                                 boolean secondCarImpossible = false;
                                 offender = leftLane.get(guiltyCar+1);
                                 for(int j = 0; j < rightLane.size(); j++) { // Try to move car.
                                     Car car = rightLane.get(j);
                                     if(Math.abs(offender.position-car.position)<5) { // Can't move, we're screwed
                                        secondCarImpossible = true;
                                        break;
                                     }
                                 }
                                 if(!secondCarImpossible) {
                                     System.out.println(""Second car could"");
                                     impossible = false;
                                     guiltyCar++;
                                 }
                             }
                             if(!impossible) {
                                 leftLane.remove(guiltyCar);
                                 rightLane.add(offender);
                                 Collections.sort(rightLane, compare);
                             }
                         } else {
                             Car offender = rightLane.get(guiltyCar);
                             for(int j = 0; j < leftLane.size(); j++) { // Try to move car.
                                 Car car = leftLane.get(j);
                                 if(Math.abs(offender.position-car.position)<5) { // Can't move, we're screwed
                                     impossible = true;
                                     break;
                                 }
                             }
                             if(impossible) {
                                 boolean secondCarImpossible = false;
                                 offender = rightLane.get(guiltyCar+1);
                                 for(int j = 0; j < leftLane.size(); j++) { // Try to move car.
                                     Car car = leftLane.get(j);
                                     if(Math.abs(offender.position-car.position)<5) { // Can't move, we're screwed
                                        secondCarImpossible = true;
                                        break;
                                     }
                                 }
                                 if(!secondCarImpossible) {
                                     System.out.println(""Second car could"");
                                     impossible = false;
                                     guiltyCar++;
                                 }
                             }
                             if(!impossible) {
                                 rightLane.remove(guiltyCar);
                                 leftLane.add(offender);
                                 Collections.sort(leftLane, compare);
                             }
                         }
                     }
                     if(nextCollision == 0 && nextCollision == lastCollideTime) {
                         impossible = true;
                         System.out.println(""IMPOSSIBLCASED"");
                     }
                     lastCollideTime = nextCollision;
                     System.out.println(""Left Lane: "" + leftLane);
                     System.out.println(""RightLane: "" + rightLane);
                 }
 
                 if(impossible) {
                     out.write(""Case #"" + i + "": "" + timeElapsed + ""\r\n"");
                     System.out.print(""Case #"" + i + "": "" + timeElapsed + ""\r\n"");
                 }
                 else {
                     out.write(""Case #"" + i + "": Possible\r\n"");
                     System.out.print(""Case #"" + i + "": Possible\r\n"");
                 }
             }
             in.close();
             out.close();
 
             displayOutput();
         } catch (Exception e) {
             System.err.println(""Oops! Error occured: "" + e.getMessage());
         }
     }
 
     public static void displayOutput() {
         System.out.println(""START OUTPUT\n-------------------"");
         try {
             FileInputStream fs = new FileInputStream(""output.txt"");
             DataInputStream in = new DataInputStream(fs);
             BufferedReader br = new BufferedReader(new InputStreamReader(in));
             String readLine;
             while ((readLine = br.readLine()) != null) {
                 System.out.println(readLine);
             }
         } catch (Exception e) {
             System.err.println(""Oops! Error occured: "" + e.getMessage());
         }
         System.out.println(""---------------------\nEND OUTPUT"");
     }
 }
","package gcj2011.round1B;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Author -
  * User: kansal
  * Date: 5/21/11
  * Time: 10:57 PM
  */
 public class KittenHouse {
     private static IOUtil.IO io;
     public static void main(String[] args) {
         String inFilePrefix = ""C:\\Users\\kansal\\Downloads\\"";
         String outFilePrefix = ""C:\\RAJAT\\Codes\\Contests\\GCJ\\src\\gcj2011\\round1B\\"";
 
         String input = ""C-small-attempt0.in"";
         String output = ""C-small-attempt1.out"";
 //        String input = ""C-large.in"";
 //        String output = ""C-large.out"";
 
         io = new IOUtil.IO(inFilePrefix + input, outFilePrefix + output);
 
         int T = io.nextInt();
         for(int i = 1; i <= T; ++i) {
             try {
                 String res = new KittenHouse().solve();
                 String print = String.format(""Case #%d: %s"", i, res);
                 io.writer.println(print);
                 System.out.println(print);
             }
             catch (Exception e) {
                 System.out.println(""Exception thrown for case:"" + i + "", "" + e);
                 e.printStackTrace();
             }
         }
 
         io.closeStreams();
     }
 
     public String solve() {
         int n = io.nextInt(), m = io.nextInt();
 
         if (m == 0) {
             StringBuilder res = new StringBuilder();
             res.append(n);
             res.append(""\n"");
             for(int i = 1; i <= n; ++i) {
                 res.append(i + "" "");
             }
             return res.toString();
         }
 
         U = new int[m];
         V = new int[m];
         for(int i = 0; i < m; ++i) {
             U[i] = io.nextInt() - 1;
         }
         for(int i = 0; i < m; ++i) {
             V[i] = io.nextInt() - 1;
         }
 
         wall = new boolean[n][n];
         for(int i = 0; i < m; ++i) {
             wall[U[i]][V[i]] = true;
             wall[V[i]][U[i]] = true;
         }
 
         colors = new int[n];
         work = new int[n];
         work[0] = 1;
         tryAll(1, 1);
 
         StringBuilder res = new StringBuilder();
         res.append(best);
         res.append(""\n"");
         for(int x: colors) {
             res.append(x);
             res.append("" "");
         }
         return res.toString();
     }
 
     int best = 0;
     int[] colors;
     int[] work;
     int[] U, V;
     boolean[][] wall;
 
     private void tryAll(int pos, int M) {
         if (pos == colors.length) {
             do {
                 if (checkColoring()) {
                     for(int i = 0; i < work.length; ++i) colors[i] = work[i];
                     best = M;
                     break;
                 }
             } while (next_permutation(work, 0, work.length));
             return;
         }
 
         for(int c = M; c <= Math.min(M+1, work.length/2+1); ++c) {
             work[pos] = c;
             tryAll(pos+1, c);
         }
     }
 
     private boolean checkColoring() {
         int n = work.length;
 
         boolean[] pillar = new boolean[n];
         for(int i = 0; i < U.length; ++i) {
             pillar[U[i]] = pillar[V[i]] = true;
         }
 
         for(int set = 7; set < (1 << n); ++set) {
             int vertices = Integer.bitCount(set);
             if (vertices < 3) {
                 continue;
             }
             List<Integer> v = new ArrayList<Integer>();
             for(int i = 0; i < n; ++i) {
                 if (((set >> i) & 1) == 1) {
                     v.add(i);
                 }
             }
             int walls = 0;
             for(int i = 0; i < vertices; ++i) {
                 for(int j = i+1; j < vertices; ++j) {
                     int u1 = v.get(i), u2 = v.get(j);
                     if (wall[u1][u2]) {
                         ++walls;
                     }
                     else {
                         if (u2 - u1 == 1 || u2 - u1 == n-1) {
                             ++walls;
                         }
                     }
                 }
             }
             if (walls == vertices) {
                 int M = work[0];
                 for(int m: work) M = Math.max(M, m);
                 boolean[] has = new boolean[M+1];
                 for(int vv: v) {
                     has[work[vv]] = true;
                 }
                 for(int i = 1; i <= M; ++i) {
                     if (!has[i]) return false;
                 }
             }
         }
         return true;
     }
 
     public static boolean next_permutation(int[] arr, int beg, int end) {
         if (end - beg <= 1)
             return false;
         int i = end - 1;
 
         for (; ;) {
             int ii = i;
             --i;
             if (arr[i] < arr[ii]) {
                 int j = end;
                 while (!(arr[i] < arr[--j])) ;
                 int tmp = arr[i];
                 arr[i] = arr[j];
                 arr[j] = tmp;
                 for (int k = ii, l = end - 1; k < l; ++k, --l) {
                     tmp = arr[k];
                     arr[k] = arr[l];
                     arr[l] = tmp;
                 }
                 return true;
             }
             if (i == beg) {
                 for (int k = beg, l = end - 1; k < l; ++k, --l) {
                     int tmp = arr[k];
                     arr[k] = arr[l];
                     arr[l] = tmp;
                 }
                 return false;
             }
         }
     }
 }
",0
188,10558,"package gcj2012.qualification;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 public class GooglerDance {
 	public static void main(String[] args) throws Exception {
 		GooglerDance main = new GooglerDance(args[0]);
 		main.solve();
 	}
 
 	private final BufferedReader in;
 
 	public GooglerDance(String input) throws Exception {
 		in = new BufferedReader(new FileReader(this.getClass().getResource(input).getFile()));
 	}
 
 	private void solve() throws Exception {
 		int T = getInt();
 		for (int c = 1; c <= T; c++) {
 			List<Integer> n = getIntegers();
 			long ans = solveOne(n);
 			System.out.println(""Case #"" + c + "": "" + ans);
 		}
 	}
 
 	private int solveOne(List<Integer> n) {
 		int sum = 0;
 		int N = n.remove(0).intValue();
 		int S = n.remove(0).intValue();
 		int p = n.remove(0).intValue();
 
 		for (Integer candid : n) {
 			if (candid.intValue() >= p * 3 - 2) {
 				sum++;
 			} else if (candid.intValue() >= p * 3 - 4 && S > 0 && p >= 2) {
 				S--;
 				sum++;
 			}
 		}
 
 		return sum;
 	}
 
 	/*
 	 * File processing
 	 */
 	private int getInt() throws Exception {
 		return Integer.valueOf(in.readLine()).intValue();
 	}
 
 	private List<Integer> getIntegers() throws Exception {
 		List<Integer> list = new ArrayList<Integer>();
 		for (String s : getStrs()) {
 			list.add(Integer.valueOf(s));
 		}
 		return list;
 	}
 
 	private List<String> getStrs() throws Exception {
 		return Arrays.asList(in.readLine().split("" ""));
 	}
 
 }
","package lk.iit.wall.framework.network;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Arrays;
 import java.util.Scanner;
 
 /**
  * Created with IntelliJ IDEA.
  * User: Amila
  * Date: 4/13/12
  * Time: 10:48 PM
  * To change this template use File | Settings | File Templates.
  */
 public class CodeJamOne {
 
     public static void main(String[] args) {
         File file = new File(""D:\\small.txt"");
         try {
             //
             // Create a new Scanner object which will read the data
             // from the file passed in. To check if there are more
             // line to read from it we check by calling the
             // scanner.hasNextLine() method. We then read line one
             // by one till all line is read.
             //
             Scanner scanner = new Scanner(file);
             int cases = scanner.nextInt();
             for (int i = 0; i < cases; i++) {
                 int googlers = scanner.nextInt();
                 int supprise = scanner.nextInt();
                 int max = scanner.nextInt();
                 int numGoog = 0;
                 int[] nums = new int[googlers];
                 for (int j = 0; j < googlers; j++) {
                     int score = scanner.nextInt();
                     nums[j] = score;
                 }
                 Arrays.sort(nums);
                 for (int j = googlers - 1; j >= 0; j--) {
                     int score = nums[j];
                     double d = score / 3f;
                     int div = (int) Math.ceil(d);
                     int mod = score % 3;
                     if (div >= max) {
                         numGoog++;
                         continue;
                     }
                     /*if (mod == 2) {
                         if (div + 2 >= max && supprise != 0 && score > 1 && score < 29) {
                             numGoog++;
                             supprise--;
                             continue;
                         }
                     } else */if(mod==0 || mod == 2){
                         if (div + 1 >= max && supprise != 0 && score > 1 && score < 29) {
                             numGoog++;
                             supprise--;
                             continue;
                         }
                     }
                 }
                 System.out.println(""Case #"" + (i + 1) + "": "" + numGoog);
 
             }
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
     }
 }
",0
189,18839,"import java.util.*;
 import java.io.*;
 
 public class cj_1A_problemA {
 	
 	
 	public static void main(String args[]) throws IOException {
 		FileInputStream fstream = new FileInputStream(""input-small.txt"");
 		// Get the object of DataInputStream
 		DataInputStream in = new DataInputStream(fstream);
 		BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		
 		 File flt = new File(""result.txt"");
 		 PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(flt)));
 		
 		int n = Integer.parseInt(br.readLine());
 		for(int i=0; i<(n); i++){
 			
 			String[]  words = br.readLine().split("" "");
 			int N = Integer.parseInt(words[0]);
 			int Pd = Integer.parseInt(words[1]);
 			int Pn = Integer.parseInt(words[2]);
 			
 			boolean found=false;
 			
 			for(int j=1; j<=N; j++){
 				double f1 = (Pd*j);///100;
 				double f = f1/100.0;
 				
 				int nnn = (int) f;
 				String input = """" + f;
 						
 				if(nnn == f){
 					
 					//System.out.println(""check "" + j + "":"" + f);
 					
 					if(((Pn != 100) && (Pn!=0)) || (Pn==Pd)){
 						//System.out.println(""check "" + j + "":"" + f);
 						System.out.println(""Case #"" + (i+1) + "": "" + ""Possible"");
 						found=true;
 						break;
 					}
 					else{
 						continue;
 						//System.out.println(""Case #"" + (i+1) + "": "" + ""Possible"");
 					}
 				}
 			}
 			
 			if(!found){
 				System.out.println(""Case #"" + (i+1) + "": "" + ""Broken"");
 			}
 			
 			//System.out.println(""Case #"" + (i+1) + "": "" + this_ans);
 		}
 		
 		out.close();
 	}
 }
","import java.io.*;
 import java.util.*;
 import java.math.*;
 
 public class WorldCup2010 extends Template {
 	public WorldCup2010(String inputFileName, String outputFileName) {
 		super(""World Cup 2010 Files"", inputFileName, outputFileName, true);
 	}
 
 	int p;
 	int m[];
 	int price[][];
 	int exp;
 	int total;
 	
 	protected void init() {
 	
 	}
 	// solve only small case
 	protected void algorithm() {
 		total = 0;
 		for (int i = exp; i >= 1; i >>= 1) {
 			for (int j = 0; j < exp; j += i) {
 				boolean bought = false;
 				for (int k = j; k < j + i; k++) {
 					if (bought) {
 						m[k]--;
 					} else if (m[k] > 0) {
 						bought = true;
 						total++;
 						m[k]--;
 					}
 				}
 			}
 		}
 	}
 
 	protected void readInputFileOneCase() throws IOException {
 		p = readLineInt();
 		exp = 1;
 		for (int i = 0; i < p; i++) {
 			exp <<= 1;
 		}
 		m = new int[exp];
 		readLineToken();
 		for (int i = 0; i < exp; i++) {
 			m[i] = getTokenInt();
 			m[i] = p - m[i];
 		}
 		price = new int[p][exp];
 		int x = exp;
 		for (int i = 0; i < p; i++) {
 			x >>= 1;
 			readLineToken();
 			for (int j = 0; j < x; j++) {
 				price[i][j] = getTokenInt();
 			}
 		}
 	}
 
 	protected void writeOutputFileOneCase() throws IOException {
 		writeLine(total);
 	}
 
 	public static void main(String[] args) {
 		//new WorldCup2010(""WorldCup2010.in.txt"", ""WorldCup2010.out.txt"");
 		new WorldCup2010(""B-small-attempt1.in.txt"", ""B-small-attempt1.out.txt"");
 		//new WorldCup2010(""B-large.in.txt"", ""B-large.out.txt"");
 	}
 }
",0
190,2436,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 
 public class FreeCell {
 
 	
 	
 	public static void main(String[] args) {
 		
 		if(args.length < 1){
 			System.out.println(""FreeCell <input> <output>"");
 			System.exit(-1);
 		}
 		
 		File input = new File(args[0]);
 		File output = new File(args[1]);
 		
 		int cases = 0;
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(input));
 			PrintWriter pw = new PrintWriter(new FileWriter(output));
 			
 			cases = Integer.parseInt(br.readLine());
 			String s ;
 			for(int i = 0 ; i < cases ; i ++){
 				s = br.readLine();
 				String[] arr = s.split("" "");
 				
 				
 				long n = Long.parseLong(arr[0]);
 //				for(int k = 0 ; k < buttons ; k ++){
 //					bt.nextButton(arr[2 * k + 1], arr[2 * k + 2]);
 //				}
 				int pd = Integer.parseInt(arr[1]);
 				int pg = Integer.parseInt(arr[2]);
 				
 				pw.println(""Case #"" + (i + 1)+ "": "" + (solve(n, pd, pg)? ""Possible"":""Broken""));
 			}
 			
 			br.close();
 			pw.close();
 			
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (NumberFormatException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} finally{
 			
 		}
 
 	}
 	
 //	public static boolean solve(int n, int pd, int pg){
 //		
 //		if(!todayIsPossible(n, pd)){
 //			return false ;
 //		}
 //		if(pg > pd){
 //			return false ;
 //		}
 //		
 //		if(pd != 0 && pg == 0){
 //			return false ;
 //		}
 //		
 //		return true ;
 //		
 //	}
 //	
 	public static boolean todayIsPossible(long n, int pd){
 		
 		float per = pd /(float)100.0 ;
 		int d ;
 		for(int i = 1 ; i <= n; i ++){
 			d = (int) (i * per) ;
 			if((float)d == i * per ){
 				return true ;
 			}
 		}
 		
 		return false;
 	}
 	
 	
 //	public static boolean solve(int n, int pd, int pg){
 //		
 //		if( !todayIsPossible(n, pd)){
 //			return false ;
 //		}
 //		if(pg == 0){
 //			return pg == pd ;
 //		}
 //		for(int i = 1 ; i <= n  ; i ++){
 //			
 //			for(int k = pg ; k <= pd ; k += pg){
 //				if( (i * (pd - k)) % 100 == 0){
 //					return true ;
 //				}
 //			}
 //		}
 //		
 //		return false ;
 //	}
 	
 	public static boolean solve(long n, int pd, int pg){
 		if(!todayIsPossible(n, pd)){
 			return false ;
 		}
 		
 		if(pg == 0){
 			return pd == 0 ;
 		}
 		
 		if(pg == 100){
 			return pd == 100 ;
 		}
 		
 		return true ;
 	}
 	
 	
 
 }
","package org.neallab.googlecodejam.snapper;
 
 public class SnapperChainSimple {
 	
 	private int num ; 
 	
 	private long status ;
 	
 	public SnapperChainSimple(int num){
 		this.setNum(num);
 	}
 
 	/**
 	 * @param num the num to set
 	 */
 	private void setNum(int num) {
 		this.num = num;
 	}
 
 	/**
 	 * @return the num
 	 */
 	public int getNum() {
 		return this.num;
 	}
 	
 	public void snap(long count){
 		this.setStatus(this.getStatus() + count);
 	}
 	
 	public boolean isOn(int snapperId){
 		
 		if( ( this.getStatus() / nthPower(snapperId - 1)) % 2 == 1){
 			return true ;
 		}else{
 			return false ;
 		}
 	}
 	public boolean isLighted(int snapperId){
 		
 		for(int i = 0 ; i < snapperId ; ++ i){
 			if( ( this.getStatus() / nthPower(i)) % 2 == 0 ){
 				return false ;
 			}
 		}
 		return true ;
 	}
 	public int nthPower(int n){
 		int result = 1 ;
 		for( int i = 1 ; i <= n ; ++ i){
 			result *= 2 ;
 		}
 		return result ;
 	}
 
 	/**
 	 * @param status the status to set
 	 */
 	public void setStatus(long status) {
 		this.status = status;
 	}
 
 	/**
 	 * @return the status
 	 */
 	public long getStatus() {
 		return status;
 	}
 }
",1
191,8949,"import java.io.File;
 import java.util.Scanner;
 
 
 public class A {
   public static void main(String[] args) throws Exception {
     Scanner s = new Scanner(new File(""A.in""));
     int T = s.nextInt();
     for (int tc = 1; tc <= T; tc++) {
       System.out.print(""Case #"" + tc + "": "");
       int k = s.nextInt();
       int[][] arr = new int[k][k];
       for (int i = 0; i < k; i++) {
         for (int j = 0; j <= i; j++) {
           arr[i - j][j] = s.nextInt();
         }
       }
       for (int i = 1; i < k; i++) {
         for (int j = i; j < k; j++) {
           arr[k+i-j-1][j] = s.nextInt();
         }
       }
       
       int size = 4 * k;
       for (int n = k; n < 4 * k; n++) {
         boolean ok = false;
         for (int roff = 0; roff < n - k + 1; roff++) {
           for (int coff = 0; coff < n - k + 1; coff++) {
             ok = true;
             for (int i = 0; i < n; i++) {
               for (int j = 0; j <= i; j++) {
                 int r1 = i - roff;
                 int c1 = j - coff;
                 int r2 = j - roff;
                 int c2 = i - coff;
                 if (r1 < 0 || r1 >= k || c1 < 0 || c1 >= k || r2 < 0 || r2 >= k || c2 < 0 || c2 >= k);
                 else if (arr[r1][c1] != arr[r2][c2]) {
                   ok = false;
                   break;
                 }
                 r1 = n - i - 1 - roff;
                 r2 = n - j - 1 - roff;
                 if (r1 < 0 || r1 >= k || c1 < 0 || c1 >= k || r2 < 0 || r2 >= k || c2 < 0 || c2 >= k);
                 else if (arr[r1][c1] != arr[r2][c2]) {
                   ok = false;
                   break;
                 }
               }
             }
             if (ok) break;
           }
           if (ok) break;
         }
         if (ok) {
           size = n;
           break;
         }
       }
       System.out.println(size * size - k * k);
     }
   }
 }
","import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 
 
 public class san {
 
 	public static void main(String[] args) {
 		new san().run();
 	}
 	
 	String dir=""D:/"";
 	String sourceFileName=""C-small-attempt3.in"";
 	String targetFileName=""C-small-attempt3.out"";
 	final String sourceFilePath=dir+sourceFileName;
 	final String targetFilePath=dir+targetFileName;
 	
 	private void run(){
 		try{
 			BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(sourceFilePath)));
 			FileWriter writer=new FileWriter(targetFilePath,false);
 			String input=reader.readLine();
 			StringTokenizer token=null;
 			int t=Integer.parseInt(input);
 			for(int k=1;k<=t;k++){
 				input=reader.readLine();
 				token=new StringTokenizer(input);
 				long times=Long.parseLong(token.nextToken());
 				long max=Long.parseLong(token.nextToken());
 				int gn=Integer.parseInt(token.nextToken());
 				long[] gp=new long[gn];
 				input=reader.readLine();
 				token=new StringTokenizer(input);
 				for(int i=0;i<gn;i++){
 					gp[i]=Long.parseLong(token.nextToken());
 				}
 				boolean[] mark=new boolean[gn];
 				long[] tt=new long[gn];
 				long sum=0;
 				for(long gpp:gp){
 					sum+=gpp;
 				}
 				long res=0;
 				if(sum<=max){
 					res=sum*times;
 				}else{
 					int start=0;
 					int cnt=0;
 					long[] cost=new long[gn+1];
 					while(true){
 						if(mark[start]){
 							break;
 						}
 						mark[start]=true;
 						tt[start]=cnt;
 						sum=0;
 						for(int i=start;;i=(i+1)%gn){
 							sum+=gp[i];
 							if(sum>max){
 								sum-=gp[i];
 								start=i%gn;
 								cnt++;
 								cost[cnt]=(cnt==1)?sum:(cost[cnt-1]+sum);
 								break;
 							}
 						}
 					}
 					long ccnt=cnt-tt[start];
 					long yu=(times-tt[start])%ccnt;
 					long shan=(times-tt[start])/ccnt;
 					if(cnt>=times){
 						res=cost[(int)times];
 					}else{
 						res=cost[(int)tt[start]]+(cost[cnt]-cost[(int)tt[start]])*shan+(yu==0?0:cost[(int)tt[start]+(int)yu]-cost[(int)tt[start]]);
 					}
 					}
 					
 				writer.write(""Case #""+k+"": ""+res+""\n"");
 			}
 			reader.close();
 			writer.close();
 		}catch(Exception e){
 			e.printStackTrace();
 		}
 	}
 
 }
",0
192,1511,"import java.util.Scanner;
 
 class SoalA{
 	static char[][] map;
 	public static void main(String[] args){
 		Scanner sc = new Scanner(System.in);
 		int T = sc.nextInt();
 		
 		for(int i=0;i<T;i++){
 			int M, N;
 			M = sc.nextInt();
 			N = sc.nextInt();
 			
 			map = new char[M][N];
 			for(int j=0;j<M;j++){
 				map[j] = sc.next().toCharArray();
 			}
 			
 			boolean impossible = false;
 			dor:
 			for(int j=0;j<M;j++){
 				for(int k=0;k<N;k++){
 					if(map[j][k] == '#'){
 						if(!fill(j,k)){
 							impossible = true;
 							break dor;
 						}
 					}
 				}
 			}
 			
 			System.out.println(String.format(""Case #%d:"", i+1));
 			if(impossible) System.out.println(""Impossible"");
 			else{
 				for(int j=0;j<M;j++){
 					for(int k=0;k<N;k++){
 						System.out.print(map[j][k]);
 					}
 					System.out.println();
 				}
 			}
 		}
 	}
 	
 	public static boolean fill(int x, int y){
 		int visited = 0;
 		boolean valid = true;
 		for(int i=x;i<=x+1;i++){
 			if(i>=0 && i < map.length){
 				for(int j=y;j<=y+1;j++){
 					if(j >=0 && j < map[0].length){
 						visited++;
 						if(map[i][j] == '.'){
 							valid = false;
 						}else if(map[i][j] == '#'){
 							if(i == x){
 								if(j == y) map[i][j] = '/';
 								else if(j == y+1) map[i][j] = '\\';
 							}else if(i == x+1){
 								if(j == y) map[i][j] = '\\';
 								else if(j == y+1) map[i][j] = '/';
 							}
 						}
 					}
 				}
 			}
 		}
 		
 		if(visited == 4 && valid)	return true;
 		return false;
 	}
 }","package edu.vk;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Formatter;
 import java.util.Scanner;
 
 public class CodeJam {
 
 	public String inFile;
 	public String outFile;
 	public static final String folder = ""/Users/Aarthie/Desktop/thesis/CodeJam/"";
 	
 	private Formatter outFileFormatter;
 	private Scanner inFileScanner;
 	private int caseNumber;
 	
 	public CodeJam() {
 		super();
 		caseNumber = 0;
 		inFile = folder + ""A-large.in"";
 		outFile = folder + ""output.txt"";
 		openFiles();
 		logic();
 		closeFiles();
 	}
 
 	// -------------------------------------- LOGIC 
 	private void logic() {
 		while(inFileScanner.hasNext()) {
 			String word = inFileScanner.next();
 			int numTests = Integer.parseInt(word);
 			for(int i=0; i<numTests; i++) {
 				String caseString = null;
 				int[][] xArray = new int[4][4];
 				int[][] oArray = new int[4][4];
 				boolean inComplete = false;
 				for(int row=0; row<4; row++) {
 					word = inFileScanner.next();
 					for(int col=0; col<4; col++) {
 						String character = word.substring(3-col, 4-col);
 						if(character.equalsIgnoreCase(""x"") || character.equalsIgnoreCase(""t""))
 							xArray[row][col] = 1;
 						if(character.equalsIgnoreCase(""o"") || character.equalsIgnoreCase(""t""))
 							oArray[row][col] = 1;
 						if(character.equalsIgnoreCase("".""))
 							inComplete = true;
 					}
 				}
 				// sum rows
 				for(int row=0; row<4; row++) {
 					int xSum = 0;
 					int oSum = 0;
 					for(int col=0; col<4; col++) {
 						xSum += xArray[row][col];
 						oSum += oArray[row][col];
 					}
 					if(xSum == 4) {
 						caseString = ""X won"";
 						break;
 					}
 					else if(oSum == 4) {
 						caseString = ""O won"";
 						break;
 					}
 				}
 				// sum columns
 				if(caseString == null) {
 					for(int col=0; col<4; col++) {
 						int xSum = 0;
 						int oSum = 0;
 						for(int row=0; row<4; row++) {
 							xSum += xArray[row][col];
 							oSum += oArray[row][col];
 						}
 						if(xSum == 4) {
 							caseString = ""X won"";
 							break;
 						}
 						else if(oSum == 4) {
 							caseString = ""O won"";
 							break;
 						}
 					}
 				}
 				
 				if(caseString == null) {
 					if((xArray[0][0] + xArray[1][1] + xArray[2][2] + xArray[3][3]) == 4 || 
 							(xArray[0][3] + xArray[1][2] + xArray[2][1] + xArray[3][0]) == 4)
 						caseString = ""X won"";
 					else if((oArray[0][0] + oArray[1][1] + oArray[2][2] + oArray[3][3]) == 4 || 
 							(oArray[0][3] + oArray[1][2] + oArray[2][1] + oArray[3][0]) == 4)
 						caseString = ""O won"";
 					else if(inComplete)
 						caseString = ""Game has not completed"";
 					else
 						caseString = ""Draw"";
 				}
 				
 				this.addLine(caseString);
 			}
 		}
 	}
 	
 	// -------------------------------------- FILE HANDLING 
 	public void openFiles() {
 		try {
 			inFileScanner = new Scanner(new File(inFile));
 			outFileFormatter = new Formatter(outFile);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 			throw new IllegalStateException(""file open error"");
 		}
 	}
 	
 	public void addLine(String line) {
 		caseNumber++;
 		outFileFormatter.format(""Case #%d: %s\n"", caseNumber, line);
 	}
 	
 	public void closeFiles() {
 		inFileScanner.close();
 		outFileFormatter.close();
 	}
 
 	// -------------------------------------- MAIN 
 	public static void main(String[] args) {
 		new CodeJam();
 	}
 
 }
",0
193,12829,"package codejam.problem.cookieclickeralpha;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class CookieClickTestCase {
 
 	private int allTestCase;
 	
 	private List<double[]> TestCaseList = new ArrayList<double[]>();
 
 	public int getAllTestCase() {
 		return allTestCase;
 	}
 
 	public void setAllTestCase(int allTestCase) {
 		this.allTestCase = allTestCase;
 	}
 
 	public List<double[]> getTestCaseList() {
 		return TestCaseList;
 	}
 	
 	public void addTestCase(double [] testCase){
 		TestCaseList.add(testCase);
 	}
 	
 }
","package codejam.problem.cookieclickeralpha;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class CookieClickTestCase {
 
 	private int allTestCase;
 	
 	private List<double[]> TestCaseList = new ArrayList<double[]>();
 
 	public int getAllTestCase() {
 		return allTestCase;
 	}
 
 	public void setAllTestCase(int allTestCase) {
 		this.allTestCase = allTestCase;
 	}
 
 	public List<double[]> getTestCaseList() {
 		return TestCaseList;
 	}
 	
 	public void addTestCase(double [] testCase){
 		TestCaseList.add(testCase);
 	}
 	
 }
",1
194,20361,"import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class Main {
 
 	public static void main(String[] args) {
 		Scanner sc = null;
 		PrintWriter out = null;
 
 		try {
 			sc = new Scanner(new FileReader(""inputLarge.txt""));
 			out = new PrintWriter(new FileWriter(""C:\\Users\\arto\\workspace\\Cookie Clicker Alpha\\outputLarge.txt""));
 		} catch (FileNotFoundException e) {
 			System.out.println(""File not found"");
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.out.println(""error"");
 		}
 		
 		int numberOfCases = Integer.parseInt(sc.nextLine());
 		int caseNumber = 1;
 		
 		while(sc.hasNext()){
 			double C = sc.nextDouble();
 			double F = sc.nextDouble();
 			double X = sc.nextDouble();
 			System.out.println(""C: "" + C + ""   F: "" + F + ""    X: "" + X );
 			
 			double earn = 0.0;
 			double timeSpend = 0.0;
 			double farms = 0.0;
 			
 			while(earn < X){
 				double earnPerSecond = (farms*F+2);
 				
 				//If I don't buy a new Farm
 				double timeSpendWithoutNewFarmToGetX = timeSpend + (X-earn)/earnPerSecond;
 				
 				//If I buy a new Farm
 				double secsNeededForNewFarm = (C-earn)/earnPerSecond;
 				double earnPerSecondWithNewFarm = earnPerSecond + F;
 				double timeSpendWithNewFarmToGetX = timeSpend + secsNeededForNewFarm + X/earnPerSecondWithNewFarm;
 				
 				
 				System.out.println(""timeSpendWithNewFarmToGetX: "" +timeSpendWithNewFarmToGetX);
 				System.out.println(""timeSpendWithoutNewFarmToGetX: "" + timeSpendWithoutNewFarmToGetX);
 				System.out.println(""farms: "" + farms);
 				System.out.println();
 				if(timeSpendWithNewFarmToGetX < timeSpendWithoutNewFarmToGetX){ // Buy a new Farm
 					farms++;
 					timeSpend = timeSpend + secsNeededForNewFarm;
 					earn = 0;
 				}else{ // Don't buy a new Farm
 					timeSpend = timeSpendWithoutNewFarmToGetX;
 					break;
 				}
 			}
 			out.println(""Case #"" + caseNumber + "": "" + timeSpend);
 //			System.out.println(""timeSpend: "" + timeSpend);
 			caseNumber++;
 //			break;
 		}
 		out.close();
 	}
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package googlecodejam;
 
 /**
  *
  * @author Ahmed
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         ProblemB.magicka();
     }
 
 }
",0
195,1927,"package z_1;
 
 import java.io.BufferedOutputStream;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class SnapperChain {
 	public static void main(String args[]) throws Exception{
 		Scanner sc=new Scanner(new File(""A-small-attempt0.in""));
 		int t=sc.nextInt(),max,n,k;
 		DataOutputStream out=new DataOutputStream(
 				new BufferedOutputStream(
 						new FileOutputStream(""z_2.txt"")));
 		
 		for(int i=1;i<=t;i++){
 			n=sc.nextInt();
 			k=sc.nextInt();
 			max=1<<n;
 			if(k%max==max-1)
 				out.writeBytes(""Case #""+i+"": ""+""ON""+""\r\n"");
 			else out.writeBytes(""Case #""+i+"": ""+""OFF""+""\r\n"");
 		}
 		
 		out.close();
 	}
 }
","import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
 import java.math.BigInteger;
 import java.util.StringTokenizer;
 
 public class D
 {
 	static class PermutationGenerator {
 
 		  private int[] a;
 		  private BigInteger numLeft;
 		  private BigInteger total;
 
 		  //-----------------------------------------------------------
 		  // Constructor. WARNING: Don't make n too large.
 		  // Recall that the number of permutations is n!
 		  // which can be very large, even when n is as small as 20 --
 		  // 20! = 2,432,902,008,176,640,000 and
 		  // 21! is too big to fit into a Java long, which is
 		  // why we use BigInteger instead.
 		  //----------------------------------------------------------
 
 		  public PermutationGenerator (int n) {
 		    if (n < 1) {
 		      throw new IllegalArgumentException (""Min 1"");
 		    }
 		    a = new int[n];
 		    total = getFactorial (n);
 		    reset ();
 		  }
 
 		  //------
 		  // Reset
 		  //------
 
 		  public void reset () {
 		    for (int i = 0; i < a.length; i++) {
 		      a[i] = i;
 		    }
 		    numLeft = new BigInteger (total.toString ());
 		  }
 
 		  //------------------------------------------------
 		  // Return number of permutations not yet generated
 		  //------------------------------------------------
 
 		  public BigInteger getNumLeft () {
 		    return numLeft;
 		  }
 
 		  //------------------------------------
 		  // Return total number of permutations
 		  //------------------------------------
 
 		  public BigInteger getTotal () {
 		    return total;
 		  }
 
 		  //-----------------------------
 		  // Are there more permutations?
 		  //-----------------------------
 
 		  public boolean hasMore () {
 		    return numLeft.compareTo (BigInteger.ZERO) == 1;
 		  }
 
 		  //------------------
 		  // Compute factorial
 		  //------------------
 
 		  private BigInteger getFactorial (int n) {
 		    BigInteger fact = BigInteger.ONE;
 		    for (int i = n; i > 1; i--) {
 		      fact = fact.multiply (new BigInteger (Integer.toString (i)));
 		    }
 		    return fact;
 		  }
 
 		  //--------------------------------------------------------
 		  // Generate next permutation (algorithm from Rosen p. 284)
 		  //--------------------------------------------------------
 
 		  public int[] getNext () {
 
 		    if (numLeft.equals (total)) {
 		      numLeft = numLeft.subtract (BigInteger.ONE);
 		      return a;
 		    }
 
 		    int temp;
 
 		    // Find largest index j with a[j] < a[j+1]
 
 		    int j = a.length - 2;
 		    while (a[j] > a[j+1]) {
 		      j--;
 		    }
 
 		    // Find index k such that a[k] is smallest integer
 		    // greater than a[j] to the right of a[j]
 
 		    int k = a.length - 1;
 		    while (a[j] > a[k]) {
 		      k--;
 		    }
 
 		    // Interchange a[j] and a[k]
 
 		    temp = a[k];
 		    a[k] = a[j];
 		    a[j] = temp;
 
 		    // Put tail end of permutation after jth position in increasing order
 
 		    int r = a.length - 1;
 		    int s = j + 1;
 
 		    while (r > s) {
 		      temp = a[s];
 		      a[s] = a[r];
 		      a[r] = temp;
 		      r--;
 		      s++;
 		    }
 
 		    numLeft = numLeft.subtract (BigInteger.ONE);
 		    return a;
 
 		  }
 	}
 
 		  
 	static class Scanner
     {
             BufferedReader br;
             StringTokenizer st;
             
             public Scanner()
             {
             		System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));
                     br = new BufferedReader(new InputStreamReader(System.in));
             }
             
             public String next()
             {
 
                     while(st == null || !st.hasMoreTokens())
                     {
                             try { st = new StringTokenizer(br.readLine()); }
                             catch(Exception e) { throw new RuntimeException(); }
                     }
                     return st.nextToken();
             }
 
             public int nextInt()
             {
                     return Integer.parseInt(next());
             }
             
             public double nextDouble()
             {
                     return Double.parseDouble(next());
             }
             
             public String nextLine()
             {
                     st = null;
                     try { return br.readLine(); }
                     catch(Exception e) { throw new RuntimeException(); }
             }
             
             public boolean endLine()
             {
                     try 
                     {
                             String next = br.readLine();
                             while(next != null && next.trim().isEmpty())
                                     next = br.readLine();
                             if(next == null)
                                     return true;
                             st = new StringTokenizer(next);
                             return st.hasMoreTokens();
                     }
                     catch(Exception e) { throw new RuntimeException(); }
             }
     }
 
 	static double[][] dp = new double[11][11];
 	
 	static Double[] dpp = new Double[11];
 	
 	public static double p(int n)
 	{
 		if(n == 0 || n == 1)
 			return 0;
 		if(dpp[n] != null)
 			return dpp[n];
 		double acum = 0;
 		for(int i = 1; i <= n; i++)
 		{
 			acum += dp[n][i] * p(n - i);
 		}
 		acum += 1;
 		dpp[n] = acum / (1 - dp[n][0]);
 		return dpp[n];
 	}
 	public static void main(String[] args) throws FileNotFoundException
 	{
 		System.setIn(new FileInputStream(""d.in""));
 		System.setOut(new PrintStream(""d.out""));
 		Scanner sc = new Scanner();
 		int[][] valores = new int[11][11];
 		for(int a = 1; a < 11; a++)
 		{
 			PermutationGenerator pg = new PermutationGenerator(a);
 			while(pg.hasMore())
 			{
 				int cuenta = 0;
 				int[] siguiente = pg.getNext();
 				for(int i = 0; i < siguiente.length; i++)
 				{
 					if(siguiente[i] == i)
 						cuenta++;
 				}
 				valores[a][cuenta]++;
 			}
 			double suma = 0;
 			for(int i = 0; i < valores.length; i++)
 				suma += valores[a][i];
 			for(int i = 0; i < valores.length; i++)
 			{
 				dp[a][i] = valores[a][i] / suma;
 			}
 		}
 		int t = sc.nextInt();
 		for(int a = 0; a < t; a++)
 		{
 			int n = sc.nextInt();
 			double acum = 0;
 			for(int i = 1; i <= n; i++)
 				if(sc.nextInt() != i)
 					acum++;
 			System.out.println(""Case #"" + (a + 1) + "": "" + acum);
 		}
 	}
 }
",0
196,15399,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 
 public class Question4 
 {
 
 	public static void main(String[] args)
 	{
 		try 
 		{
 			BufferedReader bufferedReader = new BufferedReader(new FileReader(""C:\\CodeJam\\Practice\\D-large.in""));		
 			File file = new File(""C:\\CodeJam\\Practice\\output4.txt"");
 			 
 			// if file doesnt exists, then create it
 			if (!file.exists()) 
 			{
 				file.createNewFile();
 			}
 			
 			FileWriter fw = new FileWriter(file.getAbsoluteFile());
 			BufferedWriter bw = new BufferedWriter(fw);
 			int testCases = Integer.parseInt(bufferedReader.readLine());
 			int caseNo = 1;
 			while (caseNo<=testCases) 
 			{
 				
 				int size = Integer.parseInt(bufferedReader.readLine());
 				double[] Naomi = new double[size];
 				double[] Ken = new double[size];
 				
 				String line = bufferedReader.readLine();
 				StringTokenizer st = new StringTokenizer(line);
 				int i=0;
 				while(i<size)
 				{
 					Naomi[i] = Double.parseDouble(st.nextToken());
 					i++;
 				}
 				line = bufferedReader.readLine();
 				 st = new StringTokenizer(line);
 				i=0;
 				while(i<size)
 				{
 					Ken[i] = Double.parseDouble(st.nextToken());
 					i++;
 				}
 				
 				Arrays.sort(Naomi);
 				Arrays.sort(Ken);
 				
 				//Deceitful
 				
 				int KenPointDeceit = 0;
 				int NaomiPointDeceit = 0;
 				int kenlowest = 0;
 				
 				for(int j=0; j<size; j++)
 				{
 					if(Naomi[j]<Ken[kenlowest])
 					{
 						KenPointDeceit++;
 					}
 					else
 					{
 						kenlowest++;
 						NaomiPointDeceit++;
 					}
 				}
 				
 			
 				
 				//Normal
 				int KenPoint = 0;
 				int NaomiPoint = 0;
 				for(int j=0; j<size; j++)
 				{
 					int k=0;
 					for(k=0; k<size; k++)
 					{
 						if(Ken[k]>Naomi[j])
 						{
 							KenPoint++;
 							Ken[k] = 0;
 							break;
 						}
 					}
 					
 					if(k==size)
 					{
 						NaomiPoint = size - KenPoint;
 						break;
 					}
 				}
 				
 				bw.write(""Case #""+caseNo+"": ""+NaomiPointDeceit+"" ""+NaomiPoint);
 				bw.newLine();	
 				System.out.println(""Case #""+caseNo+"": ""+NaomiPointDeceit+"" ""+NaomiPoint);
 				
 				caseNo++;
 			}
 			
 			bw.close();
 		}
 		catch (IOException e) 
 		{
 			e.printStackTrace();
 		} 
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 
 
 public class Question1 
 {
 
 	public static void main(String[] args)
 	{
 		StringMatch(""C:\\CodeJam\\Round1\\A-small-attempt0.in"");
 	}
 
 	public static void StringMatch(String filePath)
 	{
 		try 
 		{
 			BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
 			String line;
 			boolean firstline = true;
 
 
 			File file = new File(""C:\\CodeJam\\Round1\\PracInput.txt"");
 
 			// if file doesnt exists, then create it
 			if (!file.exists()) 
 			{
 				file.createNewFile();
 			}
 
 			//FileWriter fw = new FileWriter(file.getAbsoluteFile());
 			//BufferedWriter bw = new BufferedWriter(fw);
 
 
 			int testCases  = 0;
 
 			testCases = Integer.parseInt(bufferedReader.readLine());
 			int caseNo = 1;
 
 			while (caseNo<=testCases) 
 			{
 				int lines = Integer.parseInt(bufferedReader.readLine());
 				String[] arr = new String[lines];
 				int[] arr1 = new int[lines];
 
 				int maxlength = Integer.MIN_VALUE;
 				boolean possible = true;
 
 				for(int i=0; i<lines; i++)
 				{
 					arr[i] = bufferedReader.readLine();
 					if(arr[i].length()>maxlength)
 						maxlength = arr[i].length();
 				}
 
 				boolean tocontinue = true;
 				int totalops = 0;
 				int index = 0;
 
 				//Checking the start index
 
 				while(tocontinue)
 				{
 
 					for(int i=0; i<lines-1; i++)
 					{
 						if(arr[i].charAt(index)!=arr[i+1].charAt(index))
 						{
 							possible = false;
 							break;
 						}
 					}
 
 					if(possible==false)
 					{
 						tocontinue = false;
 					}
 
 					else
 					{
 
 
 						for(int i=0; i<lines; i++)
 						{
 							for(int j=0; j<arr[i].length()-1; j++)
 							{
 								if(arr[i].charAt(j)==arr[i].charAt(j+1))
 									arr1[i]++;
 								else
 									break;
 							}
 						}
 
 						int minops = Integer.MAX_VALUE;
 						for(int i=0; i<arr1.length; i++)
 						{
 							int operations = 0;
 							for(int j=0; j<arr1.length; j++)
 							{
 								if(j==i)
 									continue;
 								operations += Math.abs(arr1[j]-arr1[i]);
 							}
 
 							if(operations<minops)
 								minops = operations;
 						}
 						
 						totalops += minops;
 
 						int count = 0;
 						for(int i=0; i<lines; i++)
 						{
 							arr[i] = arr[i].substring(arr1[i]+1);
 							arr1[i] = 0;
 
 							if(arr[i].equals(""""))
 								count++;
 						}
 
 						if(count>0 && count<lines)
 						{
 							possible = false;
 							tocontinue = false;
 						}
 						
 						if(count==lines)
 						{
 							tocontinue = false;
 							possible = true;
 						}
 					}
 				}
 
 				
 				if(!possible)
 					System.out.println(""Case #""+caseNo+"": ""+""Fegla Won"");
 				else
 					System.out.println(""Case #""+caseNo+"": ""+totalops);
 						
 					caseNo++;
 			}
 
 		} 
 		catch (IOException e) 
 		{
 			e.printStackTrace();
 		} 
 	}
 
 
 
 
 }
",1
197,11770,"package Round1B;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Scanner;
 
 public class Osmos {
 	public static void main(String[] args) {
 		Scanner input = null;
 		try {	input = new Scanner(new File(""bin\\Round1B\\A-small-attempt1.in""));	} catch (FileNotFoundException e) {		e.printStackTrace();	}
 		int T = input.nextInt();
 		input.nextLine();
 		for (int i = 1; i <= T; i++) {
 			String[] s = input.nextLine().split("" "");
 			int A = Integer.parseInt(s[0]);
 			int N = Integer.parseInt(s[1]);
 			s = input.nextLine().split("" "");
 			ArrayList<Integer> motes = new ArrayList<Integer>();
 			for (int j = 0; j < N; j++) {
 				motes.add(Integer.parseInt(s[j]));
 			}
 			Collections.sort(motes);
 			int steps = 0;
 			System.out.print(""Case #"" + i + "": "");
 			if (A < 2){
 				System.out.println(N);
 				continue;
 			}
 			while (true) {
 				int absorbed = motesAbsorbed(A, motes);
 				if (absorbed >= N) break;
 				int size = A;
 				for (int k = 0; k < absorbed; k++) {
 					size += motes.get(k);
 				}
 				int next = motes.get(absorbed);
 				ArrayList<Integer> add = new ArrayList<Integer>();
 				boolean doAdd = false;
 				for (int j = 1; j <= N - absorbed; j++) {
 					add.add(size - 1);
 					size += size - 1;
 					if (size > next){
 						doAdd = true;
 						motes.addAll(add);
 						Collections.sort(motes);
 						steps += add.size();
 						N += add.size();
 						break;
 					}
 				}
 				if (!doAdd){
 //					motes.remove(N - 1);
 //					N--;
 //					steps++;
 					steps += N - absorbed;
 					break;
 				}
 				
 			}
 			System.out.println(steps);
 		}
 	}
 	static int motesAbsorbed(int startSize, ArrayList<Integer> motes){
 		int absorbed = 0;
 		for (int i = 0; i < motes.size(); i++) {
 			if (startSize > motes.get(i)){
 				startSize += motes.get(i);
 				absorbed++;
 			}
 		}
 		return absorbed;
 	}
 }
","package Round1A;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Scanner;
 
 public class Bullseye {
 	
 	public static void main(String[] args) {
 		Scanner input = null;
 		try {	input = new Scanner(new File(""bin\\Round1A\\A-small-attempt0.in""));	} catch (FileNotFoundException e) {		e.printStackTrace();	}
 		int T = input.nextInt();
 		input.nextLine();
 		long d = 4;
 		for (int i = 1; i <= T; i++) {
 			String[] s = input.nextLine().split("" "");
 			long r = Long.parseLong(s[0]) - 1;
 			long t = Long.parseLong(s[1]);
 			System.out.print(""Case #"" + i + "": "");
 			long a = 3 + r + r;
 //			System.out.print("" a="" + a + "" "");
 			a += a;
 			long n = (long)(((4 - a) + Math.sqrt((a-4)*(a-4)+32*t))/8);
 //			System.out.println(r + "" "" + t);
 			System.out.println(n);
 		}
 	}
 	
 }
",1
198,4909,"import java.util.*;
 import java.util.regex.*;
 import java.text.*;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.math.*;
 import java.awt.geom.*;
 import static java.util.Arrays.*;
 import static java.util.Collections.*;
 import static java.lang.Character.*;
 import static java.lang.Math.*;
 
 public class A {
 	
 	Scanner sc;
 	PrintWriter pw;
 	int caseNum;
 	int caseCnt;
 	
 	int N;
 	int[] o = new int[100];
 	int[] b = new int[100];
 	int[] allPos = new int[100];
 	char[] allColor = new char[100];
 	int oCnt = 0, bCnt = 0, oPos = 1, bPos = 1;
 	
 	public void doMain() throws Exception {
 		sc = new Scanner(new FileReader(""input.txt""));
 		pw = new PrintWriter(new FileWriter(""output.txt""));
 		caseCnt = sc.nextInt();
 		
 		for (caseNum = 1; caseNum <= caseCnt; ++caseNum) {
 			N = sc.nextInt();
 			oCnt = 0; bCnt = 0; oPos = 1; bPos = 1;
 			for (int i = 0; i < N; ++i) {
 				char color = sc.next().charAt(0);
 				int pos = sc.nextInt();
 				allColor[i] = color;
 				allPos[i] = pos;
 				if (color == 'O') {
 					o[oCnt++] = pos;
 				} else {
 					b[bCnt++] = pos;
 				}
 			}
 			
 			int ans = 0;
 			int oPtr = 0, bPtr = 0;
 			for (int i = 0; i < N; ++i) {
 				char color = allColor[i];
 				int pos = allPos[i];
 //				System.out.println(""color=""+color+"",pos=""+pos);
 				if (color == 'O') {
 					oPtr++;
 					int oUse = abs(oPos - pos) + 1;
 					oPos = pos;
 					ans += oUse;
 //					System.out.println(""ans=""+ans);
 					int bDist = abs(b[bPtr] - bPos);
 					if (bDist <= oUse) {
 						bPos = b[bPtr];
 					} else {
 						bPos = b[bPtr] - (bDist - oUse);
 					}
 				} else { // color == 'B'
 					bPtr++;
 					int bUse = abs(bPos - pos) + 1;
 					bPos = pos;
 					ans += bUse;
 //					System.out.println(""ans=""+ans);
 					int oDist = abs(o[oPtr] - oPos);
 					if (oDist <= bUse) {
 						oPos = o[oPtr];
 					} else {
 						oPos = o[oPtr] - (oDist - bUse);
 					}
 				}
 			}
 			pw.format(""Case #%d: %d\n"",caseNum,ans);
 //			System.out.print(String.format(""Case #%d: %d\n"",caseNum,ans));
 		}
 		
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 	
 	public static void main(String[] args) throws Exception {
 		(new A()).doMain();
 	}
 	
 	static void db(Object...os) {
 		System.out.println(deepToString(os));
 	}
 	
 }
 
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package javaapplication10;
 
 /**
  *
  * @author sunil
  */
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class JavaApplication10 {
 
     /**
      * @param args the command line arguments
      */
     
     public static boolean pallindrome(String str)
     {
         for(int i=0;i<str.length()/2;i++)
         {
             if(str.charAt(i)!=str.charAt(str.length()-i-1))
                 return false;
         }
         return true;
     }
     public static void main(String[] args) throws FileNotFoundException, IOException {
         
         
         String readLine="""";
         BufferedReader br = new BufferedReader(new FileReader(""//home//sunil//Desktop//CODEJAM//C-small-attempt0.in""));
         int no_test= Integer.parseInt(br.readLine());
         
          FileWriter output = null;
 
         output = new FileWriter(""//home//sunil//Desktop//CODEJAM//C-small-attempt0.out"");
         BufferedWriter writer = new BufferedWriter(output);
         
         for(int i=0;i<no_test;i++)
         {
             int count=0;
             String str1 = br.readLine();
             String[] bounds = str1.split("" "");
             long sart= Long.parseLong(bounds[0]);
             long end= Long.parseLong(bounds[1]);
             long sqr = (long) Math.sqrt(sart);
             long sqr1=sqr*sqr;
             if(sqr1<sart)
             {
                 sqr++;
                 sqr1=sqr*sqr;
             }
             while (sqr1<=end) 
             {
                 if(pallindrome(((Long)sqr).toString())&&pallindrome(((Long)sqr1).toString()))
                 {
                     count++;
                 }
                 sqr++;
                 sqr1=sqr*sqr;
             }
             String ret_str=""Case #""+(i+1)+"": ""+count;
             //System.out.println(ret_str);
             writer.write(ret_str);
             writer.newLine();
             
         }
       
         br.close();
         writer.close();
         // TODO code application logic here
     }
 }
",0
199,1728,"package codejam;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Scanner;
 
 public class CodeJam {
 
 	public static abstract class Problem {
 		protected void solveCase(Scanner scanner, PrintWriter writer) {
 			writer.print(solveCase(scanner).toString());
 		}
 
 		protected Object solveCase(Scanner scanner) {
 			return solveCase(scanner.nextLine());
 		}
 		
 		protected Object solveCase(String nextLine) {
 			return null;
 		}
 	}
 
 	private static final String DOWNLOADS = ""Downloads"";
 	private static final String UPLOADS = ""workspace/java/CodeJam2013/src/codejam"";
 	private static final Charset ENCODING = StandardCharsets.US_ASCII;
 	
 	public static void runBatch(Problem task, Scanner scanner, PrintWriter writer) throws IOException {
 		int t = scanner.nextInt();
 		scanner.nextLine();
 		for (int i = 1; i <= t; i++) {
 			writer.print(""Case #"");
 			writer.print(i);
 			writer.print("": "");
 			task.solveCase(scanner, writer);
 			writer.println();
 		}
 	}
 	
 	public static void runBatch(Problem task, Path input, Path output) throws IOException {
 		try (
 				Scanner scanner = new Scanner(input, ENCODING.name());
 				PrintWriter writer = new PrintWriter(Files.newBufferedWriter(output, ENCODING));
 		) {
 			runBatch(task, scanner, writer);
 		}		
 	}
 
 	public static void runBatch(Problem task, String file) throws IOException {
 		String home = System.getenv().get(""HOME"");
 		if (home == null)
 			home = System.getenv().get(""USERPROFILE"");
 		if (home == null)
 			throw new RuntimeException(""no home dir"");
 		runBatch(task, Paths.get(home, DOWNLOADS, file + "".in""), Paths.get(home, UPLOADS, file + "".out""));
 	}
 }
","import java.io.*;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 
 /**
  * @author Mikeldi Latorre (mikeldi10@gmail.com)
  */
 public class QualificationB2 implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 
 	public static void main(String[] args) {
 		new Thread(new QualificationB2()).start();
 	}
 
 	public QualificationB2() {
 		try {
 			System.setIn(new FileInputStream(""input.in""));
 			System.setOut(new PrintStream(new FileOutputStream(""output.txt"")));
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 
 	public void run() {
 	 int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
         	out.println(""Case #"" + (testNumber + 1) + "": ""+algorithm());
 		}
 		out.close();
 	}
 	
 	private String algorithm(){
 		
 		int c = in.readInt();
 		String[] cs = new String[c];
 		for (int i=0;i<c;i++){
 			cs[i]=in.readString();
 		}
 		int d = in.readInt();
 		String[] ds = new String[d];
 		for (int i=0;i<d;i++){
 			ds[i]=in.readString();
 		}
 		int n = in.readInt();
 		char[] result = new char[n];
 		
 		int[] firstOpp = new int[d];
 		int[] lastOpp = new int[d];
 		
 		String str = in.readString();
 		int x=0;
 		
 		for (int i = 0; i < n; i++) {
 			char character = str.charAt(x);
 			boolean comb = false;
 			boolean opp = false;
 			if(i==0){
 				result[i]=character;
 				char first = result[i];
 				for(int j=0;j<d;j++){
 					char opp1 = ds[j].charAt(0);
 					char opp2 = ds[j].charAt(1);
 					if(first == opp1){
 						firstOpp[j] = i+1;
 					}else if(first == opp2){
 						lastOpp[j] = i+1;
 					}
 				}
 			}else{
 				//check combinations
 				for (int j = 0; j < c; j++) {
 					char comb1 = cs[j].charAt(0);
 					char comb2 = cs[j].charAt(1);
 					if(((result[i-1]==comb1)&&(character==comb2))||((result[i-1]==comb2)&&(character==comb1))){
 						result[i-1]=cs[j].charAt(2);
 						for(int k=0;k<d;k++){
 							if(i==firstOpp[k]) firstOpp[k]=0;
 							if(i==lastOpp[k]) lastOpp[k]=0;
 						}	
 						i--;
 						n--;
 						comb=true;
 						break;
 					}
 				}
 				
 				if(!comb){
 					//check opposites
 					for(int j = 0; j < d; j++){
 						char opp1 = ds[j].charAt(0);
 						char opp2 = ds[j].charAt(1);
 						if(((character == opp1)&&(lastOpp[j]!=0))||((character == opp2)&&(firstOpp[j]!=0))){
 							n-=i+1;
 							i=-1;
 							result= new char[n];
 							firstOpp = new int[d];
 							lastOpp = new int[d];
 							opp=true;
 							break;
 						} else {
 							if((character == opp1)&&(firstOpp[j]==0)){
 								firstOpp[j] = i+1;
 							} else if((character == opp2)&&(lastOpp[j]==0)){
 								lastOpp[j] = i+1;
 							}
 						}
 							
 					}
 					if(!opp)
 						result[i] = character;
 				}
 			}
 			x++;
 		}
 		
 		boolean start = true;
 		String ret = ""["";
 		for(int i=0;i<n;i++){
 			if(start){
 				ret += """"+result[i];
 				start = false;
 			}else{
 				ret += "",""+result[i];
 			}
 		}
 		return ret+""]"";
 	}
 	
 
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
",0
200,7829,"import java.io.*;
 
 
 public class SquareTiles{
 	
 	
 	public static void main(String [] args) throws IOException{
 		BufferedReader reader = new BufferedReader(new FileReader(args[0]));
 		BufferedWriter writer = new BufferedWriter(new FileWriter(args[1]));
 		
 		int testCasesCount = Integer.parseInt(reader.readLine());
 		for (int i = 0; i < testCasesCount; i++){
 			solve(reader, writer, i);
 		}
 		
 		reader.close();
 		writer.close();
 	}
 	
 	
 	
 	private static void solve(BufferedReader reader, BufferedWriter writer, int index) throws IOException{
 		String line = reader.readLine();
 		String [] args = line.split("" "");
 		int rows = Integer.parseInt(args[0]);
 		int cols = Integer.parseInt(args[1]);
 		
 		boolean [][] blue = new boolean[rows+2][cols+2];
 		
 		for (int i = 0; i < rows; i++){
 			line = reader.readLine();
 			for (int j = 0; j < cols; j++)
 				blue[i+1][j+1] = line.charAt(j) == '#';
 		}
 		
 		char [][] tiles = new char[rows+2][cols+2];
 		boolean isImpossible = false;
 		for (int i = 1; i <= rows; i++){
 			for (int j = 1; j <= cols; j++){
 				if (blue[i][j]){
 					if (blue[i+1][j] && blue[i+1][j+1] && blue[i][j+1]){
 						blue[i][j] = false;
 						blue[i+1][j] = false;
 						blue[i+1][j+1] = false;
 						blue[i][j+1] = false;
 						tiles[i][j] = '/';
 						tiles[i+1][j+1] = '/';
 						tiles[i][j+1] = '\\';
 						tiles[i+1][j] = '\\';
 					}
 					else{
 						isImpossible = true;
 						break;
 					}
 				}
 				else if (tiles[i][j] == 0)
 					tiles[i][j] = '.';
 			}
 			
 			if (isImpossible)
 				break;
 		}
 		
 		String result;
 		if (isImpossible)
 			result = ""Impossible\n"";
 		else{
 			StringBuffer buf = new StringBuffer();
 			for (int i = 1; i <= rows; i++){
 				for (int j = 1; j <= cols; j++)
 					buf.append(tiles[i][j]);
 				buf.append(""\n"");
 			}
 			result = buf.toString();
 		}
 		
 		System.out.print(""Result:\n"" + result);
 		
 		writer.write(""Case #"" + (index+1) + "":\n"" + result);
 	}
 
 	
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 import java.util.Arrays;
 public class mines {
 public static void main(String args[])throws IOException
 {
 	BufferedReader obj = new BufferedReader(new FileReader(""D:\\C-small-attempt0.in""));
 	PrintWriter prt = new PrintWriter(new FileWriter(""D:\\output.txt""));
 	String line = obj.readLine();
 	int t = Integer.parseInt(line);
 	
 	
 	for (int i=1;i<=t;i++)
 	{
 		prt.println(""Case #""+ i+"": "");
 		line = obj.readLine();
 		String str[] = line.split("" "");
 		int r = Integer.parseInt(str[0]);
 		int c  =Integer.parseInt(str[1]);
 		int m = Integer.parseInt(str[2]);
 		if (r==1||c==1)
 		{
 			if (r==1 && c==1)
 			{
 				if (m==0)
 					prt.println(""c"");
 				else
 					prt.println(""Impossible"");
 			}
 			else if (r==1)
 			{
 				int val = r*c;
 				if (val==2 && m==1)
 					prt.println(""*c"");
 				else if (val>2 && m<=val-2)
 				{
 					for (int j=1;j<=m;j++)
 						prt.print(""*"");
 					prt.println("".c"");
 				}
 				else
 					prt.println(""Impossible"");
 					
 			}
 			else if (c==1)
 			{
 				int val = r*c;
 				if (val==2 && m==1)
 					prt.println(""*c"");
 				else if (val>2 && m<=val-2)
 				{
 					for (int j=1;j<=m;j++)
 						prt.println(""*"");
 					prt.println(""."");
 					prt.println(""c"");
 				}
 				else
 					prt.println(""Impossible"");
 					
 			}
 			continue;
 		}
 		
 		int val = r*c;
 		if (m>val-4)
 			prt.println(""Impossible"");
 		else
 		{
 			int m1=1;
 			char arr[][] = new char[r][c];
 			for (int j=0;j<r ;j++)
 				for (int k=0;k<c ;k++)
 					arr[j][k]='-';
 			arr[r-1][c-1]='c';
 			arr[r-1][c-2]='.';
 			arr[r-2][c-1]='.';
 			arr[r-2][c-2]='.';
 			for (int j=0;j<r && m1<=m;j++)
 			{
 				for (int k=0;k<c && m1<=m;k++)
 				{
 					if (arr[j][k]=='-')
 					{
 						arr[j][k]='*';
 						m1++;
 					}
 				}
 			}
 			for (int j=0;j<r ;j++)
 				{
 				for (int k=0;k<c ;k++)
 				{
 					if (arr[j][k]=='-')
 					prt.print(""."");
 					else
 						prt.print(arr[j][k]);
 				}
 				prt.println();
 				}
 			prt.println();
 		
 			
 		}
 		
 		
 		
 		
 		
 	  
 }
 	 obj.close();
 	   prt.close();
 }
 }
",0
201,6276,"package problema;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.text.MessageFormat;
 import java.util.Scanner;
 
 public class A {
 
     int a[];
     int b[];
 
     public A(int[] a, int[] b) {
         this.a = a;
         this.b = b;
     }
 
     boolean intersect(int a1, int b1, int a2, int b2) {
         int c = b1 - a1 - b2 + a2;
         int d = a2 - a1;
 
         if (c == 0) {
             return false;
         }
 
         double x = 1.0 * d / c;
         if (x > 0 & x < 1) {
             return true;
         }
         return false;
     }
 
     int solve() {
         int count = 0;
         int n = a.length;
 
         for (int i = 0; i < n; ++i) {
             for (int j = i+1; j < n; ++j) {
                 if (intersect(a[i], b[i], a[j], b[j])) {
                     count++;
                 }
             }
         }
         return count;
     }
 
     public static void main(String[] args) throws FileNotFoundException {
 //        Scanner s = new Scanner(new FileInputStream(""a.in""));
 //        Scanner s = new Scanner(new FileInputStream(""A-small-attempt0.in""));
         Scanner s = new Scanner(new FileInputStream(""A-large.in""));
         int T = s.nextInt();
         for (int i = 0; i < T; ++i) {
             int n = s.nextInt();
             int a[] = new int[n];
             int b[] = new int[n];
             for (int j = 0; j < n; ++j) {
                 a[j] = s.nextInt();
                 b[j] = s.nextInt();
             }
             String result = """" + new A(a, b).solve();
             System.out.println(MessageFormat.format(""Case #{0}: {1}"", """" + (i + 1), result));
         }
     }
 }
","package Question2;
 
 public class CookieCalculator {
 	double F; //increase in rate from farm
 	double X; //Target
 	double C; //cost of farm
 	
 	public CookieCalculator(double f, double x, double c) {
 		F = f;
 		X = x;
 		C = c;
 	}
 	public double calculate(double R){
 		double time1 = X/R;
 		double R1 = R + F;
 		double time2 = C/R + X/R1;
 		if(time1 <= time2)
 			return time1;
 		else{
 			return C/R + calculate(R1);
 		}
 			
 	}
 
 }
",0
202,17519,"import java.util.*;
 import java.io.*;
 import java.math.*;
 
 public class b {
 
   public static void main(String[] args) throws Exception {
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     String str;
 
     int numCases = Integer.parseInt(br.readLine());
     for (int nCase = 1; nCase <= numCases; nCase++) {
       String[] sa = br.readLine().split("" "");
       int L = Integer.parseInt(sa[0]);
       int P = Integer.parseInt(sa[1]);
       int C = Integer.parseInt(sa[2]);
       double R = (double)P/L;
       int count = 0;
       while (R > C) {
         R = Math.sqrt(R);
         count++;
       }
       System.out.println(""Case #"" + nCase + "": "" + count);
     }
     br.close();
 
   }
 
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Set;
 
 import com.google.common.collect.Sets;
 import com.google.common.io.LineReader;
 
 
 public class RecycledNumbers {
 
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		LineReader lineReader = new LineReader(new FileReader(args[0]));
 		FileWriter out = new FileWriter(args[0] + ""-out.txt""); 
 		
 		int t = Integer.parseInt(lineReader.readLine());
 		for (int counter = 1; counter <= t; counter++) {
 			String[] nums = lineReader.readLine().split("" "");
 			int result = compute(Integer.parseInt(nums[0]), Integer.parseInt(nums[1]));
 			out.write(String.format(""Case #%d: %d\n"", counter, result));
 		}
 		out.close();
 	}
 
 	private static int compute(int a, int b) {
 		Set<Integer> set = Sets.newHashSet();
 		int count = 0;
 		for (int n = a; n < b; n++) {
 			String nStr = Integer.toString(n);
 			set.clear();
 			for (int i = 1; i < nStr.length(); i++) {
 				String fst = nStr.substring(i);
 				String snd = nStr.substring(0, i);
 				int m = Integer.parseInt(fst + snd);
 				if (m > n && m <= b && !set.contains(m)) {
 					set.add(m);
 					count++;
 				}
 			}
 		}
 		
 		return count;
 	}
 }
",0
203,15402,"import java.util.*;
 import java.io.*;
 
 public class recycle {
     public static int[] pow10 = {1,10,100,1000,10000,100000,1000000,10000000};
 
     public static void main(String[] args) throws Throwable {
 	Scanner input=new Scanner(new File(""recycle.in""));
 	PrintWriter out=new PrintWriter(new File(""recycle.out""));
 	int cases=input.nextInt();
 	for(int test=1;test<=cases;test++) {
 	    boolean[] visited=new boolean[2000001];
 	    int a=input.nextInt();
 	    int b=input.nextInt();
 	    int rank=0, num=1;
 	    int ans=0;
 	    for(;num<=a;num*=10,rank++); // rank = #digits
 	    for(int i=a;i<=b;i++) {
 		if(visited[i]) continue;
 		visited[i]=true;
 		int temp=i;
 		int count=1;
 		for(int j=0;j<rank-1;j++) {
 		    temp=temp/10+temp%10*pow10[rank-1];
 		    if(temp<a || temp>b || visited[temp]) continue;
 		    visited[temp]=true;
 		    count++;
 		    }
 		ans+=count*(count-1)/2; //count choose 2
 		}
 	    out.println(""Case #""+test+"": ""+ans);
 	    }
 	out.close();
 	}
     }","import java.util.*;
 import java.io.*;
 
 public class dancing {
     public static void main(String[] args) throws Throwable {
 	Scanner input=new Scanner(new File(""dancing.in""));
 	PrintWriter out=new PrintWriter(new File(""dancing.out""));
 	int cases=input.nextInt();
 	for(int test=1;test<=cases;test++) {
 	    int n=input.nextInt();
 	    int s=input.nextInt();
 	    int p=input.nextInt();
 	    int[] t=new int[n];
 	    for(int i=0;i<n;i++) t[i]=input.nextInt();
 	    int numNS=0, numS=0;
 	    for(int i=0;i<n;i++) {
 		if(t[i]/3+(t[i]%3==0?0:1)>=p) numNS++;
 		}
 	    for(int i=0;i<n;i++) {
 		if(t[i]<2) {
 		    if(t[i]>=p) numS++;
 		    }
 		else {
 		    if((t[i]-2)/3+2>=p) numS++;
 		    }
 		}
 	    int ans=numNS+Math.min(numS-numNS, s);
 	    out.println(""Case #""+test+"": ""+ans);
 	    }
 	out.close();
 	}
     }",1
204,10710,"/**
  * Copyright 2010 Genius-Field All Rights Reserved.
  */
 package com.geniusfield.google.codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 /**
  * @author Junjie Jin
  * 
  */
 public class R1B {
     File input;
     File output;
     Scanner scanner;
     int C;
 
     R1B(String input, String output) {
         this.input = new File(input);
         this.output = new File(output);
         try {
             scanner = new Scanner(this.input);
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
         init();
     }
 
     void init() {
         C = scanner.nextInt();
     }
 
     void process() {
         int N, K, B, T;
         FileWriter fw = null;
         try {
             fw = new FileWriter(output);
         } catch (IOException e) {
             e.printStackTrace();
         }
         for (int i = 0; i < C; i++) {
             N = scanner.nextInt();
             K = scanner.nextInt();
             B = scanner.nextInt();
             T = scanner.nextInt();
             scanner.nextLine();
             try {
                 System.out.println();
                 fw.write(""Case #"" + (i + 1) + "": "" + subprocess(N, K, B, T)
                         + ""\n"");
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
         try {
             fw.flush();
             fw.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 
     String subprocess(int N, int K, int B, int T) {
         String result = ""IMPOSSIBLE"";
         int swap = 0;
         int z = 0;
         int[] X = new int[N], V = new int[N];
         boolean[] flag = new boolean[N];
         int count = 0;
         for (int i = 0; i < N; i++) {
             X[i] = scanner.nextInt();
         }
         for (int i = 0; i < N; i++) {
             V[i] = scanner.nextInt();
         }
         for (int i = 0; i < N; i++) {
             if (X[i] + V[i] * T >= B) {
                 flag[i] = true;
                 count++;
             }
         }
         if (count < K) {
             return ""IMPOSSIBLE"";
         }
         for (int i = N - 1; i >= 0; i--) {
             if (z >= K) {
                 break;
             }
             if (flag[i]) {
                 z++;
                 for (int j = N - 1; j > i; j--) {
                     if (V[i] == V[j - 1]) {
                         continue;
                     } else {
                         double t = (X[j - 1] - X[i]) / (V[i] - V[j - 1]);
                         if (t < 0 || t >= T) {
                             continue;
                         } else if (t == 0) {
                             if (V[i] > V[j - 1]) {
                                 swap++;
                             } else {
                                 continue;
                             }
                         } else if (t < T) {
 
                             swap++;
                         }
                     }
                 }
             }
         }
         return Integer.toString(swap);
     }
 
     /**
      * @param args
      */
     public static void main(String[] args) {
         R1B r1b = new R1B(""B-small-attempt2.in"", ""B-small.out"");
         r1b.process();
     }
 
 }
","/**
  * Copyright 2010 Genius-Field All Rights Reserved.
  */
 package com.geniusfield.google.codejam;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 /**
  * @author Junjie Jin
  * 
  */
 public class QRA {
     File input;
     File output;
     Scanner scanner;
     int T;
 
     QRA(String input, String output) {
         this.input = new File(input);
         this.output = new File(output);
         try {
             scanner = new Scanner(this.input);
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
         init();
     }
 
     void init() {
         T = scanner.nextInt();
     }
 
     void process() {
         int N, K;
         FileWriter fw = null;
         try {
             fw = new FileWriter(output);
         } catch (IOException e) {
             e.printStackTrace();
         }
         for (int i = 0; i < T; i++) {
             N = scanner.nextInt();
             K = scanner.nextInt();
             try {
                 fw.write(""Case #"" + (i + 1) + "": "" + subprocess(N, K)+""\n"");
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
         try {
             fw.flush();
             fw.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 
     String subprocess(int N, int K) {
         int power = 0;
         boolean[] snapper = new boolean[N + 1];
         for (int i = 0; i < K; i++) {
             for (int j = 0; j < power; j++) {
                 snapper[j] = false;
             }
             snapper[power] = true;
             power = N;
             for (int j = 0; j < N; j++) {
                 if (!snapper[j]) {
                     power = j;
                     break;
                 }
             }
         }
         return (power == N ? ""ON"" : ""OFF"");
     }
 
     /**
      * @param args
      */
     public static void main(String[] args) {
         QRA qra = new QRA(""A-small-attempt0.in"", ""A-small.out"");
         qra.process();
     }
 
 }
",1
205,6201,"package gcj.qual;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Scanner;
 
 public class MainD {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		// 問題の読み込み
 		Scanner sc = new Scanner(new File(""src/gcj/qual/D-large.in""));
 
 		int T = sc.nextInt();
 
 		int n;
 		for (int t=0; t<T; t++) {
 			List<Double> N = new ArrayList<Double>();
 			List<Double> K = new ArrayList<Double>();
 
 			n = sc.nextInt();
 
 			for (int i=0; i<n; i++) {
 				N.add(sc.nextDouble());
 			}
 			for (int i=0; i<n; i++) {
 				K.add(sc.nextDouble());
 			}
 
 			Collections.sort(N);
 			Collections.sort(K);
 			output(t+1, solve_dwar(N, K),  solve_war(N, K));
 
 		}
 	}
 
 	static int solve_dwar(List<Double> N, List<Double> K) {
 		int ans=0;
 
 		double dk;
 		double dn;
 
 		int k = 0;
 
 		for (int i=0; i<K.size(); i++) {
 			dk = K.get(i);
 
 			for (int j=k; j<N.size(); j++) {
 				dn = N.get(j);
 
 				if(dn > dk) {
 					k = j+1;
 					ans++;
 					break;
 				}
 
 				if (j == N.size()-1) {
 					return ans;
 				}
 			}
 		}
 		return ans;
 	}
 
 	static int solve_war(List<Double> N, List<Double> K) {
 		int ans=0;
 
 		double dk;
 		double dn;
 
 		int k = 0;
 
 		for (int i=0; i<N.size(); i++) {
 			dn = N.get(i);
 
 			for (int j=k; j<K.size(); j++) {
 				dk = K.get(j);
 
 				if(dn < dk) {
 					k = j+1;
 					ans++;
 					break;
 				}
 
 				if (j == K.size()-1) {
 					return K.size() - ans;
 				}
 			}
 		}
 		return K.size() - ans;
 	}
 
 
 	static void output(int i, int a, int b) {
 		System.out.println(""Case #"" + i + "": "" + a + "" "" + b);
 	}
 }","package gcj.qual;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main {
 
 	static int[] pow = {1, 10, 100, 1000, 10000, 100000};
 
 	public static void main(String[] args) throws FileNotFoundException {
 		// 問題の読み込み
 		Scanner sc = new Scanner(new File(""src/gcj/qual/A-small-attempt1.in""));
 
 		int T = sc.nextInt();
 
 		int[] a1 = new int[4];
 		int[] a2 = new int[4];
 
 		int row;
 		int[][] card;
 
 		for (int i=0; i<T; i++) {
 			row = sc.nextInt();
 
 			card = new int[4][4];
 
 			for (int j=0; j<4; j++) {
 				for (int k=0; k<4; k++) {
 					card[j][k] = sc.nextInt();
 				}
 			}
 			a1 = card[row-1];
 
 			card = new int[4][4];
 
 			row = sc.nextInt();
 			for (int j=0; j<4; j++) {
 				for (int k=0; k<4; k++) {
 					card[j][k] = sc.nextInt();
 				}
 			}
 			a2 = card[row-1];
 
 			solve(i+1, a1, a2);
 		}
 	}
 
 	static void solve(int t, int[] a1, int[] a2) {
 		List<Integer> ans = new ArrayList<Integer>();
 
 		for (int i=0; i<4; i++) {
 			for (int j=0; j<4; j++) {
 				if(a1[i] == a2[j]) {
 					ans.add(a1[i]);
 				}
 			}
 		}
 
 		if (ans.size() == 0) {
 			output(t, ""Volunteer cheated!"");
 		} else if (ans.size() == 1) {
 			output(t, ans.get(0).toString());
 		} else {
 			output(t, ""Bad magician!"");
 		}
 	}
 
 	static void output(int i, String str) {
 		System.out.println(""Case #"" + i + "": "" + str);
 	}
 }",1
206,20432,"package com.codejam;
 
 //b.java
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class b {
 	public static void main(String[] args) throws Exception {
 
         try {
             System.setOut(new PrintStream(new FileOutputStream(""b.txt"")));
         } catch (FileNotFoundException ex) {
             ex.printStackTrace();
             return;
         }
 
 
 		Scanner scan = new Scanner(new File(""B-large.in""));
 		int t = scan.nextInt();
 
 
 		for (int caso = 0; caso < t; caso ++){
 			int c = scan.nextInt();
 			char[][] pairs = new char[3][c];
 			for (int p = 0; p < c; p ++){
 				String s = scan.next();
 				for (int i = 0; i < 3; i ++){
 					pairs[i][p] = s.charAt(i);
 				}
 			}
 
 			int d = scan.nextInt();
 			char[][] opposed = new char[2][d];
 			for (int o = 0; o < d; o ++){
 				String s = scan.next();
 				for (int i = 0; i < 2; i ++){
 					opposed[i][o] = s.charAt(i);
 				}
 			}
 
 			int n = scan.nextInt();
 			char[] elements = new char[n];
 			String s = scan.next();
 			for (int e = 0; e < n; e ++){
 				elements[e] = s.charAt(e);
 			}
 			
 			ArrayList<Character> list = new ArrayList<Character>();
 			
 			for (int e = 0; e < n; e ++){
 				if (list.isEmpty())
 					list.add(elements[e]);
 				else{
 					char combined = combine(elements[e], list.get(list.size()-1),pairs, c );
 					if (combined != 255)//elements combine
 						list.set(list.size()-1, combined);
 					else
 						list.add(elements[e]);
 					searchOpposed(list,opposed, d );
 				}
 			}
 
 			int casoOut = caso + 1;
 			String out = ""Case #"" + casoOut + "": ["";
 			int size = list.size();
 			for (int i=0; i < size; i++){
 				out = out + list.get(i);
 				if (i+1 != size)
 					out = out + "", "";
 			}
 			out = out + ""]"";
 			System.out.println(out);
 		}
 		scan.close();
 	}
 	
 	//Return the combinated char or 255
 	private static char combine(char a, char b,char[][] pairs, int c ){
 		for (int i = 0; i < c; i ++){
 			if (pairs[0][i] == a && pairs[1][i] == b) return pairs[2][i];
 			if (pairs[1][i] == a && pairs[0][i] == b) return pairs[2][i];
 		}
 		return 255;
 	}
 
 	//Clears the list if two elements on it are opposed
 	private static void searchOpposed(ArrayList<Character> list, char[][] opposed, int d){
 		int size = list.size();
 		if (size < 2)
 			return;
 		for (int i = 0; i < size; i++){
 			for (int j = i+1; j < size; j++){
 				if (oppose(list.get(i), list.get(j),opposed, d )){
 					list.clear();
 					return;
 				}
 			}
 		}
 	}
 	
 	//Return true if opposed chars
 	private static boolean oppose(char a, char b,char[][] opposed, int d ){
 		for (int i = 0; i < d; i ++){
 			if (opposed[0][i] == a && opposed[1][i] == b) return true;
 			if (opposed[1][i] == a && opposed[0][i] == b) return true;
 		}
 		return false;
 	}
 
 
 
 }
 
 
","import java.util.*;
 import java.io.*;
 
 public class codejam4{
 	public static void main(String[] args) throws IOException{
 		Scanner sc = new Scanner(new FileReader(""D-large.in""));
 		BufferedWriter write = new BufferedWriter(new FileWriter(""output.txt""));
 
 		int caseN = sc.nextInt();
 		sc.nextLine();
 		String[] allCase = new String[caseN];
 
 		int win = 0;
 		int dwin = 0;
 
 		ArrayList<Float> naomi,naomi_temp,ken,ken_temp;
 		int time;
 		boolean pop = false;
 
 		for(int icase=0;icase<caseN;icase++){
 			time = sc.nextInt();
 			sc.nextLine();
 			naomi = new ArrayList<Float>();
 			ken = new ArrayList<Float>();
 
 			for(int round=0;round<time;round++)
 				naomi.add(sc.nextFloat());
 			for(int round=0;round<time;round++)
 				ken.add(sc.nextFloat());
 
 			naomi_temp = new ArrayList<Float>(naomi);
 			ken_temp = new ArrayList<Float>(ken);
 
 			Collections.reverse(naomi);
 			Collections.sort(ken,Collections.reverseOrder());
 
 			for(int chk=time-1;chk>=0;chk--){
 				for(int j=chk;j>=0 && !pop;j--){
 					if(ken.get(j)>naomi.get(chk)){
 						naomi.remove(chk);
 						ken.remove(j);
 						pop = true;
 					}
 					else if(ken.get(0) < naomi.get(chk)){
 						naomi.remove(chk);
 						ken.remove(chk);
 						pop = true;
 						win++;
 					}
 				}
 				pop = false;
 			}
 
 			pop=false;
 
 			naomi = new ArrayList<Float>(naomi_temp);
 			ken = new ArrayList<Float>(ken_temp);
 
 
 			Collections.sort(naomi,Collections.reverseOrder());
 			Collections.sort(ken);
 
 			for(int chk=time-1;chk>=0;chk--){
 				for(int k=chk;k>=0 && !pop;k--){
 					if(naomi.get(chk)>ken.get(k)){
 						naomi.remove(chk);
 						ken.remove(k);
 						pop=true;
 						dwin++;
 					}
 					else if(k==0 && naomi.get(chk)<ken.get(k)){
 						naomi.remove(chk);
 						ken.remove(chk);
 						pop=true;
 					}
 
 				}
 				pop = false;
 				//System.out.println(naomi+""\n""+ken);
 			}
 			allCase[icase] = ""Case #""+(icase+1)+"": ""+dwin+"" ""+win;
 			//System.out.println(dwin +"", ""+win);
 
 			win=0;
 			dwin=0;
 		}
 
 
 		for(int i=0;i<allCase.length;i++){
 			//System.out.println(allCase[i]);
 			write.append(allCase[i]+""\n"");
 		}
 		write.close();
 
 	}
 
 }",0
207,18277,"
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 
 
 /**
  *
  * @author Shubham
  */
 public class Dancers {
 
     public static void main(String a[]) throws IOException
     {
         BufferedReader br =  new BufferedReader(new InputStreamReader(System.in));
         int t = Integer.parseInt(br.readLine());
         for(int i=1;i<=t;i++)
         {
             String line = br.readLine();
             String[] ints = line.split("" "");
             int n = Integer.parseInt(ints[0]);
             int s = Integer.parseInt(ints[1]);
             int l = Integer.parseInt(ints[2]);
             int c=0;
             for(int j=3;j<3+n;j++)
             {
                 int sum = Integer.parseInt(ints[j]);
                 int r = sum - 3*l;
                 if(sum>=l)
                 {
                     if(r>=-2)
                     {
                         c++;
                     }
                     else if(r>=-4 && s>0)
                     {
                         c++;
                         s--;
                     }
                 }                
             }
             System.out.println(""Case #""+i+"": ""+c);
         }
     }
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.StringTokenizer;
 
 public class Harmony {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try{
 		BufferedReader input = new BufferedReader(new FileReader(""C:\\Users\\Srinivas\\Downloads\\a.in""));
 		BufferedWriter output = new BufferedWriter(new FileWriter(""D:\\Workspace\\Working\\src\\out.out""));
 		short testCases = Short.valueOf(input.readLine());
 		short players = 0;
 		short low =0;
 		short high =0;
 		String temp = null;
 		StringTokenizer st;
 		long freq=0;
 		long pFreq[];
 		for (short count = 0; count < testCases; count++){
 			temp = input.readLine();st=new StringTokenizer(temp);
 			players=Short.valueOf(st.nextToken());
 			low=Short.valueOf(st.nextToken());
 			high=Short.valueOf(st.nextToken());
 			temp = input.readLine();st=new StringTokenizer(temp);
 			pFreq = new long[players];
 			if(low <=1)output.write(""Case #"" + (count + 1) + "": "" + 1);else{
 				for(int i=0;i<players;i++ )pFreq[i]=Long.valueOf(st.nextToken());
 				for(int i=0;i<players;i++)for(int j = i+1;j<players;j++){
 					if(pFreq[i] > pFreq[j]){freq = pFreq[i];pFreq[i]=pFreq[j];pFreq[j]=freq;}
 				}
 				freq = pFreq[0];
 				for(int i = 1; i<players;i++){
 					if(freq == 1){
 						if(pFreq[i] != 1)freq=pFreq[i];
 					}else{
 					if(freq > high)break;
 					if(pFreq[i]%freq!=0)
 					freq = LCM(freq, pFreq[i]);}
 				}
 				if(low <= freq && freq <= high)
 				output.write(""Case #"" + (count + 1) + "": "" + freq);
 				else
 					output.write(""Case #"" + (count + 1) + "": NO"");
 			}
 			output.newLine();
 		}
 		input.close();
 		output.close();
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 		}
 
 	}
 	public static long LCM (long a, long b) {
 		long ret = gcd(a,b);
 		if(ret == 1) return a*b;
 		if(b<a) return a*b/ret;
 		if(ret < a) return a*b/ret;
 		else return ret*a;
 	}
     public static long gcd(long p, long q) {
         if (q == 0) return p;
         else return gcd(q, p % q);
     }
 }
",0
208,3158,"import java.util.*;
 
 public class Main {
 	static Scanner in = new Scanner(System.in);
 	static boolean check(char[][] table, char op, int k) {
 		int[][] dp = new int[table.length+1][table[0].length+1];
 		for(int i=table.length-1; i>=0; --i)
 			for(int j=table[0].length-1; j>=0; --j)
 			{
 				dp[i][j] = (table[i][j]==op)?(dp[i][j+1]+1):0;
 				if(dp[i][j]>=k) return true;
 			}
 		dp = new int[table.length+1][table[0].length+1];
 		for(int i=table.length-1; i>=0; --i)
 			for(int j=table[0].length-1; j>=0; --j)
 			{
 				dp[i][j] = (table[i][j]==op)?(dp[i+1][j]+1):0;
 				if(dp[i][j]>=k) return true;
 			}
 		dp = new int[table.length+1][table[0].length+1];
 		for(int i=table.length-1; i>=0; --i)
 			for(int j=table[0].length-1; j>=0; --j)
 			{
 				dp[i][j] = (table[i][j]==op)?(dp[i+1][j+1]+1):0;
 				if(dp[i][j]>=k) return true;
 			}
 		dp = new int[table.length+1][table[0].length];
 		for(int i=table.length-1; i>=0; --i)
 			for(int j=table[0].length-1; j>=0; --j)
 			{
 				if(j-1<0) dp[i][j] = (table[i][j]==op)?1:0;
 				else dp[i][j] = (table[i][j]==op)?(dp[i+1][j-1]+1):0;
 				if(dp[i][j]>=k) return true;
 			}
 		return false;
 	}
 	public static void main(String[] args) {
 		int t = in.nextInt();
 		for(int ca=1; ca<=t; ++ca) {
 			int n = in.nextInt();
 			int k = in.nextInt();
 			char[][] rotate = new char[n][n];
 			char[][] gravity = new char[n][n];
 			char[][] start = new char[n][];
 			for(int i=0; i!=n; ++i)
 				start[i] = in.next().toCharArray();
 			for(int i=0; i!=n; ++i)
 				for(int j=0; j!=n; ++j) {
 					rotate[j][n-i-1] = start[i][j];
 					gravity[i][j] = '.';
 				}
 			for(int j=0; j!=n; ++j) {
 				for(int b=n-1, i=n-1; i>=0; --i) {
 					if(rotate[i][j]!='.')
 						gravity[b--][j] = rotate[i][j];
 				}
 			}
 			boolean red=check(gravity, 'R', k), blue=check(gravity, 'B', k);
 			System.out.print(""Case #""+ca+"": "");
 			if(red&&blue) System.out.println(""Both"");
 			else if(red) System.out.println(""Red"");
 			else if(blue) System.out.println(""Blue"");
 			else System.out.println(""Neither"");
 		}
 	}
 }
","import java.util.*;
 import java.io.*;
 
 class Main {
 	private static final Scanner in = new Scanner(System.in);
 	private static final Formatter out = new Formatter(System.out);
 	public static void main(String[] args) {
 		int t = in.nextInt();
 		for(int i=0; i!=t; ++i) {
 			final int r = in.nextInt();
 			final int limit = in.nextInt();
 			final int n = in.nextInt();
 			final int g[] = new int[n];
 			final int target[] = new int[n];
 			final int cost[] = new int[n];
 			for(int j=0; j!=n; ++j)
 				g[j] = in.nextInt();
 			for(int j=0, k=0, sum = 0; j!=n; ++j) {
 				while(k-j<n&&sum+g[k%n]<=limit) 
 					sum+=g[k++%n];
 				target[j] = k%n;
 				cost[j] = sum;
 				sum -= g[j];
 			}
 			final int step[] = new int[n];
 			final long sum[] = new long[n];
 			long ans = 0;
 			for(int j=r, cur=0; j>=0; --j, cur = target[cur]) {
 				ans = sum[cur];
 				if(step[cur]>j&&j%(step[cur]-j)==0) {
 					ans = sum[cur] + j/(step[cur]-j)*(sum[cur]+cost[cur]-sum[target[cur]]);
 					break;
 				}
 				step[cur] = j;
 				sum[target[cur]] = ans + cost[cur];
 			}
 			out.format(""Case #%d: %d\n"", i+1, ans);
 		}
 		out.flush();
 	}
 }
",1
209,5685,"package One;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 public class One {
 	public static void main(String[] args) throws Exception{
 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 		int cases = Integer.parseInt(in.readLine());
 		for(int i=1;i<=cases;i++)
 		{
 			String line=in.readLine();
 			String parts[]=line.split("" "");
 			double N=Double.parseDouble(parts[0]);
 			int pd=Integer.parseInt(parts[1]);
 			int pg=Integer.parseInt(parts[2]);
 			int flag=0;
 			int canthapp=0;
 			if((pd==100&&pg==100)||(pd==0&&pg==0))
 				flag=1;
 			if((pd!=100&&pg==100)||(pd!=0&&pg==0))
 				canthapp=1;
 			if(flag==0&&canthapp==0)
 			for(int j=2;j<=N;j++)
 			{
 				double pd1=pd;
 				double t=j;
 				double num=(t*pd1)/100;
 				double var=Math.ceil(num);
 				if(num==Math.ceil(num)&&var<=num)
 					{
 					flag=1;	
 					break;
 					}
 				if(j>100)
 				{
 					break;
 				}
 			}
 			if(flag==1)
 				System.out.println(""Case #""+i+"": Possible"");
 			else
 				System.out.println(""Case #""+i+"": Broken"");
 			
 		}
 	}
 }
","import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 
 
 	public class Main_c_new {
 		public static void main(String[] args) throws Exception{
 			BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 			int cases=Integer.parseInt(in.readLine());
 			
 			for(int i=1;i<=cases;i++)
 			{
 				int count = 0;
 				String line = in.readLine();
 				String parts[] = line.split("" "");
 				int a = Integer.parseInt(parts[0]);
 				int b = Integer.parseInt(parts[1]);
 				int startlen = 0;
 				int temp1 = a; 
 				for(int k=0;k<8;k++){
 					startlen++;
 					temp1/=10;
 					if(temp1<=0){
 						break;
 					}
 				}
 				//System.out.println(""there"");
 				for(int j=a;j<b;j++){
 					//int temp = j;
 					int length = 0;
 					if( j == (int)(Math.pow(10, startlen)) ){
 						startlen++;
 					}
 					length = startlen;
 					ArrayList<Integer> list = new ArrayList<Integer>();
 					for(int k=1;k<length;k++){
 						 Integer temp = j;
 						 String val = Integer.toBinaryString(j);
 						int div = (int)Math.pow(10,k);
 						int part1 = j/div;
 						int part2 = j%div;
 						if(part2 >= (int)(Math.pow(10, k-1))){
 							int num = (part2*((int)Math.pow(10, length-k)))+part1;
 							if(num>j && num<=b){
 								int flag = 0;
 								for(int l=0; l<list.size();l++){
 									if(list.get(l) == num){
 										flag = 1;
 									}
 								}
 								
 								if(flag == 0){
 								count++;
 								list.add(num);
 								}
 							}
 						}
 					}
 						
 					}
 
 				System.out.println(""Case #""+i+"": ""+count);
 			}
 		}
 	}
",1
210,1805,"package jam.roundb;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * User: looser
  * Date: May 22, 2010
  */
 public class Chicks {
     private int n;
     private int k;
     private int b;
     private int t;
     private Integer[] x;
     private Integer[] v;
 
     public Chicks(int n, int k, int b, int t, Integer[] x, Integer[] v) {
         this.n = n;
         this.k = k;
         this.b = b;
         this.t = t;
         this.x = x;
         this.v = v;
     }
 
     public static void main(String[] args) throws Exception {
         BufferedReader f = new BufferedReader(new FileReader(""B-small-attempt1"" + "".in""));
         //BufferedReader f = new BufferedReader(new FileReader(""inp.txt""));
         //PrintStream out = System.out;
         PrintStream out = new PrintStream(""B-small-attempt1"" + "".out"");
 
         Integer C = Integer.parseInt(f.readLine());
 
         for (int i = 1; i <= C; i++) {
             String[] s = f.readLine().split("" "");
             long N = Long.parseLong(s[0]);
             long K = Long.parseLong(s[1]);
             long B = Long.parseLong(s[2]);
             long T = Long.parseLong(s[3]);
             Integer[] X = strToIntArr(f.readLine());
             Integer[] V = strToIntArr(f.readLine());
 
             Chicks o = new Chicks((int) N, (int) K, (int) B, (int) T, X, V);
 
             long start = System.currentTimeMillis();
 
             int solved = o.solve();
             out.println(""Case #"" + i + "": "" + (solved == -1 ? ""IMPOSSIBLE"" : solved));
 
             long took = System.currentTimeMillis() - start;
             System.err.println(""Case #"" + i + "" took "" + took + ""ms"");
         }
     }
 
 
 
     private int solve() {
         if (k == 0) {
             return 0;
         }
 
         List<Double> times = times();
         int[] swapsAllowed = new int[n];
 
         return doSolution(swapsAllowed, times, 0);
 
     }
 
     private int doSolution(int[] swapsAllowed, List<Double> times, int skipped) {
         if (skipped + k > n) {
             return -1;
         }
 
         int firstNotMakingIt = firstNotMakingIt(times, swapsAllowed);
         if (firstNotMakingIt == -1) {
             return 0;
         }
 
         int numberIn = n - firstNotMakingIt - 1 - skipped;
         if (numberIn >= k) {
             return 0;
         }
 
         int swaps = Integer.MAX_VALUE;        
         for (int numberOfSwaps = firstNotMakingIt; numberOfSwaps >= k-numberIn; numberOfSwaps--) {
             swapsAllowed[firstNotMakingIt] = numberOfSwaps;
             int totalSwaps = doSolution(swapsAllowed, times, skipped + 1);
 
             if (totalSwaps == -1) {
                 break;
             }
 
             totalSwaps += numberOfSwaps;
             if (totalSwaps < swaps) {
                 swaps = totalSwaps;
             }
         }
         swapsAllowed[firstNotMakingIt] = 0;
 
         return swaps == Integer.MAX_VALUE ? -1 : swaps;
     }
 
     private ArrayList<Double> times() {
         ArrayList<Double> times = new ArrayList<Double>(n);
         for (int i = 0; i < n; i++) {
             times.add((0. + b - x[i]) / v[i]);
         }
         return times;
     }
 
     private int firstNotMakingIt(List<Double> times, final int[] swapsAllowed) {
         int[] mySwaps = new int[n];
         System.arraycopy(swapsAllowed, 0, mySwaps, 0, n);
 
         List<Integer> slowChicksAhead = new ArrayList<Integer>();
         for (int i = n-1; i>=0; i--) {
             if (mySwaps[i] > 0) {
                 slowChicksAhead.add(0, i);
                 continue;
             }
 
             double timeI = times.get(i);
 
             if (timeI > t) {
                 return i;
             }
 
             if (slowChicksAhead.isEmpty()) {
                 continue;
             }
 
             for (Integer slowIndex : slowChicksAhead) {
                 if (mySwaps[slowIndex] > 0) {
                     mySwaps[slowIndex]--;
                 } else {
                     return i;
                 }
             }
 
         }
         return -1;
     }
 
     private static Integer[] strToIntArr(String s) {
         String[] strings = s.split("" "");
         Integer[] res = new Integer[strings.length];
         for (int i =0; i < strings.length; i++) {
             res[i] = Integer.parseInt(strings[i]);
         }
         return res;
     }
 
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintStream;
 
 /**
  * Created by IntelliJ IDEA.
  * User: looser
  */
 public class Dogs {
 
     public static void main(String[] args) throws Exception {
         String name = ""B-large"";
 //        String name = ""test"";
         BufferedReader f = new BufferedReader(new FileReader(name + "".in""));
 //        PrintStream out = System.out;
         PrintStream out = new PrintStream(name + "".out"");
 
         Integer T = Integer.parseInt(f.readLine());
 
         for (int i = 1; i <= T; i++) {
             String[] line = f.readLine().split("" "");
             int C = Integer.parseInt(line[0]);
             int D = Integer.parseInt(line[1]);
 
             int[][] pAndV = new int[C][2];
             for (int j = 0; j < C; j++) {
                 line = f.readLine().split("" "");
                 pAndV[j][0] = Integer.parseInt(line[0]);
                 pAndV[j][1] = Integer.parseInt(line[1]);
             }
 
             double accumulatedRight = pAndV[0][0] + ((double) pAndV[0][1] - 1) / 2 * D;
             double accumulatedTime = ((double) pAndV[0][1] - 1) / 2 * D;
 
             for (int j = 1; j < C; j++) {
                 int p = pAndV[j][0];
                 int v = pAndV[j][1];
 
                 double myTime = ((double) v - 1) / 2 * D;
                 double myLeft = p - myTime;
                 double myRight = p + myTime;
 
                 double spareTime = accumulatedTime - myTime;
                 double delta = spareTime > 0 ? spareTime : 0;
 
                 if (myLeft < accumulatedRight + D) {
                     if (spareTime > 0) {
                         // need to go right to reach the boundary
                         delta = Math.min(accumulatedRight + D - myLeft, delta);
                         myLeft += delta;
                         myRight += delta;
                         myTime += delta;
                     } else {
                         // the prev part has to move left as far as it can
                         delta = Math.abs(spareTime);
                         accumulatedTime += delta;
                         accumulatedRight -= delta;
                     }
 
                     // if we still cannot fit
                     if (myLeft < accumulatedRight + D) {
                         double targetTime = (accumulatedRight + D - myLeft) / 2;
                         myRight += targetTime;
                         myTime += targetTime;
                     }
 
                 } else {
                     // need to go left as far as i can (in the time given)
                     double newLeft = Math.max(accumulatedRight + D, myLeft - delta);
                     myRight -= myLeft - newLeft;
                 }
 
                 accumulatedRight = myRight;
 
                 if (myTime > accumulatedTime) {
                     accumulatedTime = myTime;
                 }
             }
 
             out.println(""Case #"" + i + "": "" + accumulatedTime);
         }
         out.flush();
     }
 
 }
",1
211,18389,"package salesman;
 
 import deceitfulWar.DeceitfulWar;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 public class Salesman {
 
     public static int N, M;
     public static City[] cities;
     public static List<List<Integer>> g;
     public static boolean[] DFSbool = new boolean[50];
     static int indTo[] = new int[50];
     static boolean[] chosen = new boolean[50];
     static boolean[] active = new boolean[50];
     static int[] chosenInd = new int[50];
     static int[] chosenTime = new int[50];
 
     public static void DFS(int s) {
 //        System.out.println(""DFS("" + s + "" -> "" + (cities[s].index + 1) + "")"");
         for (Integer to : g.get(s))
             if (!chosen[to] && !DFSbool[to]) {
                 DFSbool[to] = true;
                 DFS(to);
             }
     }
 
     public static void printg() {
         for (int i = 0; i < N; ++i) {
             System.out.print((cities[i].index + 1) + "":"");
             for (Integer j : g.get(i))
                 System.out.print("" "" + (cities[j].index + 1));
             System.out.println("""");
         }
     }
 
     public static void main(String[] args) {
         try {
             Scanner s = new Scanner(new BufferedReader(new FileReader(""case2.in"")));
             Writer w = new BufferedWriter(new FileWriter(""case2.out""));
 
             s.useLocale(Locale.US);
 
             int T = s.nextInt();
             for (int t = 0; t < T; ++t) {
                 N = s.nextInt();
                 M = s.nextInt();
 
                 g = new ArrayList<>();
                 for (int i = 0; i < N; ++i)
                     g.add(new ArrayList<Integer>());
 
                 cities = new City[N];
 
                 for (int i = 0; i < N; ++i)
                     cities[i] = new City(s.next(), i);
 
                 Arrays.sort(cities);
 
                 for (int i = 0; i < N; ++i)
                     indTo[cities[i].index] = i;
 
                 for (int i = 0; i < M; ++i) {
                     int a = indTo[s.nextInt() - 1];
                     int b = indTo[s.nextInt() - 1];
                     g.get(a).add(b);
                     g.get(b).add(a);
                 }
 
                 for (int i = 0; i < N; ++i)
                     Collections.sort(g.get(i));
 
                 for (int i = 0; i < N; ++i)
                     chosen[i] = false;
                 for (int i = 0; i < N; ++i)
                     active[i] = false;
 
                 int ccity = 0;
 
 //                System.out.println(""first: "" + first);
 
                 String code = cities[0].zip;
 
 
                 chosen[0] = true;
                 active[0] = true;
                 chosenInd[0] = 0;
                 chosenTime[0] = 0;
 
                 /*                for (int i = 0; i < N; ++i)
                  System.out.println((i + 1) + "" zip: "" + cities[i].zip);
                  */
                 for (int n = 1; n < N; ++n)
 //                    printg();
                     for (int c = 0; c < N; ++c) {
                         if (chosen[c])
                             continue;
 //                        System.out.println(""checking: "" + (cities[c].index + 1));
                         int found = -1;
                         for (int i = g.get(c).size() - 1; i >= 0; --i) {
                             int to = g.get(c).get(i);
                             if (active[to])
                                 if (found == -1 || chosenTime[to] > chosenTime[found])
                                     found = to;
                         }
                         if (found == -1)
 //                            System.out.println(""c = "" + (cities[c].index + 1) + "", found = -1"");
                             continue;
                         //           System.out.println(""found: "" + found);
                         for (int i = 0; i < N; ++i)
                             DFSbool[i] = false;
                         for (int i = 0; chosenInd[i] != found; ++i) {
                             DFSbool[chosenInd[i]] = true;
                             DFS(chosenInd[i]);
                         }
                         DFSbool[found] = true;
                         DFS(found);
 //                        System.out.println(""checking("" + c + "" -> "" + (cities[c].index + 1) + "")"");
                         DFSbool[c] = true;
                         DFS(c);
                         boolean val = true;
                         for (int i = 0; i < N; ++i)
                             if (!chosen[i] && !DFSbool[i]) {
                                 val = false;
 //                                System.out.println(""val = false ("" + (cities[i].index + 1) + "")"");
                                 break;
                             }
                         if (val) {
                             g.get(c).remove((Integer) ccity);
                             g.get(ccity).remove((Integer) c);
                             ccity = c;
                             chosen[ccity] = true;
                             chosenInd[n] = c;
                             chosenTime[c] = n;
                             active[c] = true;
                             for (int i = chosenTime[found] + 1; i < n; ++i)
                                 active[chosenInd[i]] = false;
                             code += cities[c].zip;
 //                            System.out.println(""choose: "" + (cities[c].index + 1));
                             break;
                         }
                     }
 
                 w.write(""Case #"" + (t + 1) + "": "" + code + ""\n"");
 //                System.out.println(""Case #"" + (t + 1) + "": "" + code);
             }
             w.flush();
             w.close();
             s.close();
         } catch (IOException ex) {
             Logger.getLogger(DeceitfulWar.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
 
     public static class City implements Comparable<City> {
 
         String zip;
         int index;
 
         public City(String zip, int index) {
             this.zip = zip;
             this.index = index;
         }
 
         @Override
         public int compareTo(City o) {
             return zip.compareTo(o.zip);
         }
     }
 }
","package candy;
 
 import java.util.Scanner;
 
 public class Main {
 	public static void main (String[] args){
 		Scanner sc = new Scanner(System.in);
 		int case_num = sc.nextInt();
 
 		for(int i=1; i<case_num+1; i++){//行
 
 			int bag_num = sc.nextInt();
 
 			int[] candylist = new int[bag_num];
 
 			for(int j=0; j<bag_num; j++){
 				candylist[j]=sc.nextInt();
 			}
 
 			Main main = new Main();
 			int xorsum = main.xor(candylist,bag_num);
 
 			if(xorsum!=0){
 				System.out.println(""Case #""+i+"": ""+""NO"");
 			}else{
 				int sum = main.sum(candylist,bag_num);
 				int min = main.min(candylist,bag_num);
 
 				int sean = sum-min;
 
 				System.out.println(""Case #""+i+"": ""+sean);
 			}
 
 		}
 	}
 
 	int xor(int[] list, int length){
 
 		int result=list[0];
 
 		for(int i=1; i<length; i++){
 			result^=list[i];
 		}
 
 		return result;
 	}
 
 
 	int sum(int[] list,int length){
 		int result=0;
 
 		for(int i=0; i<length; i++){
 			result+=list[i];
 		}
 
 		return result;
 	}
 
 	int min(int[] list, int length){
 		int result=list[0];
 
 		for(int i=1; i<length; i++){
 			if(result>list[i]){
 				result=list[i];
 			}
 		}
 
 		return result;
 	}
 
 }
",0
212,3706,"import java.io.PrintStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.Scanner;
 
 public class Lawnmower {
 	private static final String FILE_NAME = ""B-small-attempt0.in"";
 
 	private final Path INPUT = Paths.get(""in"", FILE_NAME);
 	private final Path OUTPUT = Paths.get(""out"",
 			FILE_NAME.replaceAll("".in"", "".out""));
 
 	private short[][] lawnPattern;
 	private short[][] lawnPatternReversed;
 
 	public static void main(String[] args) {
 		try {
 			new Lawnmower().run();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private void run() throws Exception {
 		Files.deleteIfExists(OUTPUT);
 
 		Scanner in = new Scanner(INPUT);
 		PrintStream out = new PrintStream(Files.newOutputStream(OUTPUT,
 				StandardOpenOption.CREATE_NEW));
 
 		final int lawns = in.nextInt();
 		// System.out.println(lawns);
 
 		for (int lawnNo = 0; lawnNo < lawns; lawnNo++) {
 			int n = in.nextInt();
 			int m = in.nextInt();
 
 			lawnPattern = new short[n][m];
 			lawnPatternReversed = new short[m][n];
 
 			// System.out.println(String.format(""%d %d"", n, m));
 
 			for (int i = 0; i < lawnPattern.length; i++)
 				for (int j = 0; j < lawnPattern[i].length; j++) {
 					lawnPattern[i][j] = in.nextShort();
 					lawnPatternReversed[j][i] = lawnPattern[i][j];
 				}
 
 			// System.out.println(Arrays.deepToString(lawnPattern));
 
 			out.println(String.format(""Case #%d: %s"", lawnNo + 1, testLawn()));
 
 			// System.out.println();
 		}
 		// System.out.println();
 
 		in.close();
 		out.close();
 	}
 
 	private Status testLawn() {
 		for (int i = 0; i < lawnPattern.length; i++)
 			for (int j = 0; j < lawnPattern[i].length; j++)
 				if (max(lawnPattern[i]) > lawnPattern[i][j]
 						&& max(lawnPatternReversed[j]) > lawnPattern[i][j])
 					return Status.NO;
 
 		return Status.YES;
 	}
 
 	private short max(short[] shorts) {
 		short max = Short.MIN_VALUE;
 
 		for (short s : shorts)
 			if (s > max)
 				max = s;
 
 		return max;
 	}
 
 	private enum Status {
 		YES, NO;
 	}
 }","import java.io.PrintStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.Scanner;
 
 public class Lawnmower {
 	private static final String FILE_NAME = ""B-large.in"";
 
 	private final Path INPUT = Paths.get(""in"", FILE_NAME);
 	private final Path OUTPUT = Paths.get(""out"",
 			FILE_NAME.replaceAll("".in"", "".out""));
 
 	private short[][] lawnPattern;
 	private short[][] lawnPatternReversed;
 
 	public static void main(String[] args) {
 		try {
 			new Lawnmower().run();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private void run() throws Exception {
 		Files.deleteIfExists(OUTPUT);
 
 		Scanner in = new Scanner(INPUT);
 		PrintStream out = new PrintStream(Files.newOutputStream(OUTPUT,
 				StandardOpenOption.CREATE_NEW));
 
 		final int lawns = in.nextInt();
 		// System.out.println(lawns);
 
 		for (int lawnNo = 0; lawnNo < lawns; lawnNo++) {
 			int n = in.nextInt();
 			int m = in.nextInt();
 
 			lawnPattern = new short[n][m];
 			lawnPatternReversed = new short[m][n];
 
 			// System.out.println(String.format(""%d %d"", n, m));
 
 			for (int i = 0; i < lawnPattern.length; i++)
 				for (int j = 0; j < lawnPattern[i].length; j++) {
 					lawnPattern[i][j] = in.nextShort();
 					lawnPatternReversed[j][i] = lawnPattern[i][j];
 				}
 
 			// System.out.println(Arrays.deepToString(lawnPattern));
 
 			out.println(String.format(""Case #%d: %s"", lawnNo + 1, testLawn()));
 
 			// System.out.println();
 		}
 		// System.out.println();
 
 		in.close();
 		out.close();
 	}
 
 	private Status testLawn() {
 		for (int i = 0; i < lawnPattern.length; i++)
 			for (int j = 0; j < lawnPattern[i].length; j++)
 				if (max(lawnPattern[i]) > lawnPattern[i][j]
 						&& max(lawnPatternReversed[j]) > lawnPattern[i][j])
 					return Status.NO;
 
 		return Status.YES;
 	}
 
 	private short max(short[] shorts) {
 		short max = Short.MIN_VALUE;
 
 		for (short s : shorts)
 			if (s > max)
 				max = s;
 
 		return max;
 	}
 
 	private enum Status {
 		YES, NO;
 	}
 }",1
213,9992,"package round1C2010;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class ProblemC {
 
 	public static void main(String[] args) throws  Exception{
 
 		File inputFile = new File(""./Round1/ProblemC.in.txt"");
 		File outputFile = new File(""./Round1/ProblemC.out.txt"");
 
 		Scanner sc = new Scanner(inputFile);
 		
 		BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile));
 		
 		int testcases = sc.nextInt();
 	//	System.out.println(testcases);
 		
 		for(int i=0;i<testcases;i++){
 			
 			int M = sc.nextInt();
 			int N = sc.nextInt();
 			
 			long board[] = new long[M]; 
 			
 			boolean cut[][] = new boolean[M][N];
 			
 			for(int j=0;j<M;j++)
 				for(int k=0;k<N;k++){
 				cut[j][k] = false;
 			}
 			
 			
 			String temp;
 			
 			for(int j=0;j<M;j++){
 				temp = sc.next();
 				
 				board[j] = Long.parseLong(temp, 16);
 			}
 		
 			for(int j=0;j<M;j++)
 				System.out.println(board[j]);
 			
 			int count =0;
 			
 			int size = Math.min(M, N);
 			int countSize[] = new int[size];
 			
 			for(int j=0;j<size;j++)
 				countSize[j] = 0;
 			
 			for(int j=size;j>0;j--){
 				long xorBy = getXorBy(j) ;
 				long valToCheck = getValToCheck(j);
 				System.out.println(""Checking for size "" + j);
 				
 				for(int k=0;k<M && k+j <= M;k++){
 					
 					for(int l=0;l<=N-j;l++){
 						
 						if(checkCut(k,l,j,cut))
 							continue;
 						
 						System.out.println("" Checking "" + k + "" "" + l);
 						
 						boolean matched = true;
 						boolean xorValCheck = true;
 						
 					for(int m=0;m<j ;m++){
 						
 							long x = ((board[k+m]  <<l) >>> (N - j) ) % (1<<j);
 							
 							System.out.println(""Board subset"" + (board[k+m]<<l) + "" "" + (N-j) + "" "" + x);
 							
 							
 							
 							System.out.println(""Xor By"" + xorBy);
 							System.out.println(""Chk By"" + valToCheck + "" "" + (x ^ xorBy));
 							
 							if(valToCheck == (x ^ xorBy) && (xorValCheck || m==0)){
 								System.out.println(""here xor"");
 								
 									xorValCheck = false;
 								continue;
 								
 							}
 							else if((x ^ xorBy) == 0 && (!xorValCheck || m==0)){
 								System.out.println(""here 0"");
 								
 									xorValCheck = true;
 								continue;
 							}
 							else{
 								matched = false;
 							}
 						}
 						
 						if(!matched)
 							continue;
 					
 						if(countSize[j-1] == 0)
 							count++;
 //						
 						countSize[j-1] ++;
 						
 						System.out.println(""Identified chess of size "" + j);
 						
 						for(int m=0;m<j;m++)
 							for(int n=0;n<j;n++){
 							cut[k+m][n+l] = true;
 							System.out.println(""Updated cut "" + (k+m) + "" "" + (n+l));
 						}
 
 						
 					}
 				}
 				
 			}
 				
 						
 			System.out.println(""Case #"" + (i+1) + "": "" + count);
 			for(int j=countSize.length-1;j>=0;j--)
 			if(countSize[j]!=0){
 				System.out.println((j+1) + "" "" + countSize[j]);
 			}
 			bw.write(""Case #"" + (i+1) + "": "" +count);
 			bw.newLine();
 			for(int j=countSize.length-1;j>=0;j--) if(countSize[j]!=0){
 				bw.write((j+1) + "" "" + countSize[j]);
 				bw.newLine();
 			}
 		}
 		
 		bw.close();
 		sc.close();
 	}
 
 	private static boolean checkCut(int k, int l, int j, boolean[][] cut) {
 		
 		for(int i=k;i<k+j;i++)
 			for(int ii=l;ii<l+j;ii++){
 				if(cut[i][ii]){
 					System.out.println( i + "" "" + ii + "" is cut."");
 					return true;
 				}
 			}
 		return false;
 	}
 
 	private static long getValToCheck(int size) {
 		// TODO Auto-generated method stub
 		return Long.parseLong(""1111111111111111111111111111111111111111111111"".substring(0, size), 2);
 	}
 
 	private static long getXorBy(int size) {
 		
 		return Long.parseLong(""1010101010101010101010101010101010101010101010"".substring(0, size), 2);
 	}
 }
","package qualificationround;
 
 import java.util.*;
 import java.io.*;
 
 public class ProblemB {
 	static char combineMap[][];
 	static boolean combineH[][];
 	static boolean opposeMap[][];
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws IOException{
 		Scanner sc = new Scanner(new FileReader(""B.in""));
 		PrintWriter out = new PrintWriter(new FileWriter(""B.out""));
 		int t = sc.nextInt();
 		for (int caseNum = 1; caseNum <= t; caseNum++)
 		{
 			combineMap = new char[26][26];
 			combineH = new boolean[26][26];
 			opposeMap = new boolean[26][26];
 			for (int i = 0; i < 26; i++) 
 				for (int j = 0; j < 26; j++){					
 					opposeMap[i][j] = false;
 					combineH[i][j] = false;
 				}
 			int c = sc.nextInt();			
 			for (int i = 0; i < c; i++){
 				String str = sc.next();
 				int c1 = (int)str.charAt(0)-65;
 				int c2 = (int)str.charAt(1)-65;
 				char c3 = str.charAt(2);
 				//System.out.println(c1+"" ""+c2+"" ""+c3);
 				combineMap[c1][c2] = c3;
 				combineMap[c2][c1] = c3;
 				combineH[c1][c2] = true;
 				combineH[c2][c1] = true;
 			}
 			int d = sc.nextInt();
 			for (int i = 0; i < d; i++){
 				String str = sc.next();
 				int c1 = (int)str.charAt(0)-65;
 				int c2 = (int)str.charAt(1)-65;
 				opposeMap[c1][c2] = true;
 				opposeMap[c2][c1] = true;
 			}
 			int seqlen = sc.nextInt();
 			String seq = sc.next();
 						
 			out.println(""Case #""+caseNum+"": ""+solve(seq));
 		}
 		out.close();
 	}
 	
 	private static String solve(String str){
 		ArrayList<Integer> arr = new ArrayList<Integer>();
 		for (int i = 0; i < str.length(); i++){
 			arr.add((int)str.charAt(i)-65);
 			if (arr.size()>=2){
 				int c1 = arr.get(arr.size()-2);
 				int c2 = arr.get(arr.size()-1);
 				if (combineH[c1][c2]){
 					arr.remove(arr.size()-1);
 					arr.remove(arr.size()-1);
 					arr.add((int)combineMap[c1][c2]-65);
 				}
 				if (arr.size()>=2){
 					int j = arr.size()-2;
 					while (j>=0 && !opposeMap[arr.get(j)][arr.get(arr.size()-1)]) 
 						j--;
 					if (j>=0){
 						arr.clear();
 					}
 				}
 			}
 		}
 		StringBuffer buffer = new StringBuffer(""["");
 		for (int i = 0; i < arr.size(); i++) {
 			buffer.append((char)(arr.get(i)+65));
 			if (i!=arr.size()-1)
 				buffer.append("", "");
 		}
 		buffer.append(']');
 		return buffer.toString();
 	}
 
 }
",0
214,2862,"import java.io.*;
 import java.util.*;
 
 public class B {
 
     void solve() throws IOException {
         in(""B-large.in""); out(""B-large.out"");
 
         int testCount = readInt();
         for (int test = 1; test <= testCount; ++test) {
             int n = readInt();
             int m = readInt();
             int[][] h = new int[n][m];
             for (int i = 0; i < n; ++i) {
                 for (int j = 0; j < m; ++j) {
                     h[i][j] = readInt();
                 }
             }
             boolean flag = true;
             for (int i = 0; i < n && flag; ++i) {
                 for (int j = 0; j < m && flag; ++j) {
                     for (int k = 0; k < n && flag; ++k) flag = h[i][j] >= h[k][j];
                     if (!flag) {
                         flag = true;
                         for (int k = 0; k < m && flag; ++k) flag = h[i][j] >= h[i][k];
                     }
                 }
             }
             println(""Case #"" + test + "": "" + (flag ? ""YES"" : ""NO""));
         }
 
         exit();
     }
 
     void in(String name) throws IOException {
         if (name.equals(""__std"")) {
             in = new BufferedReader(new InputStreamReader(System.in));
         } else {
             in = new BufferedReader(new FileReader(name));
         }
     }
 
     void out(String name) throws IOException {
         if (name.equals(""__std"")) {
             out = new PrintWriter(System.out);
         } else {
             out = new PrintWriter(name);
         }
     }
 
     void exit() {
         out.close();
         System.exit(0);
     }
 
     char readChar() throws IOException {
         return (char) in.read();
     }
 
     int readInt() throws IOException {
         return Integer.parseInt(readToken());
     }
 
     long readLong() throws IOException {
         return Long.parseLong(readToken());
     }
 
     double readDouble() throws IOException {
         return Double.parseDouble(readToken());
     }
 
     String readLine() throws IOException {
         st = null;
         return in.readLine();
     }
 
     String readToken() throws IOException {
         while (st == null || !st.hasMoreTokens()) {
             st = new StringTokenizer(in.readLine());
         }
         return st.nextToken();
     }
 
     boolean eof() throws IOException {
         return !in.ready();
     }
 
     void print(String format, Object ... args) {
         out.print(new Formatter(Locale.US).format(format, args));
     }
 
     void println(String format, Object ... args) {
         out.println(new Formatter(Locale.US).format(format, args));
     }
 
     void print(Object value) {
         out.print(value);
     }
 
     void println(Object value) {
         out.println(value);
     }
 
     void println() {
         out.println();
     }
 
     StringTokenizer st;
 
     BufferedReader in;
     PrintWriter out;
 
     public static void main(String[] args) throws IOException {
         new B().solve();
     }
 }
","package problema;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.List;
 
 public class ProblemA {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         File in = new File(""d:/develop/GoogleCodeJam/ProblemA/A-large.in"");
         Reader reader = new FileReader(in);
         BufferedReader bf = new BufferedReader(reader);
         
         String casesNum = bf.readLine();
         Integer cases = Integer.parseInt(casesNum);
         
         String line;
         
         File out = new File(""d:/develop/GoogleCodeJam/ProblemA/A-large.out"");
         Writer writer = new FileWriter(out);
         
         for (int i = 0; i < cases; i++) {
             // read the matrix
             Matrix matrix = readMatrix(bf);
             bf.readLine();
             
             writer.write(""Case #""+ (i+1) +"": "" + matrix.toString()+""\n"");
         }
         
         reader.close();
         bf.close();
         writer.close();
     }
 
     private static Matrix readMatrix(BufferedReader bf) throws IOException {
         Matrix x = new Matrix();
         // first line
         char[] c = bf.readLine().toCharArray();
         x.r1 = """"+c[0];
         x.c1 = """"+c[0];
         x.d1 = """"+c[0];
 
         x.r1 += c[1];
         x.c2 = """"+c[1];
         
         x.r1 += c[2];
         x.c3 = """"+c[2];
 
         x.r1 += c[3];
         x.c4 = """"+c[3];
         x.d2 = """"+c[3];
 
         // second line
         c = bf.readLine().toCharArray();
         x.r2 = """"+c[0];
         x.c1 += c[0];
         
         x.r2 += c[1];
         x.c2 += c[1];
         x.d1 += c[1];
         
         x.r2 += c[2];
         x.c3 += c[2];
         x.d2 += c[2];
 
         x.r2 += c[3];
         x.c4 += c[3];
 
         // third line
         c = bf.readLine().toCharArray();
         x.r3 = """"+c[0];
         x.c1 += c[0];
         
         x.r3 += c[1];
         x.c2 += c[1];
         x.d2 += c[1];
         
         x.r3 += c[2];
         x.c3 += c[2];
         x.d1 += c[2];
 
         x.r3 += c[3];
         x.c4 += c[3];
 
         // first line
         c = bf.readLine().toCharArray();
         x.r4 = """"+c[0];
         x.c1 += c[0];
         x.d2 += c[0];
         
         x.r4 += c[1];
         x.c2 += c[1];
         
         x.r4 += c[2];
         x.c3 += c[2];
 
         x.r4 += c[3];
         x.c4 += c[3];
         x.d1 += c[3];
         
         if ((x.r1+x.r2+x.r3+x.r4).contains(""."")) {
             x.stillOn = true;
         }
 
         x.addAll();
         
         return x;
     }
 }
",0
215,6385,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
 
 import org.xml.sax.InputSource;
 
 
 public class A {
 
 	public static void main(String[] args)throws Exception{
 		//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		BufferedReader br = new BufferedReader(new FileReader(""F:/A-large.in""));
 		System.setOut(new PrintStream(""A2.out""));
 		int n = Integer.parseInt(br.readLine());
 		for(int c=0;c<n;c++){
 			System.out.println(""Case #""+(c+1)+"":"");
 			String[] j = br.readLine().split("" +"");
 			int row=Integer.parseInt(j[0]);
 			int col=Integer.parseInt(j[1]);
 			char[][] mat=new char[row][col];
 			int[][] rs=new int[row][col];
 			for(int e=0;e<row;e++)mat[e]=br.readLine().toCharArray();
 			int blues=0;
 			for(int e=0;e<row;e++)for(int i=0;i<col;i++)if(mat[e][i]=='#')blues++;
 			if(blues%2==1){
 				System.out.println(""Impossible"");
 				continue;
 			}
 			int r=1;
 			for(int e=0;e<row;e++)for(int i=0;i<col;i++){
 				if(e<row-1&&i<col-1)if(mat[e][i]=='#'&&mat[e][i+1]=='#'&&mat[e+1][i]=='#'&&mat[e+1][i+1]=='#'){
 					rs[e+1][i]=r+1;
 					rs[e+1][i+1]=r+4;
 					rs[e][i]=r+3;
 					rs[e][i+1]=r+2;
 					r+=4;
 					mat[e+1][i]='.';
 					mat[e+1][i+1]='.';
 					mat[e][i]='.';
 					mat[e][i+1]='.';
 				}
 			}
 			blues=0;
 			for(int e=0;e<row;e++)for(int i=0;i<col;i++)if(mat[e][i]=='#')blues++;
 			if(blues>0){
 				System.out.println(""Impossible"");
 			}else{
 				for(int e=0;e<row;e++){
 					for(int i=0;i<col;i++){
 						if(rs[e][i]>0)System.out.print(rs[e][i]%4==0?""/"":rs[e][i]%4==3?""\\"":rs[e][i]%4==1?""/"":""\\"");
 						else System.out.print(mat[e][i]);
 					}
 					System.out.println();
 				}
 			}
 		}
 		System.out.flush();
 		System.out.close();
 	}
 	
 }
","import java.util.ArrayList;
 import java.util.List;
 
 
 public class Problem1 {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		List<Thread> threads = new ArrayList<Thread>();
 		ArrayList<String> in=Util.readFile(""A-large.in"");
 		for (int i=1;i<in.size();i++) {
 			Runnable task = new MyRunnableP1(i, in.get(i));
 			Thread worker = new Thread(task);
 			worker.start();
 			threads.add(worker);			
 		}
 
 	}
 
 	
 }
 
 class MyRunnableP1 implements Runnable {
 	private final String secondLine;
 	private final int index;
 
 	MyRunnableP1(int index, String secondLine) {
 		this.secondLine=secondLine;
 		this.index=index;
 	}
 
 	@Override
 	public void run() {
 		String[] cStr = secondLine.split("" "");
 		int totalTurn=Integer.parseInt(cStr[0]);
 		int[] orange = new int[totalTurn];
 		int[] blue = new int[totalTurn];
 		boolean[] isBlueTurn = new boolean[totalTurn];
 		int indexBlue=0;
 		int indexOrange=0;
 		int indexTurn=0;
 		for (int j = 1; j < cStr.length; j+=2) {
 			if(cStr[j].equals(""B"")){
 				blue[indexBlue] = Integer.parseInt(cStr[j+1]);
 				indexBlue++;
 			}else{
 				orange[indexOrange] = Integer.parseInt(cStr[j+1]);
 				indexOrange++;
 			}
 			isBlueTurn[indexTurn]=(cStr[j].equals(""B""))?true:false;
 			indexTurn++;
 		}
 		int currBlue=1;
 		int currOrange=1;
 		int targetBlue;
 		int targetOrange;
 		indexBlue=0;
 		indexOrange=0;
 		int result=0;
 		for (int i = 0; i < isBlueTurn.length; i++) {
 			boolean isBlue=isBlueTurn[i];
 			targetBlue=blue[indexBlue];
 			targetOrange=orange[indexOrange];
 			if(isBlue){
 				indexBlue++;
 			}else{
 				indexOrange++;
 			}
 			//
 			while(true){
 				if((isBlue&&currBlue==targetBlue)){
 					result++;
 					//System.out.println(""hit r=""+result);
 					if(currOrange<targetOrange){
 						//System.out.println(""O++"");
 						currOrange++;
 					}else{
 						if(currOrange>targetOrange){
 							//System.out.println(""O--"");
 							currOrange--;
 						}else{//stay
 							//System.out.println(""O stay"");
 						}
 					}
 					break;					
 				}
 				if((!isBlue&&currOrange==targetOrange)){
 					result++;
 					//System.out.println(""hit r=""+result);
 					if(currBlue<targetBlue){
 						currBlue++;
 						//System.out.println(""B++"");
 					}else{
 						if(currBlue>targetBlue){
 							currBlue--;
 							//System.out.println(""B--"");
 						}else{//stay
 							//System.out.println(""B stay"");
 						}
 					}
 					break;		
 				}
 
 				if(currBlue<targetBlue){
 					currBlue++;
 					//System.out.println(""B++"");
 				}else{
 					if(currBlue>targetBlue){
 						currBlue--;
 						//System.out.println(""B--"");
 					}else{//stay
 						//System.out.println(""B stay"");
 					}
 				}
 				if(currOrange<targetOrange){
 					//System.out.println(""O++"");
 					currOrange++;
 				}else{
 					if(currOrange>targetOrange){
 						//System.out.println(""O--"");
 						currOrange--;
 					}else{//stay
 						//System.out.println(""O stay"");
 					}
 				}
 					result++;
 			}
 		}
 		
 		System.out.println(""Case #""+index+"": "" + result);
 		
 
 	}
 	
 	
 }
 
 
",0
216,1273,"package pkg;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.util.List;
 
 public class FileOutput {
     public static void write(String fileName, List<String> data) {
         FileWriter f = null;
         try{
         	File outF = new File(fileName);
             f = new FileWriter(outF);
             for(int n = 0; n < data.size(); n++) {
             	f.write(data.get(n));
             	f.write(""\r\n"");
             }
         }catch(Exception e){
         	e.printStackTrace();
         } finally {
         	try {
         		if (f != null) {
         			f.close();
         		}
         	} catch (Exception e) {
         		e.printStackTrace();
         	}
         }
     }
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class MagicTrick {
     private static final String inFile = ""A-small-attempt0.in"";
     private static final String outFile = ""1_out.txt"";
 
     public static void main(String[] args) throws IOException {
         Scanner scanner = new Scanner(new FileReader(inFile));
         int T = scanner.nextInt();
         FileWriter fw = new FileWriter(outFile);
         for (int t = 1; t <= T; ++t) {
             Set<Integer> s1 = readRow(scanner);
             Set<Integer> s2 = readRow(scanner);
             s1.retainAll(s2);
             String out = """";
             switch (s1.size()) {
                 case 0:
                     out = ""Volunteer cheated!"";
                     break;
                 case 1:
                     for (int i : s1) {
                         out = Integer.toString(i);
                     }
                     break;
                 default:
                     out = ""Bad magician!"";
                     break;
             }
             fw.write(String.format(""Case #%d: %s\n"", t, out));
         }
         fw.close();
     }
 
     private static Set<Integer> readRow(Scanner scanner) {
         int row = scanner.nextInt() - 1;
         int[][] a = new int[4][4];
         for (int i = 0; i < 4; ++i) {
             for (int j = 0; j < 4; ++j) {
                 a[i][j] = scanner.nextInt();
             }
         }
         HashSet<Integer> hs = new HashSet<Integer>();
         for (int j = 0; j < 4; ++j) {
             hs.add(a[row][j]);
         }
         return hs;
     }
 }
",0
217,15477,"import java.util.*;
 import java.io.*;
 
 public class dancing {
     public static void main(String[] args) throws Throwable {
 	Scanner input=new Scanner(new File(""dancing.in""));
 	PrintWriter out=new PrintWriter(new File(""dancing.out""));
 	int cases=input.nextInt();
 	for(int test=1;test<=cases;test++) {
 	    int n=input.nextInt();
 	    int s=input.nextInt();
 	    int p=input.nextInt();
 	    int[] t=new int[n];
 	    for(int i=0;i<n;i++) t[i]=input.nextInt();
 	    int numNS=0, numS=0;
 	    for(int i=0;i<n;i++) {
 		if(t[i]/3+(t[i]%3==0?0:1)>=p) numNS++;
 		}
 	    for(int i=0;i<n;i++) {
 		if(t[i]<2) {
 		    if(t[i]>=p) numS++;
 		    }
 		else {
 		    if((t[i]-2)/3+2>=p) numS++;
 		    }
 		}
 	    int ans=numNS+Math.min(numS-numNS, s);
 	    out.println(""Case #""+test+"": ""+ans);
 	    }
 	out.close();
 	}
     }","import java.util.*;
 import java.io.*;
 
 public class add  {
     public static void main(String[] args) throws Throwable {
 	Scanner input=new Scanner(new File(""add.in""));
 	PrintWriter output=new PrintWriter(new File(""add.out""));
 	int t=input.nextInt();
 	for(int i=0;i<t;i++) {
 	    int number=input.nextInt();
 	    int[] nums=new int[number];
 	    int startnum=0;
 	    int total=0;
 	    int min=1000000000;
 	    for(int j=0;j<number;j++) {
 		nums[j]=input.nextInt();
 		total+=nums[j];
 		startnum=startnum^nums[j];
 		min=Math.min(min,nums[j]);
 		}
 	    if(startnum!=0) {
 		output.println(""Case #""+(i+1)+"": NO"");
 		}
 	    else {
 		output.println(""Case #""+(i+1)+"": ""+(total-min));
 		}
 	    }
 	output.close();
 	}
     }",1
218,4200,"import java.io.*;
 import java.util.*;
 public class Magicka
 {
     public static void main(String args[]) throws IOException
     {
         Scanner input=new Scanner(new File(""C:/Users/Gabriel Work/Desktop/B-small-attempt0.in""));
         int t=input.nextInt();
         for(int num=1; num<=t; num++){
             int c=input.nextInt();//These are the elements that combine
             char[][] combineList=new char[c][3];
             for(int indx=0; indx<c; indx++){
                 String thisString=input.next();
                 combineList[indx][0]=thisString.charAt(0);
                 combineList[indx][1]=thisString.charAt(1);
                 combineList[indx][2]=thisString.charAt(2);
             }
             
             int d=input.nextInt();//these are opposed elements
             char[][] opposeList=new char[d][2];
             for(int indx=0; indx<d; indx++){
                 String thisString=input.next();
                 opposeList[indx][0]=thisString.charAt(0);
                 opposeList[indx][1]=thisString.charAt(1);
             }
             
             int n=input.nextInt();
             String elements=input.next();
             ArrayList<Character> elementList=new ArrayList<Character>();
             for(int indx=0; indx<n; indx++){
                 elementList.add(elements.charAt(indx));
                 if(elementList.size()>=2){
                     checkElementList(elementList, combineList, opposeList);
                 }
             }
             System.out.print(""Case #""+num+"": ["");
             Iterator<Character> iterator=elementList.iterator();
             while(iterator.hasNext()){
                 System.out.print(iterator.next());
                 if(iterator.hasNext()){
                     System.out.print("", "");
                 }
             }
             System.out.println(""]"");
         }
         
         input.close();
     }
     public static ArrayList<Character> checkElementList(ArrayList<Character> elementList, char[][] combineList, char[][] opposeList){
         //check for combine
         Character one=elementList.get(elementList.size()-1);
         Character two=elementList.get(elementList.size()-2);
         for(int indx=0; indx<combineList.length; indx++){
             if((combineList[indx][0]==one.charValue()&&combineList[indx][1]==two.charValue())||(combineList[indx][1]==one.charValue()&&combineList[indx][0]==two.charValue())){
                 elementList.remove(elementList.lastIndexOf(two));
                 elementList.remove(elementList.lastIndexOf(one));
                 elementList.add(combineList[indx][2]);
                 if(elementList.size()>=2){
                     checkElementList(elementList, combineList, opposeList);
                 }
             }
         }
         //check for oppose
         Iterator<Character> itr1=elementList.iterator();
         while(itr1.hasNext()){
             one=itr1.next();
             
             for(int indx1=0; indx1<elementList.size(); indx1++){
                 two=elementList.get(indx1);
                 for(int indx=0; indx<opposeList.length; indx++){
                     if((opposeList[indx][0]==one.charValue()&&opposeList[indx][1]==two.charValue())||(opposeList[indx][1]==one.charValue()&&opposeList[indx][0]==two.charValue())){
                         elementList.clear();
                         return elementList;
                     }
                 }
             }
         }
         
         
         
         return elementList;
     }
     public static String toString(char[] stringArray){
         String answer=""["";
         for(int indx=0; indx<stringArray.length-1; indx++){
             answer=answer+stringArray[indx]+"", "";
         }
         answer=answer+stringArray[stringArray.length-1]+""]"";
         return answer;
     }
 }","package bullseye;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class Solution {
 	public static void main(String args[]) throws Exception {
 		Scanner reader = new Scanner(new File(""A-small-attempt0.in""));
 		BufferedWriter writer = new BufferedWriter(new FileWriter(""output.txt""));
 		int T = reader.nextInt();
 		for (int i = 0; i < T; i++) {
 			long r = reader.nextLong(), t = reader.nextLong();
 			String out = ""Case #"" + (i + 1) + "": "";
 			long numRings = 0;
 
 			do {
 				t -= 2 * r + 1;
 				r += 2;
 				numRings++;
 
 			} while (t >= 0);
 
 			out += --numRings;
 
 			writer.write(out + ""\n"");
 			System.out.println(i + 1 + "" / "" + T);
 		}
 
 		reader.close();
 		writer.close();
 	}
 }",1
219,4262,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class C1 {
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scanner = new Scanner(new File(""input1.txt""));
 		String tmp = scanner.nextLine();
 		int t = Integer.parseInt(tmp);
 		for (int i = 1; i <= t; i++) {
 			System.out.println(""Case #""+i+"": ""+solved(scanner, t));
 		}
 	}
 	public static int solved(Scanner scanner, int t){
 		String line = scanner.nextLine();
 		String[] tokens = line.split("" "");
 		String name = tokens[0];
 		int n = Integer.parseInt(tokens[1]);
 		boolean adjacent=false;
 		int poss=0;
 		boolean first=true;
 		//int countTokens=0;
 		int pastI=0;
 		for (int i = 0; i+n <= name.length(); i++) {
 			String sub = name.substring(i, i+n);
 			if(!iscontainVowels(sub)){
 				poss+=countPoss(i, name, n, adjacent, pastI, first);
 //				if(!adjacent){
 //					countTokens++;
 //				}
 				adjacent=true;
 				pastI=i;
 				first=false;
 			}
 			else{				
 				adjacent=false;
 			}
 		}
 		
 		//System.out.println(name+"" ""+n);
 		return poss;
 	}
 	
 	public static int countPoss(int index, String var, int n, boolean adjacent, int pastIndex, boolean first){
 		int possLeft=0;
 		int possRight=0;
 		if(!adjacent){
 			if(!first){
 				possLeft = index-pastIndex;
 			}
 			else{
 				possLeft=index+1;
 			}
 		}
 		possRight=((var.length()-(index+n))+1);
 		return (!adjacent)?possLeft*possRight:possRight;
 //		if(possLeft!=0)
 //			return possLeft;
 //		if(possRight!=0)
 //			return possRight;
 //		else
 //			return 0;
 	}
 	
 	public static boolean iscontainVowels(String var){
 		if(var.contains(""a"") || var.contains(""e"") || var.contains(""i"") || var.contains(""o"") || var.contains(""u"")){
 			return true;
 		}
 		return false;
 	}
 }
","
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.LinkedList;
 import java.util.List;
 
 
 public class MagicKa {
 	public static List<String> findPare(final String[] data,int start,int n){
 		int max=start+n;
 		List<String> result = new LinkedList<String>();
 		for (int i = start; i < max; ++i) {
 			result.add(data[i]);
 		}
 		return result;
 	}
 	
 	public static void main(String[] args) {
 		if(args.length==0){
 			args=new String[]{""bin/input2.in"",""bin/output2""};
 		}
 		BufferedReader bfr=null;
 		PrintWriter pw=null;
 		try {
 			FileReader fr=new FileReader(args[0]);
 			FileWriter fw=new FileWriter(args[1]);
 			bfr=new BufferedReader(fr);
 			pw=new PrintWriter(fw);
 			String numberOfCaseString=bfr.readLine();
 			
 			if(numberOfCaseString!=null){
 				Long numberOfTestCase=Long.parseLong(numberOfCaseString);
 				for (long i=1; i<=numberOfTestCase; ++i){
 					String line = bfr.readLine();
 					if(line!=null){
 						String[] dataIn = line.trim().split("" "");
 						int startIndex=0;
 						int nCombind=Integer.parseInt(dataIn[startIndex]);
 						List<String> listOfCombination = findPare(dataIn, startIndex+1, nCombind);
 						startIndex+=nCombind;
 						++startIndex;
 						int nOpposed=Integer.parseInt(dataIn[startIndex]);
 						List<String> listOfOpposed = findPare(dataIn, startIndex+1, nOpposed);
 						startIndex+=nOpposed;
 						++startIndex;
 						int nElements=Integer.parseInt(dataIn[startIndex]);
 						String elementsTmp=dataIn[startIndex+1];
 						if(nElements!=elementsTmp.length()){
 							System.out.println(""Wrong Data input!!!"");
 						}
 						StringBuilder sb=new StringBuilder();
 						for (int j=0; j < elementsTmp.length(); ++j) {
 							sb.append(elementsTmp.charAt(j));
 							
 							//combinding elements
 							for (String combind : listOfCombination) {
 								if(sb.toString().endsWith(combind.substring(0, 2)) || sb.toString().endsWith(String.valueOf(combind.charAt(1))+String.valueOf(combind.charAt(0)))){
 									sb=sb.delete(sb.length()-2, sb.length());
 									sb.append(combind.charAt(combind.length()-1));
 								}
 							}
 							
 							//opposing element
 							for (String opposed : listOfOpposed) {
 								String first=String.valueOf(opposed.charAt(0));
 								String second=String.valueOf(opposed.charAt(1));
 								int indexFirst=sb.lastIndexOf(first);
 //								System.out.println(""first:""+first);
 //								System.out.println(""secode:""+second);
 //								int indexFirst=sb.indexOf(first);
 								int indexSecond=sb.lastIndexOf(second);
 //								int indexSecond=sb.indexOf(second);
 								if(indexFirst!=-1 && indexSecond!=-1){
 									if(indexFirst<indexSecond){
 //										sb.delete(indexFirst, indexSecond+1);
 										sb.delete(0, sb.length());
 									}
 									else if(indexFirst>indexSecond){
 //										sb.delete(indexSecond,indexFirst+1);
 										sb.delete(0, sb.length());
 									}
 								}
 							}
 						}
 						
 						//add out-put to list and print out
 						String elements=sb.toString();
 						pw.print(""Case #""+i+"": ["");
 						for (int j = 0; j < elements.length(); ++j) {
 							if(j!=0){
 								pw.print("", "");
 							}
 							pw.print(elements.charAt(j));
 						}
 						pw.println(""]"");
 					}
 				}
 			}
 
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 		catch (IOException e) {
 			e.printStackTrace();
 		}
 		finally{
 			try {
 				if(bfr!=null)
 					bfr.close();
 				if(pw!=null)
 					pw.close();
 			} catch (Exception e) {
 				e.printStackTrace();
 			}
 		}
 	}
 }
",1
220,16564,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package D_Day;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.util.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  *
  * @author Shatadru
  */
 
 
 public class Magicka {
 
     
 public static void main(String args[])
 {
         try {
             File f1 = new File(""C:/B-large.in"");
             File f2=new File(""C:/output.txt"");
             BufferedWriter bw=new BufferedWriter(new FileWriter(f2));
             Scanner in = new Scanner(f1);
             int cnt = 0;
             int t = in.nextInt();
             char[] res2;
             Func f = new Func();
             while (t != cnt) {
                 int c = in.nextInt();
                 char[][] com = new char[c][3];
                 for (int i = 0; i < c; i++) {
                     String cmbn = in.next();
                     f.initz(cmbn.charAt(0), cmbn.charAt(1), cmbn.charAt(2), com, i);
                 }
                 int d = in.nextInt();
                 char[][] decom = new char[d][2];
                 for (int i = 0; i < d; i++) {
                     String cmbn = in.next();
                     f.deinitz(cmbn.charAt(0), cmbn.charAt(1), decom, i);
                 }
                 int n = in.nextInt();
                 
                 res2 = new char[n];
 
                 int count = 0;
 
                 char invk[]=new char[n];
                 
                 String b = in.next();
                 invk=b.toCharArray();
                 for (int i = 0; i < n; i++)
                 {
                     char inv1,inv2;
                     char res;
                     int flag=0;
                     inv1=invk[i];
 
                     res = f.decombine(inv1, res2, decom);
 
                     if (res == '2')
                     {
                        
                         Arrays.fill(res2,'\u0000');
                         count = 0;
                         continue;
                     }
                     
                     if (i < n-1 )
                     {
                         inv2 = invk[i+1];
                         
                         if ((res=f.combine(inv1, inv2, com)) != '1') {
                             res2[count--] = res;
                             count=count+2;
                             i=i+1;
                          
                             flag=1;
                         }
                         
                         
                         
                         
                     }
                         if(flag!=1)
                         {
                             res2[count++] = inv1;
                            // System.out.println(""Not COmbine""+count);
                         }
                    
                     
                     //System.out.println(""Normal""+count);
                    
                 }
                 cnt++;
                 bw.write(""Case #""+cnt+"": ["");
                 for(int j=0;j<res2.length;j++)
                 {
                     if(res2[j]!='\u0000')
                     {
                         if(j!=0)
                         {
                          bw.write("", "");   
                         }
                         bw.write(res2[j]);
                     }
 
 
                 }
                 bw.write(""]"");
                 bw.newLine();
             }
             bw.close();
         }
         catch (Exception ex) {
          ex.printStackTrace();        }
 
 
 
 }
     
 
 }
 
 
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package codejam2013;
 
 import java.io.BufferedReader;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 /**
  *
  * @author Ramshad
  */
 public class FairAndSquare {
     
     public static void main(String[] args) {
         // TODO code application logic here
          
        
        int count;
        
        
     try {
         
      
       Scanner sc=new Scanner(new BufferedReader(new FileReader(""C-small-attempt0.in"")));
      
       
       
      
      int T =sc.nextInt();
      
       if(1<=T && T<=100){
           
           
           PrintStream out = new PrintStream(new FileOutputStream(""C-small-output.txt""));
           int cas=1;
           
           
           while( cas<=T && sc.hasNext() ){
               count=0;
               long A=sc.nextInt();
               long B=sc.nextInt();
               for(long i=A;i<=B;i++){
                   if(is_palindrome(i)){
                       if(Math.ceil(Math.sqrt(i) )==Math.sqrt(i))
                           if(is_palindrome((long)Math.sqrt(i)))
                               count++;
                   }
               }
               System.setOut(out);
               System.out.println(""Case #""+cas+"": ""+count);
               
               
            cas++; 
       }
       }
      
       sc.close();
       
     } catch (Exception e) {
       // TODO Auto-generated catch block
     }
        
        
     }
     
 public static boolean is_palindrome( long orig)
 {
   long reversed = 0, n = orig;
 
   while (n > 0)
   {
     reversed = reversed * 10 + n % 10;
     n /= 10;
   }
 
   return orig == reversed;
 }
     
 }
",0
221,14657,"package codejam.y2013;
 import java.io.IOException;
 
 import codejam.base.ProblemSolver;
 
 
 public class A extends ProblemSolver {
 
 	public static void main(String[] args) throws java.io.IOException
 	{
 		A processor;
 
 		processor = new A();
 		processor.setFilePrefix(""A-small"");
 		processor.start();
 	}
 	
 	@Override
 	public String processCase(int caseNumber) throws IOException {
 		char[][] board = new char[4][4];
 		
 		for ( int i = 0; i < 4; i++ )
 			board[i] = nextString().toCharArray();
 		boolean x = false;
 		boolean o = false;
 		
 		for ( int i = 0; i < 4; i++ )
 		{
 			String s1 = """";
 			String s2 = """";
 			for ( int j = 0; j < 4; j++ )
 			{
 				s1 += board[i][j];
 				s2 += board[j][i];
 			}
 			
 			char w1 = winner(s1);
 			char w2 = winner(s2);
 			if ( w1 == 'X' || w2 == 'X' ) x = true;
 			if ( w1 == 'O' || w2 == 'O' ) o = true;
 		}
 		
 		String s1 = """";
 		String s2 = """";
 		for ( int i = 0; i < 4; i++ )
 		{
 			s1 += board[i][i];
 			s2 += board[3 - i][i];
 		}
 		char w1 = winner(s1);
 		char w2 = winner(s2);
 		if ( w1 == 'X' || w2 == 'X' ) x = true;
 		if ( w1 == 'O' || w2 == 'O' ) o = true;
 		
 		if ( o && x ) return ""Draw"";
 		if ( o ) return ""O won"";
 		if ( x ) return ""X won"";
 		boolean draw = true;
 		for ( int i = 0; i < 4; i++ )
 			for ( int j = 0; j < 4; j++ )
 				if ( board[i][j] == '.' )
 					draw = false;
 		if ( draw ) return ""Draw"";
 		return ""Game has not completed"";
 	}
 	
 	char winner ( String s )
 	{
 		s = s.replace(""T"", """");
 		char p = s.charAt(0);
 		for ( char c : s.toCharArray() )
 			if ( c != p ) return '.';
 		return p;
 	}
 
 }
","package codejam.y2013.r1a;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import codejam.base.ProblemSolver;
 
 public class A extends ProblemSolver {
 
 	public static void main(String[] args) throws java.io.IOException
 	{
 		A processor;
 
 		processor = new A();
 		processor.setFilePrefix(""A-small"");
 		processor.start();
 	}
 	
 	@Override
 	public String processCase(int caseNumber) throws IOException {
 		BigInteger r = nextBigInteger();
 		BigInteger t = nextBigInteger();
 		
 		BigInteger four = BigInteger.valueOf(4);
 		BigInteger eight = BigInteger.valueOf(8);
 		BigInteger m = r.multiply(BigInteger.valueOf(2));
 		m = m.subtract(BigInteger.ONE);
 		BigInteger mSq = m.multiply(m);
 		BigInteger disc = mSq.add(t.multiply(eight));
 		disc = sqrt(disc);
 		
 		BigInteger n1 = ((m.negate()).add(disc)).divide(four);
 		BigInteger n2 = ((m.negate()).subtract(disc)).divide(four);
 		
 		BigInteger n = n1.compareTo(n2) == 1 ? n1 : n2;
 		
 		return n.toString();
 	}
 	
 	public static BigInteger sqrt(BigInteger x) {
 	    
 	    if ( x == BigInteger.ZERO || x == BigInteger.ONE )
 	        return x;
 	    
 	    BigInteger two = BigInteger.valueOf(2L);
 	    BigInteger y;
 	    
 	    for (y = x.divide(two);
 	            y.compareTo(x.divide(y)) > 0;
 	            y = ((x.divide(y)).add(y)).divide(two));
 	    return y;
 	}
 }
",1
222,1205,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.Locale;
 
 public class GogoB extends Thread {
 	private final String _FILE_DIRECTORY = ""D:\\workspace\\codejam\\"";
 	private final String _FILE_PATH = _FILE_DIRECTORY + ""B-large"";
 	
 	public static void main(String[] args) throws IOException {
 		Locale.setDefault(Locale.US);
 		new GogoB().start();
 	}
 
 	public void run() {
 		BufferedReader br = null;
 		PrintWriter pw = null;
 
 		try {
 			br = new BufferedReader(new FileReader(_FILE_PATH + "".in""));
 			pw = new PrintWriter(_FILE_PATH + "".out"");
 	
 			int caseno = Integer.parseInt(br.readLine());
 		
 			for (int count = 1; count <= caseno; count++) {
 				pw.print(""Case #"" + count + "": "");
 				System.out.print(""Case #"" + count + "": "");
 				
 				String inputsTmp[] = br.readLine().split("" "");
 				StringBuilder inputBuf = new StringBuilder();
 				for(int i=1;i<inputsTmp.length;i++) {
 					if(inputBuf.indexOf(inputsTmp[i]) < 0)
 						inputBuf.append(inputsTmp[i]+"","");
 				}
 				String inputBufs = inputBuf.toString();
 				inputBufs = inputBufs.substring(0,inputBufs.length()-1);
 				inputsTmp = inputBufs.split("","");
 				
 				try{
 					long inputs[] = new long[inputsTmp.length];
 					for(int i=0;i<inputs.length;i++) {
 						inputs[i] = Long.parseLong(inputsTmp[i]);
 					}
 					long inputsDiff[] = new long[inputs.length];
 					for(int i=0;i<inputs.length;i++) {
 						if(i == inputs.length - 1)
 							inputsDiff[i] = Math.abs(inputs[i] - inputs[0]);
 						else
 							inputsDiff[i] = Math.abs(inputs[i] - inputs[i+1]); 
 					}
 					
 					long gcd = 0;
 					if(inputsDiff.length == 1)
 						gcd = inputsDiff[0];
 					else {
 						gcd = gcd(inputsDiff[0],inputsDiff[1]);
 						if(inputsDiff.length > 2) {
 							for(int i=2;i<inputsDiff.length;i++) {
 								gcd = gcd(gcd,inputsDiff[i]);
 							}
 						}
 						
 					}
 					long dday = 0;
 					long ddayDiff = inputs[0]%gcd;
 					if(ddayDiff == 0 || gcd == 0 || gcd == 1)
 						dday = 0;
 					else
 						dday = gcd - ddayDiff;
 					pw.print(dday + ""\n"");
 					System.out.print(dday + ""\n"");
 				}
 				catch(Exception e) {
 					BigInteger inputs[] = new BigInteger[inputsTmp.length];
 					for(int i=0;i<inputs.length;i++) {
 						inputs[i] = new BigInteger(inputsTmp[i]);
 					}
 					BigInteger inputsDiff[] = new BigInteger[inputs.length];
 					for(int i=0;i<inputs.length;i++) {
 						BigInteger a = inputs[i];
 						BigInteger b = inputs[i == inputs.length - 1 ? 0 : i + 1];
 						inputsDiff[i] = a.subtract(b).abs();
 					}
 					
 					BigInteger dday = new BigInteger(""0"");
 					BigInteger gcd = new BigInteger(""0"");
 					if(inputsDiff.length == 1)
 						gcd = inputsDiff[0];
 					else if (inputsDiff.length > 1) {
 						gcd = inputsDiff[0].gcd(inputsDiff[1]);
 						if(inputsDiff.length > 2) {
 							for(int i=2;i<inputsDiff.length;i++) {
 								gcd = gcd.gcd(inputsDiff[i]);
 							}
 						}
 					}
 					BigInteger ddayDiff = inputs[0].mod(gcd);
 					if(!(ddayDiff.compareTo(BigInteger.ZERO) == 0
 							|| gcd.compareTo(BigInteger.ZERO) == 0 
 							|| gcd.compareTo(BigInteger.ONE) == 0))
 						dday = gcd.subtract(ddayDiff);
 					
 					pw.print(dday + ""\n"");
 					System.out.print(dday + ""\n"");
 				}
 			}
 			br.close();
 			pw.close();
 		
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 		finally {
 			try {
 				if(pw != null) pw.close();
 			} catch(Exception e) {}
 			try {
 				if(br != null) br.close();
 			} catch(Exception e) {}
 		}
 	}
 	public long gcd(long x, long y) {
 		long tmp;
         while (x % y != 0) {
             tmp = y;
             y = x % y;
             x = tmp;
         }
         return y;
     }
 
 }
","import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
 public class AfatC {
 	private final String _PROBLEM_NO = ""201101CCC"";
 	private final String _FILE_DIRECTORY = ""K:/Dropbox/workspace/codejam/"" + _PROBLEM_NO + ""/"";
 	private final String _FILE_PATH = _FILE_DIRECTORY + ""D-large"";
 	
 	public static void main(String[] args) throws IOException {
 		Locale.setDefault(Locale.US);
 		new AfatC().execute();
 	}
 
 	public void execute() {
 		BufferedReader br = null;
 		PrintWriter pw = null;
 
 		try {
 			br = new BufferedReader(new FileReader(_FILE_PATH + "".in""));
 			pw = new PrintWriter(_FILE_PATH + "".out"");
 			
 			//main
 	
 			int caseno = Integer.parseInt(br.readLine());
 
 			for (int count = 1; count <= caseno; count++) {
 				pw.print(""Case #"" + count + "": "");
 				System.out.print(""Case #"" + count + "": "");
 				
 				br.readLine();
 				String[] datas = br.readLine().split("" "");
 				int[] types = new int[datas.length];
 				int type = 1;
 				
 				int pos = 0;
 				int nextpos = -1;
 				types[0] = 1;
 				
 				while(true) {
 					nextpos = Integer.parseInt(datas[pos]) - 1;
 					if(types[nextpos] <= 0) {
 						types[nextpos] = types[pos];
 						pos = nextpos;
 					}
 					else {
 						for(int i=0;i<types.length;i++) {
 							if(types[i] <= 0) {
 								pos = i;
 								type++;
 								
 								break;
 							}
 						}
 						if(types[pos] > 0) break;
 						else types[pos] = type;
 					}
 				}
 				
 				long result = 0;
 				int[] results = new int[type];
 				
 				for(int i =0;i < types.length; i++) {
 					results[types[i]-1]++;
 //					pw.print(types[i] + "" "");
 //					System.out.print(types[i] + "" "");
 				}
 				
 				for(int i =0;i < results.length; i++) {
 					int n = results[i];
 					if(n > 1) {
 						result += n;
 					}
 //					if(n > 1) {
 //						long nn = 1;
 //						while(n > 1) {
 //							nn = nn * n;
 //							n--;
 //						}
 //						result += nn;
 //					}
 				}
 				
 				pw.print(result+"".000000"");
 				System.out.print(result+"".000000"");
 				
 				pw.print(""\n"");
 				System.out.print(""\n"");
 			}
 			
 			//end
 	
 	
 			br.close();
 			pw.close();
 		
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 		finally {
 			try {
 				if(pw != null) pw.close();
 			} catch(Exception e) {}
 			try {
 				if(br != null) br.close();
 			} catch(Exception e) {}
 		}
 	}
 
 }
",1
223,3260,"import java.util.Scanner;
 
 public class B {
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int numCases = scan.nextInt();
 		for (int caseNum = 1; caseNum <= numCases; caseNum++) {
 			System.out.println(""Case #"" + caseNum + "": "" + solveProblem(scan));
 		}
 	}
 
 	private static String solveProblem(Scanner scan) {
 		long n = 1L << scan.nextLong();
 		long p = scan.nextLong();
 		long must = getMust(n, p);
 		long could = getCould(n, p);
 		return must + "" "" + could;
 	}
 
 	private static long getMust(long n, long p) {
 		long bot = 0;
 		long top = n;
 		while (top - bot > 1) {
 			long guess = (top + bot) / 2;
 			if (worstStanding(n, guess) < p) {
 				bot = guess;
 			} else
 				top = guess;
 		}
 		return bot;
 	}
 
 	private static long getCould(long n, long p) {
 		long bot = 0;
 		long top = n;
 		while (top - bot > 1) {
 			long guess = (top + bot) / 2;
 			if (bestStanding(n, guess) < p) {
 				bot = guess;
 			} else
 				top = guess;
 		}
 		return bot;
 	}
 
 	private static long worstStanding(long n, long t) {
 		return n - 1 - bestStanding(n, n - 1 - t);
 	}
 
 	private static long bestStanding(long n, long t) {
 		long numAbove = t;
 		long numBelow = n - t - 1;
 		long res = 0;
 		while (numBelow > 0) {
 			if (numAbove % 2 == 1) {
 				numAbove++;
 				numBelow--;
 			}
 			numAbove /= 2;
 			numBelow /= 2;
 		}
 		while (numAbove > 0) {
 			res <<= 1;
 			res += 1;
 			numAbove >>= 1;
 		}
 		return res;
 	}
 }
","import java.util.Arrays;
 import java.util.Scanner;
 
 public class A {
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int numCases = scan.nextInt();
 		for (int caseNum = 1; caseNum <= numCases; caseNum++) {
 			System.out.println(""Case #"" + caseNum + "": "" + solveProblem(scan));
 		}
 	}
 
 	private static int solveProblem(Scanner scan) {
 		long a = scan.nextLong();
 		int n = scan.nextInt();
 		int[] motesizes = new int[n];
 		for (int i = 0; i < n; i++) {
 			motesizes[i] = scan.nextInt();
 		}
 		Arrays.sort(motesizes);
 		if (a == 1)
 			return n;
 		int minOps = n;
 		int adds = 0;
 		for (int i = 0; i < n; i++) {
 			if (a > motesizes[i]) {
 				a += motesizes[i];
 				minOps = Math.min(minOps, adds + n - 1 - i);
 			} else {
 				a += a - 1;
 				i--;
 				adds++;
 			}
 		}
 		return minOps;
 	}
 }
",1
224,926,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package gcj2010.round1a;
 
 import gcj2009.*;
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author scbit
  */
 public class P3 {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws Exception {
         new P3().run();
     }
     PrintWriter pw;
 
     void run() throws Exception{
         File infile=new File(""C-small-attempt0.in"");
         String outfile=""result"";
         pw=new PrintWriter(outfile);
         int T=0;
         //BufferedReader br=new BufferedReader(new FileReader(infile));
         //N=Integer.parseInt(br.readLine());
         Scanner sc=new Scanner(infile);
         T=sc.nextInt();
 
         for(int case_i=1;case_i<=T;case_i++) {
             long result = 0;
             long A1=sc.nextInt();
             long A2=sc.nextInt();
             long B1=sc.nextInt();
             long B2=sc.nextInt();
             for(long a=A1;a<=A2;a++){
                 for(long b=B1;b<=B2;b++){
                     if(a<=b){
                         if(check(a,b)) result++;
                     }else{
                         if(check(b,a)) result++;
                     }
                 }
             }
             pw.printf(""Case #%d: %d\n"", case_i,result);
             System.out.printf(""Case #%d: %d\n"", case_i,result);
         }
         pw.close();
     }
 //    int[][] data=new int[1000000+1][1000000+1];
     boolean check(long a,long b){
         if(b>=(2*a)) return true;
         return !check(b-a,a);
 
     }
 }
","package net.neiti.codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class BotTrust {
 
 	public static void main(String[] args) throws Exception {
 		BufferedReader br = new BufferedReader(new FileReader(""A-small-attempt0.in""));
 		BufferedWriter bw = new BufferedWriter(new FileWriter(""output.txt""));
 		
 		int cases = Integer.parseInt(br.readLine());
 		
 		for(int count=0; count<cases; count++) {
 			String[] tokens = br.readLine().split("" "");
 			int buttons = Integer.parseInt(tokens[0]);
 			
 			int orange = 1, blue = 1;
 			int seconds = 0;
 			int i=0;
 			while(i<buttons) {
 				boolean orangePressed = false, bluePressed = false;
 				
 				String nextRobotToPress = tokens[(i*2)+1];
 				int nextIndexToPress = Integer.parseInt(tokens[(i*2)+2]);
 				
 				int nextOrangeIndex = getNextIndexToPress(""O"", (i*2)+1, tokens);
 				int nextBlueIndex = getNextIndexToPress(""B"", (i*2)+1, tokens);
 
 				//If it is ones robot turn and he is at the right position
 				//press the button
 				if(nextRobotToPress.equals(""O"") && orange == nextIndexToPress) {
 					i++;
 				}
 				if(nextRobotToPress.equals(""B"") && blue == nextIndexToPress) {
 					i++;
 				} 
 				
 				//If one of the two robots is not at the index he needs to press next
 				//move him there
 				if(nextOrangeIndex != -1 && orange != nextOrangeIndex && !orangePressed) {
 					orange += orange > nextOrangeIndex ? -1 : 1;
 				}
 				if(nextBlueIndex != -1 && blue != nextBlueIndex && !bluePressed) {
 					blue += blue > nextBlueIndex ? -1 : 1;
 				}
 				
 				seconds++;
 			}
 			
 			bw.write(""Case #"" + (count+1) + "": "" + seconds + (count < cases - 1 ? ""\n"" : """"));
 		}
 		
 		bw.flush();
 		bw.close();
 		br.close();
 	}
 
 	private static int getNextIndexToPress(String robot, int index, String[] tokens) {
 		for(int i=index; i<tokens.length; i+=2) {
 			if(tokens[i].equals(robot)) {
 				return Integer.parseInt(tokens[i+1]);
 			}
 		}
 		return -1;
 	}
 	
 }
",0
225,4824,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package googlejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.Scanner;
 
 /**
  *
  * @author Allegea
  */
 public class D {
 
     public static void main(String[] args) throws FileNotFoundException, IOException
     {
 
 
         //Scanner in = new Scanner(new File(""A-small-practice.in""));
         //FileWriter archivo = new FileWriter(""A-small-practice.out"");
         //DecimalFormat format = new DecimalFormat("".000000"");
 
         Scanner in = new Scanner(new File(""D-small-attempt0.in""));
         FileWriter archivo = new FileWriter(""D-small-attempt0.out"");
 
         PrintWriter out = new PrintWriter(archivo);
         out.flush();
 
         int cases = in.nextInt();
 
         for(int c=1;c<=cases;c++)
         {
 
             int size = in.nextInt();
             int ori[] = new int[size];
             int ord[] = new int[size];
             for(int i=0;i<size;i++)
             {
                 ori[i]=in.nextInt();
                 ord[i]=ori[i];
             }
 
             Arrays.sort(ord);
 
             int hits=0;
             for(int i=0;i<size;i++)
             {
                 if(ori[i]!=ord[i])hits++;
             }
 
             System.out.format(Locale.ENGLISH, ""Case #%d: %d.000000\n"",c, hits);
             //System.out.format(""Case #""+c+"": ""+format.format(hits));
             out.format(Locale.ENGLISH, ""Case #%d: %d.000000\n"",c, hits);
         }
 
         out.close();
        
     }
 
 
 }
","package gcj2013;
 
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 import java.io.*;
 import java.util.*;
 /**
  *
  * @author Alejandro E. Garces
  */
 public class Bullseye {
 
     static int solve(long r, double t)
     {
         int count = 0;
         double prev = r*r;
 
         while(true)
         {
           // System.out.println(r+"" - ""+count);
             r+=1;
             double aux = r*r;
             //System.out.println(prev+"" - ""+aux+"" - ""+(aux-prev)+"" - ""+ t);
             double minus = aux-prev;
             if(minus <= t){
                 count++;
                 t-=minus;
                 r+=1;
                 prev = r*r;
             }else break;
         }
         return count;
     }
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws IOException {
         String file = ""A-small-attempt0"";
         String line = """";
         StringTokenizer r;
         
         System.setIn(new FileInputStream(file+"".in""));
         System.setOut(new PrintStream(new FileOutputStream(file+""O.out"")));
         
         /////////////////////
         //Input from Console
         BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
         //Scanner in = new Scanner(System.in);
         
         /////////////////////
         //Input from file
         //BufferedReader in = new BufferedReader(new FileReader(file+"".txt""));
         //Scanner in = new Scanner(new File(file+"".txt""));
         //FileWriter archivo = new FileWriter(file+""O.txt"");
         //PrintWriter out = new PrintWriter(archivo);
         //out.flush();
         ////////////////////
         
         int cases = Integer.parseInt(in.readLine());
         int answer = -1;
         for(int cc=1;cc<=cases;cc++)
         {
             r = new StringTokenizer(in.readLine());
             long radius = Long.parseLong(r.nextToken());
             long t = Long.parseLong(r.nextToken());
             
             System.out.println(""Case #""+cc+"": ""+solve(radius, t));
         }
         
         
         in.close();
         System.exit(0);
     }
 }
",1
226,14216,"package com.mademoisellegeek.googlecodejam;
 
 import com.mademoisellegeek.googlecodejam.y2012.qualround.DancingWithTheGooglers;
 import com.mademoisellegeek.googlecodejam.y2012.qualround.RecycledNumbers;
 import com.mademoisellegeek.googlecodejam.y2012.qualround.SpeakingInTongues;
 
 public class GoogleCodeJam {
 
     public static void main(String[] args) {
         new Thread(new RecycledNumbers()).start();
     }
 }
","package gcj;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.StringTokenizer;
 
 public class DancingWithTheGooglers {
 
 	/**
 	 * @param args
 	 */
 
 	private static int[] values = null;
 	private static int[] googlers= null;
 	private static int total =0;
 	
 	public static void main(String[] args) {
 		
 		BufferedReader fin = null;
 		int t = 0;
 		StringTokenizer str = null;
 		
 		try {
 			fin = new BufferedReader(new FileReader(new File(""B-large.in"")));
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 		
 	
 			
 			try {
 				t = Integer.parseInt(fin.readLine());
 				//System.out.println(t);
 			} catch (NumberFormatException e) {
 				e.printStackTrace();
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			
 			values = new int[3];
 			
 			
 			for(int i=0;i<t;i++){
 				System.out.print(""Case #""+(i+1)+"": "");
 				try {
 					total = 0;
 					str=new StringTokenizer(fin.readLine());
 					
 					int ctr =0;
 				while(ctr<3) {
 					 
 					values[ctr]=Integer.parseInt(str.nextToken());
 					ctr++;
 					
 					}
 				//System.out.print(values[0]+"" ""+values[1]+"" ""+values[2]+"" "");
 				ctr=0;
 				googlers = new int[values[0]];
 				while(str.hasMoreElements()){
 					googlers[ctr]=Integer.parseInt(str.nextToken());
 					//System.out.print(googlers[ctr]+"" "");
 					ctr++;
 				}
 				//System.out.println();
 					
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 				
 				calculate();
 				
 			}
 	}
 
 
 	private static void calculate() {
 		
 		int value = 0 ;
 		int remainder = 0;
 		for(int i=0;i<values[0];i++){ //values[1] is the number of surprising solutions
 									  //values[2] is p
 									  //values[0] is number of cases
 									  //googlers is the totals of the each googler 
 									  //value is the division of total by 3	
 			
 			value = googlers[i]/3;
 			remainder = googlers[i]%3;
 			
 			if (googlers[i]==0&&values[2]!=0)
 				continue;
 			
 			if(value>=values[2])
 				total++;
 			else if(remainder==0&&values[1]>0&&(value+1)>=values[2]){
 				values[1]--;
 				total++;
 			}
 			else if(remainder>0&&(value+1)>=values[2])
 				total++;
 			
 			else if(remainder==2&&(value+2)>=values[2]&&values[1]>0){
 				total++;
 				values[1]--;
 			}	
 		}
 		System.out.println(total);
 	}
 
 }
",0
227,3268,"import java.io.*;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 import java.util.Locale;
 
 /**
  * @author Mikeldi Latorre (mikeldi10@gmail.com)
  */
 public class C implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 
 	public static void main(String[] args) {
 		new Thread(new C()).start();
 	}
 
 	public C() {
 		try {
 			System.setIn(new FileInputStream(""c.in""));
 			System.setOut(new PrintStream(new FileOutputStream(""c.out"")));
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 	
 	int random(int min, int max){
 		return min + (int)(Math.random() * ((max - min) + 1));
 	}
 	
 	
 	int distance(int[] x){
 		int a=0;
 		for (int i = 0; i < x.length; i++) {
 			a+=Math.abs(i-x[i]);
 		}
 		return a;
 	}
 	
 	int good(int n){
 		int[] a = new int[n];
 		for (int k=0; k<n;k++){
 		  a[k] = k;
 		}
 		for (int k=0; k<n;k++){
 		  int p = random(k,n-1);
 		  int tmp = a[k];
 		  a[k]=a[p];
 		  a[p]=tmp;
 		}
 		return distance(a);
 	}
 	
 	int bad(int n){
 		int[] a = new int[n];
 		for (int k=0; k<n;k++){
 		  a[k] = k;
 		}
 		for (int k=0; k<n;k++){
 		  int p = random(0,n-1);
 		  int tmp = a[k];
 		  a[k]=a[p];
 		  a[p]=tmp;
 		}
 		return distance(a);
 	}
 
 	public void run() {
 	 int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
         	out.println(""Case #"" + (testNumber + 1) + "": ""+algorithm());
 		}
 		out.close();
 	}
 	
 //	private String algorithm(){
 //		long avg1 = 0;
 //		long avg2 = 0;
 //		for (int i = 0; i < 1000; i++) {
 //			avg1+=good(1000);
 //			avg2+=bad(1000);
 //		}
 //		return ""\ngood:""+String.valueOf(avg1/1000)+""\nbad:""+String.valueOf(avg2/1000);
 //	}
 	
 	private String algorithm(){
 		int n = in.readInt();
 		int[] a = new int[n];
 		for (int i = 0; i < n; i++) {
 			a[i] = in.readInt();
 		}
 		return distance(a)>325500?""GOOD"":""BAD"";
 //		return String.valueOf(distance(a));
 	}
 	
 	private String format(double x){
 		return String.format(Locale.ENGLISH, ""%.7f"", x);
 	}
 
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
","import java.io.*;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 
 /**
  * @author Mikeldi Latorre (mikeldi10@gmail.com)
  */
 public class RecycledNumbers implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 
 	public static void main(String[] args) {
 		new Thread(new RecycledNumbers()).start();
 	}
 
 	public RecycledNumbers() {
 		try {
 			System.setIn(new FileInputStream(""C-small-attempt0.in""));
 			System.setOut(new PrintStream(new FileOutputStream(""C-small-attempt0.out"")));
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 
 	public void run() {
 	 int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
         	out.println(""Case #"" + (testNumber + 1) + "": ""+algorithm());
 		}
 		out.close();
 	}
 	
 	private int b;
 	
 	private int algorithm(){
 		int a = in.readInt();
 		b = in.readInt();
 		int x = (int)Math.pow(10, (""""+a).length()-1);
 		int ret = 0;
 		for (int i = a; i <= b; i++) {
 			ret += check(i,i,x);
 		}
 		return ret;
 	}
 	
 	private int check(int num, int base, int x){
 		num = num%10*x+num/10;
 		int ret = 0;
 		if(num == base){
 			return 0;
 		}
 		if((num > base)&&(num <=b)){
 			ret++;
 		}
 		ret += check(num,base,x);
 		return ret;
 	}
 
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
",1
228,19689,"
 import java.io.*;
 import java.util.*;
 
 public class Equal {
     public static final PrintStream out = System.out;
     public static final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
     public int numCases;
     
     long[] nums;
     long max;
     
     Map<Long,Subset> all = new HashMap<Long, Equal.Subset>();
     List<Subset> working = new ArrayList<Equal.Subset>();
     
     public void doCase(int caseNumber) throws Exception {
         String line = in.readLine();
         Scanner scan = new Scanner(line);
         
         int n = scan.nextInt();
         nums = new long[n];
         long sum = 0;
         for(int i = 0; i < n; i++) {
             nums[i] = scan.nextLong();
             sum += nums[i];
         }
         max = sum / 2;
         Arrays.sort(nums);
         
         all.clear();
         working.clear();
         
         for(int i = 0; i < n; i++) {
             Subset singleton = new Subset(i);
             all.put(singleton.sum,singleton);
             working.add(singleton);
         }
         
         while(!working.isEmpty()) {
             List<Subset> lastWorking = new ArrayList<Subset>(working);
             working.clear();
             for(Subset subset : lastWorking) {
                 for(Subset newSubset : subset.getNexts()) {
                     Subset alreadyFound = all.get(newSubset.sum);
                     if(alreadyFound==null) {
                         all.put(newSubset.sum,newSubset);
                         working.add(newSubset);
                     }
                     else {
                         alreadyFound.print();
                         out.println();
                         newSubset.print();
                         out.println();
                         return;
                     }
                 }
             }
         }
         
         out.println(""Impossible"");
     }
     
     public void run() throws Exception {
         numCases = Integer.parseInt(in.readLine().trim());
         for (int i = 1; i <= numCases; i++) {
             out.println(""Case #"" + i + "":"");
             doCase(i);
         }
     }
     
     public static void main(String[] args) throws Exception {
         new Equal().run();
     }
 
     class Subset {
         final long sum;
         final int lastIndex;
         final Subset prior;
         
         Subset(int index) {
             this.sum = nums[index];
             this.lastIndex = index;
             this.prior = null;
         }
         
         Subset(int index, Subset prior) {
             this.sum = prior.sum + nums[index];
             this.lastIndex = index;
             this.prior = prior;
         }
         
         void print() {
             if(this.prior==null) {
                 out.print(nums[lastIndex]);
             }
             else {
                 this.prior.print();
                 out.print("" "");
                 out.print(nums[lastIndex]);
             }
         }
         
         List<Subset> getNexts() {
             List<Subset> nexts = new ArrayList<Equal.Subset>();
             for(int i = lastIndex + 1; i < nums.length; i++) {
                 Subset next = new Subset(i,this);
                 if(next.sum > max) break;
                 nexts.add(next);
             }
             return nexts;
         }
     }
 }
","/*
 PROG: Prob1BB
 LANG: JAVA
 ID: sridhar4
 */
 
 import java.io.*;
 import java.util.*;
 
 public class Prob1BB{
 
 	public static void main(String [] args) throws IOException {
 		//long start = System.currentTimeMillis();
 		BufferedReader f = new BufferedReader(new FileReader(""Prob1BB.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""Prob1BB.out"")));
 		int T = Integer.parseInt(f.readLine());
 		for(int n = 0; n < T; n++){
 			double ans = 0;
 			String[] str = (f.readLine()).split("" "");
 			int N = Integer.parseInt(str[0]);
 			int X = Integer.parseInt(str[1]);
 			int Y = Integer.parseInt(str[2]);
 			int k = 1;
 			while(k*k*2 - k <= N)
 				k++;
 			k--;
 			int left = N - (k*k*2 - k);
 			int q = Math.abs(X) + Y - 2*k;
 			if(q < 0)
 				ans = 1;
 			else if(q > 0)
 				ans = 0;
 			else{
 				if(left == 0)
 					ans = 0;
 				else{
 					if(Y + 1 > left || (Y + 1 == left && X == 0))
 						ans = 0;
 					else{
 						double prob = 0;
 						for(int i = Y + 1; i <= left; i++){
 							double w = 0;
 							if(left - i > 2*k){
 								for(int j = 0; j <= left - 2*k; j++){
 									w += choose(2*k + j, 2*k) * Math.pow(0.5, 2*k + j);
 								}
 								//System.out.println(w);
 							}
 							else if(i > 2*k){
 								for(int j = 0; j <= left - 2*k; j++){
 									w += choose(2*k + j, 2*k) * Math.pow(0.5, 2*k + j);
 								}
 								//System.out.println(w);
 							}
 							else{
 								w = choose(left, i)* Math.pow(0.5, left);
 							}
 							prob += w;
 						}
 						ans = prob;
 						if(ans > 1)
 							ans = 1;
 					}
 				}
 			}
 			out.println(""Case #"" + (n+1) + "": "" + ans);
 		}
 		//long end = System.currentTimeMillis();
 		//System.out.println(end - start);
 		out.close();
 	}
 	
 	public static double choose(int n, int k){
 		int x = 1;
 		for(int i = k+1; i <= n; i++){
 			x *= i;
 		}
 		int y = 1;
 		for(int i = 1; i <= (n-k); i++){
 			y *= i;
 		}
 		return x/y;
 	}
 	
 
 }",0
229,20508,"package ATicTac;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class TicTac {
 	private static final int LINE = 4;
 	private static final String X = ""X"";
 	private static final String O = ""O"";
 	private static final String T = ""T"";
 	private static final String DOT = ""."";
 	private static final String DRAW = ""Draw"";
 	private static final String STUCK = ""Game has not completed"";
 	private static final String WON = "" won"";
 
 	String mWhoWon = ""hami"";
 
 	private TicTacBoard mboard;
 	List<TicTacBoard> mCases;
 
 	public TicTac(List<TicTacBoard> cases) {
 		mCases = cases;
 	}
 
 	public String[] getTicTacWinner() {
 		String[] winner = new String[mCases.size()];
 		for (int i = 0; i < mCases.size(); i++) {
 			winner[i] = findTheWInner(mCases.get(i));
 		}
 
 		return winner;
 	}
 
 	public TicTac() {
 
 		mboard = new TicTacBoard();
 
 		// String [] line1 = {""X1"", ""X2"",""X3"", ""X4""};
 		// String [] line2 = {""O1"", ""O2"",""O3"", ""O4""};
 		// String [] line3 = {""T1"", ""T2"",""T3"", ""T4""};
 		// String [] line4 = {"".1"", "".2"","".3"", "".""};
 		// mboard.addBoard(line1);
 		// mboard.addBoard(line2);
 		// mboard.addBoard(line3);
 		// mboard.addBoard(line4);
 
 		// checkHorizontal();
 		// checkVertical();
 		// checkCross();
 
 		// System.err.println(checkDraw());
 		// System.err.println(findTheWInner());
 	}
 
 	public List<TicTacBoard> readInput(StringBuilder sb) {
 		String[] lines = sb.toString().split(""\\n"");
 		List<TicTacBoard> cases = new ArrayList<TicTacBoard>();
 
 		int mNumCase = Integer.valueOf(lines[0]);
 
 		int line = 1;
 		int block = 0;
 		while (block <= mNumCase - 1) {
 			TicTacBoard tmpBoard = new TicTacBoard();
 			for (int i = 0; i < LINE; i++) {
 				// System.err.println(String.format(""%d %d %d %d"", i, line,
 				// block, i + line + block*4));
 				String[] tmp = lines[i + line + block * 4].split("""");
 				String[] temp = new String[tmp.length - 1];
 				for (int j = 0; j < temp.length; j++) {
 					temp[j] = tmp[j + 1];
 				}
 				tmpBoard.addBoard(temp);
 			}
 			cases.add(tmpBoard);
 			line++;
 			block++;
 		}
 
 		return cases;
 	}
 
 	private String findTheWInner(TicTacBoard aBoard) {
 		mboard = aBoard;
 		if (checkHorizontal()) {
 			return mWhoWon + WON;
 		}
 		if (checkVertical()) {
 			return mWhoWon + WON;
 		}
 		if (checkCross()) {
 			return mWhoWon + WON;
 		}
 
 		return checkDraw();
 	}
 
 	private boolean checkHorizontal() {
 		for (int i = 0; i < LINE; i++) {
 			String[] testLine = mboard.getBoard().get(i);
 			printLine(testLine);
 			if (isInARow(testLine)) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private boolean checkVertical() {
 		String[] testLine = new String[LINE];
 
 		for (int i = 0; i < LINE; i++) {
 			int id = 0;
 			for (int j = 0; j < LINE; j++) {
 				testLine[id++] = mboard.getBoard().get(j)[i];
 			}
 			printLine(testLine);
 			if (isInARow(testLine)) {
 				return true;
 			}
 
 		}
 		return false;
 	}
 
 	private boolean checkCross() {
 		String[] testLine1 = new String[LINE];
 
 		for (int i = 0; i < LINE; i++) {
 			testLine1[i] = mboard.getBoard().get(i)[i];
 		}
 		printLine(testLine1);
 		if (isInARow(testLine1)) {
 			return true;
 		}
 
 		// 2
 		String[] testLine2 = new String[LINE];
 		for (int i = 0; i < LINE; i++) {
 			testLine2[i] = mboard.getBoard().get(i)[LINE - 1 - i];
 		}
 		printLine(testLine2);
 		if (isInARow(testLine2)) {
 			return true;
 		}
 
 		return false;
 
 	}
 
 	/**
 	 * Use after all to detect Draww or stuc
 	 * 
 	 * @return
 	 */
 	private String checkDraw() {
 		for (int i = 0; i < LINE; i++) {
 			for (int j = 0; j < LINE; j++) {
 				if (mboard.getBoard().get(i)[j].equalsIgnoreCase(DOT)) {
 					return STUCK;
 				}
 			}
 		}
 
 		return DRAW;
 	}
 
 	private void printLine(String[] line) {
 		for (String s : line) {
 			System.out.print(s + "" "");
 		}
 		System.out.print(""\n"");
 	}
 
 	public void test() {
 		String[] test = { O, DOT, DOT, T };
 		System.err.println(isInARow(test));
 	}
 
 	private boolean isInARow(String[] testLine) {
 		String test = testLine[0];
 		if (test.equalsIgnoreCase(DOT))
 			return false;
 		for (String s : testLine) {
 			if (!(s.endsWith(test) || s.equalsIgnoreCase(T))) {
 				return false;
 			}
 		}
 		mWhoWon = test;
 		return true;
 	}
 
 	public class TicTacBoard {
 		List<String[]> mBoard = new ArrayList<String[]>();
 
 		public TicTacBoard() {
 			// createBoard();
 		}
 
 		private void createBoard() {
 			int l = 4;
 			String[] line = { ""."", ""."", ""."", ""."" };
 			mBoard.add(line);
 			mBoard.add(line);
 			mBoard.add(line);
 			mBoard.add(line);
 		}
 
 		public List<String[]> getBoard() {
 			return mBoard;
 		}
 
 		public void addBoard(String[] line) {
 			mBoard.add(line);
 		}
 	}
 
 }
","/*
  * To change this license header, choose License Headers in Project Properties.
  * To change this template file, choose Tools | Templates
  * and open the template in the editor.
  */
 
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.math.RoundingMode;
 import java.text.DecimalFormat;
 
 /**
  *
  * @author Hamza
  */
 public class GoogleCodeJam2
 {
     static double C, F, X;
     public static void main(String[] args) throws Exception {
         BufferedReader br = new BufferedReader(new FileReader(""B-small-attempt0.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""B-small-attempt0.out""));
         
         int T = Integer.parseInt(br.readLine());
         for (int i = 1; i <= T; i++)
         {
             // getting C, F and X
             initialize(br.readLine());
             
             double sum = calculateNext(2);
             //sum = Math.round(sum * 10000000) / 10000000.0;
             bw.write(""Case #""+i+"": "" + sum + ""\n"");
 			bw.flush();
         }
 		br.close();
 		bw.close();
     }
 
     private static void initialize(String line) {
             String[] vals = line.split("" "");
             
             C = Double.parseDouble(vals[0]);
             F = Double.parseDouble(vals[1]);
             X = Double.parseDouble(vals[2]);
     }
     
     private static double calculateNext(double capacity)
     {
         double sum;
         
         double win = X / capacity; // 2000 / 14
         double nextFarm = C / capacity; // 500 / 14
         
         double afterNext = X / (capacity + F); // 2000 / 18
         
         sum = 0;
         if (win > nextFarm + afterNext)
             sum += calculateNext(capacity+F) + nextFarm;
         else
             sum += win;
         
         return sum;
     }
 }
",0
230,1222,"import java.util.*;
 
 public class CandySplitting {
   public static void main(String[] args) {
     Scanner sc = new Scanner(System.in);
     int nrounds = sc.nextInt();
 
     for (int i = 0; i < nrounds; i++) {
       int nvalues = sc.nextInt();
 
       int xor = 0;
       int min = 10000000;
       int total = 0;
       for(int j = 0; j < nvalues; j++) {
         int val = sc.nextInt();
         xor ^= val;
         min = Math.min(min, val);
         total += val;
       }
 
       if (xor == 0) {
         System.out.println(""Case #"" + (i+1) + "": "" + (total - min));
       } else {
         System.out.println(""Case #"" + (i+1) + "": NO"");
       }
     }
   }
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 
 
 public class TicTacToeTomek {
 
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader br = new BufferedReader(new FileReader(""A-2013""));
 
 		String [] board = new String[4];
 		
 		int cases = Integer.parseInt(br.readLine());
 		int caseNum = 0;
 		
 		while(cases-- > 0){
 			caseNum++;
 			
 			for(int i = 0; i < 4; i++)
 				board[i] = br.readLine();
 			
 			if (caseNum != 0) {
 				br.readLine();
 			}
 			
 			int emptyCells = 0;
 			boolean xWon = false, oWon = false;
 			
 			for (int i = 0; i < board.length && !xWon && !oWon; i++) {
 				boolean temp = true;
 				char first;
 				int j;
 				
 				if (board[i].charAt(0) == 'T') {
 					first = board[i].charAt(1);
 					j = 2;
 				}
 				else {
 					if (board[i].charAt(0) == '.') {
 						emptyCells++;
 					}
 					first = board[i].charAt(0);
 					j = 1;
 				}
 				
 				for (; j < board[i].length() && !xWon && !oWon; j++) {
 					if (board[i].charAt(j) == '.') {
 						emptyCells++;
 						temp = false;
 					}
 					
 					if (temp && board[i].charAt(j) != '.' && (board[i].charAt(j) == first || board[i].charAt(j) == 'T')) {
 						
 					}
 					else if (temp){
 						temp = false;
 						
 					}
 				}
 				if (temp) {
 					switch(first){
 					case 'X':
 						xWon = true;
 						break;
 					case 'O':
 						oWon = true;
 						break;
 					}
 				}
 			}
 			
 			for (int i = 0; i < board.length && !xWon && !oWon; i++) {
 				boolean temp = true;
 				char first;
 				int j;
 				
 				if (board[0].charAt(i) == 'T') {
 					first = board[1].charAt(i);
 					j = 2;
 				}
 				else {
 					first = board[0].charAt(i);
 					j = 1;
 				}
 				
 				for (; j < board[i].length() && !xWon && !oWon; j++) {
 					if (temp && board[j].charAt(i) != '.' && (board[j].charAt(i) == first || board[j].charAt(i) == 'T')) {
 						
 					}
 					else if (temp){
 						temp = false;
 						
 					}
 				}
 				if (temp) {
 					switch(first){
 					case 'X':
 						xWon = true;
 						break;
 					case 'O':
 						oWon = true;
 						break;
 					}
 				}
 			}
 			
 			boolean temp = !xWon && !oWon;
 			
 			for (int i = 1; i < board.length && !xWon && !oWon && temp; i++) {
 				char one = board[i - 1].charAt(i - 1), two = board[i].charAt(i);
 				if (one != two && one != 'T' && two != 'T') {
 					temp = false;
 				}
 			}
 			
 			char first = board[0].charAt(0);
 			
 			if (first == 'T') {
 				first = board[1].charAt(1);
 			}
 			
 			if (temp) {
 				switch(first){
 				case 'X':
 					xWon = true;
 					break;
 				case 'O':
 					oWon = true;
 					break;
 				}
 			}
 			
 			temp = !xWon && !oWon;
 			
 			for (int i = 1; i < board.length && !xWon && !oWon && temp; i++) {
 				char one = board[i - 1].charAt(4 - i), two = board[i].charAt(4 - i - 1);
 				if (one != two && one != 'T' && two != 'T') {
 					temp = false;
 				}
 			}
 			
 			first = board[0].charAt(3);
 			
 			if (first == 'T') {
 				first = board[1].charAt(2);
 			}
 			
 			if (temp) {
 				switch(first){
 				case 'X':
 					xWon = true;
 					break;
 				case 'O':
 					oWon = true;
 					break;
 				}
 			}
 			
 			System.out.print(""Case #"" + caseNum +"": "");
 			
 			if (xWon) {
 				System.out.println(""X won"");
 			}
 			else if(oWon){
 				System.out.println(""O won"");
 			}
 			else if(emptyCells != 0){
 				System.out.println(""Game has not completed"");
 			}
 			else {
 				System.out.println(""Draw"");
 			}
 		}
 
 	}
 
 }
",0
231,13378,"import java.io.*;
 
 public class as
 {	static int n;
 	static
 	{	n=0;
 	}
 	
 	public static int count(String ms,String ns[],int cnt)
 	{	for(int i=0;i<n;i++)
 		{	if(ms.equals(ns[i])==true)
 			{	return (0+cnt);
 			}
 			
 			
 		}
 		ns[n]=ms;
 		n++;
 		int index=ms.lastIndexOf(""/"");
 		if(index>0)
 		{	String str=ms.substring(0,index);
 			
 			return count(str,ns,cnt+1);
 		}
 		else
 		{	return cnt+1;
 		}
 	}
 
 	public static void main(String agrs[]) throws IOException
 	{	File inFile = null;
 		File outFile = null;
 		FileInputStream inFis = null;
 		FileOutputStream outFos = null;
 		BufferedInputStream inBis = null;
 		BufferedOutputStream outBos = null;
 		DataInputStream inDis = null;
 		DataOutputStream outDos = null;
 		inFile = new File(""C:\\Users\\akhil\\akhil\\codejam_1\\as.in"");
 		outFile = new File(""C:\\Users\\akhil\\akhil\\codejam_1\\asout.out"");
 		inFis = new FileInputStream(inFile);
 		outFos = new FileOutputStream(outFile);
 		inBis = new BufferedInputStream(inFis);
 		outBos = new BufferedOutputStream(outFos);
 		inDis = new DataInputStream(inBis);
 		outDos = new DataOutputStream(outBos);
 		int t = Integer.parseInt(inDis.readLine());
 		System.out.println(t);
 		//Long c[]=new Long[50];
 		int i=1,m=0;
 		int cnt=0;
 		String[] ns=new String[100];
 		String[] ms=new String[10];
 		int mkdcnt=0;
 		while((inDis.available() != 0) && i<=t)
 		{	String line = inDis.readLine();
 			String[] nums = line.split("" "");
 			n=Integer.parseInt(nums[0]);
 			m=Integer.parseInt(nums[1]);
 			System.out.println(n+"" ""+m);
 			for(cnt=0;cnt<n;cnt++)
 			{	ns[cnt]= inDis.readLine();
 				System.out.println(ns[cnt]);
 			}
 			//ns[n]=""/"";
 			//n++;
 			for(cnt=0;cnt<m;cnt++)
 			{	ms[cnt]= inDis.readLine();
 				System.out.println(ms[cnt]);
 			}
 			mkdcnt=0;
 			for(cnt=0;cnt<m;cnt++)
 			{	mkdcnt+=count(ms[cnt],ns,0);
 				//System.out.println(mkdcnt);
 				//ns[n]=ms[cnt];
 				//n++;
 			}
 			for(cnt=0;cnt<n;cnt++)
 			{	//ns[cnt]= inDis.readLine();
 				System.out.println(ns[cnt]);
 			}
 			System.out.println(mkdcnt);
 			outDos.writeBytes(""Case #"" + i + "": ""+mkdcnt);
 			outDos.flush();
 			outDos.writeBytes(""\r\n"");
 			outDos.flush();
 			//outDos.flush();
 			i++;
 		}
 		outDos.close();
 		inDis.close();
 	}
 }","import java.io.*;
 
 public class al
 {	public static Long div(Long n)
 	{       	Long sum=new Long(1);
 		Double d;
 		for(int i=1;i<n;i++)
 		{	d=Math.pow(2,i);
 			sum=sum+d.longValue();
 		}
 		return sum;
 	}
 	
 	public static void main(String agrs[]) throws IOException
 	{	File inFile = null;
 		File outFile = null;
 		FileInputStream inFis = null;
 		FileOutputStream outFos = null;
 		BufferedInputStream inBis = null;
 		BufferedOutputStream outBos = null;
 		DataInputStream inDis = null;
 		DataOutputStream outDos = null;
 		inFile = new File(""C:\\Users\\akhil\\akhil\\codejam\\inputl.in"");
 		outFile = new File(""C:\\Users\\akhil\\akhil\\codejam\\outputa.out"");
 		inFis = new FileInputStream(inFile);
 		outFos = new FileOutputStream(outFile);
 		inBis = new BufferedInputStream(inFis);
 		outBos = new BufferedOutputStream(outFos);
 		inDis = new DataInputStream(inBis);
 		outDos = new DataOutputStream(outBos);
 		int t = Integer.parseInt(inDis.readLine());
 		Long n,k,d;
 		System.out.println(t);
 		int i=1;
 		while((inDis.available() != 0) && i<=t)
 		{	String line = inDis.readLine();
 			String[] nums = line.split("" "");
 			
 			n=Long.parseLong(nums[0]);
 			k=Long.parseLong(nums[1]);
 			d=al.div(n);
 			System.out.print(n+""\t""+k+""\t""+d);
 			System.out.println();
 			outDos.writeBytes(""Case #"" + i + "": "");
 			outDos.flush();
 			if(k<d)
 			{	outDos.writeBytes(""OFF\n"");
 				outDos.flush();
 			}
 			else if(k.compareTo(d)==0)
 			{	outDos.writeBytes(""ON\n"");
 				outDos.flush();
 				outDos.flush();
 			}
 			else if(k>d)
 			{	while(k>=d)
 				{	k=k-d;
 					k--;
 					//cnt++;
 				}
 				if(k+1==0)
 				{	outDos.writeBytes(""ON\n"");
 					outDos.flush();
 				}
 				else
 				{	outDos.writeBytes(""OFF\n"");
 					outDos.flush();
 				}
 			}
 			outDos.writeBytes(""\n"");
 			outDos.flush();
 			i++;
 		}	
 		outDos.close();
 		inDis.close();
 		/*FileReader fr=new FileReader(""C:\\Users\\akhil\\akhil\\codejam\\input.in"");
 		BufferedReader br=new BufferedReader(fr);
 		//RandomAccessFile raf=new RandomAccessFile(""C:\\Users\\akhil\\akhil\\codejam\\input.in"",""rw"");
 		int t;
 		int n;
 		long k;
 		t=br.read();
 		System.out.print(t+""\t"");
 		for(int i=1;i<=t;i++)
 		{	n=br.read();
 			System.out.print(n+""\t"");
 			k=br.read();
 			if(s.compareTo(13)==1 || s.compareTo(10)==1)
 			{	System.out.println(k);
 			}
 			else
 			{	System.out.println();
 			}
 		}
 		br.close();
 		fr.close();*/
 	}
 }",1
232,7270,"/*
  * Copyright (c) 2008, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
 
 public class TestA {
     public static void main(String[] args) {
 
         MyReaderx reader = new MyReaderx(""A-large.in"");
         int t = reader.readInt();
 
         for (int i = 0; i < t; i ++) {
             int n = reader.readInt();
 
             int [] aarr = new int[1024];
             int [] barr = new int[1024];
 
             for (int j = 0; j < n; j ++ ) {
                 aarr[j] = reader.readInt();
                 barr[j] = reader.readInt();
             }
 
             // try checking intersection for each wire
             int count = 0;
             for (int j = 0; j < n; j ++ ) {
                 for (int l = 0; l < j ; l ++) {
                     // checking j and l intersects?
                     int adist = aarr[j] - aarr[l];
                     int bdist = barr[j] - barr[l];
                     if ((adist > 0 && bdist < 0) || adist < 0 && bdist > 0) {
                         count ++;
                     }
                 }
             }
             System.out.println(""Case #"" + (i + 1) + "": "" + count);
         }
 
     }
 }
 
 
 class MyReaderxy {
     InputStream in;
 
     public MyReaderxy(String fileName) {
         try {
             this.in = new FileInputStream(""resources/"" + fileName);
 
         } catch (FileNotFoundException e) {
 
         }
     }
     public MyReaderxy(InputStream in) {
         this.in = in;
     }
 
     public String readString() {
         StringBuffer str = new StringBuffer();
         boolean start = true;
         try {
             while (true) {
                 int r = in.read();
                 if (r == -1) {
                     break;
                 }
                 char c = (char)r;
                 if (c == ' ' || c == '\n' || c== '\r') {
                     if (!start) {
                         break;
                     }
                 } else {
                     start = false;
                     str.append(c);
                 }
             }
         } catch (Exception e) {
         }
         return str.toString();
     }
 
     public int readInt() {
         String str = readString();
         return Integer.parseInt(str);
     }
     public long readLong() {
         String str = readString();
         return Long.parseLong(str);
     }
     public float readFloat() {
         String str = readString();
         return Float.parseFloat(str);
     }
 }
","import java.util.Scanner;
 
 public class ProblemA {
 	public static void main(String[] args) {
 		char[][] sym = new char[4][4];
 		Scanner sc = new Scanner(System.in);
 		int c = sc.nextInt();
 
 		for (int n = 0; n < c; n++) {
 			boolean allfilled = true;
 			for (int i = 0; i < 4; i++) {
 				String line = sc.next();
 				if (line.equals("""")) {
 					continue;
 				}
 				for (int j = 0; j < 4; j++) {
 					sym[i][j] = line.charAt(j);
 					if (sym[i][j] == '.') {
 						allfilled = false;
 					}
 				}
 			}
 
 //			System.out.println();
 //			for (int i = 0; i < 4; i++) {
 //				for (int j = 0; j < 4; j++) {
 //					System.out.print(sym[i][j]);
 //				}
 //				System.out.println();
 //			}
 
 			char won = '.';
 			// raw check
 			boolean found = false;
 
 			for (int i = 0; i < 4 && !found; i++) {
 				boolean lfound = true;
 				char d = sym[i][0];
 				for (int j = 0; j < 4; j++) {
 					if (sym[i][j] == 'O' || sym[i][j] == 'X') {
 						d = sym[i][j];
 						break;
 					}
 				}
 				if (d == '.' || d == 'T') {
 					continue;
 				}
 				for (int j = 0; j < 4; j++) {
 					if (sym[i][j] != d && sym[i][j] != 'T') {
 						lfound = false;
 						break;
 					}
 				}
 				if (lfound) {
 					found = true;
 					won = d;
 					break;
 				}
 			}
 			// col check
 			for (int i = 0; i < 4 && !found; i++) {
 				boolean lfound = true;
 				char d = sym[0][i];
 				for (int j = 0; j < 4; j++) {
 					if (sym[j][i] == 'O' || sym[j][i] == 'X') {
 						d = sym[j][i];
 						break;
 					}
 				}
 				if (d == '.' || d == 'T') {
 					continue;
 				}
 				for (int j = 0; j < 4; j++) {
 					if (sym[j][i] != d && sym[j][i] != 'T') {
 						lfound = false;
 						break;
 					}
 				}
 				if (lfound) {
 					found = true;
 					won = d;
 					break;
 				}
 			}
 
 			if (!found) {
 				// backslash check;
 				boolean lfound = true;
 				char d = sym[0][0];
 
 				for (int i = 0; i < 4 && !found; i++) {
 					if (sym[i][i] == 'O' || sym[i][i] == 'X') {
 						d = sym[i][i];
 						break;
 					}
 				}
 
 				if (d != '.' && d != 'T') {
 					for (int i = 0; i < 4 && !found; i++) {
 						if (sym[i][i] != d && sym[i][i] != 'T') {
 							lfound = false;
 							break;
 						}
 					}
 				} else {
 					lfound = false;
 				}
 				if (lfound) {
 					found = true;
 					won = d;
 				}
 			}
 
 			// slash check;
 			if (!found) {
 				boolean lfound = true;
 				char d = sym[0][3];
 
 				for (int i = 0; i < 4 && !found; i++) {
 					if (sym[i][3 - i] == 'O' || sym[i][3 - i] == 'X') {
 						d = sym[i][3 - i];
 						break;
 					}
 				}
 
 				if (d != '.' && d != 'T') {
 					for (int i = 0; i < 4 && !found; i++) {
 						if (sym[i][3 - i] != d && sym[i][3 - i] != 'T') {
 							lfound = false;
 							break;
 						}
 					}
 				} else {
 					lfound = false;
 				}
 				if (lfound) {
 					found = true;
 					won = d;
 				}
 			}
 			if (found) {
 				System.out.println(""Case #"" + (n + 1) + "": "" + won + "" won"");
 			} else if (allfilled) {
 				System.out.println(""Case #"" + (n + 1) + "": Draw"");
 			} else {
 				System.out.println(""Case #"" + (n + 1)
 						+ "": Game has not completed"");
 			}
 		}
 	}
 }
",1
233,18725,"import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 
 public class DeceitfulWar {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(""D-small-attempt0.in"")));
 		int t = Integer.parseInt(reader.readLine());
 		for (int cse = 1; cse <= t; cse++) {
 			int n = Integer.parseInt(reader.readLine());
 			double[] naomi = new double[n], ken = new double[n];
 			String[] split = reader.readLine().split("" "");
 			for (int i = 0; i < n; i++) naomi[i] = Double.parseDouble(split[i]);
 			split = reader.readLine().split("" "");
 			for (int i = 0; i < n; i++) ken[i] = Double.parseDouble(split[i]);
 			Arrays.sort(naomi);
 			Arrays.sort(ken);
 			System.out.println(""Case #"" + cse + "": "" + deceitfulWar(naomi, ken) + "" "" + war(naomi, ken));
 		}
 	}
 
 	private static int war(double[] n, double[] k) {
 		ArrayList<Double> naomi = new ArrayList<Double>();
 		for (double weight : n) naomi.add(weight);
 		ArrayList<Double> ken = new ArrayList<Double>();
 		for (double weight : k) ken.add(weight);
 		
 		int wins = 0;
 		while (!ken.isEmpty()) {
 			double nWeight = naomi.remove(0);
 			double kWeight = moveKen(ken, nWeight);
 			if (kWeight == -1) {
 				ken.remove(0);
 				wins++;
 			}
 		}
 		return wins;
 	}
 
 	private static double moveKen(ArrayList<Double> ken, double nWeight) {
 		double kWeight = -1;
 		for (int i = 0; i < ken.size(); i++) {
 			if (ken.get(i) > nWeight) {
 				kWeight = ken.remove(i);
 				break;
 			}
 		}
 		return kWeight;
 	}
 
 	private static int deceitfulWar(double[] n, double[] k) {
 		ArrayList<Double> naomi = new ArrayList<Double>();
 		for (double weight : n) naomi.add(weight);
 		ArrayList<Double> ken = new ArrayList<Double>();
 		for (double weight : k) ken.add(weight);
 		
 		int wins = 0;
 		
 		while (!ken.isEmpty()) {
 			double nActualWeight;
 			double nToldWeight;
 			if (ken.size() == 1)
 				nActualWeight = nToldWeight = naomi.remove(0);
 			else {
 				nActualWeight = -1;
 				double kenLowest = ken.get(0);
 				for (int i = 0; i < naomi.size(); i++) {
 					if (naomi.get(i) > kenLowest) {
 						nActualWeight = naomi.remove(i);
 						break;
 					}
 				}
 				if (nActualWeight == -1)
 					nActualWeight = nToldWeight = naomi.remove(0);
 				else {
 					nToldWeight = ken.get(ken.size() - 1) + 1e-6;
 				}
 			}
 			double kWeight = moveKen(ken, nToldWeight);
 			if (kWeight == -1) {
 				ken.remove(0);
 				wins++;
 			}
 		}
 		
 		return wins;
 	}
 
 }
","import java.math.*;
 import java.util.*;
 import java.io.*;
 import static java.lang.Math.*;
 import static java.util.Arrays.*;
 import static java.util.Collections.*;
 
 public class B {
 	public static void main(String[] args) throws Exception {
 		System.setIn(new FileInputStream(""B-small-attempt0.in""));
 		System.setOut(new PrintStream(""B.out""));
 		in = new BufferedReader(new InputStreamReader(System.in));
 		int CASES = nextInt();
 		for (int caseNo = 1; caseNo <= CASES; caseNo++) {
 			int R = nextInt();
 			int C = nextInt();
 			int D = nextInt();
 			int[][] g = new int[R][C];
 			for (int i = 0; i < g.length; i++) {
 				char[] cc = next().toCharArray();
 				for (int j = 0; j < g[i].length; j++) {
 					g[i][j] = cc[j] - '0' + D;
 				}
 			}
 			int ans = 0;
 			for (int size = 3; size <= min(R, C); size++) {
 				for (int bi = 0; bi + size - 1 < R; bi++) {
 					for (int bj = 0; bj + size - 1 < C; bj++) {
 						
 						int ei = bi + size - 1, ej = bj + size - 1;
 						int begi = bi * 2, begj = bj * 2;
 						int endi = ei * 2, endj = ej * 2;
 						int ceni = (begi + endi) / 2, cenj = (begj + endj) / 2;
 						int sumi = 0, sumj = 0;
 						
 						for (int i = bi; i <= ei; i++) {
 							for (int j = bj; j <= ej; j++) {
 								if (i == bi && j == bj)
 									continue;
 								if (i == bi && j == ej)
 									continue;
 								if (i == ei && j == bj)
 									continue;
 								if (i == ei && j == ej)
 									continue;
 								sumi += g[i][j] * (ceni - i * 2);
 								sumj += g[i][j] * (cenj - j * 2);
 							}
 						}
 						
 						if (sumi == 0 && sumj == 0) {
 							ans = size;
 						}
 						
 					}
 				}
 			}
 			
 			System.out.print(""Case #"" + caseNo + "": "" + (ans >= 3 ? ans : ""IMPOSSIBLE""));
 			System.out.println();
 		}
 	}
 
 	static BufferedReader in;
 	static StringTokenizer st = new StringTokenizer("""");
 
 	static String next() throws Exception {
 		while (!st.hasMoreTokens()) {
 			String s = in.readLine();
 			if (s == null)
 				return null;
 			st = new StringTokenizer(s);
 		}
 		return st.nextToken();
 	}
 
 	static int nextInt() throws Exception {
 		return Integer.parseInt(next());
 	}
 
 	static long nextLong() throws Exception {
 		return Long.parseLong(next());
 	}
 
 	static double nextDouble() throws Exception {
 		return Double.parseDouble(next());
 	}
 
 	static void DBG(Object... objects) {
 		System.err.println(deepToString(objects));
 	}
 
 	static int RAND(int from, int to) {
 		return (int) (random() * (to - from + 1)) + from;
 	}
 
 }
",0
234,3602,"package theKillerWord.codejam;
 
 import java.util.*;
 
 public class Case {
 	int n;
 	int m;
 	String[] d;
 	String[] l;
 	public Case(Scanner s){
 		n = s.nextInt();
 		m = s.nextInt();
 		d = new String[n];
 		l = new String[m];
 		for (int i=0; i<n; i++){
 			d[i] = s.next();
 		}
 		for (int i=0; i<m; i++){
 			l[i] = s.next();
 		}
 	}
 	
 	public String solve(){
 		String result = """";
 		for(int i=0; i<m; i++){
 			int indexOfMost = 0;
 			int mostPoints = 0;
 			for (int j=0; j<n; j++){
 				int points = 0;
 				int len = d[j].length();
 				String word = d[j];
 
 				List<String> possibles = new ArrayList<String>(n);
 				for(int k=0; k<d.length; k++){
 					if(d[k].length() == len){
 						possibles.add(d[k]);
 					}
 				}
 				List<Character> chars = createChars(i, possibles);
 				List<Character> removed = new ArrayList<Character>();
 				while(!chars.isEmpty() && !word.isEmpty()){
 					if(possibles.size()==1)
 						break;
 					Character c = chars.get(0);
 					String temp = word.replace(c.toString(), """"); 
 					if (temp.equals(word)){
 						points++;
 						possibles = removePossibles(possibles, c);
 						chars = createChars(i, possibles);
 						chars = removeChars(chars, removed);
 					}
 					else{
 						word = temp;
 						removed.add(c);
 						possibles = clarifyPossibles(possibles, c);
 						chars = createChars(i, possibles);
 						chars = removeChars(chars, removed);
 					}
 						
 				}
 				if(points>mostPoints){
 					mostPoints = points;
 					indexOfMost = j;
 				}				
 			}
 			result += d[indexOfMost] + "" "";
 		}
 		return result;
 	}
 
 	private List<String> clarifyPossibles(List<String> possibles, Character c) {
 		for(int i=0; i<possibles.size(); i++){
 			if(!possibles.get(i).contains(c.toString())){
 				possibles.remove(i);
 			}
 		}
 		return possibles;
 	}
 
 	private List<Character> removeChars(List<Character> chars, List<Character> removed) {
 		for(int i=0; i<chars.size(); i++){
 			if (removed.contains(chars.get(i)))
 					chars.remove(i);
 		}
 		return chars;
 	}
 
 	public List<Character> createChars(int i, List<String> possibles){
 		List<Character> chars = new ArrayList<Character>();
 		for (int j=0; j<l[i].length(); j++){
 			for(int k=0; k<possibles.size(); k++){
 				if(possibles.get(k).contains(String.valueOf(l[i].charAt(j)))){
 					chars.add(l[i].charAt(j));
 					break;
 				}
 			}
 		}
 		return chars;
 	}
 	
 	public List<String> removePossibles(List<String> possibles, Character c){
 		for(int i=0; i<possibles.size(); i++){
 			if(possibles.get(i).contains(c.toString())){
 				possibles.remove(i);
 			}
 		}
 		return possibles;
 	}
 
 }
","package theKillerWord.codejam;
 
 import java.util.*;
 
 public class Case {
 	int n;
 	int m;
 	String[] d;
 	String[] l;
 	public Case(Scanner s){
 		n = s.nextInt();
 		m = s.nextInt();
 		d = new String[n];
 		l = new String[m];
 		for (int i=0; i<n; i++){
 			d[i] = s.next();
 		}
 		for (int i=0; i<m; i++){
 			l[i] = s.next();
 		}
 	}
 	
 	public String solve(){
 		String result = """";
 		for(int i=0; i<m; i++){
 			int indexOfMost = 0;
 			int mostPoints = 0;
 			for (int j=0; j<n; j++){
 				int points = 0;
 				int len = d[j].length();
 				String word = d[j];
 
 				List<String> possibles = new ArrayList<String>(n);
 				for(int k=0; k<d.length; k++){
 					if(d[k].length() == len){
 						possibles.add(d[k]);
 					}
 				}
 				List<Character> chars = createChars(i, possibles);
 				List<Character> removed = new ArrayList<Character>();
 				while(!chars.isEmpty() && !word.isEmpty()){
 					if(possibles.size()==1)
 						break;
 					Character c = chars.get(0);
 					String temp = word.replace(c.toString(), """"); 
 					if (temp.equals(word)){
 						points++;
 						possibles = removePossibles(possibles, c);
 						chars = createChars(i, possibles);
 						chars = removeChars(chars, removed);
 					}
 					else{
 						word = temp;
 						removed.add(c);
 						possibles = clarifyPossibles(possibles, c);
 						chars = createChars(i, possibles);
 						chars = removeChars(chars, removed);
 					}
 						
 				}
 				if(points>mostPoints){
 					mostPoints = points;
 					indexOfMost = j;
 				}				
 			}
 			result += d[indexOfMost] + "" "";
 		}
 		return result;
 	}
 
 	private List<String> clarifyPossibles(List<String> possibles, Character c) {
 		for(int i=0; i<possibles.size(); i++){
 			if(!possibles.get(i).contains(c.toString())){
 				possibles.remove(i);
 			}
 		}
 		return possibles;
 	}
 
 	private List<Character> removeChars(List<Character> chars, List<Character> removed) {
 		for(int i=0; i<chars.size(); i++){
 			if (removed.contains(chars.get(i)))
 					chars.remove(i);
 		}
 		return chars;
 	}
 
 	public List<Character> createChars(int i, List<String> possibles){
 		List<Character> chars = new ArrayList<Character>();
 		for (int j=0; j<l[i].length(); j++){
 			for(int k=0; k<possibles.size(); k++){
 				if(possibles.get(k).contains(String.valueOf(l[i].charAt(j)))){
 					chars.add(l[i].charAt(j));
 					break;
 				}
 			}
 		}
 		return chars;
 	}
 	
 	public List<String> removePossibles(List<String> possibles, Character c){
 		for(int i=0; i<possibles.size(); i++){
 			if(possibles.get(i).contains(c.toString())){
 				possibles.remove(i);
 			}
 		}
 		return possibles;
 	}
 
 }
",1
235,9236,"import java.util.Scanner;
 import java.io.IOException;
 import java.util.Arrays;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.io.FileInputStream;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""input.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""output.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		Scanner in = new Scanner(inputStream);
 		PrintWriter out = new PrintWriter(outputStream);
 		TaskD solver = new TaskD();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class TaskD {
     public void solve(int testNumber, Scanner in, PrintWriter out) {
         int n = in.nextInt();
         double[] naomis = IOUtils.readDoubleArray(in, n);
         double[] kens = IOUtils.readDoubleArray(in, n);
 
         out.printf(""Case #%d: %d %d\n"", testNumber, deceitfulWar(naomis, kens), war(naomis, kens));
     }
 
     private int war(double[] naomis, double[] kens) {
         boolean[] chosen = new boolean[kens.length];
         Arrays.fill(chosen, false);
         int score = 0;
         for (double naomi : naomis) {
             int which = -1;
             for (int i = 0; i < kens.length; ++i) {
                 if (!chosen[i] && kens[i] > naomi && (which == -1 || kens[i] < kens[which])) {
                     which = i;
                 }
             }
             if (which != -1) {
                 chosen[which] = true;
             } else {
                 ++score;
 
                 for (int i = 0; i < kens.length; ++i) {
                     if (!chosen[i] && (which == -1 || kens[i] < kens[which])) {
                         which = i;
                     }
                 }
                 chosen[which] = true;
             }
         }
         return score;
     }
 
     private int deceitfulWar(double[] naomis, double[] kens) {
         Arrays.sort(naomis);
         boolean[] chosen = new boolean[kens.length];
         Arrays.fill(chosen, false);
         int score = 0;
         for (double naomi : naomis) {
             int which = -1;
             for (int i = 0; i < kens.length; ++i) {
                 if (!chosen[i] && (which == -1 || kens[i] < kens[which])) {
                     which = i;
                 }
             }
             if (kens[which] < naomi) {
                 ++score;
                 chosen[which] = true;
             } else {
                 which = -1;
                 for (int i = 0; i < kens.length; ++i) {
                     if (!chosen[i] && (which == -1 || kens[i] > kens[which])) {
                         which = i;
                     }
                 }
                 chosen[which] = true;
             }
         }
 //        0.389 0.907 0.832 0.959 0.557 0.300 0.899
 //        0.728 0.271 0.520 0.700 0.521 0.341 0.458
         return score;
     }
 }
 
 class IOUtils {
 
     public static double[] readDoubleArray(Scanner in, int size) {
         double[] array = new double[size];
         for (int i = 0; i < size; i++) {
             array[i] = Double.parseDouble(in.next());
         }
         return array;
     }
 }
 
","import java.util.Scanner;
 import java.io.IOException;
 import java.util.Arrays;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.io.FileInputStream;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""input.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""output.txt"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		Scanner in = new Scanner(inputStream);
 		PrintWriter out = new PrintWriter(outputStream);
 		TaskD solver = new TaskD();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class TaskD {
     public void solve(int testNumber, Scanner in, PrintWriter out) {
         int n = in.nextInt();
         double[] naomis = IOUtils.readDoubleArray(in, n);
         double[] kens = IOUtils.readDoubleArray(in, n);
 
         out.printf(""Case #%d: %d %d\n"", testNumber, deceitfulWar(naomis, kens), war(naomis, kens));
     }
 
     private int war(double[] naomis, double[] kens) {
         boolean[] chosen = new boolean[kens.length];
         Arrays.fill(chosen, false);
         int score = 0;
         for (double naomi : naomis) {
             int which = -1;
             for (int i = 0; i < kens.length; ++i) {
                 if (!chosen[i] && kens[i] > naomi && (which == -1 || kens[i] < kens[which])) {
                     which = i;
                 }
             }
             if (which != -1) {
                 chosen[which] = true;
             } else {
                 ++score;
 
                 for (int i = 0; i < kens.length; ++i) {
                     if (!chosen[i] && (which == -1 || kens[i] < kens[which])) {
                         which = i;
                     }
                 }
                 chosen[which] = true;
             }
         }
         return score;
     }
 
     private int deceitfulWar(double[] naomis, double[] kens) {
         Arrays.sort(naomis);
         boolean[] chosen = new boolean[kens.length];
         Arrays.fill(chosen, false);
         int score = 0;
         for (double naomi : naomis) {
             int which = -1;
             for (int i = 0; i < kens.length; ++i) {
                 if (!chosen[i] && (which == -1 || kens[i] < kens[which])) {
                     which = i;
                 }
             }
             if (kens[which] < naomi) {
                 ++score;
                 chosen[which] = true;
             } else {
                 which = -1;
                 for (int i = 0; i < kens.length; ++i) {
                     if (!chosen[i] && (which == -1 || kens[i] > kens[which])) {
                         which = i;
                     }
                 }
                 chosen[which] = true;
             }
         }
 //        0.389 0.907 0.832 0.959 0.557 0.300 0.899
 //        0.728 0.271 0.520 0.700 0.521 0.341 0.458
         return score;
     }
 }
 
 class IOUtils {
 
     public static double[] readDoubleArray(Scanner in, int size) {
         double[] array = new double[size];
         for (int i = 0; i < size; i++) {
             array[i] = Double.parseDouble(in.next());
         }
         return array;
     }
 }
 
",1
236,6530,"package world2011.round1a;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.util.ArrayList;
 
 public class FreecellStatistics {
 
     // INPUT AND OUTPUT FILES
     public static final String FILE_IN_SMALL = ""input/world2011/round1a/A-small-attempt2.in"";
     public static final String FILE_IN_LARGE = ""input/world2011/round1a/A-large.in"";
     public static final String FILE_OUT = ""output.txt"";
     public static String fileIN = """";
     public static String fileOUT = """";
 
     // TEST DATA
     public static ArrayList<Integer> segmentBlue = new ArrayList<Integer>();
     public static ArrayList<Integer> segmentRed = new ArrayList<Integer>();
     public static String[] allSegments = null;
 
     public static void main(String[] args) {
         if (args.length == 0) {
             fileIN = FILE_IN_LARGE;
             fileOUT = fileIN.replace(""input/"", ""output/"").replace("".in"", "".out"");
         }
         else {
             fileIN = args[0];
             fileOUT = ""output.txt"";
         }
         BufferedReader dis = null;
         Writer out = null;
         try {
             dis = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileIN))));
             out = new OutputStreamWriter(new FileOutputStream(fileOUT, false));
             int totalCases = Integer.valueOf(dis.readLine());
             for (int i = 0; i < totalCases; i++) {
                 String line[] = dis.readLine().split("" "");
                 long n = Long.valueOf(line[0]);
                 int pd = Integer.valueOf(line[1]);
                 int pg = Integer.valueOf(line[2]);
 
                 String possibility = ""Broken"";
                 for (int x = 1; x <= n && x <= 100; x++) {
                     if ((x * pd) % 100 == 0) {
                         possibility = ""Possible"";
                         break;
                     }
                 }
 
                 if (pg == 100 && pd != 100) {
                     possibility = ""Broken"";
                 }
 
                 if (pg == 0 && pd != 0) {
                     possibility = ""Broken"";
                 }
 
                 String result = ""Case #"" + (i + 1) + "": "" + possibility + ""\n"";
                 System.out.print(result);
                 out.write(result);
             }
             dis.close();
             out.close();
         }
         catch (FileNotFoundException e) {
             System.err.println(""\nERROR: Input file not found!\nUsage: java app_name input_file\n"");
         }
         catch (IOException e) {
             System.err.println(""IO exception!"");
         }
     }
 }
","package com.gcj.y2014;
 
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class CookieClicker {
     private static final String INFILE = ""in/CookieClicker/B-small-attempt0.in"";
 
     private static final String OUTFILE = ""out/CookieClicker/B-small-attempt0.out"";
 
     public static void main(String[] args) throws Exception {
         String result = """";
 
         try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTFILE))) {
             try (Scanner scanner = new Scanner(new FileInputStream(INFILE))) {
                 scanner.useLocale(Locale.ENGLISH);
                 scanner.useLocale(Locale.ENGLISH);
 
                 int T = scanner.nextInt();
                 scanner.nextLine();
 
                 for (int p = 1; p <= T; ++p) {
 
                     double C = scanner.nextDouble();
                     double F = scanner.nextDouble();
                     double X = scanner.nextDouble();
 
                     double rate = 2.0;
                     double spent = 0.0;
 
                     while (true) {
 
                         double tc = C / rate;
                         double tx = X / rate;
                         double tn = tc + (X / (rate + F));
 
                         if (tx <= tn) {
                             spent += tx;
                             result = String.format(Locale.ENGLISH, ""%.7f"", spent);
                             break;
                         }
 
                         spent += tc;
                         rate += F;
 
                     }
 
                     writer.write(""Case #"" + p + "": "" + result);
 
                     if (p < T) {
                         writer.newLine();
                     }
                 }
             }
         }
     }
 }
",0
237,18450,"/*
 choochootrain
 Google Code Jam 2012
 */
 import java.io.*;
 import java.util.*;
 
 class ProblemA 
 {
   public static void main (String [] args) throws IOException 
   {
     String filename = ""A-small-attempt0"";  
     String[][] map = {
       {""a"",""y""}, 
       {""b"",""h""},
       {""c"",""e""},
       {""d"",""s""},
       {""e"",""o""},
       {""f"",""c""},
       {""g"",""v""},
       {""h"",""x""},
       {""i"",""d""},
       {""j"",""u""},
       {""k"",""i""},
       {""l"",""g""},
       {""m"",""l""},
       {""n"",""b""},
       {""o"",""k""},
       {""p"",""r""},
       {""q"",""z""},
       {""r"",""t""},
       {""s"",""n""},
       {""t"",""w""},
       {""u"",""j""},
       {""v"",""p""},
       {""w"",""f""},
       {""x"",""m""},
       {""y"",""a""},
       {""z"",""q""}, 
     };
 
     BufferedReader f = new BufferedReader(new FileReader(filename + "".in""));
     PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(filename + "".out"")));
     int numberOfTests = Integer.parseInt(f.readLine());
     for(int n = 1; n <= numberOfTests; n++)
     {
       String line = f.readLine();
       String translated = """";
 
       for(char c : line.toCharArray()) {
         if (c == ' ')
           translated = translated + ' ';
         else
           translated = translated + map[c - 97][1];
       }
       
       String solution = translated;
       out.println(""Case #"" + n + "": "" + solution);
     }
     out.close();
     System.exit(0);
   }
 }
","package Predkolo;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 
 import java.util.Scanner;
 
 
 
 public class PalindromSq 
 {
 	public static void main(String[] args) throws FileNotFoundException 
 	{	
 		Scanner sc = new Scanner(new File (""C-small-attempt1.in"" ));
 		//Scanner sc = new Scanner(System.in);
 		PrintWriter wr =  new PrintWriter(new File (""Palindrom.out""));
 		//PrintWriter wr =  new PrintWriter(System.out);
 		
 		int num = sc.nextInt();
 		
 		for (int i = 0; i < num; i++)
 		{
 			char [] polindrom = makePolindrom(Integer.toString(sc.nextInt()).toCharArray());
 			int goal = sc.nextInt();				
 			
 			int count = 0;
 			
 			while (Integer.parseInt(String.valueOf(polindrom)) <= goal)
 			{
 				
 				double sq = Math.sqrt(Integer.parseInt(String.valueOf(polindrom)));
 				//System.out.println(Integer.parseInt(String.valueOf(polindrom)));
 				//System.out.println(sq);								
 				if (sq - (int)sq == 0 && isPolindrom(Integer.toString((int)sq).toCharArray()))					
 					count ++;
 				polindrom = add(polindrom);
 				
 			}
 			wr.printf(""Case #%d: %d\n"", i+1, count);
 		}
 		wr.close();
 		System.out.println(""finish"");
 		
 	}
 	
 		
 	public static char [] makePolindrom (char [] pol)
 	{
 		for (int i = 0; i < pol.length/2; i++)
 			
 			if (pol[i] != pol[pol.length - i - 1])
 			{
 				int one = pol[i];
 				int two = pol[pol.length - i - 1];
 				pol[pol.length - i - 1] = pol[i];			
 				if (one < two)
 					pol = add(pol);
 			}
 		return pol;		
 	}
 	
 	public static char [] add (char [] pol)
 	{
 		int carry = 1;
 		int iStart = pol.length % 2 == 0 ? (pol.length)/2 - 1 : (pol.length)/2;
 		for (int i = iStart; i >= 0; i--)
 		{
 			if (pol[i] != '9')
 			{
 				pol[i] = (char)(pol[i] + carry);
 				if (i != pol.length - i - 1)
 					pol[pol.length - i - 1] = (char)(pol[i]);
 				carry = 0;
 				
 				break;
 			}
 			else
 			{
 				pol[i] = '0';
 				pol[pol.length - i - 1] = '0';
 				carry = 1;
 			}
 		}
 		if (carry == 1)
 		{
 			char [] newC = new char[pol.length +1];
 			newC[0] = '1';
 			for (int i =1; i < newC.length - 1; i++)
 				newC[i] = '0';
 			newC[newC.length - 1] = '1';
 			return newC;
 		}
 		return pol;
 	}
 	
 	public static boolean isPolindrom (char [] pol)
 	{
 		for (int i = 0; i < pol.length; i++)
 			if (pol[i] != pol[pol.length - 1 - i])
 				return false;
 		return true;
 		
 	}
 }
",0
238,10733,"package main;
 
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.HashSet;
 
 public class Galaxy {
 	
 	
 	ArrayList<BigInteger> e;
 	long N;
 	BigInteger MIN;
 
 	public Galaxy(long N, ArrayList<BigInteger> e) {
 		this.N = N;
 		this.e = e;
 		
 		e = removeDuplicate(e);
 	}
 	
 	  public ArrayList<BigInteger> removeDuplicate(ArrayList<BigInteger> arlList)
 	  {
 	   HashSet h = new HashSet(arlList);
 	   arlList.clear();
 	   arlList.addAll(h);
 	   return arlList;
 	  }
 
 	
 	public void print(ArrayList<BigInteger> o) {
 		for (BigInteger i : o) {
 			System.out.print(i + "" "");
 		}
 		System.out.println();
 	}
 	
 	public ArrayList<BigInteger> reSetArray(ArrayList<BigInteger> o) {
 		BigInteger min = o.get(0);
 		for (int i=1; i<o.size();i++) {
 			if (o.get(i).compareTo(min) == -1) {
 				min = o.get(i);
 			}
 		}
 		MIN = min;
 		for (int i=0; i<o.size();i++) {
 			BigInteger newval = o.get(i).subtract(min);
 			o.set(i, newval);
 		}
 		return o;
 	}
 	
 	public boolean allDividedBy(ArrayList<BigInteger> e, BigInteger min) {
 		for (BigInteger i : e) {
 			if (i.mod(min).compareTo(BigInteger.ZERO) != 0)
 				return false;
 		}
 		return true;
 	}
 	
 	
 	public void run() {
 		ArrayList<BigInteger> tmp = new ArrayList<BigInteger>();
 		for (BigInteger i : e) {
 			tmp.add(i);
 		}
 		tmp = reSetArray(tmp);
 		//get min difference
 		BigInteger mindiff = (tmp.get(0).subtract(tmp.get(1))).abs();
 		for (int i=1; i<tmp.size() -1;i++) {
 			BigInteger newmin = tmp.get(i).subtract(tmp.get(i+1)).abs();
 			if (newmin.compareTo(mindiff) == -1) {
 					mindiff = newmin;
 			}
 		}
 		//end
 		
 		//System.out.println(mindiff);
 		
 
 		if (allDividedBy(e,MIN)) {
 			System.out.println(0);
 		}
 		else {
 			while (true) {
 				if (tmp.get(0).compareTo(e.get(0)) == 1) {
 					BigInteger apoc = tmp.get(0);
 					apoc = apoc.subtract(e.get(0));
 					System.out.println(apoc);
 					//print(tmp);
 					break;
 				}
 			
 				//print(tmp);
 				for (int i=0; i<tmp.size();i++) {
 					tmp.set(i, tmp.get(i).add(mindiff));
 				}
 			//print(tmp);
 			}
 		}
 
 		
 	}
 	
 	
 	
 	
 	public static void main(String[] args) {
 
 		ArrayList<String> lines = main.Reader.readLines(""input_galaxy.txt"");
 		long T = Integer.parseInt(lines.get(0));
 		int idx = 0;
 		
 		ArrayList<BigInteger> e = new ArrayList<BigInteger>();
 		long N;
 		Galaxy g;
 		
 		for (long i = 1; i<=T; i++) {
 			idx++;
 			String newline = lines.get(idx);
 			String []values = newline.split("" "");
 			N = Integer.parseInt(values[0]);
 			e.clear();
 			for (int j=1;j<values.length;j++) {
 				e.add(new BigInteger(values[j]));
 			}
 			
 			
 			System.out.print(""Case #""+ i + "": "");
 			g = new Galaxy(N,e);
 			g.run();
 			
 		}
 		
 		
 
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 
 import java.io.*;
 public class main {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		BufferedReader br=null;
 		BufferedWriter bw=null;
 		try {
 			br = new BufferedReader(new InputStreamReader(new FileInputStream(""B-large.in"")));
 			bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""out.txt"")));
 		} catch (FileNotFoundException e1) {
 			// TODO Auto-generated catch block
 			e1.printStackTrace();
 		}
 		try{
 			int t=Integer.valueOf(br.readLine());
 			for(int i=0;i<t;++i)
 			{
 				String[] temp=br.readLine().split("" "");
 				int l=Integer.valueOf(temp[0]);
 				int p=Integer.valueOf(temp[1]);
 				int c=Integer.valueOf(temp[2]);
 				int num=0;
 				int m=0;
 				if(c*l>=p)
 				{
 					bw.write(""Case #""+(i+1)+"": ""+0+""\n"");
 					continue;
 				}
 				if(p%l==0)
 					p=p/l;
 				else
 					p=p/l+1;
 				
 				l=0;
 				int u1=1,u2=0;
 				while(u1<p)
 				{
 					u1=u1*c;
 					++u2;
 				}
 				p=u2;
 				num=0;
 				while(p>1)
 				{
 					++num;
 					p=p % 2+p/2;
 				}
 					
 				
 				bw.write(""Case #""+(i+1)+"": ""+num+""\n"");
 			}
 			bw.close();
 		}
 		catch(Exception e)
 		{
 			
 		}
 	}
 
 }
",0
239,12959,"package codejam1b;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Created by IntelliJ IDEA.
  * User: Loretta
  * Date: 21/05/11
  * Time: 16:55
  * To change this template use File | Settings | File Templates.
  */
 public class ProblemOne {
 
     public static void main(String[] args) throws Exception {
         BufferedReader br = new BufferedReader(new FileReader(""A-small.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""A-small.out""));
         int noOfCases = Integer.parseInt(br.readLine());
         for (int i = 1; i <= noOfCases; i++) {
             int noOfTeams = Integer.parseInt(br.readLine());
             Integer[][] matches = new Integer[noOfTeams][noOfTeams];
             for (int j = 0; j < noOfTeams; j++) {
                 String currentLine = br.readLine();
                 for (int k = 0; k < noOfTeams; k++) {
                     switch (currentLine.charAt(k)) {
                         case '1':
                             matches[j][k] = 1;
                             break;
                         case '0':
                             matches[j][k] = 0;
                             break;
                         case '.':
                             matches[j][k] = null;
                     }
                 }
             }
             Map<Integer, Integer> totalPlayedTeams = new HashMap<Integer, Integer>();
             Map<Integer, Integer> totalWinnings = new HashMap<Integer, Integer>();
             for (int j = 0; j < noOfTeams; j++) {
                 int noOfTeamsPlayed = 0;
                 int totalScore = 0;
                 for (int k = 0; k < noOfTeams; k++) {
                     if (matches[j][k] != null) {
                         noOfTeamsPlayed++;
                         totalScore += matches[j][k];
                     }
                 }
                 totalPlayedTeams.put(j, noOfTeamsPlayed);
                 totalWinnings.put(j, totalScore);
             }
 
             Map<Integer, Double> wps = new HashMap<Integer, Double>();
             Map<Integer, Double> owps = new HashMap<Integer, Double>();
             Map<Integer, Double> oowps = new HashMap<Integer, Double>();
             for (int j = 0; j < noOfTeams; j++) {
                 wps.put(j, totalWinnings.get(j) * 1.0 / totalPlayedTeams.get(j));
                 double owpSum = 0.0;
                 for (int k = 0; k < noOfTeams; k++) {
                     if (matches[j][k] != null && matches[j][k] == 1) {
                         owpSum = owpSum + totalWinnings.get(k) * 1.0 / (totalPlayedTeams.get(k) - 1);
                     } else if (matches[j][k] != null && matches[j][k] == 0) {
                         owpSum = owpSum + (totalWinnings.get(k) - 1) * 1.0 / (totalPlayedTeams.get(k) - 1);
                     }
                 }
                 owps.put(j, owpSum / totalPlayedTeams.get(j));
             }
             for (int j = 0; j < noOfTeams; j++) {
                 double oowpSum = 0.0;
                 for (int k = 0; k < noOfTeams; k++) {
                     if (matches[j][k] != null) oowpSum = oowpSum + owps.get(k);
                 }
                 oowps.put(j, oowpSum / totalPlayedTeams.get(j));
             }
             bw.write(""Case #"" + i + "":\n"");
             for (int j = 0; j < noOfTeams; j++) {
                 bw.write(wps.get(j) * 0.25 + owps.get(j) * 0.5 + oowps.get(j) * 0.25 + ""\n"");
             }
         }
         bw.flush();
         bw.close();
         br.close();
     }
 
 }
","import java.io.*;
 class ThemePark
 {
     BufferedReader br=null;
     PrintWriter out=null;
     ThemePark(String rfPath, String wfPath){
         try{
             br=new BufferedReader(new FileReader(rfPath));
 	      out=new PrintWriter(new FileOutputStream(wfPath));
         }
         catch(Exception e){}
     }
     void startProcessing() throws Exception{
         int t,ind, pos=-1, pos2=0,i=0;
         int param[]=new int[3];
         String inLine, outLine, rkn="""", val="""";
         t=Integer.parseInt(br.readLine()); // to read numbner of test data
         for (ind=1;ind<=t;ind++)
         {            
         	rkn=br.readLine().trim();
         	rkn=rkn + "" "";
         	i=0;
         	pos=-1;
         	pos2=0;
         	while((pos=rkn.indexOf("" "" ,pos+1))!=-1)
 			{
 				val=rkn.substring(pos2,pos);
 				param[i]=Integer.parseInt(val);
 				i++;
 				pos2=pos+1;
 			}           	      	
         	inLine=br.readLine().trim();
             outLine=processTestData(param[0], param[1], param[2],inLine); // Change parameter according to requirement
                 out.println(""Case #"" + ind + "": "" + outLine);
         }
         closeFiles();
     }
     String processTestData(int r, int k, int n, String inLine)
     { //R-> No Of Ride, K-> Capacity, N-> No. of Group
     	
     	int g[]=new int[n];
     	int pos=-1, pos2=0,ind=0, i,j, rem, pepCnt=0, fnt;
     	fnt=0;
     	double amt=0;
 		String val="""";
 		inLine=inLine + "" "";
 		while((pos=inLine.indexOf("" "" ,pos+1))!=-1)
 		{
 			val=inLine.substring(pos2,pos);
 			g[ind]=Integer.parseInt(val);
 			ind++;
 			pos2=pos+1;
 		}    	
     	for(i=1;i<=r;i++)
     	{
     		rem=k; // rem no of sits remains
     		for(j=0;j<n;j++)
     		{
     			if(rem>=g[(j + fnt) % n])
     				rem=rem - g[(j + fnt) % n];
     			else
     				break;
     		}
     		while(j>0)
     		{
     			pepCnt+=g[fnt];
     			fnt=(fnt+1)%n;
     			j--;
     		}		
     	}
     	
     	return """" + pepCnt;
     }
     public boolean closeFiles(){
 	  boolean isClosed=true;
         try{
 	      br.close();
             out.close();
 	  }catch(Exception e){isClosed=false;}
         return isClosed;
     }
     public static void main(String pal[]) throws Exception
     {
         if(pal.length!=2)
         {
             System.out.println(""Error: Usage>java ThemePark souce target"");
             System.exit(0);
         }
         ThemePark s=new ThemePark(pal[0],pal[1]);
         
         s.startProcessing();
         
     }
 
 }",0
240,16211,"import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 
 
 public class RecycledNumbers {
 
 	private final String inputFile = ""D:\\input.in"";
 	private final String outputFile = ""D:\\output.out"";
 	private static  class TestCase{
 		int a;
 		int b;
 		public int calculateRecycleds(){
 			int result = 0;
 			for (int i = a; i <= b; i++){
 				int numDigits = getNumDigits(i);
 				int lastResycled = -1;
 				for (int j = 0, divisor = 10; j < numDigits - 1; j++, divisor *= 10){
 					int recycled = i % divisor;
 					for (int k = 0; k < numDigits - j - 1; k++){
 						recycled *= 10;
 					}
 					recycled += (i / divisor);
 					if (isInRange(recycled) && recycled > i && lastResycled != recycled){
 						result ++;
 						lastResycled = recycled;
 					}
 				}
 				
 			}
 			return result;
 		}
 		private int getNumDigits(int i){
 			int numDigits = 0;
 			while (i > 0){
 				numDigits++;
 				i /= 10;
 			}
 			return numDigits;
 		}
 		private boolean isInRange(int i){
 			return (i >= a) && (i <= b);
 		}
 	}
 	List<TestCase> input =  new ArrayList<RecycledNumbers.TestCase>();
 	public void parseInput(){
 		try {
 			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile)));
 			int numTestCases = Integer.parseInt(br.readLine());
 			for (int i = 0; i < numTestCases; i++){
 				String [] lineTokens = br.readLine().split("" "");
 				TestCase tc = new TestCase();
 				tc.a = Integer.parseInt(lineTokens[0]);
 				tc.b = Integer.parseInt(lineTokens[1]);
 				input.add(tc);
 			}			
 			br.close();
 			} catch (Exception e) {
 				e.printStackTrace();
 			}
 	}
 	public void doOutput(){
 		try {
 			PrintWriter pw = new  PrintWriter(new FileOutputStream(outputFile));
 			
 			for (int i = 0; i < input.size(); i++){
 				TestCase tc = input.get(i);
 				pw.println(""Case #"" + (i + 1) + "": "" + tc.calculateRecycleds());
 			}
 			pw.flush();
 			pw.close();
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 	}
 	
 	public static void main(String [] args){
 		RecycledNumbers rn  = new RecycledNumbers();
 		rn.parseInput();
 		rn.doOutput();
 	}
 }
","package hr.sandrogrzicic.gcj2010.round1C;
 
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 public class p03 {
 	// private static Input in = new Input(System.in);
 	// private static Output out = new Output(System.out);
 	private static Input in;
 	private static Output out;
 
 	public static void main(final String[] args) throws IOException {
 		in = new Input(new FileInputStream(
 		""src/hr/sandrogrzicic/gcj2010/round1C/C-large.in""));
 		out = new Output(new FileOutputStream(
 		""src/hr/sandrogrzicic/gcj2010/round1C/C-large-out.txt""));
 		int T = in.readInt();
 		for (int i = 1; i <= T; i++) {
 			out.print(""Case #"").print(i).print("": "");
 			cutBarkGrid(in.readInt(), in.readInt());
 		}
 		out.close();
 	}
 
 	private static void cutBarkGrid(final int M, final int N)
 	throws IOException {
 		boolean[][] grid = new boolean[M][N];
 		int Ndiv4 = N/4;
 		// read grid
 		for (int m = 0; m < M; m++) {
 			char[] line = in.readLine(Ndiv4);
 			for (int n = 0; n < Ndiv4; n++) {
 				String binary = Integer.toBinaryString(Integer.parseInt(String.valueOf(line[n]), 16));
 				// System.out.println(binary);
 
 				// yes, I know this is overly complex.
 				switch (binary.length()) {
 				case 1:
 					grid[m][4*n+3] = binary.charAt(0) == '0' ? false : true;
 					break;
 				case 2:
 					grid[m][4*n + 2] = binary.charAt(0) == '0' ? false : true;
 					grid[m][4*n + 3] = binary.charAt(1) == '0' ? false : true;
 					break;
 				case 3:
 					grid[m][4*n + 1] = binary.charAt(0) == '0' ? false : true;
 					grid[m][4*n + 2] = binary.charAt(1) == '0' ? false : true;
 					grid[m][4*n + 3] = binary.charAt(2) == '0' ? false : true;
 					break;
 				case 4:
 					grid[m][4*n] = binary.charAt(0) == '0' ? false : true;
 					grid[m][4*n + 1] = binary.charAt(1) == '0' ? false : true;
 					grid[m][4*n + 2] = binary.charAt(2) == '0' ? false : true;
 					grid[m][4*n + 3] = binary.charAt(3) == '0' ? false : true;
 					break;
 				}
 
 			}
 			// System.out.println(Arrays.toString(grid[m]));
 
 		}
 
 		// cut grid
 		int maxSearchSize = M < N ? M : N;
 		int[] map = new int[maxSearchSize+1];
 		boolean[][] covered = new boolean[M][N];
 
 		for (int size = maxSearchSize; size > 0; size--) {
 			for (int m = 0; m <= M-size; m++) {
 				outerSearch:
 					for (int n = 0; n <= N-size; n++) {
 						//	System.out.println(""size: "" + size);
 						if (covered[m][n]) {
 							continue;
 						}
 						// check chess grid validity
 
 						boolean color = !grid[m][n];
 						for (int i = 0; i < size; i++) {
 							for (int j = 0; j < size; j++) {
 								if (covered[m+i][n+j]) {
 									continue outerSearch;
 								}
 								color = !color;
 								if (grid[m+i][n+j] != color) {
 									//	System.out.println(""continuing: "" + m + "" "" + n);
 									continue outerSearch;
 								}
 							}
 							if ((size & 1) == 0) {
 								color = !color;
 							}
 						}
 						// chess grid is valid
 						//System.out.println(""hit! size ["" + size + ""] ("" + m + "", "" + n + "")"");
 						++map[size];
 						for (int i = 0; i < size; i++) {
 							for (int j = 0; j < size; j++) {
 								covered[m+i][n+j] = true;
 							}
 						}
 					}
 			}
 		}
 		//		System.out.println();
 		// print results
 		int numDiffChessBoards = 0;
 		int maxSize = 1;
 		for (int i = 0; i <= maxSearchSize; i++) {
 			if (map[i] != 0) {
 				++numDiffChessBoards;
 				maxSize = i;
 			}
 		}
 		out.print(numDiffChessBoards).nl();
 		for (int i = maxSize; i > 0; i--) {
 			if (map[i] != 0) {
 				out.print(i + "" "" + map[i]).nl();
 			}
 		}
 
 		//		for (int i = 0; i < M; i++) {
 		//			for (int j = 0; j < N; j++) {
 		//				System.out.print(grid[i][j] ? '1' : '0');
 		//			}
 		//			System.out.println();
 		//		}
 	}
 
 	@SuppressWarnings(""unused"")
 	private static class Input {
 		static final int BUFFER_SIZE = 65535;
 		static final int STRING_SIZE = 1024;
 
 		InputStream in;
 		byte[] buffer;
 		byte[] strBuffer;
 		int pos;
 
 		Input(final InputStream in) {
 			this.in = in;
 			this.buffer = new byte[BUFFER_SIZE];
 			this.strBuffer = new byte[STRING_SIZE];
 			this.pos = BUFFER_SIZE;
 		}
 
 		void skipWhitespace() throws IOException {
 			byte b;
 			do {
 				b = readByte();
 			} while (b <= ' ');
 			--pos;
 		}
 
 		byte readByte() throws IOException {
 			if (pos == BUFFER_SIZE) {
 				in.read(buffer);
 				pos = 0;
 			}
 			return buffer[pos++];
 		}
 
 		int readInt() throws IOException {
 			skipWhitespace();
 			int number = 0;
 			int digit = readByte();
 			int sign = 1;
 			if (digit == '-') {
 				sign = -1;
 			} else {
 				number = digit - '0';
 			}
 
 			digit = readByte();
 			while (digit >= '0') {
 				number *= 10;
 				number += digit - '0';
 				digit = readByte();
 			}
 			--pos;
 			return sign * number;
 		}
 
 		long readLong() throws IOException {
 			skipWhitespace();
 			long number = 0;
 			long digit = readByte();
 			long sign = 1;
 			if (digit == '-') {
 				sign = -1;
 			} else {
 				number = digit - '0';
 			}
 
 			digit = readByte();
 			while (digit >= '0') {
 				number *= 10;
 				number += digit - '0';
 				digit = readByte();
 			}
 			--pos;
 			return sign * number;
 		}
 
 		double readDouble() throws IOException {
 			int sign = 1;
 			if (readByte() == '-') {
 				sign = -1;
 			} else {
 				--pos;
 			}
 			double number = readInt();
 			if (readByte() != '.') {
 				return number;
 			}
 			int decimals = 1;
 			int digit = readByte();
 			while (digit >= '0') {
 				decimals *= 10;
 				number *= 10;
 				number += digit - '0';
 				digit = readByte();
 			}
 			--pos;
 			return sign * number / decimals;
 		}
 
 		char readCharFirstValid() throws IOException {
 			skipWhitespace();
 			char c = (char) readByte();
 			byte b;
 			do {
 				b = readByte();
 			} while (b > ' ');
 			--pos;
 			return c;
 		}
 
 		char[] readLine(final int brojZnakova) throws IOException {
 			skipWhitespace();
 			int length = 0;
 			do {
 				strBuffer[length++] = readByte();
 			} while (length <= brojZnakova);
 			--pos;
 			return new String(strBuffer, 0, length - 1).toCharArray();
 
 		}
 
 		String readString() throws IOException {
 			skipWhitespace();
 			int length = 0;
 			do {
 				strBuffer[length++] = readByte();
 			} while (strBuffer[length - 1] > ' ');
 			--pos;
 			return new String(strBuffer, 0, length - 1);
 		}
 
 	}
 
 	@SuppressWarnings(""unused"")
 	private static class Output {
 		static final int BUFFER_SIZE = 65535;
 
 		OutputStream out;
 		byte[] buffer;
 		int pos;
 
 		Output(final OutputStream out) {
 			this.out = out;
 			this.buffer = new byte[BUFFER_SIZE];
 		}
 
 		void printByte(final int b) throws IOException {
 			if (pos == BUFFER_SIZE) {
 				out.write(buffer);
 				pos = 0;
 			}
 			buffer[pos++] = (byte) b;
 		}
 
 		Output print(final char c) throws IOException {
 			printByte(c);
 			return this;
 		}
 
 		Output print(int i) throws IOException {
 			if (i == 0) {
 				printByte('0');
 			} else {
 				if (i < 0) {
 					i = -i;
 					printByte('-');
 				}
 				int k = 1000000000;
 				while (i / k == 0) {
 					k /= 10;
 				}
 				while (k > 0) {
 					int r = i / k;
 					printByte(r + '0');
 					i -= r * k;
 					k /= 10;
 				}
 			}
 			return this;
 		}
 
 		Output print(double d, int decimals) throws IOException {
 			if (d < 0) {
 				print('-');
 				d = -d;
 			}
 			int integer = (int) d;
 			d -= integer;
 			print(integer);
 			if (decimals > 0) {
 				print('.');
 				while (--decimals >= 0) {
 					d *= 10;
 					integer = (int) d;
 					d -= integer;
 					print(integer);
 				}
 			}
 			return this;
 		}
 
 		Output print(final String str) throws IOException {
 			for (int i = 0; i < str.length(); ++i) {
 				printByte(str.charAt(i));
 			}
 			return this;
 		}
 
 		Output nl() throws IOException {
 			printByte('\n');
 			return this;
 		}
 
 		void flush() throws IOException {
 			out.write(buffer, 0, pos);
 			pos = 0;
 		}
 
 		void close() throws IOException {
 			flush();
 			out.close();
 		}
 	}
 
 }
",0
241,12820,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.StringTokenizer;
 
 public class BotTrust {
 	public int location;
 	public boolean isBlue;
 	public int turn;
 	
 	public static void main(String[] args) {
 		
 		try {
 			BufferedReader reader = new BufferedReader(new FileReader(new File(""A-small-attempt0.in"")));
 			BufferedWriter writer = new BufferedWriter(new FileWriter(new File(""A-small-attempt0.out"")));
 			
 			int numCases = Integer.parseInt(reader.readLine());
 			
 			for (int caseNum=0; caseNum< numCases; caseNum++) {
 				StringTokenizer st = new StringTokenizer(reader.readLine());
 				writer.write(""Case #"" + (caseNum+1) + "": "" + runCase(st));
 				writer.newLine();
 			}
 			
 			reader.close();
 			writer.close();
 		} catch (IOException e) {
 			
 		}
 	}
 	private static int runCase(StringTokenizer st) {
 		int totalTime = 0;
 		st.nextToken();
 		int timeSinceBlue = 0;
 		int timeSinceOrange = 0;
 		int orangeLocation = 1;
 		int blueLocation = 1;
 		
 		while(st.hasMoreTokens()) {
 			String robotType = st.nextToken();
 			int position = Integer.parseInt(st.nextToken());
 			
 			if (robotType.equals(""O"")) {
 				if (orangeLocation != position) {
 					int timeTaken = Math.abs(orangeLocation-position);
 					if (timeTaken <= timeSinceOrange) {
 						timeTaken = 0;
 					} else {
 						timeTaken = timeTaken-timeSinceOrange;
 					}
 					totalTime += timeTaken;
 					timeSinceBlue += timeTaken;
 					orangeLocation = position;
 				}
 				timeSinceOrange = 0;
 				totalTime++;
 				timeSinceBlue++;
 			}
 			
 			if (robotType.equals(""B"")) {
 				if (blueLocation != position) {
 					int timeTaken = Math.abs(blueLocation-position);
 					if (timeTaken <= timeSinceBlue) {
 						timeTaken = 0;
 					} else {
 						timeTaken = timeTaken-timeSinceBlue;
 					}
 					totalTime += timeTaken;
 					timeSinceOrange += timeTaken;
 					blueLocation = position;
 				}
 				totalTime++;
 				timeSinceOrange++;
 				timeSinceBlue = 0;
 			}
 		}
 		return totalTime;
 	}
 }","package GCJ2012QR2012;
 
 import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.*;
 import java.util.HashMap;
 import java.util.TreeMap;
 import java.util.Iterator;
 import java.util.ArrayList;
 import java.lang.Math;
 import java.util.LinkedList;
 
 import java.util.Map;
 import java.util.Collections;
 import java.util.Comparator;
 
 import template.Template;
 
 public class B {
 	public static void main(String[] args)  throws Exception{
 		Template tpl = new Template('B', false, false, 0);
 		String line = tpl.read(0);
 		int T = Integer.parseInt(line);
 		for(int i=1; i<tpl.getSize(); i++){
 			String[] str = tpl.read(i).split("" "");
 			int N = Integer.parseInt(str[0]);
 			int S = Integer.parseInt(str[1]);
 			int p = Integer.parseInt(str[2]);
 			int[] t = new int[str.length-3];
 			for(int j=0; j<N; j++){
 				t[j] = Integer.parseInt(str[j+3]);
 			}
 			int confirmed = 0;
 			int possible = 0;
 			int never = 0;
 			
 			int cnf_sup = 0;
 			int psb_sup = 0;
 			if(p>=2){
 				cnf_sup = p+(p-1)+(p-1);
 				psb_sup = p+(p-2)+(p-2);
 			}
 			else if(p>=1){
 				cnf_sup = p+(p-1)+(p-1);
 				psb_sup = p+(p-1)+(p-1);
 			}
 			else{
 				cnf_sup = p*3;
 				psb_sup = p*3;
 			}
 					
 			for(int j=0; j<t.length; j++){
 				if(t[j]>=cnf_sup) confirmed++;
 				else if(t[j]>=psb_sup) possible++;
 				else never++;
 			}
 			int result = confirmed+Math.min(possible, S);
 			String rst = ""Case #""+i+"": ""+ result;
 			tpl.addLine(rst);
 		}
 		tpl.write();
 		
 	}
 }
",0
242,9742,"package main;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.FilenameFilter;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
 import javax.management.ImmutableDescriptor;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Collections2;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 public class Problem3 {
 	public static void main(String[] args) throws Exception {
 		new Problem3().prepareAndSolve();
 	}
 
 	private void prepareAndSolve() throws Exception {
 		File inout = new File(""inout"");
 		final String testSuffix;
 		if (getClass().getSimpleName().endsWith(""1"")) {
 			testSuffix = ""A"";
 		} else if (getClass().getSimpleName().endsWith(""2"")) {
 			testSuffix = ""B"";
 		} else if (getClass().getSimpleName().endsWith(""3"")) {
 			testSuffix = ""C"";
 		} else {
 			testSuffix = ""D"";
 		}
 		File ioDir = inout.listFiles(new FilenameFilter() {
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.compareTo(testSuffix) == 0;
 			}
 		})[0];
 
 		// SAMPLE
 
 		File sampleIn = ioDir.listFiles(new FilenameFilter() {
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.compareTo(""sample.in"") == 0;
 			}
 		})[0];
 		StringWriter buffer = new StringWriter();
 		BufferedWriter writer = new BufferedWriter(buffer);
 
 		long time = System.currentTimeMillis();
 		solve(new BufferedReader(new FileReader(sampleIn)), writer);
 		System.out.println(""Sample checked: "" + (System.currentTimeMillis() - time) + "" ms"");
 		writer.close();
 
 		File sampleOut = ioDir.listFiles(new FilenameFilter() {
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.compareTo(""sample.out"") == 0;
 			}
 		})[0];
 		if (checkCorrectness(buffer.toString(), sampleOut) == false) {
 			System.out.println(""NOT CORRECT:"");
 			System.out.println(buffer.toString());
 			return;
 		}
 
 		// ADDITIONAL
 
 		File[] additionalTest = ioDir.listFiles(new FilenameFilter() {
 
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.compareTo(""add.in"") == 0;
 			}
 		});
 		if (additionalTest.length == 1) {
 			buffer = new StringWriter();
 			writer = new BufferedWriter(buffer);
 			time = System.currentTimeMillis();
 			solve(new BufferedReader(new FileReader(additionalTest[0])), writer);
 			System.out.println(""Additional checked: "" + (System.currentTimeMillis() - time) + "" ms"");
 			writer.close();
 			File additionalTestAnswer = ioDir.listFiles(new FilenameFilter() {
 				@Override
 				public boolean accept(File dir, String name) {
 					return name.compareTo(""add.out"") == 0;
 				}
 			})[0];
 			if (checkCorrectness(buffer.toString(), additionalTestAnswer) == false) {
 				System.out.println(""NOT CORRECT:"");
 				System.out.println(buffer.toString());
 				return;
 			}
 		}
 
 		// SMALL
 
 		File[] smallTest = ioDir.listFiles(new FilenameFilter() {
 
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.contains(""small"") && name.contains(""in"");
 			}
 		});
 		if (smallTest.length == 1) {
 			buffer = new StringWriter();
 			writer = new BufferedWriter(buffer);
 			time = System.currentTimeMillis();
 			solve(new BufferedReader(new FileReader(smallTest[0])), writer);
 			System.out.print(""Small runned: "" + (System.currentTimeMillis() - time) + "" ms"");
 			writer.close();
 			File smallAnswer[] = ioDir.listFiles(new FilenameFilter() {
 				@Override
 				public boolean accept(File dir, String name) {
 					return name.compareTo(""small.out"") == 0;
 				}
 			});
 			if (smallAnswer.length == 1) {
 				if (checkCorrectness(buffer.toString(), smallAnswer[0]) == false) {
 					System.out.println(""NOT CORRECT:"");
 					System.out.println(buffer.toString());
 					return;
 				}
 				System.out.println("", verified"");
 			} else {
 				BufferedWriter solutionWriter = new BufferedWriter(new FileWriter(""inout"" + File.separatorChar + testSuffix + File.separatorChar + ""small.out""));
 				solutionWriter.write(buffer.toString());
 				solutionWriter.close();
 				System.out.println("", written"");
 			}
 		}
 
 		// RANDOM GENERATED
 
 		if (testWithRandom == true) {
 			StringWriter sw = new StringWriter();
 			BufferedWriter bw = new BufferedWriter(sw);
 			bw.write("""" + randomInputTestNum);
 			bw.newLine();
 			for (int i = 0; i < randomInputTestNum; i++) {
 				generateOneRandomInputTest(bw);
 			}
 			time = System.currentTimeMillis();
 			bw.flush();
 			solve(new BufferedReader(new StringReader(sw.toString())), new BufferedWriter(new StringWriter()));
 			System.out.print(""Random runned: "" + (System.currentTimeMillis() - time) + "" ms"");
 		}
 
 		// LARGE
 
 		File[] largeTest = ioDir.listFiles(new FilenameFilter() {
 
 			@Override
 			public boolean accept(File dir, String name) {
 				return name.contains(""large"") && name.contains(""in"");
 			}
 		});
 		if (largeTest.length == 1) {
 			buffer = new StringWriter();
 			writer = new BufferedWriter(buffer);
 			time = System.currentTimeMillis();
 			solve(new BufferedReader(new FileReader(largeTest[0])), writer);
 			System.out.print(""Large runned: "" + (System.currentTimeMillis() - time) + "" ms"");
 			writer.close();
 			File largeAnswer[] = ioDir.listFiles(new FilenameFilter() {
 				@Override
 				public boolean accept(File dir, String name) {
 					return name.compareTo(""large.out"") == 0;
 				}
 			});
 			if (largeAnswer.length == 1) {
 				if (checkCorrectness(buffer.toString(), largeAnswer[0]) == false) {
 					System.out.println(""NOT CORRECT:"");
 					System.out.println(buffer.toString());
 					return;
 				}
 				System.out.println("", verified"");
 			} else {
 				BufferedWriter solutionWriter = new BufferedWriter(new FileWriter(""inout"" + File.separatorChar + testSuffix + File.separatorChar + ""large.out""));
 				solutionWriter.write(buffer.toString());
 				solutionWriter.close();
 				System.out.println("", written"");
 			}
 		}
 	}
 
 	private boolean checkCorrectness(String answer, File correctAnswerFile) throws Exception {
 		BufferedReader reader = new BufferedReader(new FileReader(correctAnswerFile));
 		try {
 			BufferedReader stringReader = new BufferedReader(new StringReader(answer));
 			String answerLine = stringReader.readLine();
 			String solutionLine = reader.readLine();
 			while (answerLine != null && solutionLine != null) {
 				if (answerLine.compareTo(solutionLine) != 0) {
 					return false;
 				}
 				answerLine = stringReader.readLine();
 				solutionLine = reader.readLine();
 			}
 			if (solutionLine != null) {
 				solutionLine = reader.readLine();
 			}
 			if (solutionLine != null || answerLine != null) {
 				return false;
 			}
 			return true;
 		} finally {
 			reader.close();
 		}
 
 	}
 
 	private int	tasksRunning	= 0;
 
 	@SuppressWarnings(""unchecked"")
 	public void solve(BufferedReader reader, BufferedWriter writer) throws Exception {
 		int T = Integer.parseInt(reader.readLine());
 		ExecutorService xs = Executors.newFixedThreadPool(4);
 		Future<String>[] outputs = new Future[T];
 		for (int i = 0; i < outputs.length; i++) {
 			final Solution s = new Solution();
 			tasksRunning++;
 			s.readInput(reader);
 			outputs[i] = xs.submit(new Callable<String>() {
 				@Override
 				public String call() throws Exception {
 					try {
 						return s.solveInput();
 					} finally {
 						tasksRunning--;
 					}
 				}
 			});
 		}
 		new Thread() {
 			public void run() {
 				try {
 					while (true) {
 						sleep(10000);
 						if (tasksRunning == 0) {
 							interrupt();
 						}
 						System.out.println(""Tasks remaining:"" + tasksRunning);
 					}
 				} catch (InterruptedException e) {
 				}
 			};
 		}.start();
 		for (int i = 0; i < outputs.length; i++) {
 			writer.write(""Case #"" + (i + 1) + "": "" + outputs[i].get());
 			writer.newLine();
 		}
 		xs.shutdown();
 	}
 
 	// ------------------------START OF THE SOLUTION------------------------------
 
 	public static boolean	testWithRandom		= false;
 
 	public static int		randomInputTestNum	= 1;
 
 	public void generateOneRandomInputTest(BufferedWriter bw) throws Exception {
 		bw.write(500 + """");
 		bw.newLine();
 	}
 
 	public static class Solution {
 
 		private int getIntegerLength(int i) {
 			return (i + """").length();
 		}
 
 		private int recycleInt(int integer, int position) {
 			return Integer.parseInt((integer + """").substring(position) + (integer + """").substring(0, position));
 		}
 
 		private ImmutableSet<Integer> getRecycleds(int integer) {
 			ImmutableSet.Builder<Integer> res = ImmutableSet.builder();
 			for (int i = 1; i < getIntegerLength(integer); i++) {
 				res.add(recycleInt(integer, i));
 			}
 			return res.build();
 		}
 
 		private ImmutableSet<Integer> getGreaterRecycledsBetween(final int integer, final int min, final int max) {
 			return ImmutableSet.copyOf(Collections2.filter(getRecycleds(integer), new Predicate<Integer>() {
 				public boolean apply(Integer arg0) {
 					return arg0 >= min && arg0 <= max && arg0 > integer;
 				};
 			}));
 		}
 
 		private int getAllRecycledsNumBetween(int min, int max) {
 			int result = 0;
 			for (int i = min; i <= max; i++) {
 				result += getGreaterRecycledsBetween(i, min, max).size();
 			}
 			return result;
 		}
 
 		private int	minParam;
 
 		private int	maxParam;
 
 		public void readInput(BufferedReader reader) throws Exception {
 			String line = reader.readLine();
 			minParam = Integer.parseInt(line.split(""[ ]"")[0]);
 			maxParam = Integer.parseInt(line.split(""[ ]"")[1]);
 		}
 
 		public String solveInput() throws Exception {
 			return getAllRecycledsNumBetween(minParam, maxParam) + """";
 		}
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 public class BotTrust {
 
 	static class Command {
 		int button;
 		char robot;
 
 		Command(char robot, int button) {
 			this.robot = robot;
 			this.button = button;
 		}
 	}
 
 	public static void main(String[] args) throws InterruptedException, FileNotFoundException {
 		 Scanner sc = new Scanner(new File(""A-small-attempt0.in""));
 		 PrintWriter printer = new PrintWriter(new OutputStreamWriter(
 		 new FileOutputStream(new File(""bottrust.txt""))));
 //		Scanner sc = new Scanner(System.in);
 		int tCases = sc.nextInt();
 		sc.nextLine();
 		for (int t = 1; t <= tCases; t++) {
 
 			String[] input = sc.nextLine().split("" "");
 //			System.out.println(Arrays.toString(input));
 			int N = Integer.parseInt(input[0]);
 			Command[] commands = new Command[N];
 			LinkedList<Integer> blueButtons = new LinkedList<Integer>();
 			LinkedList<Integer> orangeButtons = new LinkedList<Integer>();
 			for (int i = 1, n = 0; i < input.length; i++) {
 				char robot = input[i].charAt(0);
 				i++;
 				int button = Integer.parseInt(input[i]);
 				commands[n] = new Command(robot, button);
 				n++;
 				if (robot == 'O') {
 					orangeButtons.addLast(button);
 				} else {
 					blueButtons.addLast(button);
 				}
 
 			}
 			int time = 0;
 			int oPos = 1;
 			int bPos = 1;
 
 			for (int n = 0; n < N; n++) {
 				int currentButton = commands[n].button;
 				char currentRobot = commands[n].robot;
 
 				int currentBlueButton = 0;
 				if (!blueButtons.isEmpty()) {
 					currentBlueButton = blueButtons.getFirst();
 				}
 
 				int currentOrangeButton = 0;
 				if (!orangeButtons.isEmpty()) {
 					currentOrangeButton = orangeButtons.getFirst();
 				}
 
 				int oCommand = 0;
 				int bCommand = 0;
 
 				if (currentBlueButton == 0) {
 					bCommand = 0;
 				} else if (currentBlueButton > bPos) {
 					bCommand = 1;
 				} else if (currentBlueButton < bPos) {
 					bCommand = -1;
 				} else {
 					bCommand = 0;
 				}
 
 				if (currentOrangeButton == 0) {
 					oCommand = 0;
 				} else if (currentOrangeButton > oPos) {
 					oCommand = 1;
 				} else if (currentOrangeButton < oPos) {
 					oCommand = -1;
 				} else {
 					oCommand = 0;
 				}
 //				System.out.println(""orange: "" + oCommand + ""\tblue: "" + bCommand);
 				if (currentRobot == 'O') {
 					while (currentButton != oPos) {
 						oPos += oCommand;
 						bPos += bCommand;
 
 						time++;
 //						System.out.print(time
 //								+ "" Orange: ""
 //								+ (oCommand != 0 ? ""Move to button ""
 //										: ""Stay at button "") + oPos + ""\t"");
 //						System.out.println(""Blue: ""
 //								+ (bCommand != 0 ? ""Move to button ""
 //										: ""Stay at button "") + bPos);
 
 						if (currentBlueButton == 0 || bPos == currentBlueButton) {
 							bCommand = 0;
 						}
 
 //						Thread.sleep(1000);
 					}
 //					oPos += oCommand;
 					bPos += bCommand;
 					time++;
 //					System.out.print(time + "" Orange: "" + ""Push button "" + oPos
 //							+ ""\t"");
 //					System.out.println(""Blue: ""
 //							+ (bCommand != 0 ? ""Move to button ""
 //									: ""Stay at button "") + bPos);
 
 					if (currentBlueButton == 0 || bPos == currentBlueButton) {
 						bCommand = 0;
 					}
 //					Thread.sleep(1000);
 					orangeButtons.removeFirst();
 				} else {
 					while (currentButton != bPos) {
 						bPos += bCommand;
 						oPos += oCommand;
 
 						time++;
 //						System.out.print(time
 //								+ "" Orange: ""
 //								+ (oCommand != 0 ? ""Move to button ""
 //										: ""Stay at button "") + oPos + ""\t"");
 //						System.out.println(""Blue: ""
 //								+ (bCommand != 0 ? ""Move to button ""
 //										: ""Stay at button "") + bPos);
 
 						if (currentOrangeButton == 0
 								|| oPos == currentOrangeButton) {
 							oCommand = 0;
 						}
 //						Thread.sleep(1000);
 					}
 					oPos += oCommand;
 //					bPos += bCommand;
 					time++;
 //					System.out.print(time
 //							+ "" Orange: ""
 //							+ (oCommand != 0 ? ""Move to button ""
 //									: ""Stay at button "") + oPos + ""\t"");
 //					System.out.println(""Blue: "" + ""Push button "" + bPos);
 
 					if (currentOrangeButton == 0 || oPos == currentOrangeButton) {
 						oCommand = 0;
 					}
 //					Thread.sleep(1000);
 
 					blueButtons.removeFirst();
 				}
 			}
 			// System.out.println(Arrays.toString(sc.nextLine().split("" "")));
 //			System.out.println(""Case #"" + t + "": "" + time);
 			 printer.println(""Case #"" + t + "": "" + time);
 		}
 		 printer.close();
 	}
 }
",0
243,13077,"package problemc;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.Writer;
 import java.util.HashSet;
 import java.util.Set;
 
 public class ProblemC {
 
     public static void main(String[] args) throws IOException {
         File in = new File(""d:/develop/GoogleCodeJam/ProblemC/C-small-attempt0.in"");
         Reader reader = new FileReader(in);
         BufferedReader bf = new BufferedReader(reader);
         
         String casesNum = bf.readLine();
         Integer cases = Integer.parseInt(casesNum);
         
         File out = new File(""d:/develop/GoogleCodeJam/ProblemC/C-small-attempt0.out"");
         Writer writer = new FileWriter(out);
         
         for (int i = 0; i < cases; i++) {
             String[] line = bf.readLine().split("" "");
             int x = Integer.parseInt(line[0]);
             int y = Integer.parseInt(line[1]);
             writer.write(""Case #""+ (i+1) +"": "" + getFairAndSquares(x, y)+""\n"");
         }
         
         reader.close();
         bf.close();
         writer.close();
     }
 
     public static int getFairAndSquares(int x, int y) {
         int count = 0;
         Set<Integer> squares = new HashSet<Integer>();
         int sx = (int) Math.ceil(Math.sqrt(x));
         int sy = (int) Math.floor(Math.sqrt(y));
         for (int act = sx; act <= sy; act++) {
             if (isFair(act) && isFair(act*act)) {
                 count++;
             }
         }
         return count;
     }
 
     private static boolean isFair(int x) {
         String xS = """"+x;
         String rS = new StringBuffer(xS).reverse().toString();
         return xS.equals(rS);
     }
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 
 
 public class DacingScore {
 
 	public static String SMALL_IN_FILE_NAME = ""./input.txt"";
 	static PrintStream out = null;
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		// TODO Auto-generated method stub
 		File smallIn = new File(SMALL_IN_FILE_NAME);
 		BufferedReader br = new BufferedReader(new FileReader(smallIn));
 		String s = br.readLine();
 		int caseCount = Integer.parseInt(s);
 		File smallOut = new File(""./output.txt"");
 		smallOut.createNewFile();
 		out = new PrintStream(smallOut);
 //		out = System.out;
 		
 		for (int i = 0; i < caseCount; i ++) {
 			out.printf(""Case #%d: "", i+1);
 			s = br.readLine();
 			TestCase t = new TestCase(s);
 			out.println(solveTestCase(t));
 		}
 		System.out.println(""Done"");
 	}
 	private static int solveTestCase(TestCase t) {
 		int p = t.getpScore();
 		int sCount = t.getSuprisingCount();
 		ArrayList<Triplet> triplets = t.getTriplets();
 		ArrayList<Triplet> normal = new ArrayList<Triplet>();
 		ArrayList<Triplet> candidate = new ArrayList<Triplet>();
 		ArrayList<Triplet> failed = new ArrayList<Triplet>();
 		int sNormal = 0, sCandidate = 0, sFailed = 0;
 		for (Triplet triplet : triplets) {
 			if (triplet.getBest(false) >= p) {
 				normal.add(triplet);
 				if (triplet.isSuprisable()) {
 					sNormal ++;
 				}
 			} else if (triplet.getBest(true) >= p) {
 				candidate.add(triplet);
 				sCandidate++;
 			} else {
 				failed.add(triplet);
 				if (triplet.isSuprisable()) {
 					sFailed++;
 				}
 			}
 		}
 		int result = -1;
 		if (candidate.size() >= sCount) { 
 			// plenty of candidates
 			result = normal.size() + sCount;
 		} else {
 			result = normal.size() + candidate.size();
 		}
 		return result;
 	}
 }
",0
244,17351,"import java.io.*;
 import java.util.*;
 import java.math.*;
 
 final public class Main implements Runnable {
 	private static boolean local;
 
 	public static void main(String[] args) {
 		if (args.length > 0 && args[0].equals(""local"")) {
 			local = true;
 		}
 		new Thread(null, new Main(), ""mainthread"", 1 << 27).start();
 	}
 
 	public void run() {
 		InputStream inputStream = System.in;
 		OutputStream outputStream = System.out;
 		
 		if (!local) {
 			try {
 				// inputStream = new FileInputStream(""input.txt"");
 				// outputStream = new FileOutputStream(""output.txt"");
 			} catch (Exception e) {
 				throw new RuntimeException(e);
 			}
 		}
 
 		Task solver = new Task();
 		solver.in = new InputReader(inputStream);
 		solver.out = new OutputWriter(outputStream);
 		if (local) {
 			solver.dout = new DebugWriter(solver.out);
 		}
 		solver.solve();
 		solver.out.close();
 	}
 }
 
 final class Task {
 	public InputReader in;
 	public OutputWriter out;
 	public DebugWriter dout;
 	
 	public void solve() {
 		int T = in.readInt();
 		for (int t = 1; t <= T; ++t) {
 			out.print(""Case #"" + t + "":"");
 			
 			k = in.readInt();
 			n = in.readInt();
 			
 			key = new int[k];
 			for (int i = 0; i < k; ++i)
 				key[i] = in.readInt() - 1;
 			
 			chest = new int[n][];
 			type = new int[n];
 			for (int j = 0; j < n; ++j) {
 				type[j] = in.readInt() - 1;
 				int count = in.readInt();
 				chest[j] = new int[count];
 				for (int i = 0; i < count; ++i)
 					chest[j][i] = in.readInt() - 1;
 			}			
 			
 			was = new boolean[1 << n];
 			dp = new boolean[1 << n];
 			
 			// dout.printLine(key);
 			// dout.printLine();
 			// dout.printLine(chest);
 			
 			if (!f(0)) {
 				out.printLine("" IMPOSSIBLE"");
 			} else {
 				path(0);
 				out.printLine();
 			}
 		}
 	}
 	
 	int n;
 	int k;
 	int[][] chest;
 	int[] type;
 	int[] key;
 	
 	boolean[] was;
 	boolean[] dp;	
 	boolean f(int mask) {
 		if (was[mask]) return dp[mask];
 		was[mask] = true;
 		if (mask == (1 << n) - 1) return dp[mask] = true;
 		
 		int[] mas = new int[64];
 		int count = 0;
 		for (int i = 0; i < k; ++i)
 			mas[count++] = key[i];
 		
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 1)
 				for (int i = 0; i < chest[j].length; ++i)
 					mas[count++] = chest[j][i];
 				
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 1)
 				for (int i = 0; i < count; ++i)
 					if (type[j] == mas[i]) {
 						mas[i] = mas[--count];					
 						break;
 					}
 						
 		// dout.printLine(count);	
 		// dout.printLine(mas);	
 					
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 0)
 				for (int i = 0; i < count; ++i)
 					if (type[j] == mas[i] && f(mask | (1 << j)))
 						return dp[mask] = true;
 						
 		return dp[mask];				
 	}
 	
 	void path(int mask) {
 		if (mask == (1 << n) - 1) return;
 		
 		int[] mas = new int[64];
 		int count = 0;
 		for (int i = 0; i < k; ++i)
 			mas[count++] = key[i];
 		
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 1)
 				for (int i = 0; i < chest[j].length; ++i)
 					mas[count++] = chest[j][i];
 				
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 1)
 				for (int i = 0; i < count; ++i)
 					if (type[j] == mas[i]) {
 						mas[i] = mas[--count];					
 						break;
 					}
 					
 		for (int j = 0; j < n; ++j)
 			if (((mask >> j) & 1) == 0)
 				for (int i = 0; i < count; ++i)
 					if (type[j] == mas[i] && f(mask | (1 << j))) {
 						out.print("" "" + (j + 1));
 						path(mask | (1 << j));
 						return;
 					}
 	}
 	
 }
 
 final class InputReader {
 	private boolean finished = false;
 
 	private InputStream stream;
 	private byte[] buf = new byte[1 << 13];
 	private int curChar;
 	private int numChars;
 
 	public InputReader(InputStream stream) {
 		this.stream = stream;
 	}
 
 	private int read() {
 		if (numChars == -1)
 			throw new InputMismatchException();
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				throw new InputMismatchException();
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar++];
 	}
 
 	public int peek() {
 		if (numChars == -1)
 			return -1;
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				return -1;
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar];
 	}
 
 	public int readInt() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		int res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 
 	public long readLong() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		long res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 
 	public String readString() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		StringBuilder res = new StringBuilder();
 		do {
 			res.appendCodePoint(c);
 			c = read();
 		} while (!isSpaceChar(c));
 		return res.toString();
 	}
 
 	public static boolean isSpaceChar(int c) {
 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 	}
 
 	private String readLine0() {
 		StringBuilder buf = new StringBuilder();
 		int c = read();
 		while (c != '\n' && c != -1) {
 			if (c != '\r')
 				buf.appendCodePoint(c);
 			c = read();
 		}
 		return buf.toString();
 	}
 
 	public String readLine() {
 		String s = readLine0();
 		while (s.trim().length() == 0)
 			s = readLine0();
 		return s;
 	}
 
 	public String readLine(boolean ignoreEmptyLines) {
 		if (ignoreEmptyLines)
 			return readLine();
 		else
 			return readLine0();
 	}
 	
 	public String readToEnd() {
 		StringBuilder buf = new StringBuilder();
 		int c = read();
 		while (c != -1) {
 			if (c != '\r')
 				buf.appendCodePoint(c);
 			c = read();
 		}
 		return buf.toString();
 	}
 
 	public BigInteger readBigInteger() {
 		try {
 			return new BigInteger(readString());
 		} catch (NumberFormatException e) {
 			throw new InputMismatchException();
 		}
 	}
 
 	public char readCharacter() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		return (char) c;
 	}
 
 	public double readDouble() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		double res = 0;
 		while (!isSpaceChar(c) && c != '.') {
 			if (c == 'e' || c == 'E')
 				return res * Math.pow(10, readInt());
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		}
 		if (c == '.') {
 			c = read();
 			double m = 1;
 			while (!isSpaceChar(c)) {
 				if (c == 'e' || c == 'E')
 					return res * Math.pow(10, readInt());
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				m /= 10;
 				res += (c - '0') * m;
 				c = read();
 			}
 		}
 		return res * sgn;
 	}
 
 	public boolean isExhausted() {
 		int value;
 		while (isSpaceChar(value = peek()) && value != -1)
 			read();
 		return value == -1;
 	}
 	
 	public void close() {
 		try {
 			stream.close();
 		} catch (IOException e) {
 			throw new RuntimeException();			
 		}
 	}
 }
 
 final class OutputWriter {
 	private final PrintWriter writer;
 
 	public OutputWriter(OutputStream outputStream) {
 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream), 1 << 13));
 	}
 
 	public OutputWriter(Writer writer) {
 		this.writer = new PrintWriter(writer);
 	}
 
 
 	public void print(Object... objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(Object... objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printFormat(String format, Object... objects) {
 		writer.printf(format, objects);
 	}
 
 
 	public void print(char[] objects) {
 		writer.print(objects);
 	}
 
 	public void printLine(char[] objects) {
 		writer.println(objects);
 	}
 
 	public void printLine(char[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(int[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(int[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(int[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(short[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(short[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(short[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(long[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(long[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(long[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(double[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(double[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(double[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(byte[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(byte[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(byte[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(boolean[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(boolean[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(boolean[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void close() {
 		writer.close();
 	}
 
 	public void flush() {
 		writer.flush();
 	}
 }
 
 final class DebugWriter {
 	private final OutputWriter writer;
 
 	public DebugWriter(OutputWriter writer) {
 		this.writer = writer;
 	}
 
 	private void printDebugMessage() {
 		writer.print(""DEBUG:\t"");
 	}
 
 
 	public void printLine(Object... objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printFormat(String format, Object... objects) {
 		flush();
 		printDebugMessage();
 		writer.printFormat(format, objects);
 		flush();
 	}
 
 
 	public void printLine(char[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(char[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(double[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(double[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(int[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(int[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(short[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(short[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(long[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(long[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(byte[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(byte[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void printLine(boolean[] objects) {
 		flush();
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(boolean[][] objects) {
 		flush();
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 
 	public void flush() {
 		writer.flush();
 	}
 }
","import java.io.*;
 import java.util.*;
 import java.math.*;
 
 final public class Main implements Runnable {
 	private static boolean local;
 
 	public static void main(String[] args) {
 		if (args.length > 0 && args[0].equals(""local"")) {
 			local = true;
 		}
 		new Thread(null, new Main(), ""mainthread"", 1 << 27).start();
 	}
 
 	public void run() {
 		InputStream inputStream = System.in;
 		OutputStream outputStream = System.out;
 
 		try {
 			if (local) {
 				inputStream = new FileInputStream(""X:/coding/workspace/java/main/io/input.txt"");
 				outputStream = new FileOutputStream(""X:/coding/workspace/java/main/io/output.txt"");
 			} else {
 				// inputStream = new FileInputStream(""input.txt"");
 				// outputStream = new FileOutputStream(""output.txt"");
 			}
 		} catch (Exception e) {
 			throw new RuntimeException(e);
 		}
 
 		Task.in = new InputReader(inputStream);
 		Task.out = new OutputWriter(outputStream);
 		if (local) {
 			Task.dout = new DebugWriter(Task.out);
 		}
 		new Task().solve();
 		Task.out.close();
 	}
 }
 
 final class Task {
 	public static InputReader in;
 	public static OutputWriter out;
 	public static DebugWriter dout;
 
 	public void solve() {
 		int T = in.readInt();
 		
 		
 		for (int t = 1; t <= T; ++t) {
 			out.print(""Case #"" + t + "": "");
 			long res = 0;
 			
 			TreeMap<Integer, Long> have = new TreeMap<>();
 			ArrayList<ComparablePair<Integer, ComparablePair<Integer, Integer>>> mas = new ArrayList<>();
 			
 			pay = in.readInt();
 			int n = in.readInt();
 			for (int i = 0; i < n; ++i) {
 				int a = in.readInt();
 				int b = in.readInt();
 				int count = in.readInt();
 				
 				res += get(b - a) * count % MOD;
 				if (res >= MOD) res -= MOD;
 				
 				mas.add(new ComparablePair<>(a, new ComparablePair<>(0, count)));
 				mas.add(new ComparablePair<>(b, new ComparablePair<>(1, count)));
 			}
 			
 			SequenceUtils.quickSort(mas);
 			
 			int prev = 0;
 			
 			for (int i = 0; i < mas.size(); ++i) {
 				int d = mas.get(i).first - prev;
 				prev = mas.get(i).first;
 				
 				TreeMap<Integer, Long> tmp = new TreeMap<>();
 				for (int x : have.keySet())
 					tmp.put(x + d, have.get(x));
 				have = tmp;
 					
 				long count = mas.get(i).second.second;
 				
 				if (mas.get(i).second.first == 0) {
 					if (have.containsKey(0))
 						have.put(0, have.get(0) + count);
 					else have.put(0, count);
 				} else {
 					while (count > 0) {
 						int x = have.firstKey();
 						if (have.get(x) > count) {
 							res -= get(x) * count % MOD;
 							if (res < 0) res += MOD;
 							have.put(x, have.get(x) - count);
 							count = 0;
 						} else {
 							res -= get(x) * have.get(x) % MOD;
 							if (res < 0) res += MOD;
 							count -= have.get(x);
 							have.remove(x);
 						}
 					}
 				}
 			}
 			
 			out.printLine(res);
 		}
 	}
 	
 	long MOD = 1000002013;
 	int pay;
 	
 	long get(int n) {
 		return (long) (pay + pay - (n - 1)) * n / 2 % MOD;
 	}
 }
 
 final class InputReader {
 	private boolean finished = false;
 
 	private InputStream stream;
 	private byte[] buf = new byte[1 << 13];
 	private int curChar;
 	private int numChars;
 
 	public InputReader(InputStream stream) {
 		this.stream = stream;
 	}
 
 	private int read() {
 		if (numChars == -1)
 			throw new InputMismatchException();
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				throw new InputMismatchException();
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar++];
 	}
 
 	public int peek() {
 		if (numChars == -1)
 			return -1;
 		if (curChar >= numChars) {
 			curChar = 0;
 			try {
 				numChars = stream.read(buf);
 			} catch (IOException e) {
 				return -1;
 			}
 			if (numChars <= 0)
 				return -1;
 		}
 		return buf[curChar];
 	}
 
 	public int readInt() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		int res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 
 	public long readLong() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		long res = 0;
 		do {
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		} while (!isSpaceChar(c));
 		return res * sgn;
 	}
 
 	public String readString() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		StringBuilder res = new StringBuilder();
 		do {
 			res.appendCodePoint(c);
 			c = read();
 		} while (!isSpaceChar(c));
 		return res.toString();
 	}
 
 	public static boolean isSpaceChar(int c) {
 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 	}
 
 	private String readLine0() {
 		StringBuilder buf = new StringBuilder();
 		int c = read();
 		while (c != '\n' && c != -1) {
 			if (c != '\r')
 				buf.appendCodePoint(c);
 			c = read();
 		}
 		return buf.toString();
 	}
 
 	public String readLine() {
 		String s = readLine0();
 		while (s.trim().length() == 0)
 			s = readLine0();
 		return s;
 	}
 
 	public String readLine(boolean ignoreEmptyLines) {
 		if (ignoreEmptyLines)
 			return readLine();
 		else
 			return readLine0();
 	}
 	
 	public String readToEnd() {
 		StringBuilder buf = new StringBuilder();
 		int c = read();
 		while (c != -1) {
 			if (c != '\r')
 				buf.appendCodePoint(c);
 			c = read();
 		}
 		return buf.toString();
 	}
 
 	public BigInteger readBigInteger() {
 		try {
 			return new BigInteger(readString());
 		} catch (NumberFormatException e) {
 			throw new InputMismatchException();
 		}
 	}
 
 	public char readCharacter() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		return (char) c;
 	}
 
 	public double readDouble() {
 		int c = read();
 		while (isSpaceChar(c))
 			c = read();
 		int sgn = 1;
 		if (c == '-') {
 			sgn = -1;
 			c = read();
 		}
 		double res = 0;
 		while (!isSpaceChar(c) && c != '.') {
 			if (c == 'e' || c == 'E')
 				return res * Math.pow(10, readInt());
 			if (c < '0' || c > '9')
 				throw new InputMismatchException();
 			res *= 10;
 			res += c - '0';
 			c = read();
 		}
 		if (c == '.') {
 			c = read();
 			double m = 1;
 			while (!isSpaceChar(c)) {
 				if (c == 'e' || c == 'E')
 					return res * Math.pow(10, readInt());
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				m /= 10;
 				res += (c - '0') * m;
 				c = read();
 			}
 		}
 		return res * sgn;
 	}
 
 	public boolean isExhausted() {
 		int value;
 		while (isSpaceChar(value = peek()) && value != -1)
 			read();
 		return value == -1;
 	}
 	
 	public void close() {
 		try {
 			stream.close();
 		} catch (IOException e) {
 			throw new RuntimeException();			
 		}
 	}
 }
 
 final class OutputWriter {
 	private final PrintWriter writer;
 
 	public OutputWriter(OutputStream outputStream) {
 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream), 1 << 13));
 	}
 
 	public OutputWriter(Writer writer) {
 		this.writer = new PrintWriter(writer);
 	}
 
 
 	public void print(Object... objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(Object... objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printFormat(String format, Object... objects) {
 		writer.printf(format, objects);
 	}
 
 
 	public void print(char[] objects) {
 		writer.print(objects);
 	}
 
 	public void printLine(char[] objects) {
 		writer.println(objects);
 	}
 
 	public void printLine(char[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(int[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(int[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(int[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(short[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(short[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(short[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(long[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(long[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(long[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(double[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(double[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(double[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(byte[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(byte[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(byte[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void print(boolean[] objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(boolean[] objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void printLine(boolean[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 	}
 
 
 	public void close() {
 		writer.close();
 	}
 
 	public void flush() {
 		writer.flush();
 	}
 }
 
 final class DebugWriter {
 	private final OutputWriter writer;
 
 	public DebugWriter(OutputWriter writer) {
 		this.writer = writer;
 	}
 
 	private void printDebugMessage() {
 		writer.print(""DEBUG:\t"");
 	}
 
 	public void printLine(Object... objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printFormat(String format, Object... objects) {
 		printDebugMessage();
 		writer.printFormat(format, objects);
 		flush();
 	}
 
 	public void printLine(char[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(char[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(double[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(double[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(int[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(int[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(short[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(short[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(long[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(long[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(byte[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(byte[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void printLine(boolean[] objects) {
 		printDebugMessage();
 		writer.printLine(objects);
 		flush();
 	}
 
 	public void printLine(boolean[][] objects) {
 		for (int i = 0; i < objects.length; ++i)
 			printLine(objects[i]);
 		flush();
 	}
 
 	public void flush() {
 		writer.flush();
 	}
 }
 
 final class ComparablePair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<ComparablePair<F, S>> {
 	public F first;
 	public S second;
 
 	public ComparablePair(F first, S second) {
 		this.first = first;
 		this.second = second;
 	}
 
 	public int compareTo(ComparablePair<F, S> o) {
 		int value = first.compareTo(o.first);
 		if (value != 0) return value;
 		return second.compareTo(o.second);
 	}
 
 	public int hashCode() {
 		int hFirst = first != null ? first.hashCode() : 0;
 		int hSecond = second != null ? second.hashCode() : 0;
 		return 31 * hFirst + hSecond;
 	}
 
 	public boolean equals(ComparablePair<F, S> pair) {
 		if (this == pair) return true;
 
 		return (first != null ? first.equals(pair.first) : pair.first == null) &&
 				(second != null ? second.equals(pair.second) : pair.second == null);
 	}
 
 	public ComparablePair<F, S> clone() {
 		return new ComparablePair<F, S>(first, second);
 	}
 
 	public String toString() {
 		return ""("" + first + "", "" + second + "")"";
 	}
 }
 
 final class SequenceUtils {
 	// swap
 	public final static <T> void swap(List<T> sequence, int j, int i) {
 		T tmp = sequence.get(j);
 		sequence.set(j, sequence.get(i));
 		sequence.set(i, tmp);
 	}
 
 	public final static <T> void swap(T[] sequence, int j, int i) {
 		T tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(int[] sequence, int j, int i) {
 		int tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(long[] sequence, int j, int i) {
 		long tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(char[] sequence, int j, int i) {
 		char tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(double[] sequence, int j, int i) {
 		double tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(boolean[] sequence, int j, int i) {
 		boolean tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(short[] sequence, int j, int i) {
 		short tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	public final static void swap(byte[] sequence, int j, int i) {
 		byte tmp = sequence[j];
 		sequence[j] = sequence[i];
 		sequence[i] = tmp;
 	}
 
 	// reverse
 	public final static <T> void reverse(List<T> sequence) {
 		for (int left = 0, right = sequence.size() - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static <T> void reverse(T[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(int[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(long[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(char[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(double[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(boolean[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(short[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	public final static void reverse(byte[] sequence) {
 		for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)
 			swap(sequence, left, right);
 	}
 
 	// next permutation
 	public final static <T extends Comparable<T>> boolean nextPermutation(List<T> sequence) {
 		for (int j = sequence.size() - 2; j >= 0; --j) {
 			if (sequence.get(j).compareTo(sequence.get(j + 1)) < 0) {
 				reverse(sequence.subList(j + 1, sequence.size()));
 				for (int i = j + 1; i < sequence.size(); ++i)
 					if (sequence.get(j).compareTo(sequence.get(i)) < 0) {
 						swap(sequence, j, i);
 						return true;
 					}
 			}
 		}
 		return false;
 	}
 
 	public final static <T> boolean nextPermutation(List<T> sequence, Comparator<T> comparator) {
 		for (int j = sequence.size() - 2; j >= 0; --j) {
 			if (comparator.compare(sequence.get(j), sequence.get(j + 1)) < 0) {
 				reverse(sequence.subList(j + 1, sequence.size()));
 				for (int i = j + 1; i < sequence.size(); ++i)
 					if (comparator.compare(sequence.get(j), sequence.get(i)) < 0) {
 						swap(sequence, j, i);
 						return true;
 					}
 			}
 		}
 		return false;
 	}
 
 	// random shuffle
 	public final static <T> void shuffle(List<T> sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.size(); ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static <T> void shuffle(T[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(int[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(long[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(char[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(double[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(boolean[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(short[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	public final static void shuffle(byte[] sequence) {
 		Random random = new Random(System.nanoTime());
 		for (int i = 1; i < sequence.length; ++i)
 			swap(sequence, random.nextInt(i + 1), i);
 	}
 
 	// merge sort
 	public final static <T extends Comparable<T>> void mergeSort(List<T> sequence) {
 		int n = sequence.size();
 		T[] tmp = (T[]) new Object[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence.get(i);
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static <T extends Comparable<T>> void merge(List<T> sequence, T[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence.set(i, tmp[pRight++]);
 			else if (pRight > right) sequence.set(i, tmp[pLeft++]);
 			else if (tmp[pLeft].compareTo(tmp[pRight]) <= 0) sequence.set(i, tmp[pLeft++]);
 			else sequence.set(i, tmp[pRight++]);
 	}
 
 
 	public final static <T extends Comparable<T>> void mergeSort(T[] sequence) {
 		int n = sequence.length;
 		T[] tmp = (T[]) new Object[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static <T extends Comparable<T>> void merge(T[] sequence, T[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft].compareTo(tmp[pRight]) <= 0) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static <T> void mergeSort(List<T> sequence, Comparator<T> comparator) {
 		int n = sequence.size();
 		T[] tmp = (T[]) new Object[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence.get(i);
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1), comparator);
 		}
 	}
 
 	private final static <T> void merge(List<T> sequence, T[] tmp, int left, int mid, int right, Comparator<T> comparator) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence.set(i, tmp[pRight++]);
 			else if (pRight > right) sequence.set(i, tmp[pLeft++]);
 			else if (comparator.compare(tmp[pLeft], tmp[pRight]) <= 0) sequence.set(i, tmp[pLeft++]);
 			else sequence.set(i, tmp[pRight++]);
 	}
 
 
 	public final static <T> void mergeSort(T[] sequence, Comparator<T> comparator) {
 		int n = sequence.length;
 		T[] tmp = (T[]) new Object[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1), comparator);
 		}
 	}
 
 	private final static <T> void merge(T[] sequence, T[] tmp, int left, int mid, int right, Comparator<T> comparator) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (comparator.compare(tmp[pLeft], tmp[pRight]) <= 0) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(int[] sequence) {
 		int n = sequence.length;
 		int[] tmp = new int[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(int[] sequence, int[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(long[] sequence) {
 		int n = sequence.length;
 		long[] tmp = new long[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(long[] sequence, long[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(char[] sequence) {
 		int n = sequence.length;
 		char[] tmp = new char[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(char[] sequence, char[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(double[] sequence) {
 		int n = sequence.length;
 		double[] tmp = new double[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(double[] sequence, double[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(boolean[] sequence) {
 		int n = sequence.length;
 		boolean[] tmp = new boolean[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(boolean[] sequence, boolean[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (!tmp[pLeft] || tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(short[] sequence) {
 		int n = sequence.length;
 		short[] tmp = new short[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(short[] sequence, short[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 
 	public final static void mergeSort(byte[] sequence) {
 		int n = sequence.length;
 		byte[] tmp = new byte[n];
 		for (int step = 1; step < n; step *= 2) {
 			for (int i = 0; i < n; ++i)
 				tmp[i] = sequence[i];
 			for (int i = 0; i + step < n; i += 2 * step)
 				merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));
 		}
 	}
 
 	private final static void merge(byte[] sequence, byte[] tmp, int left, int mid, int right) {
 		int pLeft = left;
 		int pRight = mid + 1;
 		for (int i = left; i <= right; ++i)
 			if (pLeft > mid) sequence[i] = tmp[pRight++];
 			else if (pRight > right) sequence[i] = tmp[pLeft++];
 			else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];
 			else sequence[i] = tmp[pRight++];
 	}
 
 	// quick sort
 	public final static <T extends Comparable<T>> void quickSort(List<T> sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.size() - 1);
 	}
 
 	private final static <T extends Comparable<T>> void quickSortImplementation(List<T> sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		T value = sequence.get(left);
 
 		while (i <= greaterThen) {
 			int cmp = sequence.get(i).compareTo(value);
 			if (cmp < 0) swap(sequence, i++, lessThen++);
 			else if (cmp > 0) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static <T extends Comparable<T>> void quickSort(T[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static <T extends Comparable<T>> void quickSortImplementation(T[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		T value = sequence[left];
 
 		while (i <= greaterThen) {
 			int cmp = sequence[i].compareTo(value);
 			if (cmp < 0) swap(sequence, i++, lessThen++);
 			else if (cmp > 0) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static <T> void quickSort(List<T> sequence, Comparator<T> comparator) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.size() - 1, comparator);
 	}
 
 	private final static <T> void quickSortImplementation(List<T> sequence, int left, int right, Comparator<T> comparator) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		T value = sequence.get(left);
 
 		while (i <= greaterThen) {
 			int cmp = comparator.compare(sequence.get(i), value);
 			if (cmp < 0) swap(sequence, i++, lessThen++);
 			else if (cmp > 0) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1, comparator);
 		quickSortImplementation(sequence, greaterThen + 1, right, comparator);
 	}
 
 
 	public final static <T> void quickSort(T[] sequence, Comparator<T> comparator) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1, comparator);
 	}
 
 	private final static <T> void quickSortImplementation(T[] sequence, int left, int right, Comparator<T> comparator) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		T value = sequence[left];
 
 		while (i <= greaterThen) {
 			int cmp = comparator.compare(sequence[i], value);
 			if (cmp < 0) swap(sequence, i++, lessThen++);
 			else if (cmp > 0) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1, comparator);
 		quickSortImplementation(sequence, greaterThen + 1, right, comparator);
 	}
 
 
 	public final static void quickSort(int[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(int[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		int value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(long[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(long[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		long value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(char[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(char[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		char value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(double[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(double[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		double value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(boolean[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(boolean[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		boolean value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (!sequence[i] && value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] && !value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(short[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(short[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		short value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 
 	public final static void quickSort(byte[] sequence) {
 		shuffle(sequence);
 		quickSortImplementation(sequence, 0, sequence.length - 1);
 	}
 
 	private final static void quickSortImplementation(byte[] sequence, int left, int right) {
 		if (left >= right) return;
 
 		int lessThen = left;
 		int greaterThen = right;
 		int i = left;
 		byte value = sequence[left];
 
 		while (i <= greaterThen) {
 			if (sequence[i] < value) swap(sequence, i++, lessThen++);
 			else if (sequence[i] > value) swap(sequence, i, greaterThen--);
 			else ++i;
 		}
 
 		quickSortImplementation(sequence, left, lessThen - 1);
 		quickSortImplementation(sequence, greaterThen + 1, right);
 	}
 
 	// unique
 	public static <T> ArrayList<T> unique(ArrayList<T> sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.size(); ++i)
 			if (!sequence.get(i).equals(sequence.get(i - 1)))
 				++size;
 
 		ArrayList<T> newSequence = new ArrayList<T>(size);
 		newSequence.add(sequence.get(0));
 
 		for (int i = 1; i < sequence.size(); ++i)
 			if (!sequence.get(i).equals(sequence.get(i - 1)))
 				newSequence.add(sequence.get(i));
 
 		return newSequence;
 	}
 
 	public static <T> T[] unique(T[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (!sequence[i].equals(sequence[i - 1]))
 				++size;
 
 		T[] newSequence = (T[]) new Object[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (!sequence[i].equals(sequence[i - 1]))
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static int[] unique(int[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		int[] newSequence = new int[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static long[] unique(long[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		long[] newSequence = new long[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static char[] unique(char[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		char[] newSequence = new char[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static double[] unique(double[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		double[] newSequence = new double[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static boolean[] unique(boolean[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		boolean[] newSequence = new boolean[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static short[] unique(short[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		short[] newSequence = new short[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 
 	public static byte[] unique(byte[] sequence) {
 		int size = 1;
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				++size;
 
 		byte[] newSequence = new byte[size];
 		newSequence[0] = sequence[0];
 		size = 0;
 
 		for (int i = 1; i < sequence.length; ++i)
 			if (sequence[i] != sequence[i - 1])
 				newSequence[++size] = sequence[i];
 
 		return newSequence;
 	}
 }
",1
245,6788,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 public class ProblemC {
     
     public void doOperation(String inputFile, String outFile) {
         try {
             List<String> input = readFileByLine(inputFile);
             List<String> output = new ArrayList<String>();
             int t = Integer.parseInt(input.get(0));
             for (int i = 0; i < t; i++) {
             	String[] str = input.get((2*i)+1).split("" "");
             	String[] str1 = input.get((2*i)+2).split("" "");
             	int n = Integer.parseInt(str[0]);
             	long l = Long.parseLong(str[1]);
             	long h = Long.parseLong(str[2]);
                 long[] numbers = new long [n];
                 for(int j=0; j<n;j++) {
                 	numbers[j] = Long.parseLong(str1[j]);
                 }
                 Arrays.sort(numbers);
                 long time = System.currentTimeMillis();
                 String result = calculate(numbers, l, h);
                 System.out.println(""Time for operation : ""+ (i+1) + "" = "" + (System.currentTimeMillis() - time));
                 output.add(""Case #""+(i+1)+"": "" + result);
             }
             writeOutputToFile(outFile, output);
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
     
     private String calculate(long[] numbers, long l, long h) {
 		long[] lcm = new long[numbers.length];
 		int i=0;
 		if(numbers[i]>h){}
 		else{
 		lcm[0] = numbers[i];
 		i++;
 		for(;i<numbers.length;i++) {
 			lcm[i] = lcm(lcm[i-1], numbers[i]);
 			if(lcm[i]>h){
 				lcm[i] = 0;
 				break;
 			}
 		}
 		}
 		long[] gcd = new long[numbers.length];
 		int j=numbers.length-1;
 		if(numbers[j]<l){}
 		else{
 		gcd[j] = numbers[j];
 		j--;
 		for(;j>=0;j--) {
 			gcd[j] = gcd(gcd[j+1], numbers[j]);
 			if(gcd[j]<l){
 				gcd[j] = 0;
 				break;
 			}
 		}
 		}
 		if(lcm[0]==0){
 			if(gcd[0]<=h && gcd[0]>=l ){
 				return Long.toString(gcd[0]);
 			} else if(gcd[0]<l) {
 				return ""NO"";
 			} else {
 				for(long z=h;z>=l;z--){
 					if((gcd[0]%z)==0){
 						return Long.toString(z);
 					}
 				}
 			}
 		}
 		if(gcd[numbers.length-1]==0){
 			if(lcm[numbers.length-1]<=h && lcm[numbers.length-1]>=l ){
 				return Long.toString(lcm[numbers.length-1]);
 			} else if(lcm[numbers.length-1]>h) {
 				return ""NO"";
 			} else {
 				if(lcm[numbers.length-1]==0){
 					return ""NO"";
 				}
 				for(long z=h;z>=l;z--){
 					if((z%lcm[numbers.length-1])==0){
 						return Long.toString(z);
 					}
 				}
 			}
 		}
 		for(int k=numbers.length-1;k>0;k--) {
 			if(gcd[k]==0 || lcm[k-1]==0){
 				continue;
 			}
 			if(gcd[k]>=lcm[k-1] && (gcd[k]%lcm[k-1])==0) {
 				if(gcd[k]<h){
 					return Long.toString(gcd[k]);
 				} else {
 					for(long z=h;z>=l;z--){
 						if((gcd[k]%z)==0 && (z%lcm[k-1])==0){
 							return Long.toString(z);
 						}
 					}
 				}
 			} else if(gcd[k]<lcm[k-1] && (lcm[k-1]%gcd[k])==0) {
 				for(long z=h;z>=l;z--){
 						if((lcm[k-1]%z)==0 && (z%gcd[k])==0 && (lcm[k-1]/z)==1 && (z/gcd[k])==1){
 							return Long.toString(z);
 						}
 					}
 			}
 		}
 		return ""NO"";
 	}
 
 	private long gcd(long f, long s) {
 		if (s == 0) {
 			return f;
 		}
 		return gcd(s, f % s);
 	}
 
 
 
 	private long lcm(long f, long s) {
 		return f*s/gcd(f,s);
 	}
 
     public static void main(String args[]) {
         if(args.length !=2) {
             System.out.println(""Incorrect number of args passed. Should pass input file and output file."");
         }
         String inputFile = args[0];
         String outFile = args[1];
         new ProblemC().doOperation(inputFile, outFile);
     }
 
     public List<String> readFileByLine(String fileName) {
         List<String> lines = new ArrayList<String>();
         try {
             FileInputStream fstream = new FileInputStream(fileName);
             DataInputStream in = new DataInputStream(fstream);
             BufferedReader br = new BufferedReader(new InputStreamReader(in));
             String strLine;
             while ((strLine = br.readLine()) != null) {
                 lines.add(strLine);
             }
             in.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
         return lines;
     }
 
     public void writeOutputToFile(String fileName, List<String> outLines) {
         try {
             FileWriter fstream = new FileWriter(fileName);
             BufferedWriter out = new BufferedWriter(fstream);
             for (int i = 0; i < outLines.size(); i++) {
                 if (i == outLines.size() - 1) {
                     out.write(outLines.get(i));
                 } else {
                     out.write(outLines.get(i) + ""\n"");
                 }
             }
             out.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.List;
 
 public class ProblemB {
     
     public void doOperation(String inputFile, String outFile) {
         try {
             List<String> input = readFileByLine(inputFile);
             List<String> output = new ArrayList<String>();
             int t = Integer.parseInt(input.get(0));
             for (int i = 1; i <= t; i++) {
                 String[] sts = input.get(i).split("" "");
                 int c = Integer.parseInt(sts[0]);
                 int d = Integer.parseInt(sts[c + 1]);
                 int n = Integer.parseInt(sts[c + d + 2]);
                 List<String> combineList = new ArrayList<String>(c);
                 for(int j=1; j<=c;j++) {
                 	combineList.add(sts[j]);
                 }
                 List<String> opposeList = new ArrayList<String>(c);
                 for(int j=c+2; j<=c+d+1;j++) {
                 	opposeList.add(sts[j]);
                 }
                 String actual = sts[c+d+3];
                 long time = System.currentTimeMillis();
                 String result = calculate(combineList,opposeList,actual);
                 System.out.println(""Time for operation : ""+ i + "" = "" + (System.currentTimeMillis() - time));
                 output.add(""Case #""+i+"": "" + result);
             }
             writeOutputToFile(outFile, output);
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
     
     
     private String calculate(List<String> combineList, List<String> opposeList, String actual) {
     	Hashtable<String, String> combineTable = new Hashtable<String, String>();
     	for(String str : combineList){
     		String str1 = str.substring(0, 1);
     		String str2 = str.substring(1, 2);
     		String str3 = str.substring(2, 3);
     		combineTable.put(str1+str2, str3);
     		combineTable.put(str2+str1, str3);
     	}
     	Hashtable<String, List<String>> opposeTable = new Hashtable<String, List<String>>();
     	for(String str : opposeList){
     		String str1 = str.substring(0, 1);
     		String str2 = str.substring(1, 2);
     		List<String> lst1 = opposeTable.get(str1);
     		if(lst1 == null) {
     			lst1 = new ArrayList<String>();
     		}
     		lst1.add(str2);
 			opposeTable.put(str1, lst1);
 			List<String> lst2 = opposeTable.get(str2);
     		if(lst2 == null) {
     			lst2 = new ArrayList<String>();
     		}
     		lst2.add(str1);
 			opposeTable.put(str2, lst2);
     	}
     	String newStr = """";
     	for(int i=0;i<actual.length();i++){
     		String str = actual.substring(i, i+1);
     		newStr = newStr + str;
     		while(true) {
     			if(newStr.length() < 2) {
     				break;
     			}
     			String str1 = newStr.substring(newStr.length() - 2);
     			String replaceString = combineTable.get(str1);
     			if(replaceString==null){
     				break;
     			} else {
     				newStr = newStr.substring(0, newStr.length() - 2) + replaceString;
     			}
     		}
     		String str1 = newStr.substring(newStr.length() - 1);
     		List<String> oppose = opposeTable.get(str1);
     		if(oppose!=null) {
     			for(String test : oppose) {
     				if(newStr.contains(test)) {
     					newStr = """";
     				}
     			}
     		}
     	}
     	String retStr = ""["";
     	for(int i=0;i<newStr.length();i++){
     		retStr += newStr.substring(i, i+1);
     		if(i!=(newStr.length()-1)) {
     			retStr += "", "";
     		}
     	}
     	retStr += ""]"";
     	return retStr;
     }
 
 
     public static void main(String args[]) {
         if(args.length !=2) {
             System.out.println(""Incorrect number of args passed. Should pass input file and output file."");
         }
         String inputFile = args[0];
         String outFile = args[1];
         new ProblemB().doOperation(inputFile, outFile);
     }
 
     public List<String> readFileByLine(String fileName) {
         List<String> lines = new ArrayList<String>();
         try {
             FileInputStream fstream = new FileInputStream(fileName);
             DataInputStream in = new DataInputStream(fstream);
             BufferedReader br = new BufferedReader(new InputStreamReader(in));
             String strLine;
             while ((strLine = br.readLine()) != null) {
                 lines.add(strLine);
             }
             in.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
         return lines;
     }
 
     public void writeOutputToFile(String fileName, List<String> outLines) {
         try {
             FileWriter fstream = new FileWriter(fileName);
             BufferedWriter out = new BufferedWriter(fstream);
             for (int i = 0; i < outLines.size(); i++) {
                 if (i == outLines.size() - 1) {
                     out.write(outLines.get(i));
                 } else {
                     out.write(outLines.get(i) + ""\n"");
                 }
             }
             out.close();
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 
 }
",1
246,16166,"import java.io.*;
 import java.util.*;
 import static java.lang.System.*;
 
 public class A {
 	public static void main (String [] args) throws IOException {new A().run();}
 	public void run() throws IOException{
 		Scanner file = new Scanner(new File(""A-small-attempt0.in.txt""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""A.out"")));
 		int T = file.nextInt();
         for(int asdf = 0; asdf<T; asdf++){
             out.printf(""Case #%d: "",asdf+1);
             TreeSet<Integer> set = new TreeSet<Integer>(), set2 = new TreeSet<Integer>();
             for(int k = 0, row = file.nextInt(); k<2; k++){
                 for(int i = 0; i<4; i++)
                     for(int j = 0; j<4; j++)
                         if( i == row-1){
                             if( k == 0) set.add(file.nextInt());
                             else set2.add(file.nextInt());
                         }else file.nextInt();
                 if( k == 0)
                     row = file.nextInt();
             }
             set.retainAll(set2);
             if( set.isEmpty())out.println(""Volunteer cheated!"");
             else if( set.size() > 1 )out.println(""Bad magician!"");
             else out.println(set.iterator().next());
         }
 		out.close();
 	}
 }","package round1a;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.text.DecimalFormat;
 
 public class ProblemA {
 
 	public ProblemA() {
 		try {
 			FileReader fr = new FileReader(""A-small-attempt0.in"");
 			BufferedReader br = new BufferedReader(fr);
 			
 			FileWriter fw = new FileWriter(""A-small-attempt0.out"");
 			BufferedWriter bw = new BufferedWriter(fw);
 			
 			int numCases = Integer.parseInt(br.readLine());
 			String line = br.readLine();
 			int caseNum = 1;
 			while(line != null) {
 				String[] nums = line.split("" "");
 				String[] probs = br.readLine().split("" "");
 				
 				int typedSoFar = Integer.parseInt(nums[0]);
 				int totalLength = Integer.parseInt(nums[1]);
 				
 				// press enter and type again and press enter again
 				double minKeyStrokes = totalLength + 2;
 				
 				for(int backspaces = 0; backspaces <= typedSoFar; backspaces++) {
 					double expectedStrokes = 0.0;
 					
 					double probDidntMiss = 1;
 					
 					for (int i=0; i<typedSoFar-backspaces; i++) {
 						double digitCorrectProb = Double.parseDouble(probs[i]);
 						
 						probDidntMiss *= digitCorrectProb;
 					}
 					
 					// now we have the probabilty we backspaced but missed before
 					
 					// if we missed
 					expectedStrokes += (1 - probDidntMiss) * 
 							(backspaces + backspaces + totalLength + 2 + totalLength - typedSoFar);
 					
 					// if we got it!
 					expectedStrokes += (probDidntMiss) * (backspaces + backspaces + 1 + totalLength - typedSoFar);
 					
 					System.out.println(""trying ""+backspaces+ "" backspaces"");
 					System.out.println(probDidntMiss + "" prob we didnt miss"");
 					System.out.println(expectedStrokes + "" expected strokes"");
 					
 					minKeyStrokes = Math.min(minKeyStrokes, expectedStrokes);
 				}
 				
 				DecimalFormat df = new DecimalFormat(""#.000000"");
 				
 				String output = ""Case #""+caseNum + "": ""+ df.format(minKeyStrokes);
 				
 				System.out.println(output);
 				
 				bw.append(output);
 				if (caseNum != numCases)
 					bw.newLine();
 				
 				line = br.readLine();
 				caseNum++;
 			}
 			
 			bw.flush();
 			bw.close();
 			br.close();
 			
 			
 		} catch(Exception e) {
 			e.printStackTrace();
 		}
 	}
 	
 	public static void main(String[] args) {
 		new ProblemA();
 	}
 
 }
",0
247,1290,"import  java.io.* ;
 import java.util.Scanner;
 import java.util.ArrayList;
 
 
 public class GCJ_B {
 
     static double getResult(double c, double f, double x) {
 
         double cookiesRate = 2.0;
         double targetTime = x / cookiesRate;
         double farmTime = 0.0;
 
         double tempTime = 0.0;
 
         while (true) {
 
             farmTime += c / cookiesRate;
 
             if (farmTime > targetTime) {
                 break;
             }
 
             cookiesRate += f;
 
             tempTime = farmTime + (x / cookiesRate);
 
             if (tempTime > targetTime) {
                 break;
             }
                 
             targetTime = tempTime;
  
 
         }
 
 
         return targetTime;
 
     }
 
 
 	public static void main(String[] args){
 	
         PrintWriter out;
 		try{
 
 			Scanner sc = new Scanner(new File(""B-small-attempt0.in""));
 			//Scanner sc = new Scanner(new File(""test.txt""));
 
             out = new PrintWriter(""small_out.txt"");
             //out = new PrintWriter(""large_out.txt"");
 
             
 
 			int row_counter = 0;
 			row_counter = Integer.valueOf(sc.nextLine());
 			System.out.println(row_counter);
 			
 			
 			double C;
             double F;
             double X;
 
             int index = 1;
 			while(sc.hasNextLine()){
 				String phrase = sc.nextLine();
 	
                 String[] tokens = phrase.split("" "");
 
                 C = Double.valueOf(tokens[0]);
                 F = Double.valueOf(tokens[1]);
                 X = Double.valueOf(tokens[2]);
 
                 //System.out.println(phrase);
 
                 //System.out.println(C + "" "" + F + "" "" + X);
                 double res = getResult(C, F, X);
 
                 System.out.println(""Case #"" + index + "": "" + res);
                 out.println(""Case #"" + index + "": "" + res);
                 index++;
 			}
             out.close();
 			
 		}catch(Exception e){
 		
 		}
 	}
 
 }","import  java.io.* ;
 import java.util.Scanner;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 
 
 public class GCJ_D {
 
     static int getResult(double[] naomi, double[] ken, int type) {
 
         int indexStart = 0;
         int indexEnd = naomi.length - 1;
         int res = 0;
 
         if (type == 0) {
             
             for (int i = naomi.length - 1 ; i >= 0 ; i--) {
                 double n = naomi[i];
 
                 if (ken[indexEnd] > n) {
                     indexEnd--;
                 } else {
                     res++;
                 }
 
             }
 
 
         } else {
 
             for (int i = ken.length - 1 ; i >= 0 ; i--) {
                 double n = ken[i];
 
                 if (naomi[indexEnd] > n) {
                     res++;
                     indexEnd--;
                 } else {
                     //indexEnd--;
                 }
 
             }
 
         }
 
         //System.out.println(res);
 
         return res;
     }
 
 
 	public static void main(String[] args){
 	
         String naomiStr[] = new String[0];
         String kenStr[] = new String[0];
 
         double naomiNormal[];
         double kenNormal[];
 
         double naomiDeceitful[];
         double kenDeceitful[];
 
         PrintWriter out;
 
 		try{
 
             Scanner sc = new Scanner(new File(""D-small-attempt0.in""));
             //Scanner sc = new Scanner(new File(""D-large.in""));
 
             //Scanner sc = new Scanner(new File(""test.txt""));
 
             out = new PrintWriter(""small_out.txt"");
             //out = new PrintWriter(""large_out.txt"");
 
             
 
             int row_counter = 0;
             row_counter = Integer.valueOf(sc.nextLine());
             System.out.println(row_counter);
 
 
             for (int index = 1 ; index <= row_counter ; index++) {
                 int arrCount = Integer.valueOf(sc.nextLine());
 
                 naomiNormal = new double[arrCount];
                 kenNormal = new double[arrCount];
                 naomiDeceitful = new double[arrCount];
                 kenDeceitful = new double[arrCount];
                 
                 String line = sc.nextLine();
                 naomiStr = line.split("" "");
 
                 for (int i = 0 ; i < arrCount ; i++) {
                     naomiNormal[i] = Double.valueOf(naomiStr[i]);
                     naomiDeceitful[i] = Double.valueOf(naomiStr[i]);
 
                 }
                 Arrays.sort(naomiNormal);
                 Arrays.sort(naomiDeceitful);
 
 
                 line = sc.nextLine();
                 kenStr = line.split("" "");
 
                 for (int i = 0 ; i < arrCount ; i++) {
                     kenNormal[i] = Double.valueOf(kenStr[i]);
                     kenDeceitful[i] = Double.valueOf(kenStr[i]);
 
                 }
                 Arrays.sort(kenNormal);
                 Arrays.sort(kenDeceitful);
 
 
                 int normal = getResult(naomiNormal, kenNormal, 0);
                 int deceitful = getResult(naomiDeceitful, kenDeceitful, 1);
 
 
                 // for (int i = 0 ; i < naomiNormal.length ; i++) {
                 //     System.out.print(naomiNormal[i] + "" "");
                 //     System.out.print(naomiDeceitful[i] + "" "");
 
                 // }
                 // System.out.println();
                 // for (int i = 0 ; i < kenNormal.length ; i++) {
                 //     System.out.print(kenNormal[i] + "" "");
                 //     System.out.print(kenDeceitful[i] + "" "");
 
                 // }
                 // System.out.println();
 
                 // System.out.println(""------------------------------"");
 
 
 
                 System.out.println(""Case #"" + index + "": "" + deceitful + "" "" + normal);
                 out.println(""Case #"" + index + "": "" + deceitful + "" "" + normal);
 
             }
 
             out.close();
             
         }catch(Exception e){
         
         }
 
 	}
 
 }",1
248,577,"
 import java.io.*;
 import java.util.*;
 
 public class CodeJam2012_Q_D {
 
 	public int calc(int H, int W, int D, String[] mirror) {
 		int[][] seen = new int[D*2+1][D*2+1];
 		int sx=0,sy=0;
 		for(int i=0; i<D*2+1; i++)
 			Arrays.fill(seen[i], -1);
 		
 		boolean[][] m = new boolean[H][W];
 		for(int i=0; i<H; i++) {
 			if(mirror[i].indexOf('X')>=0) {
 				sx = mirror[i].indexOf('X');
 				sy = i;
 			}
 			for(int j=0; j<W; j++) {
 				if(mirror[i].charAt(j)=='#') m[i][j] = true;
 			}
 		}
 		
 		for(int y=-D; y<=D; y++) {
 			for(int x=-D; x<=D; x++) {
 				if(y*y+x*x>D*D || (x==0 && y==0)) {
 					seen[y+D][x+D] = 0;
 				}
 				if(seen[y+D][x+D]!=-1) continue;
 				
 				int gcd = Math.abs(gcd(x, y));
 				int dx = x/gcd;
 				int dy = y/gcd;
 				int unit = dx*dy==0? 2:Math.abs(dx*dy)*2;
 				int cellx = sx;
 				int celly = sy;
 				int lx = unit/2;
 				int ly = unit/2;
 				int pathMax = x==0? y*unit/dy : x*unit/dx;
 				int pathCnt = 0;
 				while(pathCnt<pathMax) {
 					pathCnt++;
 					lx += dx;
 					ly += dy;
 					int nx, ny, ndx, ndy, nlx, nly;
 					if(celly==sy && cellx==sx && ly==unit/2 && lx==unit/2) {
 						//return to start point
 						seen[y+D][x+D]=1;
 						dx = x/gcd;
 						dy = y/gcd;
 						for(int d=1; -D<=y+d*dy && y+d*dy<=D && -D<=x+d*dx && x+d*dx<=D; d++) {
 							seen[y+d*dy+D][x+d*dx+D]=0;
 						}
 						break;
 					}
 					nx=cellx;
 					ny=celly;
 					ndx=dx;
 					ndy=dy;
 					nlx=lx;
 					nly=ly;
 					if(ly%unit==0 && lx%unit==0) {
 						if(m[celly + (dy>0?1:-1)][cellx + (dx>0?1:-1)]) {
 							//hit a corner
 							if(!m[celly + (dy>0?1:-1)][cellx] && !m[celly][cellx + (dx>0?1:-1)]) break;
 							
 							//reflected with horizontal mirror
 							if(m[celly + (dy>0?1:-1)][cellx]) {
 								ndy = -dy;
 							} else {
 								ny = celly+(dy>0?1:-1);
 								nly = ly==0?unit:0;
 							}
 							
 							//reflected with vertical mirror
 							if(m[celly][cellx + (dx>0?1:-1)]) {
 								ndx = -dx;
 							} else {
 								nx = cellx+(dx>0?1:-1);
 								nlx = lx==0?unit:0;
 							}
 							
 						} else {
 							nx = cellx+(dx>0?1:-1);
 							ny = celly+(dy>0?1:-1);
 							nlx = lx==0?unit:0;
 							nly = ly==0?unit:0;
 						}
 					} else if(ly%unit==0) {
 						//reflected with horizontal mirror
 						if(m[celly + (dy>0?1:-1)][cellx]) {
 							ndy = -dy;
 						} else {
 							ny = celly+(dy>0?1:-1);
 							nly = ly==0?unit:0;
 						}
 
 					} else if(lx%unit==0) {
 						//reflected with vertical mirror
 						if(m[celly][cellx + (dx>0?1:-1)]) {
 							ndx = -dx;
 						} else {
 							nx = cellx+(dx>0?1:-1);
 							nlx = lx==0?unit:0;
 						}
 					}
 					cellx=nx;
 					celly=ny;
 					dx=ndx;
 					dy=ndy;
 					lx=nlx;
 					ly=nly;
 				}
 				if(seen[y+D][x+D]==-1) seen[y+D][x+D]=0;
 			}
 		}
 		
 		int cnt=0;
 		for(int[] s1 : seen)
 			for(int s2 : s1)
 				cnt += s2;
 		return cnt;
 	}
 	
 	public int gcd(int a, int b) {
 		return b==0? a : gcd(b, a%b);
 	}
 	
 	public static void main(String[] args) {
 		try{
 //			(new CodeJam2012_Q_D()).exec(""D-small-attempt0.in"", ""2012_Q_D-small.out"");
 			(new CodeJam2012_Q_D()).exec(""D-large.in"", ""2012_Q_D-large.out"");
 			}catch(Exception ex) {
 				
 			}
 	}
 
 	public final void exec(String inFileName, String outFileName) throws Exception{
 		BufferedReader	inReader	= new BufferedReader(new FileReader(inFileName));
 		PrintWriter		outWriter	= new PrintWriter(new BufferedWriter(new FileWriter(outFileName)));
 		int caseNums=0;
 		caseNums = Integer.parseInt(inReader.readLine());
 		
 		for(int i=0; i<caseNums; i++) {
 			String[] input = inReader.readLine().split("" "");
 			int H = Integer.valueOf(input[0]);
 			int W = Integer.valueOf(input[1]);
 			int D = Integer.valueOf(input[2]);
 			String[] mirror = new String[H];
 			for(int j=0; j<H; j++) {
 				mirror[j] = inReader.readLine();
 			}
 			int outStr = calc(H, W, D, mirror);
 
 			String fmtOutStr=""Case #"" + (i+1) + "": "" + outStr;	
 			outWriter.println(fmtOutStr);
 			System.out.println(fmtOutStr);
 		}
 		System.out.println(caseNums + "" cases complete"");
 
 		outWriter.close();
 		inReader.close();
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class A {
 	Scanner sc;
 	PrintWriter pw;
 	long budget;
 	int N;
 	long[] X;
 	
 	public static void main(String[] args) throws Exception{
 		String filePrefix = args.length>0?args[0]:""A-small-attempt2"";
 
 		try {
 			new A().run(filePrefix);
 		} catch(Exception e) {
 			System.err.println(""file read error"");
 		}
 	}
 	
 	public void run(String filePrefix) throws Exception {
 		sc = new Scanner(new FileReader(filePrefix + "".in""));
 		pw = new PrintWriter(new FileWriter(filePrefix + "".out""));
 		int ntest = sc.nextInt();
 		for(int test=1; test<=ntest; test++) {
 			read(sc);
 			pw.print(""Case #"" + test + "": "");
 			System.out.print(""Case #"" + test + "": "");
 			solve();
 		}
 		System.out.println(""Finished."");
 		sc.close();
 		pw.close();
 		
 	}
 	
 	void read(Scanner sc) {
 		budget = sc.nextLong();
 		N = sc.nextInt();
 		X = new long[N];
 		for(int i=0; i<N; i++) {
 			X[i] = sc.nextLong();
 		}
 	}
 	
 	void print(Object s) {
 		pw.print(s);
 		System.out.print(s);
 	}
 	
 	void println(Object s) {
 		pw.println(s);
 		System.out.println(s);
 	}	
 	
 	public void solve() {
 		long[] Y = new long[37];
 		for(int i=0; i<N; i++)
 			Y[i] = X[i];
 		Arrays.sort(Y);
 		
 		double max=0;
 		long last=0;
 		for(int i=0; i<=36; i++) {
 			if(Y[i]>last) {
 				if(i>0) {
 					long need = 0;
 					for(int j=0; j<i; j++)
 						need += last-Y[j];
 					
 					long rest = budget-need;
 					if(rest<i)
 						break;
 					long minbet = Math.min(Y[i]-last-1, rest/i);
 					if(minbet>0)
 						max = Math.max(max, (need+minbet*i)*36.0/i - (need+minbet*i));
 					if(rest>=(Y[i]-last)*i) {
 						int j=i;
 						while(j<=36 && Y[i]==Y[j])
 							j++;
 						
 						max = Math.max(max, (need+(Y[i]-last)*i)*36.0/j - (need+(Y[i]-last)*i));
 					}
 				}
 				last = Y[i];
 			}
 		}
 		
 		println(max);
 	}
 }
",1
249,16739,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 
 public class MagicTrick {
 	public static void main(String args[]) {
 		String in1 = """", in2 = """", in3 = """", in4 = """", in5 = """", in6 = """", in7 = """",
 				in8 = """";
 		int testCases=0;
 		int row1 = 0, row2 = 0;
 		int matrix1[][] = new int[4][4];
 		int matrix2[][] = new int[4][4];
 		try {
 			BufferedReader bf = new BufferedReader(new FileReader(""git.txt""));
 			 testCases = Integer.parseInt(bf.readLine());
 			for (int j = 0; j < testCases; j++) {
 				row1 = Integer.parseInt(bf.readLine());
 				in1 = bf.readLine();
 				in2 = bf.readLine();
 				in3 = bf.readLine();
 				in4 = bf.readLine();
 				
 				String strArray1[] = in1.split("" "");
 				String strArray2[] = in2.split("" "");
 				String strArray3[] = in3.split("" "");
 				String strArray4[] = in4.split("" "");
 
 				for (int i = 0; i < 4; i++) {
 					matrix1[0][i] = Integer.parseInt(strArray1[i]);
 					matrix1[1][i] = Integer.parseInt(strArray2[i]);
 					matrix1[2][i] = Integer.parseInt(strArray3[i]);
 					matrix1[3][i] = Integer.parseInt(strArray4[i]);
 				}
 				row2 = Integer.parseInt(bf.readLine());
 				in5 = bf.readLine();
 				in6 = bf.readLine();
 				in7 = bf.readLine();
 				in8 = bf.readLine();
 				
 				
 				String strArray5[] = in5.split("" "");
 				String strArray6[] = in6.split("" "");
 				String strArray7[] = in7.split("" "");
 				String strArray8[] = in8.split("" "");
 
 				for (int i = 0; i < 4; i++) {
 					matrix2[0][i] = Integer.parseInt(strArray5[i]);
 					matrix2[1][i] = Integer.parseInt(strArray6[i]);
 					matrix2[2][i] = Integer.parseInt(strArray7[i]);
 					matrix2[3][i] = Integer.parseInt(strArray8[i]);
 				}
 				int row11 = --row1;
 				int row22 = --row2;
 				int counter = 0;
 				int card = 0;
 				int selected = 0;
 				for(int i=0;i<4;i++){
 					card = matrix1[row11][i];
 					for(int k=0;k<4;k++){
 						if(card == matrix2[row22][k]){
 							counter++;
 							selected = card;
 						}
 						
 					}
 					
 				}
 				if(counter == 0){
 					System.out.println(""Case #""+(1+j)+"": ""+""Volunteer cheated!"");
 				}
 				else if(counter == 1){
 					System.out.println(""Case #""+(1+j)+"": ""+selected);
 					
 				}
 				else{
 					System.out.println(""Case #""+(1+j)+"": ""+""Bad magician!"");
 					
 				}
 				
 			}
 
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		
 
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 
 
 public class C {
 
 	public static void main(String args[]) {
 
 		try {
 			BufferedReader bf = new BufferedReader(new FileReader(""hello.in""));
 
 			int testCases = Integer.parseInt(bf.readLine());
 			for (int x = 0; x < testCases; x++) {
 				int inputs[] = stringToIntArray(bf.readLine());
 				
 				int A = inputs[0];
 				int B = inputs[1];
 				int C = inputs[2];
 				int counter = 0;
 				for(int i=0;i<A;i++){
 					String AA = Integer.toBinaryString(A);
 					for(int j=0;j<B;j++){
 						String BB = Integer.toBinaryString(B);
 						int c = i & j;
 						if(c < C){
 							//System.out.println(Integer.toBinaryString(i)+""  ""+Integer.toBinaryString(j)+""  ""+""  ""+Integer.toBinaryString(c)+""  =  ""+Integer.toBinaryString(C));
 							counter++;
 						}
 						
 						
 						
 						
 					}
 				//	System.out.println();
 					
 				}
 				System.out.println(""Case #""+(1+x)+"": ""+counter);
 				
 				
 
 			}
 			bf.close();
 
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 	public static int[] stringToIntArray(String input){
 		String strArray[] = input.split("" "");
 		int intArray[] = new int[strArray.length];
 		for(int i=0;i < strArray.length; i++){
 			intArray[i] = Integer.parseInt(strArray[i]);
 		}
 		return intArray;
 	}
 	public static void printIntArray(int array[]){
 		for(int i=0;i<array.length;i++){
 			
 			System.out.println(i);
 		}
 	}
 	public static void print2DIntArray(int array[][]){
 		for(int i=0;i<array.length;i++){
 			for(int j=0;j<array[i].length; j++){
 				System.out.print(i);
 			}
 			System.out.println();
 		}
 	}
 	public static void printStrArray(int array[]){
 		for(int i=0;i<array.length;i++){
 			
 			System.out.println(i);
 		}
 	}
 	public static void print2DStrArray(String array[][]){
 		for(int i=0;i<array.length;i++){
 			for(int j=0;j<array[i].length; j++){
 				System.out.print(i);
 			}
 			System.out.println();
 		}
 	}
 
 }
",1
250,13048,"package codejams;
 
 import java.io.BufferedReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
 
 public class Repeater {
 
 	public Repeater() {
 
 	}
 
 	public void testCase(BufferedReader br, PrintWriter pw) {
 		try {
 			int i = Integer.parseInt(br.readLine());
 
 
 			String str = br.readLine();
 			String pattern = str.charAt(0)+""+"";
 			for (int b = 1;b < str.length();b++) {
 				if (str.charAt(b) != str.charAt(b-1)) {
 					pattern = pattern+str.charAt(b)+""+"";
 				}
 			}
 			
 			if (Main.debug) System.out.println(pattern);
 
 			int l = pattern.length()/2;
 			int[][] count = new int[i][l];
 
 			for (int a = 0;a < i;a++) {
 				if (a > 0) 	str = br.readLine();
 				if (!str.matches(pattern)) {
 					pw.print(""Fegla Won"");
 					return;
 				}
 				int d = 0;
 				count[a][d]++;
 
 				for (int b = 1;b < str.length();b++) {
 					if (str.charAt(b) != str.charAt(b-1)) {
 						d++;
 					}
 					count[a][d]++;
 				}
 
 			}
 			
 			int[] s = new int[i];
 			
 			int r = 0;
 			for (int a = 0;a < l;a++) {
 				for (int b = 0;b < i;b++) {
 					s[b] = count[b][a];
 					System.out.print(count[b][a]);
 				}
 				System.out.print(""\n"");
 				Arrays.sort(s);
 				int mid = i/2;
 				for (int b = 0;b < i;b++) {
 					r += Math.abs(s[b]-s[mid]);
 				}
 				System.out.println(r);
 
 			}
 			pw.print(r);
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 }","package codejams;
 
 import java.io.BufferedReader;
 import java.io.PrintWriter;
 
 public class Magic {
 	
 	public Magic() {
 		
 	}
 	
 	public void testCase(BufferedReader br, PrintWriter pw) {
 		try {
 			int firstRow = Integer.parseInt(br.readLine()) - 1;
 			String[][] firstGrid = new String[4][4];
 			firstGrid[0] = br.readLine().split("" "");
 			firstGrid[1] = br.readLine().split("" "");
 			firstGrid[2] = br.readLine().split("" "");
 			firstGrid[3] = br.readLine().split("" "");
 			int secondRow = Integer.parseInt(br.readLine()) - 1;
 			String[][] secondGrid = new String[4][4];
 			secondGrid[0] = br.readLine().split("" "");
 			secondGrid[1] = br.readLine().split("" "");
 			secondGrid[2] = br.readLine().split("" "");
 			secondGrid[3] = br.readLine().split("" "");		
 			
 			String r = null;
 			for (String i : firstGrid[firstRow]) {
 				for (String j : secondGrid[secondRow]) {
 					if (Main.debug) System.out.println(""."" + i + ""."" + j + ""."");
 					if (i.equals(j)) {
 						if (Main.debug) System.out.println(""match!"");
 						if (r != null) {
 							pw.print(""Bad magician!"");
 							return;
 						}
 						r = j;
 					}
 				}
 			}
 			if (r == null) {
 				pw.print(""Volunteer cheated!"");
 				return;
 			}
 			pw.print(r);
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 	
 }",1
251,726,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class lawnmower
 {
 	private static final String newline = System.getProperty(""line.separator"");
 
 	//***Customise to any meaningful names
 	//Reading states
 	private static final int READING_AMOUNT_TEST_CASES = 1;
 	private static final int READING_ROWS_AMOUNT = 2;
 	private static final int READING_COLUMNS_AMOUNT = 3;
 	private static final int READING_CASE_ROWS = 4;
 	
 	public static void main(String[] args) throws IOException
 	{
 		//System.out.println(""Start!"");
 
 		//***Customise if more than 1 argument
 		//Read Input
 		if (args.length != 1)
 		{
 			//System.out.println(args.length);
 			return;
 		}
 
 		//System.out.println(""1 Argument!"");
 
 		String filePath = args[0];
 		File inputFile = new File(filePath);
 
 		if (!inputFile.exists())
 		{
 			return;
 		}
 
 		//System.out.println(""FileExists!"");
 
 		int readingState;
 
 		if (!inputFile.canRead())
 		{
 			return;
 		}
 
 		//System.out.println(""File can be read!"");
 		
 
 		//READ INPUT FILE--------------------------------------------------------------------
 
 		//***Customise to any variables needed
 		//Variables to initialise and useful outside Reading phase
 		int amountTestCases = 0;
 				
 		
 		//***Customise to any objects needed to be feed during Reading
 		//Objects to be feed during Reading phase
 		String[] testCase = new String [0];
 		
 		boolean[] solutions = new boolean[0];
 		
 		
 		//Declaration of objects required for Reading
 		FileReader inputStream = null;
 		BufferedReader aBufferedReader = null;
 		Scanner scannerObject = null;	
 		
 		try  //Reading
 		{
 			//Initialise objects in charge of reading File
 			inputStream = new FileReader(inputFile);
 			aBufferedReader = new BufferedReader(inputStream);
 			scannerObject = new Scanner(aBufferedReader);
 			
 			//***Customise to any variables needed
 			//Useful variables during Reading Phase
 			int inputInteger = -1;
 			int rows_counter = 0;
 			int testCaseCounter = 0;
 			int amount_rows = 0;
 			int amount_colums = 0;
 			
 			//Initial Reading State
 			readingState = READING_AMOUNT_TEST_CASES;
 
 			//***Customise ""While"" block to meet requirements
 			while (scannerObject.hasNext())
 			{
 				String nextReadThing = """";
 				String nextReadLine = """";	
 
 				switch (readingState)
 				{
 					case READING_AMOUNT_TEST_CASES:
 						nextReadThing = scannerObject.next();
 						inputInteger = Integer.parseInt(nextReadThing);
 						amountTestCases = inputInteger;
 						
 						solutions = new boolean[amountTestCases];
 
 						readingState = READING_ROWS_AMOUNT;
 						break;
 						
 					case READING_ROWS_AMOUNT:
 						nextReadThing = scannerObject.next();
 						inputInteger = Integer.parseInt(nextReadThing);
 												
 						amount_rows = inputInteger;
 						testCase = new String[amount_rows];
 						
 						readingState = READING_COLUMNS_AMOUNT;
 						break;
 						
 					case READING_COLUMNS_AMOUNT:
 						nextReadThing = scannerObject.next();
 						inputInteger = Integer.parseInt(nextReadThing);
 						
 						amount_colums = inputInteger;
 					
 						readingState = READING_CASE_ROWS;
 					    break;
 
 					case READING_CASE_ROWS:
 						nextReadLine = scannerObject.nextLine();						
 						
 						if(nextReadLine.length() > 0)
 						{
 							String row = nextReadLine;
 							testCase[rows_counter] = row;
 							rows_counter++;
 							
 							if(rows_counter == amount_rows)
 							{
 								solutions[testCaseCounter] = processTestCase(testCase);
 								testCaseCounter++;
 								rows_counter = 0;
 								readingState = READING_ROWS_AMOUNT;
 							}						
 							
 						}//if(nextReadLine.length() > 0)						
 
 						break;
 				}//switch (readingState) 	   
 			}
 		}
 		catch (IOException e)
 		{
 			System.out.println(e.getMessage());
 		}
 		finally
 		{
 			//***Clean up some objects if required
 			//memberHashMap = null;
 
 			if (scannerObject != null)
 			{
 				scannerObject.close();
 			}
 
 			if (aBufferedReader != null)
 			{
 				aBufferedReader.close();
 			}
 
 			if (inputStream != null)
 			{
 				inputStream.close();
 			}
 		}//finally	
 			
 		
 		//Processing
 					
 				
 		//Output
 		//Remember not to print a new line at the end of the last line
 		String newLineCharacter = newline;
 		
 		//output solution
 		for(int i=0; i<amountTestCases; i++)
 		{
 			if(i == amountTestCases-1)
 			{
 				newLineCharacter = """";
 			}
 			
 			int currentTestCase = i + 1;
 			
 			//String currentSolution = solutions[i];
 			
 			String currentSolution = ""NO"";
 			
 			if(solutions[i])
 			{
 				currentSolution = ""YES"";
 			}
 			
 			String currentOutputLine = """";			
 			
 			currentOutputLine = ""Case #"" + currentTestCase + "": "" + currentSolution + newLineCharacter;
 			System.out.print(currentOutputLine);			
 		}//for(int i=0; i<amountTestCases; i++)
 
 			
 
 		//System.out.print(""End!"");		
 
 	}//public static void main(String[] args) throws IOException
 	
 	
 	private static boolean processTestCase(String[] testCase)
 	{
 		boolean isPossible = true;
 		
 		int rows_amount = testCase.length;
 		
 		String[] checker = testCase[0].split("" "");
 		int colums_amount = checker.length;
 		
 		String[][] str_testCase = new String [rows_amount][colums_amount];
 		
 		for(int i=0; i<rows_amount; i++)
 		{
 			str_testCase[i] = testCase[i].split("" "");
 		}	
 		
 		int[][] int_testCase = new int [rows_amount][colums_amount];
 		
 		for(int i=0; i<rows_amount; i++)
 		{
 			for(int j=0; j<colums_amount; j++)
 			{
 				int_testCase[i][j] = Integer.parseInt(str_testCase[i][j]); 
 			}
 		}		
 		
 		isPossible = studyCase(int_testCase);
 				
 		return isPossible;	
 	}//private static boolean processTestCase(String[] testCase)
 	
 	
 	private static boolean studyCase(int[][] int_testCase)
 	{
 		boolean isPossible = true;
 		
 		for(int i=0; i<int_testCase.length;i++) //rows
 		{
 			int[] row = int_testCase[i];
 			
 			for(int j=0; j<row.length;j++) //colums
 			{
 				if(wayOut(int_testCase, i, j) == false)
 				{
 					isPossible = false;
 					break;
 				}				
 			}		
 		}
 		
 		return isPossible;			
 	}//private static boolean studyCase(int_testCase)
 	
 	
 	private static boolean wayOut(int[][] int_testCase, int row, int column)
 	{
 		boolean thereIsWayOut = false;
 		
 		if(horizontalWayOut(int_testCase[row], column) || verticalWayOut(int_testCase, row, column))
 		{
 			return true;			
 		}
 		
 		return thereIsWayOut;		
 	}//private static boolean wayOut(int[][] int_testCase, int i, int j)
 	
 	
 	private static boolean horizontalWayOut(int[] row, int column_index)
 	{
 		boolean thereIsWayOut = true;
 		
 		for(int i=0; i<row.length; i++)
 		{
 			if(row[i] > row[column_index])
 			{
 				thereIsWayOut = false;
 				break;
 			}
 		}
 		
 		return thereIsWayOut;		
 	}
 	
 	
 	private static boolean verticalWayOut(int[][] int_testCase, int row, int column)
 	{
 		boolean thereIsWayOut = true;
 		
 		for(int i=0; i<int_testCase.length; i++)
 		{	
 			if(int_testCase[i][column] > int_testCase[row][column])
 			{
 				thereIsWayOut = false;
 				break;
 			}			
 		}
 		
 		return thereIsWayOut;		
 	}
 }//public class lawnmower
","/**
  * Created by homulerdora on 3/31/14.
  */
 import java.math.BigDecimal;
 import java.util.*;
 import java.io.*;
 
 public class A {
 
     public static void main(String[] args){
         try {
             new A().solve();
         } catch (IOException e){
             e.printStackTrace();
             System.exit(1);
         }
     }
 
     public int getGen(long denom, long num){
         if(num == 0){
             return 0;
         }
         int count = 0;
         while(denom > num){
             if(denom%2 != 0){
                 return -1000000000;
             }
             denom /= 2;
             count++;
         }
         num -= denom;
         if(num == 0){
             return count;
         }
         count = Math.min(count, count+getGen(denom, num));
         return count;
     }
 
     public void solve() throws IOException {
         try(BufferedReader br = new BufferedReader(new FileReader(""A.in""));
             BufferedWriter bw = new BufferedWriter(new FileWriter(""A-output.txt""))
         ){
 
             int T = Integer.parseInt(br.readLine());
             for (int i = 1; i <= T; i++){
                 String[] str = br.readLine().split(""/"");
                 long num = Long.parseLong(str[0]);
                 long denom = Long.parseLong(str[1]);
                 int ans = getGen(denom, num);
                 bw.write(""Case #"" + i + "": "");
                 if(ans >= 0){
                     bw.write(ans + ""\n"");
                 } else {
                     bw.write(""impossible\n"");
                 }
             }
         }
     }
 
     public int[] nextInts(BufferedReader br) throws IOException {
         String[] strs = br.readLine().split("" "");
         int[] ret = new int[strs.length];
         for(int i = 0; i < ret.length; i++){
             ret[i] = Integer.parseInt(strs[i]);
         }
         return ret;
     }
 }
",0
252,12919,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.io.Reader;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
 
 
 public class Main 
 {
 	
 	public static HashMap<Character,Character> mapp = new HashMap<Character,Character>();
 	
 	public static void main(String[] args) throws Exception
 	{
 		PrintWriter writer = new PrintWriter(new FileWriter(""output.txt""));
 		BufferedReader input = new BufferedReader(new FileReader(""C-large.in""));
 		int size=Integer.parseInt(input.readLine());
 		for(int i=0; i<size; i++)
 		{
 			Set<String> mySet = new HashSet<String>();
 			String tokens[] = input.readLine().split("" "");
 			int lowLimit = Integer.parseInt(tokens[0]);
 			int highLimit = Integer.parseInt(tokens[1]);
 			int count=0;
 			for(int j=lowLimit; j<highLimit; j++)
 			{
 					Integer num1 = j;
 					String str1 = num1.toString();
 						for(int x=0; x<str1.length(); x++)
 						{
 							String temp = (String)str1.subSequence(str1.length()-1-x, str1.length()) + (String)str1.subSequence(0, (str1.length()-1-x));
 							
 							//System.out.println(""temp=""+temp+""	Str2=""+str2);
 							if(Integer.parseInt(temp)>j && Integer.parseInt(temp)<=highLimit)
 							{
 								mySet.add(str1+temp);
 							}
 						}
 			}
 			writer.println(""Case #""+(i+1)+"": ""+mySet.size());
 		}
 		writer.close();
 		input.close();
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.io.Reader;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
 
 
 public class Main 
 {
 	
 	public static HashMap<Character,Character> mapp = new HashMap<Character,Character>();
 	
 	public static void main(String[] args) throws Exception
 	{
 		PrintWriter writer = new PrintWriter(new FileWriter(""output.txt""));
 		BufferedReader input = new BufferedReader(new FileReader(""C-small-attempt0.in""));
 		int size=Integer.parseInt(input.readLine());
 		for(int i=0; i<size; i++)
 		{
 			Set<String> mySet = new HashSet<String>();
 			String tokens[] = input.readLine().split("" "");
 			int lowLimit = Integer.parseInt(tokens[0]);
 			int highLimit = Integer.parseInt(tokens[1]);
 			int count=0;
 			for(int j=lowLimit; j<highLimit; j++)
 			{
 				for(int k=j+1; k<=highLimit; k++)
 				{
 					Integer num1 = j;
 					Integer num2 = k;
 					String str1 = num1.toString();
 					String str2 = num2.toString();
 					if(str1.length()!=str2.length())
 					{
 						continue;
 					}
 					else
 					{
 						for(int x=0; x<str1.length(); x++)
 						{
 							String temp = (String)str1.subSequence(str1.length()-1-x, str1.length()) + (String)str1.subSequence(0, (str1.length()-1-x));
 							
 							//System.out.println(""temp=""+temp+""	Str2=""+str2);
 							if(Integer.parseInt(temp)==Integer.parseInt(str2))
 							{
 								mySet.add(str1+str2);
 							}
 						}
 					}
 				}
 			}
 			writer.println(""Case #""+(i+1)+"": ""+mySet.size());
 		}
 		writer.close();
 		input.close();
 	}
 
 }
",1
253,4109,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package codejam1a;
 import java.io.*;
 import java.util.*;
 
 /**
  *
  * @author Brain
  */
 public class A {
     private static Scanner in;
     private static PrintWriter out;
     private static PrintWriter out2;
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         in = new Scanner(System.in);
         out2 = new PrintWriter(System.out);
         out = new PrintWriter(System.out);
 
         try {
             in = new Scanner(new File(""A-small-attempt1.in""));
             out = new PrintWriter(new File(""out.txt""));
         } catch (Exception e) {
 
         }
 
         int t = in.nextInt();
 
         for (int i = 0; i<t; i++) {
             out2.println(""Doing test "" + Long.toString(i));
             runTask(i+1);
         }
 
         out.flush();
         out2.flush();
     }
 
     private static void runTask(int n) {
         int minSets = in.nextInt();
         int pd = in.nextInt();
         int pg = in.nextInt();
 
         int iterStepd = iterationStep(pd);
         int iterStepg = iterationStep(pg);
 
         if (iterStepd <= minSets && ((pg < 100) || (pd == 100)) && (pg > 0 || pd == 0)) {
             out.println(""Case #"" + n + "": Possible"");
         } else {
             out.println(""Case #"" + n + "": Broken"");
         }
         
     }
 
     private static int iterationStep(int pd) {
         int res = 100;
 
         while ((pd % 2 == 0) && (res % 2 == 0)) {
             pd = pd / 2;
             res = res / 2;
         }
 
         while ((pd % 5 == 0) && (res % 5 == 0)) {
             pd = pd / 5;
             res = res / 5;
         }
 
         return res;
     }
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package codejam1a;
 import java.io.*;
 import java.util.*;
 
 /**
  *
  * @author Brain
  */
 public class A {
     private static Scanner in;
     private static PrintWriter out;
     private static PrintWriter out2;
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         in = new Scanner(System.in);
         out2 = new PrintWriter(System.out);
         out = new PrintWriter(System.out);
 
         try {
             in = new Scanner(new File(""A-small-attempt1.in""));
             out = new PrintWriter(new File(""out.txt""));
         } catch (Exception e) {
 
         }
 
         int t = in.nextInt();
 
         for (int i = 0; i<t; i++) {
             out2.println(""Doing test "" + Long.toString(i));
             runTask(i+1);
         }
 
         out.flush();
         out2.flush();
     }
 
     private static void runTask(int n) {
         int minSets = in.nextInt();
         int pd = in.nextInt();
         int pg = in.nextInt();
 
         int iterStepd = iterationStep(pd);
         int iterStepg = iterationStep(pg);
 
         if (iterStepd <= minSets && ((pg < 100) || (pd == 100)) && (pg > 0 || pd == 0)) {
             out.println(""Case #"" + n + "": Possible"");
         } else {
             out.println(""Case #"" + n + "": Broken"");
         }
         
     }
 
     private static int iterationStep(int pd) {
         int res = 100;
 
         while ((pd % 2 == 0) && (res % 2 == 0)) {
             pd = pd / 2;
             res = res / 2;
         }
 
         while ((pd % 5 == 0) && (res % 5 == 0)) {
             pd = pd / 5;
             res = res / 5;
         }
 
         return res;
     }
 
 }
",1
254,8488,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Calendar;
 
 
 public class RPI {
 	void readFile(String ipfilename, String opfilename) throws IOException {
 		int numTests, N, schedule[][], win[], games[], idx;
 		double WP[], OWP[], OOWP[], R[], var;
 		File ifile, ofile;
 		BufferedReader br;
 		PrintWriter wr;
 		String line, strArr[];
 		
 		ifile = new File(ipfilename);
 		ofile = new File(opfilename);
 		
 		if( ifile.canRead() == false ) {
 			System.err.println(""Error: Cannot read file "" + ipfilename);
 			return;
 		}
 		br = new BufferedReader(new FileReader(ifile));
 		ofile.createNewFile();
 		wr = new PrintWriter(ofile);
 		
 		line = br.readLine();
 		numTests = Integer.parseInt(line);
 		
 		for (int i = 0; i < numTests; i++) {
 			line = br.readLine();
 			N = Integer.parseInt(line);
 			schedule = new int[N][N];
 			win = new int[N];
 			games = new int[N];
 			WP = new double[N];
 			OWP = new double[N];
 			OOWP = new double[N];
 			R = new double[N];
 			
 			for (int j = 0; j < N; j++) {
 				line = br.readLine();
 				win[j] = 0;
 				games[j] = 0;
 				for (int k = 0; k < N; k++) {
 					if (line.charAt(k) == '.') {
 						schedule[j][k] = -1;
 					} else if (line.charAt(k) == '0') {
 						schedule[j][k] = 0;
 						games[j] ++;
 					} else if (line.charAt(k) == '1') {
 						schedule[j][k] = 1;
 						win[j] ++;
 						games[j] ++;
 					}
 					WP[j] = (double)win[j] / (double)games[j];
 				}
 			}
 			
 			for (int j = 0; j < N; j++) {
 				var = 0;
 				idx = 0;
 				for (int k = 0; k < N; k++) {
 					if (schedule[j][k] == -1) {
 						continue;
 					}	else {
 						if (schedule[k][j] == 1) {
 							var += ((double)(win[k] - 1) / (double)(games[k] - 1));
 						} else {
 							var += ((double)(win[k]) / (double)(games[k] - 1));
 						}
 						idx++;
 					}
 				}
 				OWP[j] = var / idx;
 			}
 			
 			for (int j = 0; j < N; j++) {
 				var = 0;
 				idx = 0;
 				for (int k = 0; k < N; k++) {
 					if (schedule[j][k] == -1) {
 						continue;
 					}
 					var += OWP[k];
 					idx ++;				
 				}
 				OOWP[j] = var / idx;
 			}
 			
 			for (int j = 0; j < N; j++) {
 				 R[j] = 0.25 * WP[j] + 0.50 * OWP[j] + 0.25 * OOWP[j];
 			}
 			
 			wr.println(""Case #"" + (i + 1) + "":"");
 			for (int j = 0; j < N; j++) {
 				wr.println(R[j]);
 			}
 		}
 		
 		br.close();
 		wr.close();
 	}
 	
 	public static void main(String [] args) throws IOException {
 		long startTime, endTime;
 		
 		startTime = Calendar.getInstance().getTimeInMillis();
 		RPI r = new RPI();
 		r.readFile(""A-small-attempt0.in"", ""op.txt"");
 		endTime = Calendar.getInstance().getTimeInMillis();
 		System.out.println(""Starttime: "" + startTime + "" , endTime: "" + endTime + "" , Diff: "" + (endTime - startTime));
 
 	}
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collections;
 
 public class CandySplitting {
 	void readFile(String ipfilename, String opfilename) throws IOException {
 		int numTests, numBags, val, ret;
 		File ifile, ofile;
 		BufferedReader br;
 		PrintWriter wr;
 		String line, strArr[];
 		ArrayList <Integer> bags;
 		
 		ifile = new File(ipfilename);
 		ofile = new File(opfilename);
 		
 		if( ifile.canRead() == false ) {
 			System.err.println(""Error: Cannot read file "" + ipfilename);
 			return;
 		}
 		br = new BufferedReader(new FileReader(ifile));
 		ofile.createNewFile();
 		wr = new PrintWriter(ofile);
 		
 		line = br.readLine();
 		numTests = Integer.parseInt(line);
 		
 		for (int i = 0; i < numTests; i++) {
 			line = br.readLine();
 			numBags = Integer.parseInt(line.trim());
 			line = br.readLine();
 			strArr = line.split("" +"", numBags);
 			bags = new ArrayList <Integer> ();
 			ret = 0;
 			for (int j = 0; j < numBags; j++) {
 				val = Integer.parseInt(strArr[j]);
 				bags.add(val);
 				ret ^= val; 
 			}
 			if (ret != 0) {
 				wr.println(""Case #"" + (i + 1) + "": NO"");
 			} else {
 				Collections.sort(bags);
 				for (int j = 1; j < bags.size(); j++) {
 					 ret += bags.get(j);
 				}
 				wr.println(""Case #"" + (i + 1) + "": "" + ret);
 			}
 		}
 		
 		br.close();
 		wr.close();
 	}
 	
 	public static void main(String [] args) throws IOException {
 		long startTime, endTime;
 		
 		startTime = Calendar.getInstance().getTimeInMillis();
 		CandySplitting cs = new CandySplitting();
 		cs.readFile(""C-large.in"", ""op.txt"");
 		endTime = Calendar.getInstance().getTimeInMillis();
 		System.out.println(""Starttime: "" + startTime + "" , endTime: "" + endTime + "" , Diff: "" + (endTime - startTime));
 
 	}
 }
",1
255,125,"package r1b1;
 
 import java.io.BufferedReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.google.common.collect.Lists;
 
 public class Case
 {
     private List<String> strings = new ArrayList<>();
     
     public Case(List<String> strings)
     {
         this.strings.addAll(strings);
     }
     
     @Override
     public String toString()
     {
         StringBuffer buffer = new StringBuffer();
         for (String s : strings)
         {
             buffer.append(s).append('\n');
         }
         return buffer.toString();
     }
     
     public String solve()
     {
         if (!check())
         {
             return ""Fegla Won"";
         }
         else
         {
             return findCount();
         }
     }
     
     private String findCount()
     {
         List<Character> chars = new ArrayList<>();
         char previous = '\0';
         for (char c : strings.iterator().next().toCharArray())
         {
             if (c != previous)
             {
                 chars.add(c);
                 previous = c;
             }
         }
         
         int sum = 0;
         
         List<Integer> lastIndex = new ArrayList<>();
         for (int i = 0; i < strings.size(); ++i)
         {
             lastIndex.add(0);
         }
         
         for (int i = 0; i < chars.size(); ++i)
         {
             char currentChar = chars.get(i);
             List<Integer> counts = new ArrayList<>();
             for (int j = 0; j < strings.size(); ++j)
             {
                 int index = lastIndex.get(j);
                 int count = 0;
                 String currentString = strings.get(j);
                 while (index < currentString.length() && currentString.charAt(index) == currentChar)
                 {
                     count++;
                     index++;
                 }
                 counts.add(count);
                 lastIndex.set(j, index);
             }
             
             int minTotal = Integer.MAX_VALUE;
             for (int j = Collections.min(counts); j <= Collections.max(counts); ++j)
             {
                 int total = 0;
                 for (int k : counts)
                 {
                     total += Math.abs(k - j);
                 }
                 
                 if (total < minTotal)
                 {
                     minTotal = total;
                 }
             }
             
             sum += minTotal;
         }
         
         return """" + sum;
     }
     
     private boolean check()
     {
         List<String> tmp = new ArrayList<>();
         for (String s : strings)
         {
             tmp.add(s.replaceAll(""(.)\\1+"", ""$1""));
         }
         
         String first = tmp.iterator().next();
         for (String s : tmp)
         {
             if (!first.equals(s))
             {
                 return false;
             }
         }
         
         return true;
     }
 }
","package problem1;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import com.google.common.collect.Sets;
 import com.google.common.collect.Sets.SetView;
 
 /**
  * A test case for the first problem
  * 
  * @author 116@lab0.net
  * 
  */
 public class Case
 {
     private List<Integer>             rows  = new ArrayList<>(2);
     private List<List<List<Integer>>> grids = new ArrayList<>(2); // y,x
                                                                   
     /**
      * 
      * @param input
      *            row1, grid1, row2, grid2
      */
     public Case(List<String> input)
     {
         for (int i = 0; i < 2; ++i)
         {
             rows.add(Integer.parseInt(input.get(0 + i * 5)));
             grids.add(new ArrayList<List<Integer>>());
             for (int y = 0; y < 4; ++y)
             {
                 String[] split = input.get(1 + y + i * 5).split("" "");
                 grids.get(i).add(new ArrayList<Integer>(4));
                 for (int x = 0; x < 4; ++x)
                 {
                     grids.get(i).get(y).add(Integer.parseInt(split[x]));
                 }
             }
         }
     }
     
     public String getResult()
     {
         Set<Integer> ints0 = new HashSet<>(grids.get(0).get(rows.get(0)-1));
         Set<Integer> ints1 = new HashSet<>(grids.get(1).get(rows.get(1)-1));
         
         SetView<Integer> res = Sets.intersection(ints0, ints1);
 //        System.out.println(rows);
 //        System.out.println(res);
         switch (res.size())
         {
             case 0:
                 return ""Volunteer cheated!"";
             case 1:
                 return String.valueOf(res.iterator().next());
             default:
                 return ""Bad magician!"";
         }
     }
     
     @Override
     public String toString()
     {
         StringBuilder sb = new StringBuilder();
         for (List<List<Integer>> grid : grids)
         {
             for (List<Integer> row : grid)
             {
                 for (int i : row)
                 {
                     System.out.printf(""%3d"", i);
                 }
                 System.out.println();
             }
             System.out.println();
         }
         
         return sb.toString();
     }
     
 }
",1
256,963,"import java.io.*;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 
 /**
  * @author Egor Kulikov (egor@egork.net)
  *         Created on 14.03.2010
  */
 public class TaskA implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 
 	public static void main(String[] args) {
 		new Thread(new TaskA()).start();
 //		new Template().run();
 	}
 
 	public TaskA() {
 		String id = getClass().getName().toLowerCase();
 		try {
 			System.setIn(new FileInputStream(id + "".in""));
 			System.setOut(new PrintStream(new FileOutputStream(id + "".out"")));
 //			System.setIn(new FileInputStream(""input.txt""));
 //			System.setOut(new PrintStream(new FileOutputStream(""output.txt"")));
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 
 	public void run() {
         int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
 			System.err.println(testNumber);
 			out.print(""Case #"" + (testNumber + 1) + "": "");
 			long ans = -1;
 			int d = in.readInt();
 			int k = in.readInt();
 			int[] a = new int[k];
 			for (int i = 0; i < k; i++)
 				a[i] = in.readInt();
 			if (k <= 2) {
 				if (k == 1 || a[0] != a[1])
 					out.println(""I don't know."");
 				else
 					out.println(a[0]);
 				continue;
 			}
 			int max = 1;
 			for (int i = 0; i < d; i++)
 				max *= 10;
 			boolean[] isPrime = new boolean[max];
 			Arrays.fill(isPrime, true);
 			isPrime[0] = isPrime[1] = false;
 			for (int i = 2; i * i < max; i++) {
 				if (isPrime[i]) {
 					for (int j = i * i; j < max; j += i)
 						isPrime[j] = false;
 				}
 			}
 			int minp = 0;
 			for (int A : a)
 				minp = Math.max(minp, A + 1);
 			for (int p = minp; p < max; p++) {
 				if (isPrime[p]) {
 					int d1 = a[0] - a[1];
 					int d2 = a[1] - a[2];
 					long aa, bb;
 					if (d1 == 0) {
 						if (d2 == 0) {
 							aa = 1;
 							bb = 0;
 						} else
 							continue;
 					} else {
 						aa = ((new BigInteger(d1 + """").modInverse(new BigInteger(p + """")).longValue() * d2) % p);
 						bb = (a[1] - aa * a[0]) % p;
 					}
 					boolean good = true;
 					for (int i = 1; i < k; i++) {
 						long next = (aa * a[i - 1] + bb) % p;
 						if (next < 0)
 							next += p;
 						if (next != a[i]) {
 							good = false;
 							break;
 						}
 					}
 					if (good) {
 						long cand = (a[k - 1] * aa + bb) % p;
 						if (cand < 0)
 							cand += p;
 						if (ans == -1)
 							ans = cand;
 						else if (ans != cand) {
 							ans = -1;
 							break;
 						}
 					}
 				}
 			}
 			if (ans == -1)
 				out.println(""I don't know."");
 			else
 				out.println(ans);
         }
 		out.close();
 	}
 
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
","import java.io.*;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.InputMismatchException;
 
 /**
  * @author Egor Kulikov (egor@egork.net)
  *         Created on 14.03.2010
  */
 public class TaskA implements Runnable {
 	private InputReader in;
 	private PrintWriter out;
 
 	public static void main(String[] args) {
 		new Thread(new TaskA()).start();
 //		new Template().run();
 	}
 
 	public TaskA() {
 		String id = getClass().getName().toLowerCase();
 		try {
 			System.setIn(new FileInputStream(id + "".in""));
 			System.setOut(new PrintStream(new FileOutputStream(id + "".out"")));
 //			System.setIn(new FileInputStream(""input.txt""));
 //			System.setOut(new PrintStream(new FileOutputStream(""output.txt"")));
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 	}
 
 	public void run() {
         int numTests = in.readInt();
         for (int testNumber = 0; testNumber < numTests; testNumber++) {
 			out.print(""Case #"" + (testNumber + 1) + "": "");
 			long ans = -1;
 			int d = in.readInt();
 			int k = in.readInt();
 			int[] a = new int[k];
 			for (int i = 0; i < k; i++)
 				a[i] = in.readInt();
 			if (k <= 2) {
 				if (k == 1 || a[0] != a[1])
 					out.println(""I don't know."");
 				else
 					out.println(a[0]);
 				continue;
 			}
 			int max = 1;
 			for (int i = 0; i < d; i++)
 				max *= 10;
 			boolean[] isPrime = new boolean[max];
 			Arrays.fill(isPrime, true);
 			isPrime[0] = isPrime[1] = false;
 			for (int i = 2; i * i < max; i++) {
 				if (isPrime[i]) {
 					for (int j = i * i; j < max; j += i)
 						isPrime[j] = false;
 				}
 			}
 			int minp = 0;
 			for (int A : a)
 				minp = Math.max(minp, A + 1);
 			for (int p = minp; p < max; p++) {
 				if (isPrime[p]) {
 					int d1 = a[0] - a[1];
 					int d2 = a[1] - a[2];
 					long aa, bb;
 					if (d1 == 0) {
 						if (d2 == 0) {
 							aa = 1;
 							bb = 0;
 						} else
 							continue;
 					} else {
 						aa = ((new BigInteger(d1 + """").modInverse(new BigInteger(p + """")).longValue() * d2) % p);
 						bb = (a[1] - aa * a[0]) % p;
 					}
 					boolean good = true;
 					for (int i = 1; i < k; i++) {
 						long next = (aa * a[i - 1] + bb) % p;
 						if (next < 0)
 							next += p;
 						if (next != a[i]) {
 							good = false;
 							break;
 						}
 					}
 					if (good) {
 						long cand = (a[k - 1] * aa + bb) % p;
 						if (cand < 0)
 							cand += p;
 						if (ans == -1)
 							ans = cand;
 						else if (ans != cand) {
 							ans = -1;
 							break;
 						}
 					}
 				}
 			}
 			if (ans == -1)
 				out.println(""I don't know."");
 			else
 				out.println(ans);
         }
 		out.close();
 	}
 
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 }
",1
257,2128,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 
 public class Zad1 {
 
 	public static void main(String[] args) throws IOException {
 		Scanner sc = new Scanner(new File(""test.txt""));
 		BufferedWriter out = new BufferedWriter(new FileWriter(""out.txt""));
 
 		int cas = sc.nextInt();
 		
 		for (int c = 1; c <= cas; c++) {
 			int Y, X;
 			Y = sc.nextInt();
 			X = sc.nextInt();
 			char[][] map = new char[Y][X];
 			
 			for (int i = 0; i < Y; i++) {
 				String s = sc.next();
 				for (int j = 0; j < s.length(); j++) {
 					map[i][j] = s.charAt(j);
 				}
 			}
 			
 			
 			boolean bad = false;
 			for (int i = 0; i < Y; i++) {
 				for (int j = 0; j < X; j++) {
 					if (map[i][j] == '#') {
 						if (i == Y - 1 || j == X - 1 || map[i + 1][j] == '.' || map[i + 1][j + 1] == '.' || map[i][j + 1] == '.') {
 							bad = true;
 						}
 						else {
 							map[i][j] = '/';
 							map[i][j + 1] = '\\';
 							map[i + 1][j] = '\\';
 							map[i + 1][j + 1] = '/';
 						}
 					}
 				}
 			}
 			out.write(""Case #"" + c + "":\n"");
 			if (bad) out.write(""Impossible\n"");
 			else {
 				for (int i = 0; i < Y; i++) {
 					for (int j = 0; j < X; j++) out.write(map[i][j]);
 					out.write('\n');
 				}
 			}
 			
 		}
 		out.close();
 	}
 
 }
","import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class Main {
 
 	private static double c;
 	private static double f;
 	private static double x;
 	/**
 	 * @param args
 	 * @throws FileNotFoundException
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		Locale.setDefault(Locale.US);
 		Scanner in = new Scanner(new FileInputStream(""B-large.in""));
 		PrintWriter out = new PrintWriter(""OUTPUT.TXT"");
 		int t = in.nextInt();
 		for (int t0 = 0; t0 < t; ++t0) {
 			c = in.nextDouble();
 			f = in.nextDouble();
 			x = in.nextDouble();
 			out.println(String.format(""Case #%d: %.8f"", t0+1, solve()));
 		}
 		in.close();
 		out.close();
 	}
 
 	private static double solve() {
 		double cps = 2.0;
 		double time = 0.0;
 		if (x<=c) return x/cps;
 		while (true){
 			double time1 = x/cps;
 			double time2 = c/cps+x/(cps+f);
 			if (time1<=time2){
 				time+=time1;
 				break;
 			}
 			else{
 				time+=c/cps;
 				cps+=f;
 			}
 		}
 		return time;
 	}
 
 }
",0
258,5786,"package main;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 public class TestClass {
 
 	public static void main (String[] args) throws IOException {
 		BufferedReader reader = new BufferedReader(new FileReader(""C:\\in.txt""));
 		BufferedWriter writer = new BufferedWriter(new FileWriter(""C:\\out.txt""));
 		TestClass testClass = new TestClass();
 
 		int caseNum = Integer.parseInt(reader.readLine());
 		for(int i=0; i<caseNum; i++) {
 			String line = reader.readLine();
 			String[] numbers = line.split("" "");
 
 			int N = Integer.parseInt(numbers[0]);
 			List<Long> scores = new ArrayList<Long>();
 
 			for(int j=0; j<N; j++) {
 				scores.add(Long.parseLong(numbers[j+1]));
 			}
 			List<Long> s1 = new ArrayList<Long>();
 			List<Long> s2 = new ArrayList<Long>();
 			Collections.sort(scores);
 			testClass.getC(scores, s1, s2);
 			writer.write(""Case #"" + (i+1) + "":\n"");
 
 			if(s1.isEmpty()) {
 				writer.write(""Impossible"");
 			} else {
 				for(int j=0; j<s1.size(); j++) {
 					writer.write(Long.toString(s1.get(j)));
 					if(j != s1.size() - 1) {
 						writer.write("" "");
 					}
 				}
 				writer.write(""\n"");
 
 				for(int j=0; j<s2.size(); j++) {
 					writer.write(Long.toString(s2.get(j)));
 					if(j != s2.size() - 1) {
 						writer.write("" "");
 					}
 				}
 			}
 			writer.write(""\n"");
 
 			writer.flush();
 			scores.clear();
 		}
 	}
 
 	private void getC(List<Long> nums, List<Long> s1, List<Long> s2) {
 		long pos = (long)Math.pow(2, nums.size());
 		long sum1 = 0;
 		long sum2 = 0;
 		for(long i=1; i<pos-1; i++) {
 			sum1 = 0;
 			String b1 = getBinaryNum(i, nums.size());
 			for(int j=0; j<b1.length(); j++) {
 				if(b1.charAt(j) == '1') {
 					sum1 += nums.get(j);
 				}
 			}
 
 			for(long j=1; j<pos-1; j++) {
 				String b2 = getBinaryNum(j, nums.size());
 				sum2 = 0;
 				for(int k=0; k<b2.length(); k++) {
 					if(b2.charAt(k) == '1') {
 						if(b1.charAt(k) == '1') {
 							break;
 						}
 						sum2 += nums.get(k);
 						if(sum1 == sum2) {
 							for(int l=0; l<b1.length(); l++) {
 								if(b1.charAt(l) == '1') {
 									s1.add(nums.get(l));
 								}
 							}
 
 							for(int l=0; l<b2.length(); l++) {
 								if(b2.charAt(l) == '1') {
 									s2.add(nums.get(l));
 								}
 							}
 							return;
 						} else if(sum2 > sum1) {
 							break;
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private LinkedList<Double> getA(List<Integer> scores) {
 		Integer sum = 0;
 		for(Integer score : scores) {
 			sum += score;
 		}
 
 		return getAHelper(scores, sum * 2);
 	}
 
 	private LinkedList<Double> getAHelper(List<Integer> scores, int points) {
 		LinkedList<Double> ret = new LinkedList<Double>();
 		Double avg = new Double(points) / scores.size();
 
 		Integer sum = 0;
 		for(Integer score : scores) {
 			sum += score;
 		}
 
 		for(int i=0; i<scores.size(); i++) {
 			if(avg <= scores.get(i)) {
 				points -= scores.get(i);
 				scores.remove(i);
 				ret = getAHelper(scores, points);
 				ret.add(i, new Double(0));
 				return ret;
 			}
 		}
 		for(Integer score : scores) {
 			ret.add((avg - new Double(score)) / new Double(points - sum) * new Double(100));
 		}
 		return ret;
 	}
 
 	private int getSwitchForBooleanTree(BooleanTreeNode node, int value) {
 		if(node.And == -1 || !node.change) {
 			return node.value == value ? 0 : -1;
 		} else {
 			int left1 = getSwitchForBooleanTree(node.left, 1);
 			int left0 = getSwitchForBooleanTree(node.left, 0);
 			int right1 = getSwitchForBooleanTree(node.right, 1);
 			int right0 = getSwitchForBooleanTree(node.right, 0);
 			int and = -1;
 			int or = -1;
 
 			if(value == 1) {
 				and = getSwitchForBooleanTreeHelper(left1, right1);
 				if(right1 == -1) {
 					or = left1;
 				} else if(left1 == -1) {
 					or = right1;
 				} else {
 					or = min(right1, left1);
 				}
 			} else if(value == 0) {
 				if(right0 == -1) {
 					and = left0;
 				} else if(left0 == -1) {
 					and = right0;
 				} else {
 					and = min(right0, left0);
 				}
 				or = getSwitchForBooleanTreeHelper(left0, right0);
 			}
 
 			if(!node.change) {
 				return node.And == 1 ? and : or;
 			} else {
 				if(node.And == 1) {
 
 				}
 			}
 		}
 		throw new RuntimeException(""It's not scientific!"");
 	}
 
 	private int getSwitchForBooleanTreeHelper(int i, int j) {
 		if(i == -1 || j == -1) {
 			return -1;
 		}
 		return i + j;
 	}
 
 	private class BooleanTreeNode {
 		public int value;
 		public int And;
 		public boolean change;
 		public BooleanTreeNode left;
 		public BooleanTreeNode right;
 
 		public BooleanTreeNode(int value, int and) {
 			this.value = value;
 			this.And = and;
 			change = false;
 			left = null;
 			right = null;
 		}
 	}
 
 	private List<Integer> getPrimeNum(int max) {
 		List<Integer> ret = new ArrayList<Integer>();
 		boolean[] nums = new boolean[max+1];
 		Arrays.fill(nums, true);
 		for(int i=2; i<nums.length/2; i++) {
 			int tmp = 2 * i;
 			while(tmp < nums.length) {
 				nums[tmp] = false;
 				tmp += i;
 			}
 		}
 		for(int i=2; i<nums.length; i++) {
 			if(nums[i]) {
 				ret.add(i);
 			}
 		}
 		return ret;
 	}
 
 	private String format(String pattern, double value) {
 		DecimalFormat myFormatter = new DecimalFormat(pattern);
 		return myFormatter.format(value);
 	}
 
 	private int[] getMilkShake(int N, List<Customer> customers) {
 		int[] ret = new int[N];
 		Arrays.fill(ret, 0);
 		boolean flag = true;
 		while(flag) {
 			flag = false;
 			for(Customer customer : customers) {
 				if(!customer.getMalt && customer.unmaltNum == 0) {
 					if(customer.malt == -1) {
 						return null;
 					}
 
 					int turnMalted = customer.malt;
 					ret[turnMalted] = 1;
 					customer.getMalt = true;
 
 					for(Customer customer1 : customers) {
 						if(customer1.malt == turnMalted) {
 							customer1.getMalt = true;
 						} else if(customer1.unmalt.contains(turnMalted)) {
 							customer1.unmaltNum--;
 						}
 					}
 					flag = true;
 					break;
 				}
 			}
 		}
 		return ret;
 	}
 
 	private class Customer {
 		public int malt;
 		public List<Integer> unmalt;
 		public boolean getMalt;
 		public int unmaltNum;
 
 		public Customer(int malt, List<Integer> unmalt) {
 			this.malt = malt;
 			this.unmalt = new ArrayList<Integer>(unmalt);
 			getMalt = false;
 			unmaltNum = unmalt.size();
 		}
 
 		public Customer(List<Integer> unmalt) {
 			this(-1, unmalt);
 		}
 	}
 
 	private long getMinScalarProduct(long[] xs, long[] ys) {
 		Arrays.sort(xs);
 		Arrays.sort(ys);
 		long min = 0;
 		for(int i=0; i<xs.length; i++) {
 			min += xs[i] * ys[xs.length - 1 - i];
 		}
 		return min;
 	}
 
 	private int getB(LinkedList<Level> levels) {
 		Collections.sort(levels);
 		int star = 0;
 		int trial = 0;
 		boolean flag = false;
 
 		while(!levels.isEmpty()) {
 			if(levels.get(0).bi <= star) {
 				if(levels.get(0).doneA) {
 					star++;
 				} else {
 					star += 2;
 				}
 				trial++;
 				levels.removeFirst();
 			} else {
 				for(int i= levels.size()-1; i>=0; i--) {
 					if(levels.get(i).ai <= star && !levels.get(i).doneA) {
 						star += 1;
 						trial++;
 						levels.get(i).doneA = true;
 						flag = true;
 						break;
 					}
 				}
 				if(flag) {
 					flag = false;
 					continue;
 				}
 				return -1;
 			}
 		}
 
 		return trial;
 	}
 
 	private class Level implements Comparable<Level>{
 		public int ai;
 		public int bi;
 		public boolean doneA;
 
 		@Override
 		public int compareTo(Level o) {
 			return bi - o.bi;
 		}
 
 		public Level(int ai, int bi) {
 			this.ai = ai;
 			this.bi = bi;
 			doneA = false;
 		}
 	}
 
 	private Double getA(int A, int B, List<Double> possibs) {
 		Double third = new Double(A + B + 1);
 		Double forth = new Double(B + 2);
 		Double min = third > forth ? forth : third;
 		for(int i=0; i<A; i++) {
 			Double sum = new Double(1);
 
 			Double pos1 = possibs.get(A - i);
 			if(i > 0) {
 				pos1 += possibs.get(A);
 			}
 			int key1 = i + B - A + i + 1;
 
 			Double pos2 = new Double(1) - pos1;
 			int key2 = key1 + B + 1;
 
 			sum = pos1 * key1 + pos2 * key2;
 
 			if(sum < min) {
 				min = sum;
 			}
 		}
 		return min;
 	}
 
 	private List<Double> getPossibility(List<Double> Ais) {
 		List<Double> times = new ArrayList<Double>();
 		times.add(new Double(1));
 		for(int i=0; i<Ais.size(); i++) {
 			times.add(times.get(i) * Ais.get(i));
 		}
 
 		List<Double> poss = new ArrayList<Double>();
 		for(int i=0; i<Ais.size(); i++) {
 			poss.add( (1-Ais.get(i)) * times.get(i) );
 		}
 		poss.add(times.get(Ais.size()));
 
 		return poss;
 	}
 
 	private int getSwitchRowNum(int[][] matrix) {
 		int ret = 0;
 		int[] line = new int[matrix.length];
 		Arrays.fill(line, 0);
 		for(int i=0; i<matrix.length; i++) {
 			for(int j=matrix.length-1; j>=0; j--) {
 				if(matrix[i][j] == 1) {
 					line[i] = j;
 					break;
 				}
 			}
 		}
 
 		boolean flag = true;
 		while(flag) {
 			flag = false;
 			for(int i=0; i<line.length; i++) {
 				if(line[i] > i) {
 					for(int j=i+1; j<line.length; j++) {
 						if(line[j] <= i) {
 							for(int k=j; k>i; k--) {
 								swap(line, k, k-1);
 							}
 							ret += j - i;
 							flag = true;
 							break;
 						}
 					}
 				}
 			}
 		}
 
 		return ret;
 	}
 
 	private void swap(int[] line, int i, int j) {
 		int tmp = line[i];
 		line[i] = line[j];
 		line[j] = tmp;
 	}
 
 	private long minBase(String msg) {
 		Map<Character, Character> charMap = new HashMap<Character, Character>();
 		charMap.put(msg.charAt(0), '1');
 		int index = 0;
 		String ret = ""1"";
 
 		for(int i=1; i<msg.length(); i++) {
 			char c = msg.charAt(i);
 			if(!charMap.containsKey(c)) {
 				if(index > 9) {
 					charMap.put(c, (char)('a' + index-10));
 				} else {
 					charMap.put(c, (char)('0' + index));
 				}
 				if(index == 0) {
 					index += 2;
 				} else {
 					index++;
 				}
 			}
 			ret += charMap.get(c);
 		}
 		return stringToLong(ret, index < 2 ? 2 : index);
 	}
 
 	private double getPossibility(FeatureTree root, HashSet<String> features) {
 		//tree ::= (weight [feature tree tree])
 		double ret = root.weight;
 		if(!root.feature.equals("""")) {
 			if(features.contains(root.feature)) {
 				ret *= getPossibility(root.left, features);
 			} else {
 				ret *= getPossibility(root.right, features);
 			}
 		}
 		return ret;
 	}
 
 	private class FeatureTree {
 		public FeatureTree(double weight) {
 			this.weight = weight;
 			feature = """";
 			left = null;
 			right = null;
 		}
 
 		public FeatureTree(double weight, String feature, FeatureTree left, FeatureTree right) {
 			this.weight = weight;
 			this.feature = feature;
 			this.left = left;
 			this.right = right;
 		}
 
 		public double weight;
 		public String feature;
 		public FeatureTree left;
 		public FeatureTree right;
 	}
 
 	private FeatureTree parseFeatureTree(BufferedReader reader) throws IOException {
 		String token = getToken(reader, '[');
 		if(token.equals(""("")) {
 			token = getToken(reader, '[');
 		} else {
 			token = token.substring(1);
 		}
 
 		if(token.endsWith("")"")) {
 			return new FeatureTree(Double.parseDouble(token.substring(0, token.length()-1)));
 		}
 		String token1 = getToken(reader, ')');
 		if(token1.equals("")"")) {
 			return new FeatureTree(Double.parseDouble(token.substring(0, token.length())));
 		} else {
 			FeatureTree ret = new FeatureTree(Double.parseDouble(token), token1, parseFeatureTree(reader), parseFeatureTree(reader));
 			getToken(reader, ')');
 			return ret;
 		}
 	}
 
 	private String getToken(BufferedReader reader, char stopChar) throws IOException {
 		char c = (char)reader.read();
 		for(; c == ' ' || c == '\n'; c = (char)reader.read()) {}
 		String ret = """";
 		for(; c != ' ' && c != '\n'; c = (char)reader.read()) {
 			ret += c;
 			if(c == stopChar) {
 				break;
 			}
 		}
 		return ret;
 	}
 
 	private String getNextNum(String num) {
 		for(int i=num.length()-1; i>0; i--) {
 			if(num.charAt(i) > num.charAt(i-1)) {
 				int j = i;
 				for(; j+1 < num.length() && num.charAt(j+1) > num.charAt(i-1); j++) {}
 				if(j != num.length()-1) {
 					return num.substring(0, i-1) + num.charAt(j) + sortString(num.substring(i-1, j) + num.substring(j+1));
 				} else {
 					return num.substring(0, i-1) + num.charAt(j) + sortString(num.substring(i-1, num.length()-1));
 				}
 			}
 		}
 		if(num.length() == 1) {
 			return num + ""0"";
 		} else {
 			String ret = sortString(num);
 			if(ret.startsWith(""0"")) {
 				for(int i=1; i<ret.length(); i++) {
 					if(ret.charAt(i) != '0') {
 						if(i+1 <ret.length()) {
 							num = ret.charAt(i) + ret.substring(0, i) + ret.substring(i+1);
 						} else {
 							num = ret.charAt(i) + ret.substring(0, i);
 						}
 						return num.charAt(0) + ""0"" + num.substring(1);
 					}
 				}
 			} else {
 				return ret.charAt(0) + ""0"" + ret.substring(1);
 			}
 		}
 		return """";
 	}
 
 	private String sortString(String str) {
 		char[] tmp = str.toCharArray();
 		Arrays.sort(tmp);
 		return String.valueOf(tmp);
 	}
 
 	private int getRecycleNum(int A, int B) {
 		//A <= n < m <= B
 		int ret = 0;
 		Set<Integer> tmp = new HashSet<Integer>();
 		for(int num=A; num<=B; num++) {
 			String numStr = Integer.toString(num);
 			int length = numStr.length();
 			for(int i=0; i<length-1; i++) {
 				String numStr2 = numStr.substring(1, numStr.length()) + numStr.charAt(0);
 				int num2 = Integer.parseInt(numStr2);
 				if(num2 <= B && num2 > num && !tmp.contains(num2)) {
 					ret++;
 				}
 				tmp.add(num2);
 				numStr = numStr2;
 			}
 			tmp.clear();
 		}
 		return ret;
 	}
 
 	private int getNumOfGoogler(int S, int p, List<Integer> points) {
 		if(p == 0) {
 			return points.size();
 		}
 		int ret = 0;
 		for(int point : points) {
 			if(point >= 3 * p - 2) {
 				ret++;
 			} else if(point >= 3 * p - 4 && S > 0 && p > 1) {
 				S--;
 				ret++;
 			}
 		}
 		return ret;
 	}
 
 
 	Map<Character, Character> map = new HashMap<Character, Character>();
 
 	private String getTranslation(String gs) {
 		String ret = """";
 		for(int i=0; i<gs.length(); i++) {
 			ret += map.get(gs.charAt(i));
 		}
 		return ret;
 	}
 
 	private void getTranslation() {
 		String gs1 = ""ejp mysljylc kd kxveddknmc re jsicpdrysi"";
 		String gs2 = ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"";
 		String gs3 = ""de kr kd eoya kw aej tysr re ujdr lkgc jv"";
 
 		String str1 = ""our language is impossible to understand"";
 		String str2 = ""there are twenty six factorial possibilities"";
 		String str3 = ""so it is okay if you want to just give up"";
 		map.put('q', 'z');
 		map.put('z', 'q');
 		getTranslation(gs1, str1);
 		getTranslation(gs2, str2);
 		getTranslation(gs3, str3);
 	}
 
 	private void getTranslation(String gs, String str) {
 		for(int i=0; i<gs.length(); i++) {
 			map.put(gs.charAt(i), str.charAt(i));
 		}
 	}
 
 	private int getHappyNum(List<Integer> bases) {
 		for(int i=bases.get(0); ; i++) {
 			boolean breakOut = false;
 			for(int base : bases) {
 				if(!isNumHappy(i, base)) {
 					breakOut = true;
 					break;
 				}
 			}
 			if(!breakOut) {
 				return i;
 			}
 		}
 	}
 
 	private boolean isNumHappy(int num, int base) {
 		int sum = 0;
 		List<String> previous = new ArrayList<String>();
 		while(sum != 1) {
 			sum = 0;
 			String numStr = intToString(num, base);
 			if(previous.contains(numStr)) {
 				return false;
 			}
 			previous.add(numStr);
 			for(int i=0; i<numStr.length(); i++) {
 				sum += Math.pow(numStr.charAt(i) - '0', 2);
 			}
 			num = sum;
 		}
 		return true;
 	}
 
 	/**
 	 * Accept 0~9 a~z
 	 * @param str
 	 * @param base
 	 * @return
 	 */
 	private long stringToLong(String str, int base) {
 		long ret = 0;
 		long pow = 1;
 		for(int i=str.length()-1; i>=0; i--) {
 			if(str.charAt(i) >= 'a') {
 				ret += (str.charAt(i) - 'a' + 10) * pow;
 			} else {
 				ret += (str.charAt(i) - '0') * pow;
 			}
 			pow *= base;
 		}
 		return ret;
 	}
 
 	private String intToString(int i, int base) {
 		return intToString(i, base, 0);
 	}
 
 	private String intToString(int i, int base, int length) {
 		String ret = """";
 		while(i != 0) {
 			ret = i % base + ret;
 			i /= base;
 		}
 		if(ret.length() < length) {
 			ret = new String(new char[length - ret.length()]).replace(""\0"", ""0"") + ret;
 		}
 		return ret;
 	}
 
 	private int getTicketFair(int P, int M[], int price[]) {
 		int min = Integer.MAX_VALUE;
 		int teamNum = (int)Math.pow(2, P);
 		int gameNum = teamNum - 1;
 		int possibility = (int)Math.pow(2, gameNum);
 		for(int i=0; i<possibility; i++) {
 			String buy = getBinaryNum(i, gameNum);
 			int sum = 0;
 			if(doesTeamWork(M, buy)) {
 				for(int k=0; k<gameNum; k++) {
 					if(buy.charAt(k) == '1') {
 						sum += price[k];
 					}
 				}
 			}
 			if(sum != 0 && sum < min) {
 				min = sum;
 			}
 		}
 		return min;
 	}
 
 	private boolean doesTeamWork(int M[], String buy) {
 		for(int i=0; i<M.length; i++) {
 			int index = i / 2;
 			int indexPlus = (buy.length() + 1) / 2;
 			int sum = 0;
 			int gameNum = 0;
 			while(index < buy.length()) {
 				if(buy.charAt(index) == '1') {
 					sum++;
 				}
 				gameNum++;
 				index = indexPlus + i / (int)Math.pow(2, gameNum+1);
 				indexPlus = indexPlus + indexPlus / 2;
 			}
 			if(gameNum - M[i] > sum) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	private String getBinaryNum(long i, int length) {
 		String ret = Long.toBinaryString(i);
 		if(ret.length() < length) {
 			return new String(new char[length - ret.length()]).replace(""\0"", ""0"") + ret;
 		}
 		return ret;
 	}
 
 	private class Chick {
 		Chick(int b, int t, int x, int v) {
 			T = t;
 			B = b;
 			X = x;
 			V = v;
 			arrive = (B - X) / (double)V <= T;
 		}
 
 		private int T;
 		private int B;
 		private int X;
 		private int V;
 		private boolean arrive;
 	}
 
 	private int getSwapNum(List<Chick> chicken, int K) {
 		int ret = 0;
 		for(int i=chicken.size()-1; i>=0; i--) {
 			if(K == 0) {
 				break;
 			}
 			if(!chicken.get(i).arrive) {
 				ret += K;
 			} else {
 				K--;
 			}
 		}
 		if(K != 0) {
 			return -1;
 		}
 		return ret;
 	}
 
 	private class Directory {
 		Directory(String n) {
 			name = n;
 			dirs = new ArrayList<Directory>();
 		}
 
 		Directory getChild(String name) {
 			for(Directory dir : dirs) {
 				if(dir.name.equals(name)) {
 					return dir;
 				}
 			}
 			return null;
 		}
 
 		private String name;
 		private List<Directory> dirs;
 	}
 
 	private int getNumOfMkdir(Directory root, List<List<String>> newDirs) {
 		int ret = 0;
 		Directory curr, pre;
 		for(List<String> newDir : newDirs) {
 			curr = root;
 			for(String folder : newDir) {
 				pre = curr;
 				curr = curr.getChild(folder);
 				if(curr == null) {
 					ret++;
 					pre.dirs.add(new Directory(folder));
 					curr = pre.getChild(folder);
 				}
 			}
 		}
 		return ret;
 	}
 
 	private List<String> getDirNames(String dir) {
 		List<String> ret = new ArrayList<String>(Arrays.asList(dir.split(""/"")));
 		ret.remove(0);
 		return ret;
 	}
 
 	private String rotate(int K, char[][] position) {
 		char[][] rotated = new char[position.length][position.length];
 		for(int i=0; i<position.length; i++) {
 			for(int j=0; j<position.length; j++) {
 				rotated[j][position.length-1-i] = position[i][j];
 			}
 		}
 		for(int j=0; j<position.length; j++) {
 			int tmp = position.length - 1;
 			for(int i=position.length-1; i>=0; i--) {
 				if(rotated[i][j] != '.') {
 					rotated[tmp][j] = rotated[i][j];
 					tmp--;
 				}
 			}
 			for(; tmp>=0; tmp--) {
 				rotated[tmp][j] = '.';
 			}
 		}
 
 		boolean r = checkColor('R', K, rotated);
 		boolean b = checkColor('B', K, rotated);
 
 		if(r && b) {
 			return ""Both"";
 		} else if(r) {
 			return ""Red"";
 		} else if(b) {
 			return ""Blue"";
 		} else {
 			return ""Neither"";
 		}
 	}
 
 	private boolean checkColor(char color, int K, char[][] rotated) {
 		int num = 0;
 		for(int i=0; i<rotated.length; i++) {
 			for(int j=0; j<rotated.length; j++) {
 				if(rotated[i][j] == color) {
 					num++;
 					if(num == K) {
 						return true;
 					}
 				} else {
 					num = 0;
 				}
 			}
 			num = 0;
 		}
 
 		num = 0;
 		for(int i=0; i<rotated.length; i++) {
 			for(int j=0; j<rotated.length; j++) {
 				if(rotated[j][i] == color) {
 					num++;
 					if(num == K) {
 						return true;
 					}
 				} else {
 					num = 0;
 				}
 			}
 			num = 0;
 		}
 
 		num = 0;
 		for(int i=0; i<rotated.length; i++) {
 			for(int j=0; j<rotated.length; j++) {
 				for(int k=0; k<K; k++) {
 					if(i+k >=rotated.length || j+k >= rotated.length) {
 						break;
 					}
 					if(rotated[i+k][j+k] == color) {
 						num++;
 						if(num == K) {
 							return true;
 						}
 					} else {
 						break;
 					}
 				}
 				num = 0;
 			}
 		}
 
 		num = 0;
 		for(int i=0; i<rotated.length; i++) {
 			for(int j=0; j<rotated.length; j++) {
 				for(int k=0; k<K; k++) {
 					if(i+k >=rotated.length || j-k < 0) {
 						break;
 					}
 					if(rotated[i+k][j-k] == color) {
 						num++;
 						if(num == K) {
 							return true;
 						}
 					} else {
 						break;
 					}
 				}
 				num = 0;
 			}
 		}
 
 		return false;
 	}
 
 	private class WalkWay implements Comparable<WalkWay>{
 		WalkWay(int b, int e, int w) {
 			B = b;
 			E = e;
 			W = w;
 		}
 
 		private int B;
 		private int E;
 		private int W;
 
 		@Override
 		public int compareTo(WalkWay o) {
 			if(W == o.W) {
 				return 0;
 			}
 			return W < o.W ? -1 : 1;
 		}
 	}
 
 	private Double getMinTimeForWalkWay(int X, int S, int R, Double t, List<WalkWay> walkWays) {
 		int walkWayNum = walkWays.size();
 		int tmp = 0;
 		for(int i=0; i<X; i++) {
 			if(tmp >= walkWayNum) {
 				walkWays.add(new WalkWay(i, X, 0));
 				break;
 			}
 			if(i < walkWays.get(tmp).B) {
 				walkWays.add(new WalkWay(i, walkWays.get(tmp).B, 0));
 				i = walkWays.get(tmp).E - 1;
 				tmp++;
 			} else if(i == walkWays.get(tmp).B) {
 				i = walkWays.get(tmp).E - 1;
 				tmp++;
 			}
 		}
 		Collections.sort(walkWays);
 
 		Double ret = new Double(0);
 		for(WalkWay walkWay : walkWays) {
 			if(t > 0) {
 				Double ideaT = (new Double(walkWay.E) - walkWay.B) / (walkWay.W + R);
 				if(t >= ideaT) {
 					t -= ideaT;
 					ret += ideaT;
 				} else {
 					Double pass = t * (walkWay.W + R);
 					ret += t + (new Double(walkWay.E) - pass - walkWay.B) / (walkWay.W + S);
 					t = new Double(-1);
 				}
 			} else {
 				ret += (new Double(walkWay.E) - walkWay.B) / (walkWay.W + S);
 			}
 		}
 
 		return ret;
 	}
 
 	private String getPerfertHarmony(Long L, Long H, List<Long> frequencise) {
 		boolean flag = true;
 		for(long i=L; i<=H; i++) {
 			flag = true;
 			for(Long frequency : frequencise) {
 				if(i % frequency != 0 && frequency % i != 0) {
 					flag = false;
 					break;
 				}
 			}
 			if(flag) {
 				return """" + i;
 			}
 		}
 		return ""NO"";
 	}
 
 	private Long getRocketTime(Long L, Long t, Long N, List<Long> distance) {
 		Long sum = new Long(0);
 		List<Long> singleDis = new ArrayList<Long>();
 		for(Long dis : distance) {
 			sum += dis;
 		}
 		Long nRound = N / distance.size();
 		Long nRemain = N % distance.size();
 		Long time = nRound * sum;
 		for(int i=0; i<nRemain; i++) {
 			time += distance.get(i);
 			singleDis.add(distance.get(i));
 		}
 		time *= 2;
 
 		if(t >= time || L == 0) {
 			return time;
 		}
 
 		Long pass = t/2;
 		Long passRound = pass / sum;
 		Long passRemain = pass % sum;
 		Long passRoundRemain = nRound - passRound;
 
 		if(t != 0) {
 			for(int i=0; i<distance.size(); i++) {
 				if(passRemain > 0) {
 					passRemain -= distance.get(i);
 				} else {
 					singleDis.add(distance.get(i));
 				}
 			}
 			if(passRemain != 0) {
 				singleDis.add(-passRemain);
 			}
 			passRoundRemain--;
 		}
 
 		Collections.sort(distance);
 		Collections.sort(singleDis);
 
 		Long minus = new Long(0);
 		int singleDisIndex = singleDis.size()-1;
 		for(int i=distance.size()-1; i>=0; i--) {
 			while(singleDisIndex >= 0 && singleDis.get(singleDisIndex) >= distance.get(i)) {
 				minus += singleDis.get(singleDisIndex);
 				singleDisIndex--;
 				L--;
 			}
 			if(L <= passRoundRemain) {
 				minus += L * distance.get(i);
 				break;
 			} else {
 				minus += passRoundRemain * distance.get(i);
 				L -= passRoundRemain;
 			}
 		}
 
 		return time - minus;
 	}
 
 	private char[][] tiles;
 	private boolean test() {
 		for(int i=0; i<tiles.length; i++) {
 			for(int j=0; j<tiles[i].length; j++) {
 				if(tiles[i][j] == '#') {
 					if(i+1 >= tiles.length || j+1 >= tiles[i+1].length || tiles[i][j+1] != '#' || tiles[i+1][j] != '#' || tiles[i+1][j+1] != '#') {
 						return false;
 					}
 					tiles[i][j] = '/';
 					tiles[i+1][j] = '\\';
 					tiles[i][j+1] = '\\';
 					tiles[i+1][j+1] = '/';
 				}
 			}
 		}
 		return true;
 	}
 
 	private String test1(List<String> words, String seq) {
 		int maxScore = -1;
 		String maxString = """";
 
 		for(String word : words) {
 			int score = -1;
 			StringBuilder wildCard = new StringBuilder(new String(new char[word.length()]).replace(""\0"", ""_""));
 			List<String> words2 = new ArrayList<String>(words);
 			int words2Size = words.size();
 
 			for(int i=0; i<seq.length(); i++) {
 				Character seqChar = seq.charAt(i);
 				int j=0;
 
 				while(j<words2Size) {
 					if(words2.get(j).indexOf(seqChar) != -1) {
 						break;
 					}
 					j++;
 				}
 
 				if(j == words2Size) {
 					continue;
 				}
 
 				if(word.indexOf(seqChar) == -1) {
 					score++;
 				} else {
 					int beginIndex = 0;
 					while(true) {
 						beginIndex = word.indexOf(seqChar, beginIndex);
 						if(beginIndex == -1) {
 							break;
 						}
 						wildCard.setCharAt(beginIndex, seqChar);
 						beginIndex++;
 					}
 
 					for(j=0; j<words2Size; j++) {
 						if(!killerWordWildCard(words2.get(j), wildCard.toString(), seqChar)) {
 							words2.remove(words2.get(j));
 							words2Size--;
 							j--;
 						}
 					}
 
 					if(words2Size == 1) {
 						break;
 					}
 				}
 			}
 			if(score > maxScore) {
 				maxScore = score;
 				maxString = word;
 			}
 		}
 		return maxString;
 	}
 
 	private boolean killerWordWildCard(String word, String wildCard, Character notIn) {
 		if(!wildCardMatch(word, wildCard)) {
 			return false;
 		} else if(notIn != null) {
 			int begin = -1;
 			while(true) {
 				if(begin+1 >= word.length()) {
 					break;
 				}
 				begin = word.indexOf(notIn, begin + 1);
 				if(begin == -1) {
 					break;
 				}
 				if(wildCard.charAt(begin) != notIn) {
 					return false;
 				}
 			}
 			//			wildCard.indexOf(notIn);
 		}
 		return true;
 	}
 
 	private boolean wildCardMatch(String str1, String str2) {
 		if(str1.length() != str2.length()) {
 			return false;
 		}
 		for(int i=0; i<str1.length(); i++) {
 			if(str2.charAt(i) != '_' && str1.charAt(i) != str2.charAt(i)) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	private Integer max(Integer... numbers) {
 		int max = numbers[0];
 
 		for(Integer number : numbers) {
 			if(number > max) {
 				max = number;
 			}
 		}
 		return max;
 	}
 
 	private Double max(Double... numbers) {
 		Double max = numbers[0];
 
 		for(Double number : numbers) {
 			if(number > max) {
 				max = number;
 			}
 		}
 		return max;
 	}
 
 	private Integer min(Integer... numbers) {
 		Integer min = numbers[0];
 
 		for(Integer number : numbers) {
 			if(number < min) {
 				min = number;
 			}
 		}
 		return min;
 	}
 
 	private Double min(Double... numbers) {
 		Double min = numbers[0];
 
 		for(Double number : numbers) {
 			if(number < min) {
 				min = number;
 			}
 		}
 		return min;
 	}
 
 	private int lcm(int a, int b) {
 		return a * b / gcd(a, b);
 	}
 
 	private int gcd(int a, int b) {
 		while(a != b) {
 			if(a > b) {
 				a -= b;
 			} else {
 				b -= a;
 			}
 		}
 		return a;
 	}
 }
","package cj141cc;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 public class CJ141CC {
 
     static BufferedReader inp;
     static PrintWriter out;
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         inp = new BufferedReader(new FileReader(""C:\\Users\\Faheem\\Desktop\\inc.txt""));
         int t = Integer.parseInt(inp.readLine());
         String mi;
         String[] k = null;
         PrintWriter outp = new PrintWriter(new FileWriter(""C:\\Users\\Faheem\\Desktop\\Output.txt""));
 
         for (int i = 0; i < t; i++) {
             outp.print(""Case #"" + (i + 1) + "": "");
             System.out.print(""Case #"" + (i + 1) + "": "");
             mi = inp.readLine();
             k = mi.split("" "");
             int ans = 0;
             int N = Integer.parseInt(k[0]);
             int M = Integer.parseInt(k[1]);
             int K = Integer.parseInt(k[2]);
             if (N < 2 || M < 2) {
                 ans = K;
             } 
             else {
                 int bs = ((N - 2) * (M - 2)) + (2 * (N + M - 4));
                 if (K >= bs) {
                     ans = 2 * (N + M - 4);
                     ans += (K - bs);
                 } else {
                     boolean st = false;
                     while (true) {
                         if (N < M && N > 2) {
                             int md = M - 1;
                             int bs1 = ((N - 2) * (md - 2)) + (2 * (N + md - 4));
                             if (bs1 < K) {
                                 st = true;
                             } else {
                                 M = md;
                             }
                         } else if (M > 2) {
                             int md = N - 1;
                             int bs1 = ((md - 2) * (M - 2)) + (2 * (md + M - 4));
                             if (bs1 < K) {
                                 st = true;
                             } else {
                                 N = md;
                             }
                         } else {
                             st = true;
                         }
                         if (st) {
                             break;
                         }
                     }
                     bs = ((N - 2) * (M - 2)) + (2 * (N + M - 4));
                     ans = 2 * (N + M - 4);
                     //ans -=(bs-K);
                 }
             }
             outp.println(ans);
             System.out.println(ans);
         }
         outp.close();
     }
 }
",0
259,14892,"import java.util.*;
 import java.io.*;
 
 public class A {
 	int T;
 	long r, t;
 	
 	public void doit() throws IOException {
 		Scanner sc = new Scanner(new BufferedReader(new FileReader(""C:\\Users\\think\\workspace\\GCJ 2013 1A\\src\\A-small-attempt0.in"")));
 		PrintWriter pw = new PrintWriter(new File(""C:\\Users\\think\\workspace\\GCJ 2013 1A\\src\\A.out""));
 		T = sc.nextInt();
 			for (int i=1; i<=T; i++) {
 				r = sc.nextLong();
 				t = sc.nextLong();
 				long k = bs();
 				pw.printf(""Case #%s: %s\n"", i, k);
 			}
 		pw.close();
 	}
 	
 	public long bs() {
 		long head = 1;
 		long tail = 1000000000;
 		while (tail - head > 1) {
 			long mid = (head + tail) / 2;
 			if (2 * mid * mid + (2*r-1) * mid - t <= 0)
 				head = mid;
 			else tail = mid;
 		}
 		if (2 * head * head + (2*r-1) * head - t <= 0 && (2 * head * head) + (2 * r + 3) * head + 1 + 2 *r > t)
 			return head;
 		return tail;
 	}
 	
 	public static void main(String[] args) throws IOException {
 		new A().doit();
 	}
 }
","package codejam;
 
 import java.io.*;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.Collections;
 
 
 class wire implements Comparator{
     int a;
     int b;
 
     public wire() {
     }
 
     public wire(int a, int b) {
         this.a = a;
         this.b = b;
     }
 
     public int compare(Object o1, Object o2){
         wire w1 = (wire)o1;
         wire w2 = (wire)o2;
         return (w1.a!=w2.b?w1.a-w2.a:w1.b-w2.b);
     }
 }
 
 public class RopeIntranet {
 
     public static void main(String args[]){
 
         String input = ""d:\\A-small-attempt0.in"";
         String output = ""d:\\A-small-attempt0.out"";
         File input_file = null;
         File output_file = null;
         BufferedReader br = null;
         BufferedWriter bw = null;
 
         try{
 
             input_file = new File(input);
             br = new BufferedReader(new FileReader(input_file));
 
             output_file = new File(output);
             bw = new BufferedWriter(new FileWriter(output_file));
 
             int case_count = Integer.parseInt(br.readLine());
             for(int i=1 ; i<=case_count ; i++){
                 ArrayList wires = new ArrayList();
                 int n = Integer.parseInt(br.readLine());
                 for(int j=0 ; j<n ; j++){
                     String h[] = br.readLine().split("" "");
                     wires.add(new wire(Integer.parseInt(h[0]),Integer.parseInt(h[1])));
                 }
                 Collections.sort(wires,new wire());
 
                 int point = process(wires,n);
                 bw.write(""Case #""+i+"": ""+point+""\n"");
             }
 
             br.close();
             bw.close();
 
         }catch(Exception e){
             e.printStackTrace();
         }
     }
 
 
     public static int process(ArrayList wires,int n){
         int point = 0;
         int a[] = new int[n];
         int b[] = new int[n];
         for(int i=0 ; i<n ; i++){
             wire w = (wire)wires.get(i);
             a[i] = w.a;
             b[i] = w.b;
             //System.out.println(i+"" = ""+""[""+a[i]+"",""+b[i]+""]"");
         }
 
         for(int i=0 ; i<n-1 ; i++){
             for(int j=i+1 ; j<n ; j++){
                 if(b[i]>b[j]) point++;
             }
         }
 
         return point;
     }
 }
",0
260,949,"import java.io.BufferedReader;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 
 
 public class RollerCoaster
 {
 	public static void main(String[] args) throws Exception
 	{
 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		FileWriter fw = new FileWriter(""output"");
 		
 		int cases = Integer.parseInt(br.readLine());
 		int r,n,k,run,pos,spos,cap,tot;
 		String[] line;
 		int[] groups;
 		
 		for(int i = 1; i <= cases; i++)
 		{
 			line = br.readLine().split("" "");
 			r = Integer.parseInt(line[0]);
 			k = Integer.parseInt(line[1]);
 			n = Integer.parseInt(line[2]);
 			groups = new int[n];
 			line = br.readLine().split("" "");
 			run = 0;
 			pos = 0;
 			spos = 0;
 			cap = 0;
 			tot = 0;
 			for(int j = 0; j < n; j++)
 				groups[j] = Integer.parseInt(line[j]);
 			
 			while(run < r)
 			{
 				if((pos == spos && cap > 0) || cap + groups[pos] > k)
 				{
 					tot += cap;
 					cap = 0;
 					run++;
 					spos = pos;
 				}
 				else
 				{
 					cap += groups[pos];
 					pos = (pos + 1) % n;
 				}
 			}
 			
 			fw.write(""Case #""+i+"": ""+tot+""\n"");
 		}
 		
 		fw.close();
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 
 public class FreeCellStatsFinder {
 
 	public static void main(String[] args) throws Exception {
 
 		BufferedReader br = new BufferedReader(new InputStreamReader(
 				new FileInputStream(args[0])));
 		String nextLine = br.readLine();
 		int testNumber = 1;
 		while ((nextLine = br.readLine()) != null) {
 			String[] splitParams = nextLine.split("" "");
 			if (findIfStatsPossible(Long.parseLong(splitParams[0]),
 					Long.parseLong(splitParams[1]),
 					Long.parseLong(splitParams[2]))) {
 				System.out.println(""Case #"" + testNumber + "": Possible"");
 			} else {
 				System.out.println(""Case #"" + testNumber + "": Broken"");
 			}
 			testNumber++;
 		}
 	}
 
 	public static boolean findIfStatsPossible(long numGamesPlayedToday,
 			long winPercentToday, long winPercentEver) {
 		if (winPercentEver == 100 && winPercentToday != 100)
 			return false;
 		if (winPercentEver == 0 && winPercentToday != 0)
 			return false;
 		if (winPercentToday == 0 || winPercentEver == 100)
 			return true;
 		for (int i = 1; i <= numGamesPlayedToday; i++) {
 			for (int j = 0; j <= i; j++) {
 				if ((100 * j) / i == winPercentToday && (100 * j) % i == 0) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 }
",0
261,2747,"import java.util.*;
 import static java.lang.Math.*;
 import java.io.*;
 
 public class B {
 	public static void p(Object... args) { System.out.println(Arrays.toString(args));}
 	
 	// Should be done, check for overflow
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		int T = in.nextInt();
 		for (int zz = 1; zz <= T; zz++) {
 			int N = in.nextInt();
 			long P = in.nextLong();
 			System.out.format(""Case #%d: %d %d \n"", zz, mustWin(N, P), couldWin(N, P));
 		}
 	}
 	static long couldWin(int N, long P) {
 		long low = 0;
 		long high = (1L<<N)-1;
 		// low could win, don't know about high
 		while (low < high) {
 			long mid = (low + high + 1) / 2;
 			if (couldWin(N, P, mid)) {
 				low = mid;
 			} else {
 				high = mid - 1;
 			}
 		}
 		return low;
 	}
 	static boolean couldWin(int N, long P, long K) {
 		long B = (1L << N) - 1 - K;
 		long numBeaten = 0;
 		long numLeftEqual = 1L << N;
 		while (B > 0) {
 			numLeftEqual /= 2;
 			numBeaten += numLeftEqual;
 			B = (B - 1) / 2;
 		}
 		long numLostTo = (1L << N) - numBeaten - 1;
 		return numLostTo < P;
 	}
 	static long mustWin(int N, long P) {
 		long low = 0;
 		long high = (1L<<N)-1;
 		// low must win, don't know about high
 		while (low < high) {
 			long mid = (low + high + 1) / 2;
 			if (mustWin(N, P, mid)) {
 				low = mid;
 			} else {
 				high = mid - 1;
 			}
 		}
 		return low;
 	}
 	static boolean mustWin(int N, long P, long K) {
 		long A = K;
 		long numLostTo = 0;
 		long numLeftEqual = 1L << N;
 		while (A > 0) {
 			numLeftEqual /= 2;
 			numLostTo += numLeftEqual;
 			A = (A - 1) / 2;
 		}
 		return numLostTo < P;
 	}
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package googlecodejam2012_qualification;
 import java.io.*;
 import java.util.*;
 /** 
  * @author neil
  */
 public class NewMain2 {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args)  throws IOException
     {         
         //BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   
         BufferedReader in = new BufferedReader(new FileReader(""C:\\Documents and Settings\\neil\\Desktop\\C-large.in""));        
         BufferedWriter out = new BufferedWriter(new FileWriter(""C:\\Documents and Settings\\neil\\Desktop\\C-large-output.txt""));
         PrintStream ps = new PrintStream(System.out,true);
         StringTokenizer st;//st = new StringTokenizer(in.readLine(),"" "");
         int t = Integer.parseInt(in.readLine());
         int count=0,count1=0;
         while(count++<t)
         {
             count1=0;
             st = new StringTokenizer(in.readLine(),"" "");
             int A = Integer.parseInt(st.nextToken());
             int B = Integer.parseInt(st.nextToken());
             //boolean n[] = new boolean[B+1];
             for(int i=A;i<=B;i++)
             {
                 String N = Integer.toString(i);
                  ArrayList<String> hey = new ArrayList<String>();
                 for(int j=1;j<N.length();j++)
                 {
                    
                     N = N.substring(N.length()-1)+N.substring(0,N.length()-1);
                     if(!N.startsWith(""0"")&&(Integer.parseInt(N)>=A&&Integer.parseInt(N)<i)&&!hey.contains(N))
                     {
                         hey.add(N);
                         //System.out.println(N+"" : ""+i);
                         count1++;                                                
                     }                    
                 }                            
             }                                                        
             
             ps.println(""Case #""+count+"": ""+count1);
             out.write(""Case #""+count+"": ""+count1+""\n"");
             out.flush();
         }   
        
        
     }
 }
",0
262,5597,"package tw.cosecant.q;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 
 import com.sun.org.apache.bcel.internal.generic.NEW;
 
 public class GCJ2014QD {
 
 	public static class WarGame {
 		int res = 0;
 		int resDec = 0;
 		private Comparator<Double> comp = new Comparator<Double>(){
 
 			@Override
 			public int compare(Double o1, Double o2) {
 				return -o1.compareTo(o2);
 			}
 			
 		};
 		public WarGame(ArrayList<Double> nBlocks, ArrayList<Double> kBlocks) {
 			Collections.sort(nBlocks, comp);
 			Collections.sort(kBlocks, comp);
 			double kmin = kBlocks.get(kBlocks.size()-1);
 			ArrayList<Double> kBlocksDec = new ArrayList<Double>(kBlocks); 
 			for(Double weight : nBlocks){
 				if (weight > kBlocks.get(0)){
 					kBlocks.remove(kBlocks.size() - 1);
 					res ++;
 				}
 				else{
 					int idx = 0;
 					for(int i = 0 ; i < kBlocks.size() ; i++){
 						if (kBlocks.get(i) > weight) {
 							idx = i;
 						}
 						else{
 							break;
 						}
 					}
 					kBlocks.remove(idx);
 				}
 			}
 			Collections.sort(nBlocks);
 			resDec = nBlocks.size();
 			for(Double weight : nBlocks){
 				if (kmin > weight){
 					kBlocksDec.remove(0);
 					resDec --;
 				}
 				else{
 					break;
 				}
 			}
 			for(Double weight : kBlocksDec){
 				if (weight > nBlocks.get(nBlocks.size() - 1)){
 					resDec --;
 				}
 				else{
 					break;
 				}
 			}
 		}
 
 		public String result() {			
 			return resDec+"" ""+res;
 		}
 
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(""D-small-attempt1.in"")));
 		int caseCount = Integer.parseInt(in.readLine());
 		for (int i = 0 ; i < caseCount ;i ++){
 			int n = Integer.parseInt(in.readLine());
 			ArrayList<Double> nBlocks = new ArrayList<Double>();
 			ArrayList<Double> kBlocks = new ArrayList<Double>();
 			String[] vals = in.readLine().split(""\\s"");
 			for (int j = 0; j < vals.length; j++) {
 				nBlocks.add(Double.valueOf(vals[j]));
 			}
 			vals = in.readLine().split(""\\s"");
 			for (int j = 0; j < vals.length; j++) {
 				kBlocks.add(Double.valueOf(vals[j]));
 			}
 			WarGame wg = new WarGame(nBlocks, kBlocks);
 			
 			System.out.println(""Case #""+(i+1)+"": ""+wg.result());
 		}
 	}
 
 }
","package tw.cosecant.q;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.Collections;
 import java.util.HashSet;
 
 public class GCJ2014QA {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(""A-small-attempt0.in"")));
 //	    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 	    String s;
 	    int caseCount = Integer.parseInt(in.readLine());
 	    for (int i = 0 ; i < caseCount ;i ++){
 	    	HashSet<String> set1 = new HashSet<String>();
 	    	HashSet<String> set2 = new HashSet<String>();
 	    	HashSet<String> set3 = new HashSet<String>();
 	    	int	row1 = Integer.parseInt(in.readLine());
 	    	
 	    	for (int j = 0 ; j < 4 ; j++){
 	    		String[] nums = in.readLine().split(""\\s"");
 	    		if (row1 == j + 1)
 	    			Collections.addAll(set1, nums);
 	    	}
 	    	int	row2 = Integer.parseInt(in.readLine());
 	    	
 	    	for (int j = 0 ; j < 4 ; j++){
 	    		String[] nums = in.readLine().split(""\\s"");
 	    		if (row2 == j + 1)
 	    			Collections.addAll(set2, nums);
 	    	}
 	    	for (String n : set1){
 	    		if (set2.contains(n)) set3.add(n);
 	    	}
 	    	if (set3.size() == 1){
 	    		System.out.println(""Case #""+(i+1)+"": ""+set3.iterator().next());
 	    	}else if (set3.size() == 0){
 	    		System.out.println(""Case #""+(i+1)+"": Volunteer cheated!"");
 	    	}else{
 	    		System.out.println(""Case #""+(i+1)+"": Bad magician!"");
 	    	}
 	    		
 	    }
 	  
 	  
 
 	}
 
 }
",1
263,2110,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Collections;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Vector;
 
 public class DeceitfulWar {
 	private File file = new File(""D:\\Sources\\GoogleCodeJam\\files\\D-large.in"");
 	private File outFile = new File(""D:\\Sources\\GoogleCodeJam\\files\\result.out"");
 
 	private Integer[] war;
 	private Integer[] dWar;
 	private Integer solved = 0;
 
 	public void readData() {
 		boolean first = true;
 		Scanner scanner;
 		try {
 			scanner = new Scanner(file);
 			while (scanner.hasNextLine()) {
 				String line = scanner.nextLine();
 				Scanner scan = new Scanner(line);
 				if (first) {
 					int t = scan.nextInt();
 					war = new Integer[t];
 					dWar = new Integer[t];
 					first = false;
 				} else {
 					int n = scan.nextInt();
 					scan.close();
 					line = scanner.nextLine();
 					scan = new Scanner(line);
 					List<Double> naomi = new Vector<Double>(n);
 					for (int i = 0; i < n; i++) {
 						naomi.add(scan.nextDouble());
 					}
 					scan.close();
 					line = scanner.nextLine();
 					scan = new Scanner(line);
 					List<Double> ken = new Vector<Double>(n);
 					for (int i = 0; i < n; i++) {
 						ken.add(scan.nextDouble());
 					}
 					scan.close();
 					war[solved] = solveWar(naomi, ken);
 					dWar[solved] = solveDWar(naomi, ken);
 					solved++;
 				}
 				scan.close();
 			}
 			scanner.close();
 			printResult();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private int solveWar(List<Double> namoi, List<Double> ken) {
 		Collections.sort(namoi);
 		Collections.sort(ken);
 		int count = 0;
 		int curNamoi = 0, curKen =0;
 		while(curNamoi < namoi.size()) {
 			while(curKen < ken.size() && ken.get(curKen) < namoi.get(curNamoi)) {
 				curKen++;
 				count++;
 			}
 			if(curKen > ken.size()) {
 				break;
 			}
 			curKen++;
 			curNamoi++;
 		}
 		return count;
 	}
 	
 	private int solveDWar(List<Double> namoi, List<Double> ken) {
 		Collections.sort(namoi);
 		Collections.reverse(namoi);
 		Collections.sort(ken);
 		Collections.reverse(ken);
 		int count = 0;
 		int curNamoi = 0, curKen = 0;
 		while((curNamoi + count) < namoi.size()) {
 			while((curNamoi + count) < namoi.size() && ken.get(curKen) > namoi.get(curNamoi)) {
 				curKen++;
 				count++;
 			}
 			if(curKen >= ken.size()) {
 				break;
 			}
 			curKen++;
 			curNamoi++;
 		}
 		return namoi.size() - count;
 	}
 
 	private void printResult() {
 		try {
 			FileWriter fstream = new FileWriter(outFile);
 			BufferedWriter out = new BufferedWriter(fstream);
 			for (int i = 0; i < war.length; i++) {
 				out.write(""Case #"" + (i + 1) + "": "" + dWar[i] + "" "" + war[i]);
 				out.newLine();
 			}
 			out.close();
 			fstream.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 }
","import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 
 public class Main {
 	private static File file = new File(""C:\\Documents and Settings\\forsst00\\Desktop\\codejam\\A-large.in"");
 	private static File outFile = new File(""C:\\Documents and Settings\\forsst00\\Desktop\\codejam\\result.out"");
 	
 	private static String[] plays;
 	private static int teams = 0;
 	
 	public static void main(String[] args) {
 		Scanner scanner;
 		boolean first = true;
 		boolean second = true;
 		boolean odd = true;
 		int count = 1;
 		int i = 0;
 		try {
 			FileWriter fstream = new FileWriter(outFile);
 			BufferedWriter out = new BufferedWriter(fstream);
 			scanner = new Scanner(file);
 			while (scanner.hasNextLine()) {
 				String line = scanner.nextLine();
 				Scanner scan = new Scanner(line);
 				while(scan.hasNext()) {
 					if(first) {
 						scan.next();
 						first = false;
 					} else if (second) {
 						teams = scan.nextInt();
 						plays = new String[teams];
 						second = false;
 					} else if (i < teams) {
 						plays[i] = scan.next();
 						i++;
 						if(i == teams) {
 							double[] res = calcRPI();
 							out.write(""Case #"" + count  + "": "");
 							out.newLine();
 							for(int j = 0; j < teams; j++) {
 								out.write(((Double)res[j]).toString());
 								out.newLine();
 							}
 							count++;
 							second = true;
 							i = 0;
 						}
 					} 
 				}
 			}
 			out.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private static double[] calcRPI() {
 		double[] wp = new double[teams];
 		for(int i = 0; i < teams; i++) {
 			double win = 0.0;
 			double lose = 0.0;
 			for(int j = 0; j < plays[i].length(); j++){
 				if(plays[i].charAt(j) == '0')
 					lose++;
 				else if (plays[i].charAt(j) == '1')
 					win++;
 			}
 			wp[i] = win / (win + lose);
 		}
 		double[] owp = new double[teams];
 		for(int i = 0; i < teams; i++) {
 			double curTeams = 0;
 			owp[i] = 0.0;
 			for(int j = 0; j < teams; j++){
 				if(i == j)
 					continue;
 				if(plays[i].charAt(j) == '.')
 					continue;
 				curTeams++;
 				double win = 0.0;
 				double lose = 0.0;
 				for(int k = 0; k < plays[j].length(); k++) {
 					if(k == i)
 						continue;
 					if(plays[j].charAt(k) == '0')
 						lose++;
 					else if (plays[j].charAt(k) == '1')
 						win++;
 				}
 				owp[i] += win / (win + lose);
 			}
 			owp[i] = owp[i] / curTeams;
 		}
 		
 		double[] oowp = new double[teams];
 		for(int i = 0; i < teams; i++) {
 			double curTeams = 0;
 			oowp[i] = 0.0;
 			for(int j = 0; j < teams; j++){
 				if(i == j)
 					continue;
 				if(plays[i].charAt(j) == '.')
 					continue;
 				curTeams++;
 				oowp[i] += owp[j];
 			}
 			oowp[i] = oowp[i] / curTeams;
 		}
 		
 		double[] res  = new double[teams];
 		for(int i = 0; i < teams; i++) {
 			res[i] = 0.25 * wp[i] + 0.5 * owp[i] + 0.25 * oowp[i];
 		}
 		return res;
 	}
 
 }",1
264,17686,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class CookieClickerAlpha {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scanner = new Scanner(new File(""B-large.in""));
 		int t = scanner.nextInt();
 		int caseNumber = 1;
 		while (caseNumber <= t) {
 			double c = scanner.nextDouble();
 			double f = scanner.nextDouble();
 			double x = scanner.nextDouble();
 
 			double result = 0;
 
 			int breakingPoint = (int) (x / c - 2 / f);
 			
 			int i = 0;
 			for (; i < breakingPoint; i++) {
 				result += c / (f * i + 2);
 			}
 			
 			result += x / (f * i + 2);
 			
 			System.out.println(""Case #"" + caseNumber++ + "": "" + result);
 		}
 	}
 	
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 public class ProblemA {
 
 	//private static final String PROBLEM_NAME = ""A-test"";
 
 	private static final String PROBLEM_NAME = ""A-small-attempt0"";
 	// private static final String PROBLEM_NAME = ""A-small-attempt1"";
 	// private static final String PROBLEM_NAME = ""A-small-attempt2"";
 	// private static final String PROBLEM_NAME = ""A-small-attempt3"";
 
 	// private static final String PROBLEM_NAME = ""A-large"";
 
 	private static boolean checkFeglaWon(String[] array) {
 		String[] strings = new String[array.length];
 		System.arraycopy(array, 0, strings, 0, array.length);
 		
 		for (int i = 0; i < strings.length; i++) {
 			String s = strings[i];
 			for (int j = 0; j < s.length() - 1;) {
 				if (s.charAt(j) == s.charAt(j + 1)) {
 					s = s.substring(0, j) + s.substring(j + 1);
 				} else {
 					j++;
 				}
 			}
 			strings[i] = s;
 		}
 		for (int i = 1; i < strings.length; i++) {
 			if (!strings[0].equals(strings[i])) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	public static void solve(Scanner in, PrintStream out) {
 		int n = in.nextInt();
 		String[] strings = new String[n];
 		for (int i = 0; i < n; i++) {
 			strings[i] = in.next();
 		}
 
 		if (checkFeglaWon(strings)) {
 			out.println(""Fegla Won"");
 			return;
 		}
 
 		int diffLetters = 1;
 		for (int i = 0; i < strings[0].length() - 1; i++) {
 			if (strings[0].charAt(i) != strings[0].charAt(i + 1)) {
 				diffLetters++;
 			}
 		}
 		int[][] letters = new int[n][diffLetters];
 		for (int i = 0; i < n; i++) {
 			String s = strings[i];
 			int index = 0;
 			for (int j = 0; j < s.length() - 1; j++) {
 				letters[i][index]++;
 				if (s.charAt(j) != s.charAt(j + 1)) {
 					index++;
 				}
 			}
 			letters[i][index]++;
 		}
 		
 		int result = 0;
 		for (int i = 0; i < diffLetters; i++) {
 			double average = 0.0;
 			for (int j = 0; j < n; j++) {
 				average += letters[j][i];
 			}
 			average /= n;
 			int mid = -1;
 			double minDelta = Double.MAX_VALUE;
 			for (int j = 0; j < n; j++) {
 				if (Math.abs(average - letters[j][i]) < minDelta) {
 					minDelta = Math.abs(average - letters[j][i]);
 					mid = letters[j][i];
 				}
 			}
 			for (int j = 0; j < n; j++) {
 				result += Math.abs(letters[j][i] - mid);
 			}
 		}
 		
 		out.println(result);
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new File(PROBLEM_NAME + "".in""));
 		PrintStream out = new PrintStream(new File(PROBLEM_NAME + "".out""));
 
 		int t = in.nextInt();
 		int caseNumber = 1;
 		long start = System.currentTimeMillis();
 		while (caseNumber <= t) {
 			System.out.println((System.currentTimeMillis() - start) + "": Case #"" + caseNumber);
 			out.print(""Case #"" + caseNumber++ + "": "");
 			solve(in, out);
 		}
 	}
 
 }
",1
265,6237,"import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Scanner;
 
 public class D {
 	
 	Scanner scanner = null;
 		
 	int line = 1;
 	boolean debug = false;
 	String inputFile = ""D-large.in"";	
 	int N;
 	List<Double> Nn;
 	List<Double> Nk;
 			
 	void read() {
 		N = scanner.nextInt();
 		
 		Nn = new ArrayList<Double>();
 		Nk = new ArrayList<Double>();
 		
 		for(int i=0;i<N;i++){
 			Nn.add(scanner.nextDouble());
 		}
 		for(int i=0;i<N;i++){
 			Nk.add(scanner.nextDouble());
 		}
 		Collections.sort(Nn);
 		Collections.sort(Nk);
 		
 		//debugln(Nn.toString());
 		//debugln(Nk.toString());
 	}
 	
 	
 	void solve() {
 		
 		List<Double> DNn = new ArrayList<Double>(Nn);
 		List<Double> DNk = new ArrayList<Double>(Nk);
 		
 		warScore(DNk,DNn,0,0, true);
 		System.out.print("" "");
 		List<Double> WNn = new ArrayList<Double>(Nn);
 		List<Double> WNk = new ArrayList<Double>(Nk);
 		
 		warScore(WNn,WNk,0,0, false);
 		
 
 	}
 	
 	void deceitfulWarScore(List<Double> DNn, List<Double> DNk, int kscore, int nscore){
 		
 
 
 	}
 	
 	void warScore(List<Double> WNn, List<Double> WNk, int kscore, int nscore, boolean deceitful){
 		
 		double ken = WNk.get(0);
 		double naomi = WNn.get(0);						;
 		if (ken > naomi){
 			kscore += 1;
 			WNk.remove(0);
 			WNn.remove(0);
 		}else{
 			WNk.remove(0);
 			WNn.remove(WNn.size()-1);
 			nscore+=1;
 		}
 		if(WNn.size()>0){
 			warScore(WNn,WNk,kscore,nscore,deceitful);
 		}else{
 			if(deceitful){
 				System.out.print(kscore);
 			}else{
 				System.out.print(nscore);
 			}
 		}		
 	}
 	
 	void run() {
 		long stime = System.currentTimeMillis();
 		int caseN = scanner.nextInt();		
 		for (int caseID = 1; caseID <= caseN; caseID++) {			
 			System.out.printf(""Case #%d: "", caseID);
 			read();
 			solve();
 			System.out.println();
 			debugln(""=================================="");
 			System.out.flush();
 		}
 		long ctime = System.currentTimeMillis();
 		debugln(String.format(""--- Done: %3.0fs"",(ctime-stime)*0.001));
 	}
 	
 	private void debug(String message){
 		if(debug){
 			System.out.print(message);
 		}
 	}
 	
 	private void debugln(String message){
 		if(debug){
 			System.out.println(message);
 		}
 	}
 
 	public D(){
 		try {
 			System.setIn(new BufferedInputStream(new FileInputStream(inputFile)));			
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		scanner = new Scanner(System.in);
 	}
 	
 	public static void main(String[] args) {
 		D a =new D();
 		a.run();
 	}
 }
","import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Scanner;
 
 public class B {
 	
 	Scanner scanner = null;
 		
 	boolean debug = false;
 	String inputFile = ""B-small-attempt0.in"";	
 	int A;
 	int B;
 	int K;
 	Map<Integer,Integer> combinationMap;
 		
 		
 	void read() {
 		A = scanner.nextInt();
 		B = scanner.nextInt();
 		K = scanner.nextInt();			
 	}
 		
 	void solve() {
 		combinationMap = new HashMap<Integer,Integer>();
 		
 		for(int a=0;a<A;a++){
 			for(int b=0;b<B;b++){
 				int result = a&b;
 				if(!combinationMap.containsKey(result)){
 					combinationMap.put(result, 0);
 				}
 				combinationMap.put(result, combinationMap.get(result)+1);
 			}
 		}
 		int match=0;
 		for(int k=0;k<K;k++){
 			if(combinationMap.containsKey(k)){
 				match+=combinationMap.get(k);
 			}
 		}
 		System.out.println(match);		
 	}
 
 	void run() {
 		long stime = System.currentTimeMillis();
 		int caseN = scanner.nextInt();		
 		for (int caseID = 1; caseID <= caseN; caseID++) {			
 			System.out.printf(""Case #%d: "", caseID);
 			read();
 			solve();
 			System.out.println();
 			debugln(""=================================="");
 			System.out.flush();
 		}
 		long ctime = System.currentTimeMillis();
 		debugln(String.format(""--- Done: %3.0fs"",(ctime-stime)*0.001));
 	}
 	
 	private void debug(String message){
 		if(debug){
 			System.err.print(message);
 		}
 	}
 	
 	private void debugln(String message){
 		if(debug){
 			System.err.println(message);
 		}
 	}
 
 	public B(){
 		try {
 			System.setIn(new BufferedInputStream(new FileInputStream(inputFile)));			
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		scanner = new Scanner(System.in);
 	}
 	
 	public static void main(String[] args) {
 		B a =new B();
 		a.run();
 	}
 }
",1
266,9315,"package codejam2013.qual.fairsquare;
 
 import java.util.*;
 import java.io.*;
 
 public class FairSquare {
 	final static String PROBLEM_NAME = ""fairsquare"";
 	final static String WORK_DIR = ""./src/codejam2013/qual/fairsquare/"";
 
 	long[] fairsquares = new long[100];
 	int fairsquarescount = 0;
 
 	void preCalculate(){
 		System.out.println(""Precalculating.."");
 		Arrays.fill(fairsquares, -1);
 		long a = 1;
 		long b = 1000000000000000L;
 
 		long sqrtA = (int) Math.sqrt(a);
 		long sqrtB = (int) Math.sqrt(b);
 		
 		long init = ((long)(sqrtA*sqrtA) == a?sqrtA:sqrtA+1);
 		for(long i=init;i<=sqrtB;i++){
 			if(isPalindrome(i)){
 				long iSquare = i*i;
 				if(isPalindrome(iSquare)){
 					fairsquares[fairsquarescount++] = iSquare;
 				}
 			}
 		}		
 	}
 	
 	void solve(Scanner sc, PrintWriter pw) {
 		long a = sc.nextLong();
 		long b = sc.nextLong();
 
 		int count=0;
 		for(int i=0;i<fairsquares.length;i++){
 			if(fairsquares[i]>=a&&fairsquares[i]<=b)
 				count++;
 		}
 
 		pw.println(""""+count);
 	}
 
 	private boolean isPalindrome(long iSquare) {
 		String str = iSquare+"""";
 		int len = str.length();
 		char[] chars = new char[len];
 		str.getChars(0, len, chars , 0);
 		for(int i=0;i<len;i++){
 			if(chars[i]!=chars[len-i-1]){
 				return false;
 			}
 		}
 		return true;
 	}
 
 	public static void main(String[] args) throws Exception {
 
 		FairSquare fairSquareProb = new FairSquare();
 		fairSquareProb.preCalculate();
 		
 		Scanner sc = new Scanner(new FileReader(WORK_DIR + ""C-large-1.in""));
 		PrintWriter pw = new PrintWriter(new FileWriter(WORK_DIR + ""output.txt""));
 		int caseCnt = sc.nextInt();
 		sc.nextLine();
 		for (int caseNum = 0; caseNum < caseCnt; caseNum++) {
 			System.out.println(""Processing test case "" + (caseNum + 1));
 			pw.print(""Case #"" + (caseNum + 1) + "": "");
 			
 			fairSquareProb.solve(sc, pw);
 		}
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 }
","import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class B {
 
 	private static String problem = ""bl"";
 	private static String inputFile = ""input/"" + problem + "".in"";
 	private static String outputFile = ""output/"" + problem + "".out"";
 
 	private static double eps = 1e-6;
 
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner(new File(inputFile));
 		PrintWriter out = new PrintWriter(new File(outputFile));
 
 		int nbTest = in.nextInt();
 		for (int testCase = 1; testCase <= nbTest; testCase++) {
 			int r = in.nextInt();
 			int c = in.nextInt();
 			long d = in.nextInt();
 			long[][] mass = new long[r][c];
 			for (int i = 0; i < r; i++) {
 				String s = in.next();
 				for (int j = 0; j < c; j++) {
 					mass[i][j] = d + s.charAt(j) - '0';
 				}
 			}
 
 			long[][] tm = new long[r][c];
 			Point[][] cm = new Point[r][c];
 			tm[0][0] = mass[0][0];
 			cm[0][0] = new Point(0, 0);
 
 			for (int j = 1; j < c; j++) {
 				tm[0][j] = tm[0][j - 1] + mass[0][j];
 				Point p1 = cm[0][j - 1];
 				Point p2 = new Point(0, j + 0);
 				cm[0][j] = centar(p1, tm[0][j - 1], p2, mass[0][j]);
 			}
 			for (int i = 1; i < r; i++) {
 				long mmm = 0;
 				Point ppp = new Point(0, 0);
 				for (int j = 0; j < c; j++) {
 					ppp = centar(ppp, mmm, new Point(i, j), mass[i][j]);
 					mmm += mass[i][j];
 					tm[i][j] = mmm + tm[i - 1][j];
 					cm[i][j] = centar(ppp, mmm, cm[i - 1][j], tm[i - 1][j]);
 				}
 			}
 
 			int max = -1;
 			for (int i = 2; i < r; i++) {
 				for (int j = 2; j < c; j++) {
 					for (int k = 2; k <= Math.min(i, j); k++) {
 						if (k <= max)
 							continue;
 						long m = tm[i][j];
 						Point p = cm[i][j];
 						p = centar(p, m, new Point(i, j), -mass[i][j]);
 						m -= mass[i][j];
 						p = centar(p, m, new Point(i - k, j), -mass[i - k][j]);
 						m -= mass[i - k][j];
 						p = centar(p, m, new Point(i, j - k), -mass[i][j - k]);
 						m -= mass[i][j - k];
 						p = centar(p, m, new Point(i - k, j - k),
 								-mass[i - k][j - k]);
 						m -= mass[i - k][j - k];
 
 						if (i > k) {
 							p = centar(p, m, cm[i - k - 1][j],
 									-tm[i - k - 1][j]);
 							m -= tm[i - k - 1][j];
 						}
 						if (j > k) {
 							p = centar(p, m, cm[i][j - k - 1], -tm[i][j - k
 									- 1]);
 							m -= tm[i][j - k - 1];
 						}
 						if (i > k && j > k) {
 							p = centar(p, m, cm[i - k - 1][j - k - 1], tm[i
 									- k - 1][j - k - 1]);
 							m += tm[i - k - 1][j - k - 1];
 						}
 
 						if (p.equals(new Point(i - 0.5 * k, j - 0.5 * k))) {
 							max = Math.max(max, k);
 						}
 					}
 				}
 			}
 
 			out.print(""Case #"" + testCase + "": "");
 			if (max == -1) {
 				out.println(""IMPOSSIBLE"");
 			} else {
 				out.println(max + 1);
 			}
 			//System.out.println(max + 1);
 		}
 
 		in.close();
 		out.close();
 	}
 
 	private static Point centar(Point p1, long m1, Point p2, long m2) {
 		double x = p1.x * m1 / (m1 + m2) + p2.x * m2 / (m1 + m2);
 		double y = p1.y * m1 / (m1 + m2) + p2.y * m2 / (m1 + m2);
 		return new Point(x, y);
 	}
 
 	private static class Point {
 		double x, y;
 
 		public Point(double x, double y) {
 			super();
 			this.x = x;
 			this.y = y;
 		}
 
 		@Override
 		public boolean equals(Object arg0) {
 			if (arg0 instanceof Point) {
 				Point p = (Point) arg0;
 				return Math.abs(x - p.x) < eps && Math.abs(y - p.y) < eps;
 			}
 			return super.equals(arg0);
 		}
 
 		@Override
 		public String toString() {
 
 			return ""("" + x + "", "" + y + "")"";
 		}
 	}
 }
",0
267,12155,"import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 
 public class Main {
 	
 	private long solve(int r, int k, int[] g) {
 		long result = 0;
 		int n = g.length;
 		
 		int[] rr = new int[n];
 		int[] steps = new int[n];
 		countSteps(k, g, n, rr, steps);
 		
 		int step = 0;
 		while (r > 0) {
 			r--;
 			result += rr[step];
 			step = (step + steps[step]) % n;
 		}
 		return result;
 	}
 
 
 
 	private void countSteps(int k, int[] g, int n, int[] rr, int[] steps) {
 		int sum = 0;
 		int j = 0;
 		for (int i = 0 ; i < n; i++) {
 			while (sum + g[j] <= k) {
 				sum += g[j];
 				j = (j+1) % n;
 				if (j == i) {
 					break;
 				}
 			}
 			rr[i] = sum;
 			sum -= g[i];
 			steps[i] = (j-i+n) % n;
 		}
 	}
 
 	private final static String file = ""C-large"";//""test2"";//""A-large"";
 	
 	
 
 	public static void main(String[] args) throws IOException {
 		long time1 = System.currentTimeMillis();
 		Main solver = new Main();
 		BufferedReader stdin = new BufferedReader(new InputStreamReader(new FileInputStream(file + "".in"")));
 		PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(file + "".out"")));
 		
 		int t = Integer.valueOf(stdin.readLine().trim());
 		StringTokenizer st;
 		for (int i = 1 ; i <= t; i++) {
 			st = new StringTokenizer(stdin.readLine());
 			int r = Integer.valueOf(st.nextToken());
 			int k = Integer.valueOf(st.nextToken());
 			int n = Integer.valueOf(st.nextToken());
 			int[] g = new int[n];
 			st = new StringTokenizer(stdin.readLine());
 			for (int j = 0 ; j < n; j++) {
 				g[j] = Integer.valueOf(st.nextToken());
 			}
 			
 			out.println(""Case #"" + i + "": "" + solver.solve(r,k,g));
 		}
 		out.flush();
 		out.close();
 		long time2 = System.currentTimeMillis();
 		System.out.println(""time: "" + (time2 - time1));
 	}
 
 	
 }
","import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 
 public class Main {
 	
 	private long solve(int r, int k, int[] g) {
 		long result = 0;
 		int n = g.length;
 		
 		int[] rr = new int[n];
 		int[] steps = new int[n];
 		countSteps(k, g, n, rr, steps);
 		
 		int step = 0;
 		while (r > 0) {
 			r--;
 			result += rr[step];
 			step = (step + steps[step]) % n;
 		}
 		return result;
 	}
 
 
 
 	private void countSteps(int k, int[] g, int n, int[] rr, int[] steps) {
 		int sum = 0;
 		int j = 0;
 		for (int i = 0 ; i < n; i++) {
 			while (sum + g[j] <= k) {
 				sum += g[j];
 				j = (j+1) % n;
 				if (j == i) {
 					break;
 				}
 			}
 			rr[i] = sum;
 			sum -= g[i];
 			steps[i] = (j-i+n) % n;
 		}
 	}
 
 	private final static String file = ""C-small-attempt0"";//""test2"";//""A-large"";
 	
 	
 
 	public static void main(String[] args) throws IOException {
 		long time1 = System.currentTimeMillis();
 		Main solver = new Main();
 		BufferedReader stdin = new BufferedReader(new InputStreamReader(new FileInputStream(file + "".in"")));
 		PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(file + "".out"")));
 		
 		int t = Integer.valueOf(stdin.readLine().trim());
 		StringTokenizer st;
 		for (int i = 1 ; i <= t; i++) {
 			st = new StringTokenizer(stdin.readLine());
 			int r = Integer.valueOf(st.nextToken());
 			int k = Integer.valueOf(st.nextToken());
 			int n = Integer.valueOf(st.nextToken());
 			int[] g = new int[n];
 			st = new StringTokenizer(stdin.readLine());
 			for (int j = 0 ; j < n; j++) {
 				g[j] = Integer.valueOf(st.nextToken());
 			}
 			
 			out.println(""Case #"" + i + "": "" + solver.solve(r,k,g));
 		}
 		out.flush();
 		out.close();
 		long time2 = System.currentTimeMillis();
 		System.out.println(""time: "" + (time2 - time1));
 	}
 
 	
 }
",1
268,5607,"package codejam2014;
 
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.Scanner;
 
 /**
  * Title: CookieClickerAlpha
  * 
  * Link: https://code.google.com/codejam/contest/2974486/dashboard#s=p1
  */
 public class CookieClickerAlpha {
     public static void main(String... args) throws Exception {
         //resolve(""2014-QR-cookie-tiny"");
         //resolve(""2014-QR-cookie-small0"");
         resolve(""2014-QR-cookie-small1"");
         //resolve(""2014-QR-cookie-large"");
     }
     
     private static void resolve(String dataFile) throws Exception {
         Locale.setDefault(Locale.US);
         // Initialize input and output.
         Scanner scanner = new Scanner(new File(dataFile + "".in""));
         PrintWriter printer = new PrintWriter(dataFile + "".out"");
         
         // Read number of test cases.
         int T = scanner.nextInt();
         
         // Evaluate each test case.
         for(int t=0; t<T; t++) {
             // Read input.
             double C = scanner.nextDouble();
             double F = scanner.nextDouble();
             double X = scanner.nextDouble();
             
             // Calculate result.
             //System.out.println(C + "" - "" + F + "" - "" + X);
             double result = resolveTestCase(C, F, X);
             
             // Print output.
             String message = ""Case #"" + (t+1) + "": "" + String.format(""%.7f"", result) + ""\n"";
             System.out.printf(message);
             printer.append(message);
         }
         
         printer.flush();
         printer.close();
     }
     
     private static double resolveTestCase(final double farmCost, final double farmRate, final double goal) {
         // Calculate number of farms to buy:  X/(2 + n*F) <= (X + C)/(2 + n*F + F)
         long n = 0;
         double aprox = (farmRate * goal - 2*farmCost - farmRate*farmCost) / (farmRate*farmCost); 
         if(aprox > 0) n = (long) Math.ceil(aprox);
         //System.out.println(""n: "" + n + "" - "" + aprox);   
         
         // Since 'n' is round, try two alternatives.
         double hooker1 = blackJack(farmCost, farmRate, goal, n);
         double hooker2 = blackJack(farmCost, farmRate, goal, n-1);
         
         return hooker1 < hooker2? hooker1 : hooker2;
     }
     
     public static double blackJack(final double farmCost, final double farmRate, final double goal, long n) {
         // Verify if at least one farm is going to be buyed.
         double rate = 2.0;
         double farmTime = 0.0;
         if(n > 0) {
             // Calculate the time need to buy all the farms.
             for(long i=0; i<n; i++) {
                 farmTime += farmCost/rate;
                 rate += farmRate;
             }
         }
         
         // Sum farm time to goal time.
         return farmTime + goal/rate;
     }
 }
","package jam2014.r1b;
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 
 /**
  * Title: 
  * 
  * Link: 
  */
 public class TheRepeater_v2 {
     public static void main(String[] args) throws Exception {
         resolve(""txt/2014/r1b/repeater-tiny2"");
         //resolve(""txt/2014/r1b/repeater-small"");
         resolve(""txt/2014/r1b/repeater-large"");
     }
     
     private static void resolve(String dataFile) throws Exception {
         // Initialize input and output.
         Locale.setDefault(Locale.US);
         Scanner scanner = new Scanner(new File(dataFile + "".in""));
         PrintWriter printer = new PrintWriter(dataFile + "".out"");
         
         // Read number of test cases.
         int T = scanner.nextInt();
         
         // Evaluate each test case.
         for(int t=0; t<T; t++) {
             // Read input.
             int N = scanner.nextInt(); 
             String vals[] = new String[N];
             for(int i=0; i<N; i++) vals[i] = scanner.next();
             
             // Calculate result.
             int result = resolveTestCase(vals);
             
             // Print output.
             String message = ""Case #"" + (t+1) + "": "" + (result<0? ""Fegla Won"" : result) + ""\n"";
             System.out.print(message);
             printer.append(message);
         }
         
         printer.flush();
         printer.close();
     }
     
     private static int resolveTestCase(String[] vals) {
         CharCount[][] strs = new CharCount[vals.length][];
         for(int i=0; i<vals.length; i++) strs[i] = toCharCount(vals[i]);
         
         // Calculo movimientos por cada letra.
         int res = 0;
         CharCount[] first = strs[0];
         for(int c=0; c<first.length; c++) {
             
             // Cantidades de la letra 'c'.
             int[] cant = new int[strs.length];
             for(int s=0; s<strs.length; s++) {
                 CharCount[] str = strs[s];
                 
                 if(first.length != str.length || first[c].c != str[c].c) return -1;
                     
                 cant[s] = str[c].n;
             }
             
             // Calculo minimos movimientos para unificar la letra 'c'.
             Arrays.sort(cant);
             int min = cant[0];
             int max = cant[cant.length - 1];
             int movC = -1;
             for(int g=min; g<=max; g++) {
                 int movs = 0;
                 for(int a=0; a<cant.length; a++) {
                     movs += Math.abs(cant[a] - g);
                 }
                 if(movC < 0 || movs < movC) movC = movs;
             }
             res += movC;
         }
     
         return res;
     }
         
     private static int distance(CharCount[] str1, CharCount[] str2) {
         int res = 0;
         
         if(str1.length != str2.length) return -1;
         
         for(int i=0; i<str1.length; i++) {
             if(str1[i].c == str2[i].c) {
                 res += Math.abs(str1[i].n - str2[i].n);
             } else {
                 return -1;
             }
         }
         
         return res;
     }
     
     private static CharCount[] toCharCount(String str) {
         List<CharCount> res = new ArrayList<>();
         
         char[] aux = str.toCharArray();
         for(int i=0; i<aux.length; i++) {
             if(res.isEmpty() || res.get(res.size() - 1).c != aux[i]) {
                 CharCount algo = new CharCount();
                 algo.c = aux[i];
                 algo.n = 1;
                 res.add(algo);
             } else {
                 res.get(res.size() - 1).n++;
             }
         }
         
         return res.toArray(new CharCount[res.size()]);
     }
 }
 
 class CharCount {
     public char c = ' ';
     public int n = 0;
 }
",1
269,13049,"import java.io.*;
 import java.util.*;
 
 /**
  * @author Denys Kopiychenko.
  *         Date: Apr 14, 2013
  *         Time: 1:48:31 AM
  */
 public class CJ2 {
 
     static List<int[][]> testList = new ArrayList<int[][]>();
 
     public static void main(String[] args) {
         readFile();
         List<Integer> res = new LinkedList<Integer>();
         for (int[][] a : testList)
             res.add(analyze(a));
         writeFile(res);
     }
 
     private static void writeFile(List<Integer> res) {
         StringBuilder s = new StringBuilder();
         for (int i = 1; i <= res.size(); i++){
             s.append(""Case #"" + i + "": "");
             if(res.get(i - 1)==1){
                 s.append(""YES"");
             } else s.append(""NO""); 
             s.append(""\r\n"");
         }
         try{
             // Create file
             FileWriter fstream = new FileWriter(""2.out"");
             BufferedWriter out = new BufferedWriter(fstream);
             System.out.println(s.toString());
             out.write(s.toString());
             //Close the output stream
             out.close();
         }catch (Exception e){//Catch exception if any
             System.err.println(""Error: "" + e.getMessage());
         }
     }
 
     private static int analyze(int[][] a) {
         int size = a.length * a[0].length;
         int[][] m = new int[a.length][a[0].length];
 
         for (int i = 1; i < a.length; i++){
             for (int j = 1; j < a[0].length; j++)
                 if (a[i][j] == 1 && !connected(i, j, a, new HashSet<Pair>())) return 0;
         }
         return 1;
     }
 
     private static boolean connected(int i, int j, int[][] a, Set<Pair> pl) {
         Set<Pair> plc = new HashSet<Pair>(pl);
         plc.add(new Pair(i, j));
         if (i == 0 || j == 0 || i == a.length - 1 || j == a[0].length - 1) return true;
         if ((a[i - 1][j] == 1 && !pl.contains(new Pair(i - 1, j)) && connected(i - 1, j, a, plc)) ||
             (a[i + 1][j] == 1 && !pl.contains(new Pair(i + 1, j))&& connected(i + 1, j, a, plc)) ||
             (a[i][j - 1] == 1 && !pl.contains(new Pair(i, j - 1))&& connected(i, j - 1, a, plc)) ||
             (a[i][j + 1] == 1 && !pl.contains(new Pair(i, j + 1))&& connected(i, j + 1, a, plc))) return true;
         return false;
     }
 
     private static void readFile() {
 
         BufferedReader br = null;
 
         try {
             br = new BufferedReader(new FileReader(""B-small-attempt1.in""));
             int testNumber = Integer.parseInt(br.readLine());
             System.out.println(testNumber);
             for (int i = 1; i <= testNumber; i++){
                 String ss[] = br.readLine().trim().split("" "");
                 int a = Integer.parseInt(ss[0]);
                 int b = Integer.parseInt(ss[1]);
                 int[][] matrix = new int[a][b];
                 for (int m = 0; m < a; m++){
                     String s = br.readLine();
                     System.out.println(s);
                     String[] sss = s.trim().split("" "");
                     for (int n = 0; n < b; n++){
                         matrix[m][n] = Integer.parseInt(sss[n]);
                     }
                 }
                 System.out.println(analyze(matrix));
                 testList.add(matrix);
                 System.out.println("" "");
             }
             br.close();
 
         } catch (IOException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
 
     }
 
 
 }
 
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.LinkedList;
 import java.util.Queue;
 import java.util.Scanner;
 
 
 public class C {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		
 		Scanner sc = new Scanner(new File(""C-small-attempt0.in""));
 		int t = Integer.parseInt(sc.nextLine());
 
 		for (int tc = 1; tc <= t; tc++) {
 			String line = sc.nextLine();
 			String[] tup = line.split("" "");
 			int r = Integer.parseInt(tup[0]);
 			int k = Integer.parseInt(tup[1]);
 			int n = Integer.parseInt(tup[2]);
 			line = sc.nextLine();
 			tup = line.split("" "");
 
 			Queue<Integer> q = new LinkedList<Integer>();
 			for (int g = 0; g < n; g++) q.add(Integer.parseInt(tup[g]));
 			
 			int income = 0;
 			for (int i = 0; i < r; i++) {
 				int np = 0;
 				for (int j = 0; j < n && np + q.peek() <= k; j++ ) {
 						int re = q.poll();
 						np += re;
 						q.add(re);
 				}
 				income += np;
 			}
 
 			System.out.println(""Case #"" + tc + "": "" + income);
 		}
 		sc.close();
 	}
 }
",0
270,12409,"import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class FairSquare {
 
 	private long comeco;
 	private long fim;
 
 	public FairSquare(long comeco, long fim) {
 		this.comeco = comeco;
 		this.fim = fim;
 	}
 
 	public static void resolver(Scanner scanner, BufferedWriter writer)
 			throws IOException {
 		int numberOfCases = scanner.nextInt();
 		scanner.nextLine();
 		for (int currentCase = 0; currentCase < numberOfCases; currentCase++) {
 			String ent = scanner.nextLine();
 			String[] ls = ent.split("" "");
 			long comeco = Long.parseLong(ls[0]);
 			long fim = Long.parseLong(ls[1]);
 			FairSquare fs = new FairSquare(comeco, fim);
 			System.out.println(""Case #"" + (currentCase+1));
 			writer.write(""Case #"" + (currentCase+1) + "": "" + fs.quantidade());
 			writer.newLine();
 		}
 	}
 
 	private int quantidade() {
 		int start = (int) Math.ceil(Math.sqrt(this.comeco)) - 1;
 		int end = (int) Math.floor(Math.sqrt(this.fim));
 		String sstart = String.valueOf(start);
 		String send = String.valueOf(end);
 		// System.out.println(""Comeco/Fim - ""+start+""/""+end);
 		return GoodPalyndromeFinder.goodPalyndromesUntil(send)
 				- GoodPalyndromeFinder.goodPalyndromesUntil(sstart);
 	}
 
 }
","import java.io.BufferedWriter;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Scanner;
 
 
 public class GeneralSolution {
 
 	final static Charset ENCODING = StandardCharsets.UTF_8;
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		Path pathin = Paths.get(""B-large.in"");
 		Path pathout = Paths.get(""output.txt"");
 		int numberOfCases = 0;
 		int currentCase = 1;
 		try (Scanner scanner = new Scanner(pathin, ENCODING.name())) {
 			try (BufferedWriter writer = Files.newBufferedWriter(pathout,
 					ENCODING)) {
 				LawnMower.resolver(currentCase++, scanner, writer);
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
",1
271,15301,"package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class q2011_A {
     
     public static void main(String[] args) throws FileNotFoundException {
         Scanner scanner = new Scanner(new File(""C:/docs/codejam/A-small-attempt0.in""));
         PrintWriter output = new PrintWriter(new File(""C:/docs/codejam/out1.txt""));
         
         int T;
         int N;
         
         int Odst = 0;
         int Opos = 1;
         int Bdst = 0;
         int Bpos = 1;
         
         int time = 0;
         int d;
         int c;
         
         char R;
         int P;
         
         System.out.println(System.currentTimeMillis());
         T = scanner.nextInt();
         for (int i = 0; i < T; i++) {
             time = 0;
             Odst = 0;
             Opos = 1;
             Bdst = 0;
             Bpos = 1;
             N = scanner.nextInt();
             for (int j = 0; j < N; j++) {
                 R = scanner.next().charAt(0);
                 P = scanner.nextInt();
                 if (R == 'O') {
                     d = (P > Opos ? P - Opos : Opos - P);
                     c = Math.max(d - Odst, 0) + 1;
                     Bdst += c;
                     time += c;
                     Opos = P;
                     Odst = 0;
                 } else {
                     d = (P > Bpos ? P - Bpos : Bpos - P);
                     d = Math.abs(P - Bpos);
                     c = Math.max(d - Bdst, 0) + 1;
                     Odst += c;
                     time += c;
                     Bpos = P;
                     Bdst = 0;
                 }
             }
         output.println(""Case #"" + Integer.toString(i + 1) + "": "" + Integer.toString(time));
         }
         System.out.println(System.currentTimeMillis());
         output.close();
     }
     
 }
","package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 public class q2011_C {
     
     public static int patrick_sum(int[] arr, int from, int to) {
         int s = 0;
         for (int i = from; i < to; i++) {
             s ^= arr[i];
         }
         return s;
     }
     
     public static int sean_sum(int[] arr, int from, int to) {
         int s = 0;
         for (int i = from; i < to; i++) {
             s += arr[i];
         }
         return s;
     }
     
     public static int check(int[] D, int N, int j, int max) {
         int x, y, z;
         System.out.println(Arrays.toString(D));
         x = patrick_sum(D, 0, j);
         y = patrick_sum(D, j, N);
         if (x == y) {
             System.out.println(j);
             System.out.println(""------------"");
             
             z = sean_sum(D, j, N);
             if (z > max) {
                 return z;
             }
         }
         return max;
     }
     
     public static void swap(int[] D, int i, int j) {
         int temp = D[i];
         D[i] = D[j];
         D[j] = temp;
     }
     
     public static void main(String[] args) throws FileNotFoundException {
         Scanner scanner = new Scanner(new File(""C:/docs/codejam/in1.txt""));
         PrintWriter output = new PrintWriter(new File(""C:/docs/codejam/out_C.txt""));
         
         int T = scanner.nextInt();
         int N;
         int[] C = new int[15];
         int[] D = new int[15];
         int max = -1;
         int x, y, z;
         
         for (int i = 0; i < T; i++) {
             System.out.println(""new test"");
             N = scanner.nextInt();
             for (int j = 0; j < N; j++) {
                 C[j] = scanner.nextInt();
             }
             System.arraycopy(C, 0, D, 0, N);
             for (int j = 1; j < N; j++) {
                 for (int k = 0; k < j; k++) {
                     for (int l = j; l < N; l++) {
                         max = check(D, N, j, max);
                         swap(D, k, l);
                     }
                 }
             }
             output.println(""Case #"" + Integer.toString(i + 1) + "": "" + (max < 0 ? ""NO"" : Integer.toString(max)));
         }
         output.close();
         scanner.close();
     }
     
 }
",1
272,15243,"import static java.lang.System.*;
 import java.util.*;
 
 public class Main {
 	static int MAX = 102;
 	
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(in);
 
 		int setnum = sc.nextInt();
 		for(int seti=1; seti<=setnum; seti++) {
 			int n = sc.nextInt();
 
 			boolean f = true;
 			int length = 0;
 			int[][] str = new int[n][MAX];
 			char[] chr = new char[MAX];
 			for(int i=0; i<n; i++) {
 				char[] tmp = sc.next().toCharArray();
 				 
 				int idx = -1;
 				for(int j=0; j<tmp.length; j++) {
 					if(j==0 || tmp[j-1]!=tmp[j]) {
 						idx++;
 						if(i==0) chr[idx] = tmp[j];
 					}
 					if(chr[idx] != tmp[j]) f = false;
 					
 					str[i][idx]++;
 				}
 				if(i==0) length = idx;
 				if(idx != length) f = false;
 			}
 			if(!f) {
 				out.println(""Case #"" + seti + "": Fegla Won"");
 				continue;
 			}
 			length++;
 //			out.println(length);
 //			for(int j=0; j<length; j++) out.print(chr[j]+ "" "");
 //			out.println();
 //			for(int i=0; i<n; i++) {
 //				for(int j=0; j<length; j++) out.print(str[i][j] + "" "");
 //				out.println();
 //			}
 			
 			int[][] count = new int[length][MAX];
 			for(int i=0; i<length; i++) {
 				for(int j=0; j<n; j++) {
 					count[i][str[j][i]]++;
 				}
 			}
 //			for(int i=0; i<length; i++) {
 //				for(int j=0; j<10; j++) out.print(count[i][j] + "" "");
 //				out.println();
 //			}
 			
 			int ans = 0;
 			for(int i=0; i<length; i++) {
 				int score = Integer.MAX_VALUE;
 				int nscore = 0;
 				int right = n;
 				int left = 0;
 				for(int j=1; j<MAX; j++) nscore += j*count[i][j];
 				for(int j=1; j<MAX; j++) {
 					nscore -= right;
 					right -= count[i][j];
 					left += count[i][j-1];
 					nscore += left;
 					
 					score = Math.min(score, nscore);
 				}
 				ans += score;
 			}
 
 			out.println(""Case #"" + seti + "": "" + ans);
 		}
 	}
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package numbers;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author Serban
  */
 public class Input {
 
     PrintWriter out;
 
     public Input(String fileName) {
         //C-large-practice.in
         try {
             out = new PrintWriter(new File(""result.txt""));
             Scanner scan = new Scanner(new File(fileName));
             int T = scan.nextInt();
             scan.nextLine();
             for (int i = 0; i < T; i++) {
                 int A = scan.nextInt();
                 int B = scan.nextInt();
                 solve(A, B, digits(A), i);
             }
             out.close();
         } catch (Exception e) {
             System.out.println(e.getMessage());
         }
     }
 
     private void solve(int A, int B, int digits, int testCase) {
         out.print(""Case #"" + (testCase + 1) + "": "");
         int nr = 0;
         int n = (int) Math.pow(10, digits);
 
         if (A >= 10) {
             for (int i = A; i < n; i++) {
                 int m = reverse(i, digits);
                 while (m != i) {
                     if (i < m && m <= B) {
                         nr++;
                     }
                     m = reverse(m, digits);
                 }
             }
         }
         System.out.println(nr);
         out.print(nr);
         out.println();
         out.flush();
     }
 
     private int digits(int nr) {
         int digits = 0;
         while (nr > 0) {
             nr /= 10;
             digits++;
         }
         return digits;
     }
 
     private int reverse(int nr, int digits) {
         int last = 0;
         while (last == 0) {
             last = nr % 10;
             nr = nr / 10;
         }
         nr = last * (int) Math.pow(10, digits - 1) + nr;
         return nr;
     }
 }
",0
273,13433,"package c;
 
 import java.util.ListIterator;
 import java.util.Vector;
 
 public class Folder 
 {
 	private String _name;
 	private Vector<Folder> _subFolders;
 	
 	public Folder(String name)
 	{
 		_name = name;
 		_subFolders = new Vector<Folder>();
 	}
 	
 	public String getName()
 	{
 		return _name;
 	}
 	
 	public Folder addSubFolder(String name)
 	{
 		if(hasSubFolder(name)) return null;
 		
 		Folder f = new Folder(name);
 		
 		_subFolders.add(f);
 		return f;
 	}
 	
 	public boolean hasSubFolder(String name)
 	{
 		if(getSubFolder(name) == null) return false;
 		return true;
 	}
 	
 	public Folder getSubFolder(String name)
 	{
 		ListIterator<Folder> li = _subFolders.listIterator();
 		Folder c = null;
 		
 		while(li.hasNext())
 		{
 			c = li.next();
 			if(c.getName().equals(name)) return c;
 		}
 		
 		return null;
 	}
 }
","package C;
 
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.LinkedList;
 import java.util.ListIterator;
 import java.util.Vector;
 
 import Backmask.Tools;
 
 public class Main {
 
 	public static void main(String[] args) throws IOException 
 	{
 		Vector<Integer> input = Tools.readInput(""A-small-attempt0.in"");
 		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));
 		
 		ListIterator<Integer> li = input.listIterator();
 		
 		int nbCases = li.next();
 		int inputkey = 1;
 		int r, k, n, money, tmpk;
 		LinkedList<Integer> queue = new LinkedList<Integer>();
 		LinkedList<Integer> inside = new LinkedList<Integer>();
 		
 		// each case
 		for(int i=0; i<nbCases; i++)
 		{
 			queue.clear();
 			inside.clear();
 			
 			r = li.next();
 			k = li.next();
 			n = li.next();
 			money = 0;
 			tmpk = 0;
 			
 			for(int j=0; j<n; j++)
 			{
 				queue.add(li.next());
 			}
 			
 			// each run
 			while(r > 0)
 			{
 				int tmp = -1;
 				boolean done = false;
 				tmpk = 0;
 				
 				// fill rollercoaster
 				while(!done)
 				{
 					tmp = queue.getFirst(); 
 					
 					// take passengers
 					if(tmpk + tmp <= k)
 					{
 						inside.add(tmp);
 						queue.pop();
 						tmpk += tmp;
 					}
 					else done = true;
 					
 					if(queue.size() == 0) done = true;
 				}
 				
 				// add money
 				money += tmpk;
 				
 				// empty rollercoaster
 				while(inside.size() > 0)
 				{
 					queue.add(inside.pop());
 				}
 				
 				r--;
 			}
 			
 			// write
 			out.println(""Case #"" + (i+1) + "": "" + money);
 		}
 		
 		
 		System.out.print(""DONE"");
 		out.close();
 	}
 }
",1
274,1417,"import java.io.*;
 import java.util.*;
 
 public class Diamond {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		BufferedReader input = null;
 		BufferedWriter output = null;
 		try {
 			input = new BufferedReader(new FileReader(""C:\\Users\\cerberus\\eclipse-workspace\\1C-A\\src\\A-small-attempt1.in""));
 			output = new BufferedWriter(new FileWriter(""C:\\Users\\cerberus\\eclipse-workspace\\1C-A\\src\\outp""));
 			Deque<Integer> stk = null;
 			TreeMap<Integer, Vector<Integer>> inherit = null;
 			TreeMap<Integer, Integer> visited = null;
 			TreeMap<Integer, Vector<Integer>> parents = null;
 			
 			int T = Integer.valueOf(input.readLine());
 		    for(int i=1; i<=T; i++) {
 		    	int N = Integer.valueOf(input.readLine());
 		    	inherit = new TreeMap<Integer, Vector<Integer>>();
 		    	visited = new TreeMap<Integer, Integer>();
 		    	parents = new TreeMap<Integer, Vector<Integer>>();
 		    	output.write(""Case #""+i+"": "");
 		    	
 		    	for(int j=1; j<=N; j++) {
 		    		String nums[] = input.readLine().split("" "");
 			    	int n = Integer.valueOf(nums[0]);
 			    	Vector<Integer> list = new Vector<Integer>();
 			    	for(int k=1; k<=n; k++) {
 			    		int m = Integer.parseInt(nums[k]);
 			    		list.add(m);
 			    		Vector<Integer> pa = parents.get(m);
 			    		if(pa == null) {
 			    			pa = new Vector<Integer>();
 			    		}
 			    		pa.add(j);
 			    		parents.put(m, pa);
 			    	}
 			    	inherit.put(j, list);
 			    	visited.put(j, 0);
 		    	}
 		    	Vector<Integer> acpat = new Vector<Integer>();
 		    	for(int j=1; j<=N; j++) {
 		    		if(parents.get(j) == null) acpat.add(j);
 		    	}
 		    	Vector<Integer> acp = new Vector<Integer>();
 		    	for(int tem: acpat) {
 		    		while(inherit.get(tem).size() < 2) {
 		    			if(inherit.get(tem).size() == 1)
 		    				tem = inherit.get(tem).firstElement();
 		    			else
 		    				break;
 		    		}
 		    		if(inherit.get(tem).size() > 1)
 		    			acp.add(tem);		    		
 		    	}
 		    	
 		    	boolean hasDiamond = false;
 		    	for(int j=0; j<acp.size(); j++) {
 			    	stk = new ArrayDeque<Integer>();
 			    	stk.push(acp.get(j));
 			    	for(int k=1; k<=N; k++)
 			    		visited.put(k, 0);
 			    	while(!stk.isEmpty()) {
 			    		int current = stk.pop();
 			    		visited.put(current, visited.get(current)+1);
 			    		if(visited.get(current) == 1) {
 			    			for(int kk: inherit.get(current))
 			    				stk.push(kk);
 			    		}
 			    	}
 			    	hasDiamond = false;
 			    	for(int n: visited.values()) {
 			    		if(n>1) {
 			    			hasDiamond = true;
 			    			break;
 			    		}
 			    	}
 			    	if(hasDiamond) break;
 		    	}
 		    	output.write(hasDiamond ? ""Yes"" : ""No"");
 		    	if(i<T) output.write(""\n"");
 		    }
 		} catch (FileNotFoundException e) {
 			System.out.println(""input file not found: "");
 			e.printStackTrace();
 		} catch(IOException e) {
 			System.out.println(""Error opening files: "");
 		    e.printStackTrace();
 		    System.exit(1);
 		} finally {
 			try {
 				input.close();
 				output.close();
 				System.out.println(""Done !!"");
 			} catch (IOException e) {
 				System.out.println(""Error closing files: "");
 				e.printStackTrace();
 			}
 		}
 	}
 
 }
","package qualification;
 import java.io.*;
 import java.util.*;
 import java.math.*;
 
 public class B {
 	//static String PROBLEM_NAME = ""b-practice"";
 	//static String PROBLEM_NAME = ""b-small-0"";
 	static String PROBLEM_NAME = ""b-small-1"";
 	//static String PROBLEM_NAME = ""b-small-2"";
 	//static String PROBLEM_NAME = ""b-small-3"";
 	//static String PROBLEM_NAME = ""b-small-4"";
 	//static String PROBLEM_NAME = ""b-large"";
 	
 	public static String[] words;
 	public static String list;
 	
 	public static int countPoints( String word ) throws Exception
 	{
 		int points=0;
 		HashSet<String> wordsLeft = new HashSet<String>();
 		for( int i=0; i<words.length; i++)
 			if( words[i].length() == word.length() )
 				wordsLeft.add( words[i] );
 		
 		int missing=word.length();
 		for(int i=0; missing > 0; i++ )
 		{
 			String letter = list.substring(i,i+1);
 			boolean found=false;
 			for(String tword:wordsLeft)
 			{
 				if( tword.indexOf(letter) != -1 )
 				{
 					found = true;
 					break;
 				}
 			}
 			
 			if( found )
 			{
 				int matches=0;
 				for(int j=0; j<word.length(); j++)
 				{
 					if( word.substring(j,j+1).equals(letter) )
 					{
 						matches++;
 						HashSet<String> newWordsLeft = new HashSet<String>();
 						for( String tword:wordsLeft )
 							if( tword.substring(j,j+1).equals(letter) )
 								newWordsLeft.add( tword );
 						
 						wordsLeft = newWordsLeft;
 					}
 				}
 				
 				if( matches == 0 )
 				{
 					points++;
 					HashSet<String> newWordsLeft = new HashSet<String>();
 					for( String tword:wordsLeft )
 						if( tword.indexOf(letter) == -1 )
 							newWordsLeft.add( tword );
 					wordsLeft = newWordsLeft;
 				}
 				else
 					missing -= matches;
 			}
 		}
 
 		return points;
 	}
 	
 	public static void solveCase() throws Exception {
 		int W = INT();
 		int L = INT();
 		
 		words = new String[W];
 
 		for(int i=0; i<W; i++)
 			words[i] = TOKEN();
 		
 		for(int i=0; i<L; i++)
 		{
 			String word = """";
 			int max=-1;
 			list = TOKEN();
 			
 			for(int j=0; j<W; j++)
 			{
 				int pts = countPoints(words[j]);
 				if( pts > max )
 				{
 					max = pts;
 					word = words[j];
 				}
 			}
 
 			if(i != 0)
 				print("" "");
 
 			print(word);
 		}
 		
 		
 		
 		println("""");
 	}
 
 	
 	// *************************************************************************************
 	// ****************** FRAMEWORK (borrowed from eireksten and modified) *****************
 	// *************************************************************************************
 	
 	public static File input;
 	public static FileReader inputreader;
 	public static BufferedReader in;
 	
 	public static File output;
 	public static FileWriter outputwriter;
 	public static BufferedWriter out;
 	
 	public static StringTokenizer st;
 	public static void main(String[] args) throws Exception {
 		setInput(""src/qualification/""+ PROBLEM_NAME +"".in"");
 		setOutput(""src/qualification/""+ PROBLEM_NAME +"".out"");
 		
 		int cases = INT();
 		for(int cc = 1;cc<=cases;cc++) {
 						
 			print(""Case #""+cc+"": "");
 			solveCase();
 		}
 		
 		close();
 	}
 	
 	// **************** PRINT METHODS **********************
 	
 	public static void println() throws IOException {
 		out.write(""\n"");
 		System.out.println();
 	}
 	
 	public static void println(Object obj) throws IOException {
 		out.write(obj.toString());
 		out.write(""\n"");
 		System.out.println(obj.toString());
 	}
 	
 	public static void print(Object obj) throws IOException {
 		out.write(obj.toString());
 		System.out.print(obj.toString());
 	}
 	
 	public static void println(long number) throws IOException {
 		out.write(Long.toString(number));
 		out.write(""\n"");
 		System.out.println(number);
 	}
 	
 	public static void print(long number) throws IOException {
 		out.write(Long.toString(number));
 		System.out.print(number);
 	}
 	
 	public static void println(char c) throws IOException {
 		out.write(Character.toString(c));
 		out.write(""\n"");
 		System.out.println(c);
 	}
 	
 	public static void print(char c) throws IOException {
 		out.write(Character.toString(c));
 		System.out.print(c);
 	}
 	
 	public static void println(String line) throws IOException {
 		out.write(line);
 		out.write(""\n"");
 		System.out.println(line);
 	}
 	
 	public static void print(String line) throws IOException {
 		out.write(line);
 		System.out.print(line);
 	}
 	
 	// ******************** INPUT DECLARATION ******************
 	
 	public static void setInput(String filename) throws IOException {
 		input = new File(filename);
 		inputreader = new FileReader(input);
 		in = new BufferedReader(inputreader);
 	}
 	
 	public static void setOutput(String filename) throws IOException {
 		output = new File(filename);
 		outputwriter = new FileWriter(output);
 		out = new BufferedWriter(outputwriter);
 	}
 	
 	public static void close() throws IOException {
 		if(in!=null)in.close();
 		if(inputreader!=null)inputreader.close();
 		
 		if(out!=null)out.flush();
 		if(out!=null)out.close();
 		if(outputwriter!=null)outputwriter.close();
 	}
 	
 	// ************************** INPUT READING *****************
 	
 	static String LINE() throws IOException { return in.readLine(); }
 	static String TOKEN() throws IOException {
 		while (st == null || !st.hasMoreTokens())st = new StringTokenizer(LINE());
 		return st.nextToken();
 	}
 	static int INT() throws IOException {return Integer.parseInt(TOKEN());}
 	static long LONG() throws IOException {return Long.parseLong(TOKEN());}
 	static double DOUBLE() throws IOException {return Double.parseDouble(TOKEN());}
 	static BigInteger BIGINT() throws IOException {return new BigInteger(TOKEN());}
 	
 }
",0
275,13435,"package qualificationround;
 
 import java.util.*;
 import java.io.*;
 
 public class ProblemB {
 	static char combineMap[][];
 	static boolean combineH[][];
 	static boolean opposeMap[][];
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws IOException{
 		Scanner sc = new Scanner(new FileReader(""B.in""));
 		PrintWriter out = new PrintWriter(new FileWriter(""B.out""));
 		int t = sc.nextInt();
 		for (int caseNum = 1; caseNum <= t; caseNum++)
 		{
 			combineMap = new char[26][26];
 			combineH = new boolean[26][26];
 			opposeMap = new boolean[26][26];
 			for (int i = 0; i < 26; i++) 
 				for (int j = 0; j < 26; j++){					
 					opposeMap[i][j] = false;
 					combineH[i][j] = false;
 				}
 			int c = sc.nextInt();			
 			for (int i = 0; i < c; i++){
 				String str = sc.next();
 				int c1 = (int)str.charAt(0)-65;
 				int c2 = (int)str.charAt(1)-65;
 				char c3 = str.charAt(2);
 				//System.out.println(c1+"" ""+c2+"" ""+c3);
 				combineMap[c1][c2] = c3;
 				combineMap[c2][c1] = c3;
 				combineH[c1][c2] = true;
 				combineH[c2][c1] = true;
 			}
 			int d = sc.nextInt();
 			for (int i = 0; i < d; i++){
 				String str = sc.next();
 				int c1 = (int)str.charAt(0)-65;
 				int c2 = (int)str.charAt(1)-65;
 				opposeMap[c1][c2] = true;
 				opposeMap[c2][c1] = true;
 			}
 			int seqlen = sc.nextInt();
 			String seq = sc.next();
 						
 			out.println(""Case #""+caseNum+"": ""+solve(seq));
 		}
 		out.close();
 	}
 	
 	private static String solve(String str){
 		ArrayList<Integer> arr = new ArrayList<Integer>();
 		for (int i = 0; i < str.length(); i++){
 			arr.add((int)str.charAt(i)-65);
 			if (arr.size()>=2){
 				int c1 = arr.get(arr.size()-2);
 				int c2 = arr.get(arr.size()-1);
 				if (combineH[c1][c2]){
 					arr.remove(arr.size()-1);
 					arr.remove(arr.size()-1);
 					arr.add((int)combineMap[c1][c2]-65);
 				}
 				if (arr.size()>=2){
 					int j = arr.size()-2;
 					while (j>=0 && !opposeMap[arr.get(j)][arr.get(arr.size()-1)]) 
 						j--;
 					if (j>=0){
 						arr.clear();
 					}
 				}
 			}
 		}
 		StringBuffer buffer = new StringBuffer(""["");
 		for (int i = 0; i < arr.size(); i++) {
 			buffer.append((char)(arr.get(i)+65));
 			if (i!=arr.size()-1)
 				buffer.append("", "");
 		}
 		buffer.append(']');
 		return buffer.toString();
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Random;
 
 public class A
 {
     public static void main(String args[]) throws Exception
     {
         Random r = new Random();
         int temp;
         int[] array = new int[1000];
         int[][] dist = new int[1000][1000];
         int index;
         for(int j = 0; j < 1000000; j++)
         {
             for(int i = 0; i < 1000; i++)
                 array[i] = i;
             for(int i = 0; i < 1000; i++)
             {
                 index = r.nextInt(1000);
                 temp = array[i];
                 array[i] = array[index];
                 array[index] = temp;
             }
             for(int i = 0; i < 1000; i++)
             {
                 dist[i][array[i]]++;
             }
         }
         
         BufferedWriter bw = new BufferedWriter(new FileWriter(""/Users/dennisqin/Downloads/C.out""));
         
         BufferedReader br = new BufferedReader(new FileReader(""/Users/dennisqin/Downloads/C-small-attempt0.in.txt""));
         br.readLine();
         
         for(int j = 0; j < 120; j++)
         {
             br.readLine();
             String line = br.readLine();
             String[] splits = line.split("" "");
             double relativeProb = 1;
             for(int k = 0; k < 1000; k++)
             {
                 relativeProb *= dist[k][Integer.parseInt(splits[k])]/(double)1000;
             }
             if (relativeProb > 1)
             {
                 bw.write(""Case #"" + (j+1) + "": BAD\n"");
             }
             else
             {
                 bw.write(""Case #"" + (j+1) + "": GOOD\n"");
             }
         }
         bw.flush();
     }
 }
",0
276,16185,"package codejam2014;
 import java.io.*;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.*;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class A {	
 	private static final int ThreadCheckTime = 2000;
 	private static final int TreadCount = 10;
 	//private String inFileName = ""H:\\Codejam\\src\\codejam2014\\A.in"";
 	private String inFileName = ""H:\\Codejam\\src\\codejam2014\\A-small-attempt0.in"";
 	//private String inFileName = ""H:\\Codejam\\src\\codejam2014\\A-large.in"";
 	private String outFileNeme = ""H:\\Codejam\\src\\codejam2014\\output.txt"";	
 	public int testCaseCount=0;	
 	public List<TestCase> cases;
 	public class TestCase implements Runnable{		
 		public String result;	
 		int N, X;
 		List<Integer> di;
 		public TestCase(){
 			N = getInt();
 			X = getInt();
 			di = new ArrayList<Integer>();
 			for (int i = 0; i < N; i++) {
 				di.add(getInt());
 			}
 			Collections.sort(di);
 			Collections.reverse(di);
 		}		
 		public void run(){
 			Integer count = 0;
 			System.out.println(di);
 			while(di.size()>0){
 				count++;
 				int a = di.get(0);
 				int b = 0;
 				di.remove(0);
 				int i;
 				if (di.size()>0) {
 					i = 0;
 					for (i = 0; i < di.size(); i++) {
 						if (a + di.get(i) <= X) {
 							b = di.get(i);
 							break;
 						}
 					}
 					try {
 						di.remove(i);
 					} catch (Exception e) {
 					}
 				}
 			}
 			result = count.toString();
 		}
 	}	
 	public void runCommon(){
 		
 	}
 	public void execute(){
 		testCaseCount = getInt();
 		System.out.println(testCaseCount + "" cases"");
 		cases = new ArrayList<TestCase>();
 		for(int i =0; i<testCaseCount; i++){
 			cases.add(getCase());
 		}
 		runCommon();
 		runSerial();
 		for(int i =0; i<testCaseCount; i++){
 			TestCase cs = cases.get(i);
 			String op = ""Case #"" + (i+1) + "": "" + cs.result;
 			System.out.println(op);
 			writeLine(op);
 		}
 	}	
 	public void runSerial(){
 		for(int i =0; i<testCaseCount; i++){
 			TestCase cs = cases.get(i);
 			cs.run();
 		}
 	}
 	public void runParallel(){
 		ExecutorService service = Executors.newFixedThreadPool(TreadCount);
 		for(int i=0;i<testCaseCount;i++){service.execute(cases.get(i));}
 		service.shutdown();
 		while(true){if(service.isTerminated())break;
 		try {Thread.sleep(ThreadCheckTime);} 
 		catch (InterruptedException e) {e.printStackTrace();}
 		}
 	}
 	public TestCase getCase(){
 		return new TestCase();
 	}	
 	public void writeLine(String line){outSc.format(line+'\n');}
 	public String nextLine(){return inSc.nextLine();}
 	public String getWord(){return inSc.next();}	
 	public Integer getInt(){return inSc.nextInt();}	
 	public Double getDouble(){return inSc.nextDouble();}	
 	public Long getLong(){return inSc.nextLong();}	
 	public BigInteger getBigInt(){return  new BigInteger(getWord());}	
 	public BigDecimal getBigDecimal(){return  new BigDecimal(getWord());}
 	public void closeOutputFile(){outSc.flush();outSc.close();}	
 	Scanner inSc;
 	Formatter outSc;	
 	public A() {
 		try {inSc = new Scanner(new File(inFileName));} 
 		catch (FileNotFoundException e1) {e1.printStackTrace();}	
 		try {outSc = new Formatter(outFileNeme);} catch (FileNotFoundException e) {e.printStackTrace();}
 	}	
 	public void complete(){inSc.close();outSc.flush();outSc.close();}
 	public static void main(String[] args) {
 		A st = new A();
 		st.execute();
 		st.complete();
 	}
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class MagicTrick {
 	
 	static int thisCase;
 	
 	public static void main(String[] args) throws IOException
 	{
 		Scanner in = new Scanner(new FileReader(args[0]));
 		PrintWriter out = new PrintWriter(new FileWriter( ""out.txt""));
 		int cases = in.nextInt();
 		in.nextLine();
 		for (thisCase = 1; thisCase <= cases; thisCase++) {
 			String display = ""Case #"" + thisCase + "": "" + solve(in);
 			out.println(display);
 			System.out.println(display);
 		}
 		out.close();
 	}
 
 	private static String solve(Scanner in) {
 		int rowNum1 = in.nextInt();
 		in.nextLine();
 		int[] row1 = new int[4];
 		for (int i = 0; i < 4; i++) {
 			if (i + 1 == rowNum1) {
 				row1[0] = in.nextInt();
 				row1[1] = in.nextInt();
 				row1[2] = in.nextInt();
 				row1[3] = in.nextInt();
 			}
 			in.nextLine();
 		}
 		int rowNum2 = in.nextInt();
 		in.nextLine();
 		int[] row2 = new int[4];
 		for (int i = 0; i < 4; i++) {
 			if (i + 1 == rowNum2) {
 				row2[0] = in.nextInt();
 				row2[1] = in.nextInt();
 				row2[2] = in.nextInt();
 				row2[3] = in.nextInt();
 			}
 			in.nextLine();
 		}
 		return solveHelper(row1, row2);
 	}
 
 	private static String solveHelper(int[] row1, int[] row2) {
 		boolean match = false;
 		int matchedInt = 0;
 		int test;
 		for (int i = 0; i < 4; i++) {
 			test = row1[i];
 			for (int j = 0; j < 4; j++) {
 				if (row2[j] == test) {
 					if (match) {
 						return ""Bad magician!"";
 					}
 					match = true;
 					matchedInt = test;
 					break;
 				}
 			}
 		}
 		if (!match) {
 			return ""Volunteer cheated!"";
 		} else {
 			return """" + matchedInt;
 		}
 	}
 
 }
",0
277,18705,"import java.io.File;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 
 public class A {
 	private static final String INPUT_FILE = ""inputs/Asmall-in.txt"";
 	private static final boolean IS_DEBUG = false;
 	
 	private final Scanner inputScanner;
 	private final int numCases;
 	private final String[] outputLines;
 	private final List<AComputeJob> jobs = new ArrayList<AComputeJob>();
 	private final ExecutorService threadPool = Executors.newFixedThreadPool(4);
 	
 	public A() throws Exception {
 		inputScanner = new Scanner(new File(INPUT_FILE));
 		numCases = inputScanner.nextInt();
 		outputLines = new String[numCases];
 		
 		for (int i = 0; i < numCases; i++) {
 			jobs.add(new AComputeJob(i));
 		}
 		
 		if (IS_DEBUG) {
 			for (int i = 0; i < jobs.size(); i++) {
 				jobs.get(i).call();
 			}
 		} else {
 			threadPool.invokeAll(jobs);
 		}
 		
 		FileOutputStream fos = new FileOutputStream(""outputs/A-sol.txt"");
 		PrintStream ps = new PrintStream(fos);
 		
 		for (int i = 0; i < numCases; i++) {
 			ps.println(""Case #"" + (i+1) + "": "" + outputLines[i]);
 		}
 		
 		fos.close();
 		System.exit(0);
 	}
 	
 	private class AComputeJob implements Callable<Void> {
 		private final int num;
 		char [][] sched;
 		double [] numWins;
 		double [] numGames;
 		double [] wp;
 		double [] owp;
 		double [] oowp;
 		double [] rpi;
 		int numTeams;
 		
 		public AComputeJob(int num) {
 			this.num = num;
 			
 			numTeams = inputScanner.nextInt();
 			sched = new char[numTeams][numTeams];
 			numWins = new double[numTeams];
 			numGames = new double[numTeams];
 			wp = new double[numTeams];
 			owp = new double[numTeams];
 			oowp = new double[numTeams];
 			rpi = new double[numTeams];
 			
 			for (int i = 0; i < numTeams; i++) {
 				String teamSched = inputScanner.next();
 				for (int j = 0; j < numTeams; j++) {
 					sched[i][j] = teamSched.charAt(j);
 				}
 			}
 			
 			
 			
 			
 			
 		}
 
 		
 
 		private void makeWp(int t) {
 			int numCurWins = 0;
 			int numCurGames = 0;
 			
 			for (int i = 0; i < numTeams; i++) {
 				if (sched[t][i] == '1') {
 					numCurWins++;
 					numCurGames++;
 				} else if (sched[t][i] == '0') {
 					numCurGames++;
 				}
 			}
 			
 			numWins[t] = numCurWins;
 			numGames[t] = numCurGames;
 			wp[t] = (double)numCurWins / (double)numCurGames;
 			
 		}
 		
 		private void makeOwp(int t) {
 			double sum = 0.0;
 			double divisor = 0.0;
 
 			for (int j = 0; j < numTeams; j++) {
 				if (sched[t][j] == '1') {
 					sum += (numWins[j] / (numGames[j] - 1.0));
 					divisor += 1.0;
 				} else if (sched[t][j] == '0') {
 					sum += ((numWins[j] - 1.0) / (numGames[j] - 1.0));
 					divisor += 1.0;
 				}
 			}
 			
 			owp[t] = sum / divisor;
 
 		}
 		
 		private void makeOowp(int t) {
 			double sum = 0.0;
 			double divisor = 0.0;
 			
 			for (int i = 0; i < numTeams; i++) {
 				if (sched[t][i] == '0' || sched[t][i] == '1') {
 					sum += owp[i];
 					divisor += 1.0;
 				}
 			}
 			
 			oowp[t] = sum / divisor;
 		}
 		
 		private void makeRpi(int t) {
 			rpi[t] = 0.25 * wp[t] + 0.5 * owp[t] + 0.25 * oowp[t];
 		}
 
 		@Override
 		public Void call() throws Exception {
 			String output = """";
 			StringBuffer sb = new StringBuffer();
 			
 			
 			for (int i = 0; i < numTeams; i++) {
 				makeWp(i);
 			}
 			
 			for (int i = 0; i < numTeams; i++) {
 				makeOwp(i);
 			}
 			
 			for (int i = 0; i < numTeams; i++) {
 				sb.append(""\n"");
 				makeOowp(i);
 				makeRpi(i);
 				sb.append("""" + rpi[i]);
 			}
 			
 			output = sb.toString();
 			
 			
 			
 
 			outputLines[num] = output;
 			System.out.println(""JOB-"" + num + "": Output is "" + outputLines[num]);
 			return null;
 		}
 
 		
 	}
 	
 
 	
 	
 	public static void main(String[] args) throws Exception {
 		new A();
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 /**
  *
  * @author Saul Hidalgo
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         try {
             Scanner sc = new Scanner(new File(""test.txt""));
             PrintStream ps = new PrintStream(new File(""output.txt""));
 
             int T = sc.nextInt();
             for ( int t = 1 ; t <= T ; t++ ){
                 int n = sc.nextInt(), s = sc.nextInt(), p = sc.nextInt();
 
                 int[] l = new int[n];
                 for ( int i = 0 ; i < n ; i++ ){
                     l[i] = sc.nextInt() - p ;
                 }
 
                 int a = 0 , b = 0;
 
                 for ( int i = 0 ; i < n ; i++ ){
                     if ( l[i] == -1 && p > 0 ){
                     }else if ( l[i] >= 2*( p - 1 ) ){
                         ++a;
                     }else if ( l[i] >= 2*( p - 2 ) ){
                         ++b;
                     }
                 }
                 ps.println(""Case #"" + t + "": "" + ( a + b - Math.max(0, b - s ) ));
             }
             
         }
         catch (FileNotFoundException ex) {
             // =(
         }
     }
 }
",0
278,13241,"package codejam.google.problems;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.LinkedList;
 
 public class ThemePark {
 
 	private int numOfCases;
 	private LinkedList<Integer> groupQueue;
 
 	public ThemePark(String aFileName) {
 
 		groupQueue = new LinkedList<Integer>();
 		File inputFile = new File(aFileName);
 		try {
 			BufferedReader in = new BufferedReader(new FileReader(inputFile));
 			numOfCases = Integer.parseInt(in.readLine());
 			for (int i = 1; i <= numOfCases; i++) {
 				String aLine = in.readLine();
 				String[] aString = aLine.split("" "");
 				int noOfGroups = Integer.parseInt(aString[2]);
 				String[] groups = in.readLine().split("" "");
 				for (int j = 0; j < groups.length; j++)
 					groupQueue.add(Integer.parseInt(groups[j]));
 				displayResult(i, numOfPeople(Integer.parseInt(aString[0]),
 						Integer.parseInt(aString[1]), noOfGroups));
 				for (int j = 0; j < groups.length; j++)
 					groupQueue.remove();
 			}
 
 		} catch (IOException e) {
 
 		}
 	}
 
 	private int numOfPeople(int noOfRides, int capacity, int noOfGroups) {
 
 		int noOfPeople = 0, localCapacity, groupSize;
 		for (int i = 0; i < noOfRides; i++) {
 			localCapacity = capacity;
 			groupSize = noOfGroups;
 			while (localCapacity >= 0 && groupSize >= 0) {
 				localCapacity -= groupQueue.peek();
 				groupSize -= 1;
 				if (localCapacity >= 0 && groupSize >= 0) {
 					int anItem = groupQueue.removeFirst();
 					noOfPeople += anItem;
 					groupQueue.add(anItem);
 				}
 
 			}
 
 		}
 
 		return noOfPeople;
 
 	}
 
 	private void displayResult(int i, int noOfPeople) {
 
 		try {
 			BufferedWriter out = new BufferedWriter(new FileWriter(
 					""C:\\GCJ\\out3.txt"", true));
 
 			System.out.println(""Case #"" + i + "": "" + noOfPeople);
 			out.write(""Case #"" + i + "": "" + noOfPeople);
 
 			out.write(""\r\n"");
 			out.close();
 		} catch (IOException e) {
 
 		}
 	}
 
 	public static void main(String s[]) {
 
 		ThemePark test = new ThemePark(""C:\\GCJ\\C-small-attempt0.in"");
 	}
 
 }
","package codejam.google.problems;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 
 public class B {
 
 	int numOfCases, l, p, c;
 
 	public B(String aFileName) {
 		initData(aFileName);
 	}
 
 	private void initData(String aFileName) {
 
 		try {
 			BufferedReader in = new BufferedReader(new FileReader(new File(
 					aFileName)));
 			numOfCases = Integer.parseInt(in.readLine());
 			for (int i = 0; i < numOfCases; i++) {
 				String[] aString = in.readLine().split("" "");
 				l = Integer.parseInt(aString[0]);
 				p = Integer.parseInt(aString[1]);
 				c = Integer.parseInt(aString[2]);
 				System.out.println(""Case #"" + (i + 1) + "": "" + noOfTests());
 				// displayResult();
 
 			}
 		} catch (IOException e) {
 
 		}
 	}
 
 	private int noOfTests() {
 		int count = 0;
 		double temp = p;
 		if (p == c * l)
 			return 0;
 		else {
 			if (p % c != 0) {
 				count++;
 				temp = Math.floor(p / c);
 			}
 			while (temp % l == 0 && temp > l * c) {
 				count++;
 				temp = temp / c;
 			}
 		}
 
 		return count;
 	}
 
 	public static void main(String[] args) {
 		long startTime = System.currentTimeMillis();
 		B test = new B(""C:\\GCJ\\load.in"");
 		long endTime = System.currentTimeMillis();
 		System.out.println(endTime - startTime);
 
 	}
 
 }
",1
279,12741,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 
 public class SwingingWild {
 
 	static final String input_path = ""data/input.txt"";
 		
 	private static boolean solve(int[] d, int[] I, int D) {
 		int N = d.length;
 		
 		int currentpos = d[0];
 		int prevpos = 0;
 		int coverage = (d[0] - prevpos) * 2;
 		
 		if (coverage >= D)
 			return true;
 		int currentpoint = 0;		
 		while (true) {
 			int max_coverage = -1;
 			int max_point = -1;
 			int max_position = -1;
 			int max_len = -1;
 			
 			for (int i = currentpoint + 1; i < N; i ++)
 				if (d[i] <= coverage) {
 					int next_len = d[i] - currentpos;
 					if (I[i] < next_len) 
 						next_len = I[i];
 					int new_coverage = d[i] + next_len;
 					int new_pos = d[i];
 					
 					if (next_len > max_len)
 //					if (new_coverage > max_coverage) {
 					if (next_len > max_len) {
 						max_len = next_len;
 						max_coverage = new_coverage;
 						max_point = i;
 						max_position = new_pos;
 					}
 					
 					if (new_coverage >= D)
 						return true;
 				}
 			
 			if (max_position < 0)
 				return false;
 			else {
 				currentpoint = max_point;
 				coverage = max_coverage;
 				currentpos = max_position;
 //				System.out.println(String.format(""%d %d %d"", currentpos, currentpoint, coverage));
 			}
 		}
 		
 	}
 	
 	/**
 	 * Good luck, Wash :)
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		BufferedReader in = new BufferedReader(new FileReader(input_path)); 
 		String intext = in.readLine();
 		int T = Integer.parseInt(intext);
 		for (int caseIter = 0; caseIter < T; caseIter ++) {
 			intext = in.readLine();
 			int N = Integer.parseInt(intext);
 			int[] d = new int[N];
 			int[] I = new int[N];
 			
 			for (int i = 0; i < N; i ++) {
 				intext = in.readLine();
 				String[] parts = intext.split("" "");
 				d[i] = Integer.parseInt(parts[0]);
 				I[i] = Integer.parseInt(parts[1]);
 			}
 				
 			intext = in.readLine();
 			int D = Integer.parseInt(intext);
 			
 			boolean ans = solve(d,I,D);
 			
 			if (ans)
 				System.out.println(String.format(""Case #%d: YES"", caseIter + 1));
 			else
 				System.out.println(String.format(""Case #%d: NO"", caseIter + 1));
 			
 		}
 		in.close();
 	}
 
 }
","package com.google.codejam.ka.tic;
 
 import java.io.*;
 import java.util.Scanner;
 
 public class TicTacToeTomek {
 
     private enum Status {
 
         X_WON(""X won""), O_WON(""O won""), DRAW(""Draw""), GAME_HAS_NOT_COMPLETED(""Game has not completed"");
 
         private String msg;
 
         private Status(String msg) {
             this.msg = msg;
         }
 
         @Override
         public String toString() {
             return msg;
         }
     }
 
     private class StatusHolder {
         Status status;
         boolean hasFreeCell;
 
         private StatusHolder(Status status, boolean hasFreeCell) {
             this.status = status;
             this.hasFreeCell = hasFreeCell;
         }
     }
 
     private String readInput(Scanner scanner) {
         StringBuilder result = new StringBuilder();
         int caseCnt = Integer.parseInt(scanner.nextLine().trim());
         for (int i = 0; i < caseCnt; i++) {
             Status statusForCase = getStatusForCase(scanner);
             result.append(String.format(""Case #%d: %s\n"", i+1, statusForCase));
             scanner.nextLine();
         }
 
         return result.toString();
     }
 
     private Status getStatusForCase(Scanner scanner) {
         char[][] board = new char[4][4];
         for (int x = 0; x < 4; ++x) {
             String line = scanner.nextLine().trim();
             for (int y = 0; y < 4; ++y) {
                 board[x][y] = line.charAt(y);
             }
             StatusHolder lineStatus = getStatus(board[x]);
             if (lineStatus.status != null) {
                 for (int j = x + 1; j < 4; ++j) {
                     line = scanner.nextLine();
                 }
                 return lineStatus.status;
             }
         }
         StatusHolder rowAndDiagonalStatus = getRowAndDiagonalStatus(board);
         return rowAndDiagonalStatus.status;
     }
 
     private StatusHolder getRowAndDiagonalStatus(char[][] board) {
         boolean canContinue = false;
         Evaluator evaluator = new Evaluator();
         for (int y = 0; y < 4; ++y) {
             evaluator.reset();
             for (int x = 0; x < 4; ++x) {
                 evaluator.addChar(board[x][y]);
             }
             StatusHolder statusHolder = evaluator.eval();
             if (statusHolder.status != null) {
                 return statusHolder;
             } else if (statusHolder.hasFreeCell) {
                 canContinue = true;
             }
         }
 
         evaluator.reset();
         for (int x = 0; x < 4; ++x) {
             evaluator.addChar(board[x][x]);
         }
         StatusHolder statusHolder = evaluator.eval();
         if (statusHolder.status != null) {
             return statusHolder;
         }
 
         evaluator.reset();
         for (int x = 0; x < 4; ++x) {
             evaluator.addChar(board[3-x][x]);
         }
         statusHolder = evaluator.eval();
         if (statusHolder.status != null) {
             return statusHolder;
         }
 
         if (!canContinue) {
             return new StatusHolder(Status.DRAW, false);
         } else {
             return new StatusHolder(Status.GAME_HAS_NOT_COMPLETED, true);
         }
     }
 
     private StatusHolder getStatus(char[] chars) {
         Evaluator evaluator = new Evaluator();
         for (int i = 0; i < chars.length; i++) {
             evaluator.addChar(chars[i]);
         }
         return evaluator.eval();
     }
 
     public static void main(String[] args) throws IOException {
         TicTacToeTomek ttt = new TicTacToeTomek();
         String result = ttt.readInput(new Scanner(new File(args[0])));
         FileWriter fileWriter = new FileWriter(""c:/work/codejam/out.txt"");
         fileWriter.write(result);
         fileWriter.close();
     }
 
     private class Evaluator {
         private boolean hasX = false;
         private boolean hasO = false;
         private boolean hasFreeCell = false;
 
         void addChar(char c) {
             switch (c) {
                 case 'X':
                     hasX = true;
                     break;
                 case 'O':
                     hasO = true;
                     break;
                 case 'T':
                     break;
                 case '.':
                     hasFreeCell = true;
                     break;
                 default:
                     throw new IllegalArgumentException(""Invalid char: "" + c);
             }
         }
 
         void reset() {
             hasX = false;
             hasO = false;
             hasFreeCell = false;
         }
 
         StatusHolder eval() {
             if (!hasFreeCell) {
                 if (hasX && !hasO) {
                     return new StatusHolder(Status.X_WON, false);
                 } else if (hasO && !hasX) {
                     return new StatusHolder(Status.O_WON, false);
                 } else {
                     return new StatusHolder(null, false);
                 }
             } else {
                 return new StatusHolder(null, true);
             }
         }
     }
 }
",0
280,20520,"import java.util.*;
 
 class A
 {
 	public static void main (String [] args)
 	{
 		Scanner sc = new Scanner(System.in);
 		int numTests = sc.nextInt();
 		TESTS:
 		for(int test = 1; test <= numTests; test++)
 		{
 			String ansStart = ""Case #"" + test + "": "";
 			int rowA = sc.nextInt();
 			int[][] boardA = new int[4][4];
 			boardCards(boardA, sc);
 			
 			int rowB = sc.nextInt();
 			int[][] boardB = new int[4][4];
 			boardCards(boardB, sc);
 			
 			int[] hits = new int[17];
 			calcHits(hits, boardA, rowA);
 			calcHits(hits, boardB, rowB);
 			
 			int yourCard = -1;
 			for(int i = 1; i <= 16; i++)
 			{
 				if(hits[i] > 1)
 				{
 					if(yourCard != -1){
 						System.out.println(ansStart + ""Bad magician!"");
 						continue TESTS;
 					}
 					yourCard = i;
 				}
 			}
 			if(yourCard == -1)
 				System.out.println(ansStart + ""Volunteer cheated!"");
 			else
 				System.out.println(ansStart + yourCard);
 
 		}
 	}
 	static void calcHits(int[] hits, int[][] board, int row)
 	{
 		for(int j = 0; j < 4; j++)
 		{
 			int r = board[row - 1][j];
 			hits[r]++;
 		}
 	}
 	static void boardCards(int[][] b, Scanner sc)
 	{
 		for(int i = 0; i < 4; i++)
 		{
 			for(int j = 0; j < 4; j++)
 			{
 				b[i][j] = sc.nextInt();
 			}
 		}
 	}
 }","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package go;
 
 
 import java.io.*;
 import java.math.*;
 
 /**
  *
  * @author keith
  */
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         new Main().run();
     }
 
 
         public void run() {
         BufferedReader in = null;
         BufferedWriter out = null;
         try{
 
             in = new BufferedReader(new FileReader(""B-small-attempt0.in""));
             out = new BufferedWriter(new FileWriter(""Bs.out""));
             
             int T = Integer.parseInt(in.readLine());
             System.out.println(""T=""+T);
             for(int i=0;i<T;i++){
                 int no = 0;
                 String res;
                 String[] one = in.readLine().split("" "");
                 int N = Integer.parseInt(one[0]);
                 int M = Integer.parseInt(one[1]);
                 int [][] lawn = new int[N][M];
                 for(int n=0;n<N;n++){
                     one = in.readLine().split("" "");
                     for(int m=0;m<M;m++){
                         lawn[n][m]= Integer.parseInt(one[m]);
                     }
                 }
                 int go = 1;
                 for(int n=0;n<N;n++){
                     for(int m=0;m<M;m++){
                         int h = lawn[n][m];
                         go = 1;
                         for(int a=0;a<N;a++){
                             if(h<lawn[a][m]){
                                 go = 0;
                                 break;
                             }
                         }
                         if(go==0){
                             for(int a=0;a<M;a++){
                                 if(h<lawn[n][a]){
                                     no = 1;
                                     break;
                                 }
                             }
                         }
                         if(no==1){
                             break;
                         }
                     }
                     if(no==1){
                         break;
                     }
                 }
 
                 if(no==1){
                     res = ""NO"";
                 } else {
                     res = ""YES"";
                 }
                 out.write(""Case #""+(i+1)+"": ""+res+""\n"");
                 System.out.print(""Case #""+(i+1)+"": ""+res+""\n"");
             }
             in.close();
             out.close();
         }catch(Exception e){
             e.printStackTrace();
             try{
                 in.close();
                 out.close();
             }catch(Exception e1){
                 e1.printStackTrace();
             }
         }
         System.out.print(""done.\n"");
     }
 
 }
",0
281,2141,"/**
  * 
  */
 package com.battleofcodes.magicka;
 
 /**
  * @author aroras
  *
  */
 public class Remover {
 	private String strToRemove;
 	public Remover(String strToRemove){
 		this.strToRemove = strToRemove;
 	}
 	
 	public String tryRemoving(String fullString){
 		while(fullString.contains(new String(new char[] {strToRemove.charAt(0)})) && fullString.contains(new String(new char[] {strToRemove.charAt(1)}))){
 			if(fullString.indexOf(strToRemove.charAt(1)) > fullString.indexOf(strToRemove.charAt(0))){
 				fullString = fullString.replaceAll(fullString.substring(fullString.indexOf(strToRemove.charAt(0)), fullString.indexOf(strToRemove.charAt(1))+1),"""");
 			}else{
 				fullString = fullString.replaceAll(fullString.substring(fullString.indexOf(strToRemove.charAt(1)), fullString.indexOf(strToRemove.charAt(0))+1),"""");
 			}
 		}
 		return fullString;
 	}
 }
","package speakingintongues;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.io.Writer;
 
 
 
 public class Input {
 	static String path = ""A-small-attempt0.in"";
 	public String getPath() {
 		return path;
 	}
 	StringBuffer sb = new StringBuffer();
 	public StringBuffer getSb() {
 		return sb;
 	}
 	public Input(String path) {
 		this.path = path;
 	}
 	public static void main(String[] str) {
 		try {
 			// Open the file that is the first
 			// command line parameter
 			FileInputStream fstream = new FileInputStream(path);
 			// Get the object of DataInputStream
 			DataInputStream in = new DataInputStream(fstream);
 			BufferedReader br = new BufferedReader(new InputStreamReader(in));
 			String strLine;
 			String strNew = """";
 			// Read File Line By Line
 			int lineNumber = 0;
 			Writer output = null;
 			  
 			  File file = new File(""out.txt"");
 			  output = new BufferedWriter(new FileWriter(file));
 			  Translator translator = new Translator();
 			while ((strLine = br.readLine()) != null) {
 				// Print the content on the console
 				lineNumber++;
 				if(lineNumber == 1){continue;}
 				output.write(""Case #"" +(lineNumber-1)+ "": "" + translator.translate(strLine) + ""\n"");
 				  
 			}
 			// Close the input stream
 			output.close();
 			in.close();
 		} catch (Exception e) {// Catch exception if any
 			System.err.println(""Error: "" + e.getMessage());
 		}
 
 	}
 }
",1
282,2858,"package round1a;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 
 public class ProblemA
 {
 	public static void main(String[] args)
 	{
 		try {
 			//ProblemA p = new ProblemA(""test.txt"");
 			ProblemA p = new ProblemA(""C:\\Downloads\\A-small-attempt6.in"");
 			// ProblemA p = new ProblemA(""C:\\Downloads\\A-large.in"");
 			p.slove();
 			p.close();
 		} catch (Throwable e) {
 			e.printStackTrace();
 		}
 	}
 
 	BufferedReader reader;
 	OutputStreamWriter writer;
 
 	public ProblemA(String inputFileName) throws Throwable
 	{
 		reader = new BufferedReader(new InputStreamReader(new FileInputStream(
 				inputFileName)));
 		writer = new OutputStreamWriter(new FileOutputStream(inputFileName
 				+ "".out"", false));
 	}
 	
 	public void close() throws IOException
 	{
 		reader.close();
 		writer.close();
 	}
 
 	int readInt() throws Throwable
 	{
 		return Integer.parseInt(readString());
 	}
 
 	long readLong() throws Throwable
 	{
 		return Long.parseLong(readString());
 	}
 
 	String readString() throws Throwable
 	{
 		StringBuilder s = new StringBuilder();
 		while (true) {
 			int c = reader.read();
 			if (c < 0 || c == ' ' || c == '\t' || c == '\r' || c == '\n') {
 				if (s.length() == 0)
 					continue;
 				else
 					break;
 			}
 			s.append((char) c);
 		}
 		if (s.length() == 0)
 			throw new IOException(""EOF"");
 
 		return s.toString();
 	}
 
 	String readLine() throws Throwable
 	{
 		return reader.readLine();
 	}
 
 	void outline(String str) throws Throwable
 	{
 		writer.write(str + ""\r\n"");
 		System.out.println(str);
 	}
 
 	/**
 	 * todo here
 	 */
 	public void slove() throws Throwable
 	{
 		int T;
 		T = readInt();
 		for (int caseOrder = 1; caseOrder <= T; caseOrder++) {
 			long N = readInt();
 			long Pd = readInt();
 			long Pg = readInt();
 			
 			boolean ret;
 			if (Pg == 0 && Pd > 0) {
 				ret = false;
 			} else if (Pg == 100 && Pd < 100) {
 				ret = false;
 			} else {
 				if (N >= 100) {
 					ret = true;
 				} else {
 					boolean f = true;
 					for (int i = 1; i <= N; i++) {
 						long dw = i * Pd;
 						if (dw % 100 == 0)
 							f = false;
 					}
 					if (f)
 						ret = false;
 					else
 						ret = test(100 - Pg, Pd - Pg, N);
 				}
 			}
 			outline(""Case #"" + caseOrder + "": "" + (ret ? ""Possible"" : ""Broken""));
 		}
 	}
 
 	private boolean test(long a, long b, long n)
 	{
 		// (aY + bD / 100) 
 		for (int y = 0; y < 100; y++) {
 			for (int d = 1; d <= n; d++) {
 				long s = a * y + b * d;
 				if (s % 100 == 0)
 					return true;
 			}	
 		}
 		return false;
 	}
 }
","import java.io.*;
 import java.util.*;
 import static java.lang.Double.*;
 import static java.lang.Integer.*;
 import static java.lang.Long.*;
 import static java.lang.Math.*;
 import static java.lang.System.*;
 /**
  * @author Diego Satoba
  * @mail diego.satoba@gmail.com
  * @veredict unknown
  * @problemId 
  * @judge codejam
  * @category 
  * @level 
  * @solution 
  * @date
  */
 @SuppressWarnings(""unused"")
 public class ThemePark {
 	public static void main(String[] args) throws Throwable {
 		BufferedReader in = new BufferedReader(new FileReader(""input.in""));
 		System.setOut(new PrintStream(""output.out""));
 		for (int nCase = 1, nCases = parseInt(in.readLine().trim()); nCase <= nCases; nCase++) {
 			StringTokenizer stk = new StringTokenizer(in.readLine());
 			int R = parseInt(stk.nextToken()), k = parseInt(stk.nextToken()), N = parseInt(stk.nextToken()), a[] = new int[N], sum = 0;
 			stk = new StringTokenizer(in.readLine());
 			for (int i = 0; i < N; i++) a[i] = parseInt(stk.nextToken());
 			for (int i = 0, idx = 0, IDX, c; i < R; i++) {
 				for (c = 0, IDX = idx; c <= k; ) {
 					if (c + a[idx] <= k) {
 						c += a[idx]; idx = (idx + 1)%N;
 						if (idx == IDX) break;
 					} 
 					else break;
 					
 				}
 				sum += c; 
 			}
 			System.out.printf(""Case #%d: %d%n"", nCase, sum);
 		}
 	}
 }
 
",0
283,14349,"package round1c;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.util.StringTokenizer;
 
 public class A {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		A instance = new A();
 		try {
 			instance.execute();
 		} catch (Exception e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 	}
 
 	private void execute() throws Exception {
 		FileReader fr = new FileReader(""c:\\d\\work\\google1c\\A-large.txt"");
 		BufferedReader reader = new BufferedReader(fr);
 		String line = reader.readLine();
 		int caseNo = 0;	
 		while((line = reader.readLine())!=null){
 			caseNo++;
 			StringTokenizer tokenizer = new StringTokenizer(line, "" "");
 			int rows = Integer.parseInt(tokenizer.nextToken());
 			int cols = Integer.parseInt(tokenizer.nextToken());
 			char[][] matrix = new char[rows][cols];
 
 			for(int i = 0; i < rows;i++){
 				line = reader.readLine();
 				for(int j = 0; j < cols;j++){
 						matrix[i][j]=line.charAt(j);
 				}
 			}
 			if(process(matrix)){
 				System.out.println(""Case #""+caseNo+"":"");
 				for(int i = 0; i < rows;i++){
 					for(int j = 0; j < cols;j++){
 						System.out.print(matrix[i][j]);
 					}
 					System.out.println();
 				}
 				
 			}else{
 				System.out.println(""Case #""+caseNo+"":"");
 				System.out.println(""Impossible"");
 			}
 		}
 	}
 
 	private boolean process(char[][] matrix) {
 		boolean flag = true;
 		try{
 			for(int i = 0; i < matrix.length;i++){
 				for(int j = 0; j < matrix[i].length;j++){
 					if(matrix[i][j]=='#'){
 						matrix[i][j]='/';
 						j++;
 						if(matrix[i][j]=='#'){
 							matrix[i][j]='\\';
 						}else{
 							flag=false;
 							break;
 						}
 						j--;
 						i++;
 						if(matrix[i][j]=='#'){
 							matrix[i][j]='\\';
 						}else{
 							flag=false;
 							break;
 						}
 						j++;
 						if(matrix[i][j]=='#'){
 							matrix[i][j]='/';
 						}else{
 							flag=false;
 							break;
 						}
 						i--;
 						j--;
 					}
 				}
 			}
 		}catch(Exception e){
 			flag=false;
 		}
 		return flag;
 	}
 
 }
","package code_jam;
 
 import java.io.*;
 import java.util.*;
 
 public class a {
 
   public static void main(String[] args) throws Exception{
     Scanner inf = new Scanner(new FileReader(""in.txt""));
     int nn = inf.nextInt();
     for (int ii = 0; ii < nn; ii++) {
       int x = inf.nextInt() - 1;
       HashSet<Integer> candidate = new HashSet<Integer>();
       for (int i = 0; i < 4; i++)
         for (int j = 0; j < 4; j++) {
           int num = inf.nextInt();
           if (x == i) candidate.add(num);
         }
       int y = inf.nextInt() - 1;
       HashSet<Integer> ans = new HashSet<Integer>();
       for (int i = 0; i < 4; i++)
         for (int j = 0; j < 4; j++) {
           int num = inf.nextInt();
           if (y == i && candidate.contains(num)) ans.add(num);
         }
       System.out.print(""Case #"" + (ii+1) + "": "");
       if (ans.size() == 0)
         System.out.println(""Volunteer cheated!"");
       else if (ans.size() == 1)
         System.out.println(ans.toArray()[0]);
       else
         System.out.println(""Bad magician!"");
     }
   }
 
 }
",0
284,12996,"package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main {
 	
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner sc = new Scanner(new File(args[0]));
 		
 		Integer numberOfTests = sc.nextInt();
 		List<TicTacToeTomek> cases = new ArrayList<TicTacToeTomek>(numberOfTests);
 		sc.nextLine();
 		for (int i = 0; i < numberOfTests; i++){
 			Board board = new Board(sc.nextLine(), sc.nextLine(), sc.nextLine(), sc.nextLine());
 			sc.nextLine();
 			cases.add(new TicTacToeTomek(i + 1, board));
 		}
 		
 		for (TicTacToeTomek tic : cases)
 			System.out.println(String.format(""Case #%s: %s"", tic.caseNumber(), tic.result()));
 	}
 }
 
 class Board{
 	BoardElements[][] board;
 	public Board (String... lines){
 		board = new BoardElements[lines.length][lines.length];
 		for (int i = 0; i < lines.length; i++){
 			for (int j = 0; j < lines.length; j++) {
 				board[i][j] = BoardElements.valueOf(lines[i].charAt(j) == '.' ? ""Dot"" : lines[i].charAt(j) + """");
 			}
 		}
 	}
 	
 	public boolean anyRowContainsOnly(BoardElements... elements) {
 		for (int i = 0; i < board.length; i++) {
 			boolean containOnlyElements = true;
 			for (int j = 0; j < board.length; j++) {
 				if (!Arrays.asList(elements).contains(board[i][j])) 
 					containOnlyElements = false;
 			}
 			if (containOnlyElements)
 				return true;
 		}
 		return false;
 	}
 	
 	public boolean anyColumnContainsOnly(BoardElements... elements) {
 		for (int j = 0; j < board.length; j++) {
 			boolean containOnlyElements = true;
 			for (int i = 0; i < board.length; i++) {
 				if (!Arrays.asList(elements).contains(board[i][j])) 
 					containOnlyElements = false;
 			}
 			if (containOnlyElements)
 				return true;
 		}
 		return false;
 	}
 	
 	public boolean anyDiagonalContainsOnly(BoardElements... elements) {
 		boolean diagonalUp = true;
 		boolean diagonalDown = true;
 		for (int i = 0; i < board.length; i++) {
 			
 			if (!Arrays.asList(elements).contains(board[i][i])) 
 				diagonalUp = false;
 			
 			if (!Arrays.asList(elements).contains(board[i][board.length - 1 - i])) 
 				diagonalDown = false;
 		}
 		return diagonalUp || diagonalDown;
 	}
 
 	public boolean hasElement(BoardElements dot) {
 		for (int j = 0; j < board.length; j++) 
 			for (int i = 0; i < board.length; i++)
 				if (board[j][i] == dot)
 					return true;
 		return false;
 	}
 }
 
 enum BoardElements {
 	X, O, T, Dot
 }
 
 class TicTacToeTomek {
 
 	Board board;
 	Integer caseNumber;
 	
 	public TicTacToeTomek(Integer caseNumber, Board board) {
 		this.board = board;
 		this.caseNumber = caseNumber;
 	}
 
 	public Object caseNumber() {
 		return caseNumber;
 	}
 
 	public String result() {
 		
 		if (elementWon(BoardElements.O)) 
 			return ""O won"";
 	
 		if (elementWon(BoardElements.X)) 
 			return ""X won"";
 		
 		if (gameStillOn())
 			return ""Game has not completed"";
 		
 		return ""Draw"";
 	}
 
 	private boolean gameStillOn() {
 		return board.hasElement(BoardElements.Dot);
 	}
 
 	private boolean elementWon(BoardElements o) {
 		return board.anyColumnContainsOnly(o, BoardElements.T) 
 			|| board.anyRowContainsOnly(o, BoardElements.T)
 			|| board.anyDiagonalContainsOnly(o, BoardElements.T);
 	}
 
 }","package codejam.twentyfourteen;
 
 import java.io.IOException;
 import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class DeceitfulWar {
 	List<Float> naomisBlocksSorted; 
 	List<Float> kensBlocksSorted;
 	
 	List<Float> naomisBlocksReversed; 
 	List<Float> kensBlocksReversed;
 	
 	public DeceitfulWar(List<Float> naomisBlocks, List<Float> kensBlocks) {
 		naomisBlocksSorted = new ArrayList<>(naomisBlocks);
 		kensBlocksSorted = new ArrayList<>(kensBlocks);
 		Collections.sort(naomisBlocksSorted);
 		Collections.sort(kensBlocksSorted);
 		
 		naomisBlocksReversed = new ArrayList<>(naomisBlocksSorted);
 		kensBlocksReversed = new ArrayList<>(kensBlocksSorted);
 		Collections.reverse(naomisBlocksReversed);
 		Collections.reverse(kensBlocksReversed);
 	}
 
 	public static void main(String[] args) throws IOException {
 		Scanner sc = new Scanner(Paths.get(""C:\\Users\\isabella\\Downloads\\D-large.in""));
 		int numberOfTests = sc.nextInt();
 		sc.useLocale(Locale.US);
 		int test = 0;
 		while (test++ < numberOfTests) {
 			DeceitfulWar dwar = readCase(sc);
 			String result = dwar.solve();
 			System.out.println(String.format(""Case #%s: %s"", test, result));
 			
 		}
 	}
 	
 	private String solve() {
 		return String.format(""%s %s"", solveDeceitful(), solveOptimally());
 	}
 
 	private String solveOptimally() {
 		int naomisPoints = 0;
 		for (int i = 0; i < naomisBlocksSorted.size(); i++) {
 			Float naomisBlock = naomisBlocksSorted.get(i);
 			Float kensBlock = getFirstBigger(naomisBlock);
 			
 			if (naomisBlock > kensBlock)
 				naomisPoints++;
 		}
 		return """" + naomisPoints;
 	}
 
 	private Float getFirstBigger(Float naomisBlock) {
 		Iterator<Float> iterator = kensBlocksSorted.iterator();
 		while(iterator.hasNext()) {
 			Float block = iterator.next();
 			
 			if (block > naomisBlock) {
 				iterator.remove();
 				return block;
 			}
 		}
 		
 		Iterator<Float> iterator2 = kensBlocksSorted.iterator();
 		Float minorBlock = iterator2.next();
 		iterator2.remove();
 		return minorBlock;
 	}
 
 	private String solveDeceitful() {
 		int naomisPoints = 0;
 		for (int i = 0; i < naomisBlocksReversed.size(); i++) {
 			Float naomisBlock = naomisBlocksReversed.get(i);
 			Float kensBlock = getFirstSmaller(naomisBlock);
 			
 			if (naomisBlock > kensBlock)
 				naomisPoints++;
 		}
 		return """" + naomisPoints;
 	}
 
 	private Float getFirstSmaller(Float naomisBlock) {
 		Iterator<Float> iterator = kensBlocksReversed.iterator();
 		while(iterator.hasNext()) {
 			Float block = iterator.next();
 			
 			if (block < naomisBlock) {
 				iterator.remove();
 				return block;
 			}
 		}
 		
 		Iterator<Float> iterator2 = kensBlocksReversed.iterator();
 		Float biggestBlock = iterator2.next();
 		iterator2.remove();
 		return biggestBlock;
 	}
 
 	private static DeceitfulWar readCase(Scanner sc) {
 		int numberOfBlocks = sc.nextInt();
 		
 		List<Float> naomisBlocks = readBlocks(sc, numberOfBlocks);
 		List<Float> kensBlocks = readBlocks(sc, numberOfBlocks);
 		
 		return new DeceitfulWar(naomisBlocks, kensBlocks);
 	}
 
 	private static List<Float> readBlocks(Scanner sc, int numberOfBlocks) {
 		List<Float> blocks = new ArrayList<>();
 		for (int i = 0; i < numberOfBlocks; i++) {
 			blocks.add(sc.nextFloat());
 		}
 		return blocks;
 	}
 	
 }",1
285,1111,"package codeJam;
 
 import candySplitting.CandySplitting;
 import magicka.Magicka;
 import botTrust.BotTrust;
 import snapperChain.SnapperChain;
 import themePark.ThemePark;
 import fairWarning.FairWarning;
 import goroSort.GoroSort;
 
 @SuppressWarnings(""unused"")
 public class CodeJamMain {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		//CodeJamIO codeJamIO = new SnapperChain(""snapperChain/A-small-attempt0"");
 		//CodeJamIO codeJamIO = new FairWarning(""fairWarning/B-large"");
 		//CodeJamIO codeJamIO = new ThemePark(""themePark/C-small-attempt0"");
 		//CodeJamIO codeJamIO = new BotTrust(""botTrust/A-large"");
 		//CodeJamIO codeJamIO = new Magicka(""magicka/B-large"");
 		CodeJamIO codeJamIO = new CandySplitting(""candySplitting/C-small-attempt0"");
 		//CodeJamIO codeJamIO = new GoroSort(""goroSort/D-small-attempt0"");
 		codeJamIO.run();
 	}
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 
 public class QA2013 {
 	
 	public void szamol(){
 		//String filename=""input.txt"";
 		//String filename=""A-small-attempt0.in"";
 		String filename=""A-large.in"";
 		String thisLine;
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(filename));
 			BufferedWriter bw= new BufferedWriter(new FileWriter(filename+"".out""));
 			thisLine=br.readLine();
 			Integer tnum=Integer.parseInt(thisLine);
 		    for(int i=0;i<tnum;i++) { // while loop begins here
 		    	Integer[][] tabla=new Integer[4][4];
 		    	Integer[] oszlopx=new Integer[4];
 		    	Integer[] oszlopo=new Integer[4];
 		    	Integer[] sorx=new Integer[4];
 		    	Integer[] soro=new Integer[4];
 
 		    	Integer atlo1x=0;
 		    	Integer atlo1o=0;
 		    	Integer atlo2x=0;
 		    	Integer atlo2o=0;
 		    	Boolean vanpont=false;
 		    	for (int j=0;j<4;j++){
 		    		oszlopx[j]=0;
 		    		oszlopo[j]=0;
 		    		sorx[j]=0;
 		    		soro[j]=0;
 		    	/*	for (int k=0;k<4;k++){
 		    			tabla[j][k]=0;
 		    		}*/
 		    	}
 		    	
 		    	String result="""";
 		    	for (int j=0;j<4;j++){
 		    	 	thisLine=br.readLine();
 		    	 	char[] sor=thisLine.toCharArray();
 		    	 	for (int k=0;k<4;k++){
 		    	 		if (sor[k]=='.') vanpont=true;
 		    	 		if (sor[k]=='T'){
 		    	 			sorx[j]++;
 		    	 			soro[j]++;
 		    	 			oszlopx[k]++;
 		    	 			oszlopo[k]++;
 		    	 			if (k==j) {
 		    	 				atlo1x++;
 		    	 				atlo1o++;
 		    	 			}
 		    	 			if (k==3-j){
 		    	 				atlo2x++;
 		    	 				atlo2o++;
 		    	 			}
 		    	 		}
 		    	 		if (sor[k]=='X'){
 		    	 			sorx[j]++;
 		    	 			oszlopx[k]++;
 		    	 			if (k==j) {
 		    	 				atlo1x++;
 		    	 			}
 		    	 			if (k==3-j){
 		    	 				atlo2x++;
 		    	 			}
 		    	 		}
 		    	 		if (sor[k]=='O'){
 		    	 			soro[j]++;
 		    	 			oszlopo[k]++;
 		    	 			if (k==j) {
 		    	 				atlo1o++;
 		    	 			}
 		    	 			if (k==3-j){
 		    	 				atlo2o++;
 		    	 			}
 		    	 		}
 		    	 	}
 		    	}
 		    	br.readLine();
 		    	if (atlo1x==4 || atlo2x==4) result=""X won"";
 		    	if (atlo1o==4 || atlo2o==4) result=""O won"";
 		    	for (int j=0;j<4;j++){
 			    	if (oszlopx[j]==4 || sorx[j]==4) result=""X won"";
 			    	if (oszlopo[j]==4 || soro[j]==4) result=""O won"";		    		
 		    	}
 		    	if (result.length()==0){
 		    		if (vanpont) result=""Game has not completed"";
 		    		else result=""Draw"";
 		    	}
 		        bw.write(""Case #""+(i+1)+"": ""+result+""\n"");
 		     } // end while 
 		     br.close();
 		     bw.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 	
 	
 	public static void main(String[] args) {
 		new QA2013().szamol();
 
 	}
 
 }
",0
286,6895,"import java.util.*;
 import java.io.*;
 
 public class AMagicTrick
 {
 	public static void main(String[] args) throws IOException
 	{
 		Scanner in = new Scanner(new BufferedReader(new FileReader(""A-small.in"")));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""A-small.out"")));
 		
 		int t = in.nextInt();
 		for (int i = 1; i <= t; i++)
 		{
 			int r1 = in.nextInt() - 1;
 			Set<Integer> poss1 = new HashSet<Integer> ();
 			for (int r = 0; r < 4; r++)
 				for (int c = 0; c < 4; c++)
 				{
 					int x = in.nextInt();
 					if (r1 == r)
 						poss1.add(x);
 				}
 			int r2 = in.nextInt() - 1;
 			Set<Integer> poss2 = new HashSet<Integer> ();
 			for (int r = 0; r < 4; r++)
 				for (int c = 0; c < 4; c++)
 				{
 					int x = in.nextInt();
 					if (r2 == r)
 						poss2.add(x);
 				}
 			poss1.retainAll(poss2);
 			if (poss1.size() > 1)
 				out.println(""Case #"" + i + "": Bad magician!"");
 			else if (poss1.size() < 1)
 				out.println(""Case #"" + i + "": Volunteer cheated!"");
 			else
 				for (int n : poss1)
 					out.println(""Case #"" + i + "": "" + n);
 		}
 		out.flush();
 		out.close();
 	}
 }","import java.math.*;
 import java.util.*;
 import java.io.*;
 
 public class B
 {
 	public static void main(String[] args) throws IOException
 	{
 		Scanner in = new Scanner(new BufferedReader(new FileReader(""B-large.in"")));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""B-large.out"")));
 		
 		int tt = in.nextInt();
 		for (int I = 1; I <= tt; I++)
 		{
 			out.print(""Case #"" + I + "": "");
 			Map<Integer, Set<Integer>> edges = new HashMap<> ();
 			int n = in.nextInt();
 			for (int i = 1; i <= n; i++)
 				edges.put(i, new HashSet<Integer> ());
 			for (int i = 1; i < n; i++)
 			{
 				int a = in.nextInt();
 				int b = in.nextInt();
 				edges.get(a).add(b);
 				edges.get(b).add(a);
 			}
 			System.out.println(edges);
 			int best = n - 1;
 			int choice = 0;
 			for (int i = 1; i <= n; i++)
 				if (edges.get(i).size() > 1)
 				{
 					int temp = n - rootTree(edges, i);
 					if (temp < best)
 					{
 						best = temp;
 						choice = i;
 					}
 				}
 			out.println(best);
 			System.out.println(best + "" "" + choice);
 		}
 		out.flush();
 		out.close();
 	}
 	
 	private static int rootTree(Map<Integer, Set<Integer>> edges, int root)
 	{
 //		System.out.println(""\tcalling roottree on "" + root + "" with "" + edges);
 		if (edges.get(root).size() == 2)
 			return explore(edges, root);
 		else if (edges.get(root).size() < 2)
 			throw new RuntimeException();
 		else
 		{
 			List<Integer> list = new ArrayList<> ();
 			for (int edge : new HashSet<Integer> (edges.get(root)))
 			{
 				edges.get(root).remove(edge);
 				edges.get(edge).remove(root);
 				list.add(explore(edges, edge));
 				edges.get(root).add(edge);
 				edges.get(edge).add(root);
 			}
 			Collections.sort(list);
 			Collections.reverse(list);
 //			System.out.println(""\trootTree on "" + root + "" returning "" + (list.get(0) + list.get(1) + 1));
 			return list.get(0) + list.get(1) + 1;
 		}
 	}
 	
 	private static int explore(Map<Integer, Set<Integer>> edges, int root)
 	{
 //		System.out.println(""\tcalling explore on "" + root + "" with "" + edges);
 		if (edges.get(root).size() <= 1)
 			return 1;
 		if (edges.get(root).size() > 2)
 			return rootTree(edges, root);
 		Set<Integer> explored = new HashSet<> ();
 		explored.add(root);
 		Queue<Integer> frontier = new LinkedList<> (edges.get(root));
 		int safe = 0;
 		while (!frontier.isEmpty())
 		{
 			int node = frontier.remove();
 			explored.add(node);
 			if (edges.get(node).size() <= 2)
 				continue;
 			if (edges.get(node).size() == 3)
 			{
 				for (int n : edges.get(node))
 					if (!explored.contains(n))
 						frontier.add(n);
 			}
 			else
 			{
 				int parent = -1;
 				for (int n : edges.get(node))
 					if (explored.contains(n))
 						parent = n;
 				edges.get(parent).remove(node);
 				edges.get(node).remove(parent);
 				safe += rootTree(edges, node) - 1;
 				edges.get(node).add(parent);
 				edges.get(parent).add(node);
 			}
 		}
 //		System.out.println(""\texplore on "" + root + "" returning "" + (explored.size() + safe));
 		return explored.size() + safe;
 	}
 }
",1
287,9613,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.SortedSet;
 import java.util.TreeSet;
 
 
 public class DS {
 
 	public static void main(String args[]) {
 		FileReader fr = null;
 		BufferedReader br = null;
 		try {
 			fr = new FileReader(""D-small-attempt2.in.txt"");
 			br = new BufferedReader(fr);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 
 		FileWriter fw = null;
 		BufferedWriter bw = null;
 		try {
 			fw = new FileWriter(""D-small-attempt2.out.txt"");
 			bw = new BufferedWriter(fw);
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		}
 
 		int count = 0;
 		try {
 			count = Integer.parseInt(br.readLine());
 		} catch (NumberFormatException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 		for (int i = 1; i <= count ; i++) {
 
 			StringBuilder sb = new StringBuilder();
 			SortedSet<Float> naomiBlockSet = new TreeSet<Float>();
 			SortedSet<Float> kenBlockSet = new TreeSet<Float>();
 			try {
 				br.readLine(); // ignore size
 				String naomiBlock = br.readLine();
 				String kenBlock = br.readLine();
 				String [] naomiBlocks = naomiBlock.split("" "");
 				String [] kenBlocks = kenBlock.split("" "");
 				for(int j = 0; j < naomiBlocks.length ; j++) {
 					float naomi = Float.parseFloat(naomiBlocks[j]);
 					naomiBlockSet.add(naomi);
 					float ken = Float.parseFloat(kenBlocks[j]);
 					kenBlockSet.add(ken);
 				}
 
 					int size = naomiBlockSet.size();
 					Float [] naomiArray = new Float [size];
 					naomiBlockSet.toArray(naomiArray);
 					Float [] kenArray = new Float [size];
 					kenBlockSet.toArray(kenArray);
 				if (naomiArray[naomiArray.length - 1] < kenArray[0]) {
 					sb.append(""0 0"");
 				} else if (naomiArray[0] > kenArray[naomiArray.length - 1]) {
 					sb.append(naomiArray.length).append("" "").append(naomiArray.length);
 				} else {
 					sb.append(getDeceitfulCount(naomiArray, kenArray)).append("" "").append(getWarCount(naomiArray, kenArray));
 				}
 
 			} catch (IOException e1) {
 				e1.printStackTrace();
 			}
 
 			String result = sb.toString();
 
 			StringBuffer resultStr = new StringBuffer();
 			resultStr.append(""Case #"");
 			resultStr.append(i);
 			resultStr.append("": "");
 			resultStr.append(result);
 			resultStr.append(""\n"");
 			try {
 				bw.write(resultStr.toString());
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			System.out.print(resultStr.toString());
 		}
 		try {
 			bw.flush();
 			bw.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 	}
 
 	private static int getWarCount(Float [] naomi, Float [] ken) {
 		int count = 0;
 		for(int i = 0,j = 0;i < naomi.length && j < ken.length;i++, j++) {
 			while(naomi[i] > ken[j]) {
 				j++;
 				if (j == naomi.length) return naomi.length - count;
 			}
 			count++;
 		}
 		return naomi.length - count;
 	}
 
 	private static int getDeceitfulCount(Float [] naomi, Float [] ken) {
 		int count = 0;
 		for(int i = 0,j = 0;i < naomi.length && j < ken.length;i++, j++) {
 			while(ken[i] > naomi[j]) {
 				j++;
 				if (j == naomi.length) return count;
 			}
 			count++;
 		}
 		return count;
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 
 public class BS {
 
 	public static void main(String args[]) {
 		FileReader fr = null;
 		BufferedReader br = null;
 		try {
 			fr = new FileReader(""B-large.in.txt"");
 			br = new BufferedReader(fr);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 
 		FileWriter fw = null;
 		BufferedWriter bw = null;
 		try {
 			fw = new FileWriter(""B-large.out.txt"");
 			bw = new BufferedWriter(fw);
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		}
 
 		int count = 0;
 		try {
 			count = Integer.parseInt(br.readLine());
 		} catch (NumberFormatException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 		for (int i = 1; i <= count ; i++) {
 
 			double C, F, X;
 			String row = null;
 			try {
 				row = br.readLine();
 			} catch (IOException e1) {
 				e1.printStackTrace();
 			}
 			String [] numbers = row.split("" "");
 			C = Double.parseDouble(numbers[0]);
 			F = Double.parseDouble(numbers[1]);
 			X = Double.parseDouble(numbers[2]);
 
 			double baseCookieRate = 2;
 
 			double noMoreFarmTime;
 			double oneMoreFarmTime;
 			double currentOneMoreFarmTime = 0;
 			double elapsedTime = 0;
 
 			do {
 				elapsedTime += currentOneMoreFarmTime;
 				noMoreFarmTime = X / baseCookieRate;
 				currentOneMoreFarmTime = C / baseCookieRate;
 				oneMoreFarmTime = X / (baseCookieRate + F) + currentOneMoreFarmTime;
 				baseCookieRate += F;
 			} while (noMoreFarmTime >= oneMoreFarmTime);
 
 			String result = String.format(""%.7f"" , elapsedTime + noMoreFarmTime);//String.valueOf(elapsedTime + noMoreFarmTime);
 
 			StringBuffer resultStr = new StringBuffer();
 			resultStr.append(""Case #"");
 			resultStr.append(i);
 			resultStr.append("": "");
 			resultStr.append(result);
 			resultStr.append(""\n"");
 			try {
 				bw.write(resultStr.toString());
 			} catch (IOException e) {
 				e.printStackTrace();
 			}
 			System.out.print(resultStr.toString());
 		}
 		try {
 			bw.flush();
 			bw.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 	}
 
 }
",1
288,20108,"
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 
 public class TicTacToeTomekProcessor {
 	private int ROWS=4;
 	private int COLS=4;
 	private FileReader reader;
 	private FileWriter writer;
 	private int cases;
 
 	public TicTacToeTomekProcessor(String filename) {
 		reader = new FileReader(""resources/tictactoetomek/""+filename+"".in"");
 		writer = new FileWriter(""resources/tictactoetomek/""+filename+"".out"");
 		initialize();
 	}
 	
 	private void initialize() {
 		cases = Integer.parseInt(consumeNext());
 		
 	}
 
 	public void processAll(){
 		int currentCase=1;
 		while(currentCase<=cases){
 			writer.writeLine(String.format(""Case #%s: %s"", currentCase, processNext()));
 			currentCase++;
 		}
 		writer.close();
 		reader.close();
 	}
 
 	private String processNext() {
 		TicTacToeTomek match = new TicTacToeTomek(ROWS, COLS);
 		for(int r=0; r<ROWS;r++){
 			String readLine = consumeNext();
 			if(!match.hasWinner()){
 				match.addLine(readLine);
 			}
 		}
 		consumeNext();
 		if(match.hasWinner()){
 			return match.getWinner()+ "" won"";
 		}
 		return match.isCompleted() ? ""Draw"" : ""Game has not completed"";
 	}
 
 	private String consumeNext() {
 		String readLine = reader.readLine();
 		return readLine;
 	}
 
 	public static void main(String[] args){
 		TicTacToeTomekProcessor processor = new TicTacToeTomekProcessor(""A-large"");
 		processor.processAll();
 	}
 	
 }
","import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 import java.util.TreeSet;
 
 public class D {
   static BufferedReader stdin = new BufferedReader(new
       InputStreamReader(System.in));
   static StringTokenizer st = new StringTokenizer("""");
   public static void main(String[] args) throws Exception {
     final int T = readInt();
     for (int t = 1; t <= T; t++) {
       final int N = readInt();
       TreeSet<Double> naomi = new TreeSet<Double>();
       TreeSet<Double> ken = new TreeSet<Double>();
       for (int i = 0; i < N; i++) {
         naomi.add(readDouble());
       }
       for (int i = 0; i < N; i++) {
         ken.add(readDouble());
       }
       int deceitful = 0;
       int sincere = 0;
       // begin with sincere
       TreeSet<Double> naomiSincere = new TreeSet<Double>(naomi);
       TreeSet<Double> kenSincere = new TreeSet<Double>(ken);
       while (!naomiSincere.isEmpty()) {
         double n = naomiSincere.first();
         naomiSincere.remove(n);
         Double k = kenSincere.higher(n);
         if (k == null) { // Ken loses here, so he picks his lowest one
           k = kenSincere.first();
         }
         kenSincere.remove(k);
         if (n > k) {
           sincere++;
         }
       }
       // deceitful
       while (!naomi.isEmpty()) {
         double k = ken.first();
         Double n = naomi.higher(k);
         if (n == null) {
           // Naomi doesn't have any higher than this, so terminate
           break;
         }
         ken.remove(k);
         naomi.remove(n);
         deceitful++;
       }
       
       System.out.printf(""Case #%d: %d %d\n"", t, deceitful, sincere);
     }
   }
   
   static String readString() throws Exception {
     while (!st.hasMoreTokens()) {
       st = new StringTokenizer(stdin.readLine());
     }
     return st.nextToken();
   }
   
   static int readInt() throws Exception {
     return Integer.parseInt(readString());
   }
   
   static double readDouble() throws Exception {
     return Double.parseDouble(readString());
   }
 }
",0
289,173,"import java.io.*;
 import java.math.*;
 import java.util.*;
 
 public class SpaceEmergency
 {
 	static class Pair implements Comparable<Pair>
 	{
 		int save;
 		int quantity;
 		public Pair(int s, int q) { save = s; quantity = q; }
 		
 		public int compareTo(Pair p) { return p.save - save; }
 		public String toString() { return save + "":""+quantity; }
 	}
 	
 	static Scanner sc = new Scanner(System.in);
 	public static void main(String[] args)
 	{
 		for(int caseId=1,totalCases=sc.nextInt();caseId<=totalCases;caseId++)
 		{
 			System.out.print(""Case #""+caseId+"": "");
 			
 			int L = sc.nextInt();
 			long t = sc.nextLong();
 			int N = sc.nextInt();
 			int C = sc.nextInt();
 			
 			int[] a = new int[C];
 			for(int i=0;i<C;i++)
 				a[i] = sc.nextInt();
 			
 			long res = 0;
 			for(int i=0,index=0;i<N;i++,index++)
 			{
 				if(index>=C)
 					index = 0;
 				res += 2*a[index];
 			}
 			
 			long time = 0; int index = 0, count = 0;
 			while(count<N)
 			{
 				if(index >= C)
 					index = 0;
 				
 				if(time + 2*a[index] < t)
 				{
 					time += 2*a[index];
 					index++;
 					count++;
 					continue;
 				}
 				else
 				{
 					Pair[] all = new Pair[C+1];
 					all[C] = new Pair((int)((time + 2*a[index] - t)/2), 1);
 					count++; index++;
 					for(int i=0;i<C;i++, index++)
 					{
 						if(index >= C)
 							index = 0;
 						all[i] = new Pair(a[index], (N-count)/C + ((N-count)%C > i ? 1 : 0));
 					}
 					Arrays.sort(all);
 					for(int i=0;i<=C;i++)
 					{
 						int diff = Math.min(L, all[i].quantity);
 						res -= (long)diff * all[i].save;
 						L -= diff;
 					}
 					count = N;
 				}
 			}
 			System.out.println(res);
 			System.out.flush();
 		}
 	}
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class MagicalTour {
     static Scanner input;
     static PrintWriter out;
     public static void main(String[] args) throws Exception {
 //        input = new Scanner(System.in);
         input = new Scanner(new FileReader(""A-small-attempt0.in""));
         
 //        out = new PrintWriter(System.out);
         out = new PrintWriter(new FileWriter(""A-small-attempt1.out""));
         
         int testCases = input.nextInt();
         for(int testCase = 1; testCase <= testCases; testCase++) {
             out.println(""Case #"" + testCase + "": "" + solveCase(testCase));
         }
         out.close();
     }
     
     static double solveCase(int testCase) {
         int n = input.nextInt();
         int p = input.nextInt(), q = input.nextInt(), r = input.nextInt(), s = input.nextInt();
         int[] values = new int[n];
         long sum = 0;
         for(int i=0;i<n;i++) {
             values[i] = (int)(((long)i * p + q) % r + s);
             sum += values[i];
         }
         
         long res = Integer.MIN_VALUE, leftSum = 0, middle = values[0], rightSum = sum - middle;
         for(int a = 0, b = 0; a < n; a++) {
             while(true) {
                 if(b + 1 == n)
                     break;
                 if(b < a || middle + values[b+1] <= rightSum - values[b+1]) {
                     middle += values[b+1];
                     rightSum -= values[b+1];
                     b++;
                 }
                 else
                     break;
             }
             res = Math.max(res, sum - Math.max(leftSum, Math.max(rightSum, middle)));
             if (b + 1 < n) {
                 res = Math.max(res, sum - Math.max(leftSum, Math.max(rightSum - values[b+1], middle + values[b+1])));
             }
             leftSum += values[a];
             middle -= values[a];
         }
         return (double) res / sum;
     }
 }
",1
290,5093,"package com.Garm;
 
 
 
 public class Loc {
 	private int x;
 	private int y;
 
 	//Constructors
 	public Loc() {
 		x = 0;
 		y = 0;
 	}
 	public Loc(int a, int b) {
 		x = a;
 		y = b;
 	}
 	public Loc(Loc l) {
 		x = l.getX();
 		y = l.getY();
 	}
 
 	//Getters
 	public int getX() { return x; }
 	public int getY() { return y; }
 	
 	//Setters
 	public void setX(int a) { x = a; }
 	public void setY(int b) { y = b; }
 	public void set(Loc l) {
 		x = l.getX();
 		y = l.getY();
 	}
 
 	//Methods
 	public boolean equals(Loc compare) {
 		return (x == compare.getX()) && (y == compare.getY());
 	}
 
 	/**Returns true if it was able to increase, false if it's at the max size **/
 	public boolean increase(int boardSize) {
 		if(x < (boardSize - 1)) {
 			x++;
 			return true;
 		} else {
 			if(y < (boardSize - 1)) {				
 				y++;
 				x = 0;
 				return true;
 			} else {
 				return false;
 			}
 		}
 	}
 	
 	//Used for incrementing the iterator in the following pattern: bottom to top through a column, then left to right to the next column
 	public boolean increment(int boardSize) {
 		if(y < boardSize - 1) {
 			y++;
 			return true;
 		} else {
 			if(x < (boardSize - 1)) {
 				x++;
 				y = 0;
 				return true;
 			} else {
 				return false;
 			}
 		}
 	}
 	
 	/**
 	 * Increments the values of x and y in the pattern used for taking input from input.in:
 	 * left to right, top to bottom
 	 * @return true if an increment is made, false if the last cell is reached 
 	 * and can no longer be incremented
 	 */
 	public boolean inputIncrement(int boardSize) {
 		if(x < boardSize - 1) {
 			x++;
 			return true;
 		} else {
 			if(y < boardSize - 1) {
 				y++;
 				x = 0;
 				return true;
 			} else {
 				return false;
 			}
 		}
 	}
 
 	//Resets the x and y values to 0
 	public void reset() {
 		x = 0;
 		y = 0;
 	}
 
 	
 
 	/** Increment a direction indicator to the next direction
 	 * 		- Loc(0, 1) = up
 	 * 		- Loc(1, 1) = up-right
 	 * 		- Loc(1, 0) = right
 	 * 		- Loc(1, -1) = down-right
 	 * 		- Loc(0, -1) = down
 	 * 		- Loc(-1, -1) = down-left
 	 * 		- Loc(-1, 0) = left
 	 * 		- Loc(-1, 1) = up-left 
 	 * 
 	 */
 	public void nextDirection() {
 		if(x == 0 && y == 1) {
 			x = 1;
 		} else if(x == 1 && y == 1) {
 			y = 0;
 		} else if(x == 1 && y == 0) {
 			y = -1;
 		} else if(x == 1 && y == -1) {
 			x = 0;
 		} else if(x == 0 && y == -1) {
 			x = -1;
 		} else if(x == -1 && y == -1) {
 			y = 0;
 		} else if(x == -1 && y == 0) {
 			y = 1;
 		}
 	}
 	
 	/**
 	 * For Tic-Tac-Toe-Tomek, increment to the next iterator for checking for lines
 	 * @param boardSize
 	 * @return
 	 */
 	public boolean ticNextDirection(int boardSize) {
 		if(y == 0) {
 			this.inputIncrement(boardSize);
 			return true;
 		} else if(y != boardSize - 1) {
 			this.inputIncrement(boardSize);
 			this.inputIncrement(boardSize);
 			this.inputIncrement(boardSize);
 			this.inputIncrement(boardSize);
 			return true;
 		} else {
 			return false;
 		}
 	}
 	
 	/**
 	 * Return a new Loc that's the addition of this Loc and the passed Loc
 	 * @param loc
 	 * @return
 	 */
 	public Loc plus(Loc loc) {
 		return new Loc(x + loc.getX(), y + loc.getY());
 	}
 	
 	public boolean equals(Object o) {
 		if(o instanceof Loc) {
 			return (this.x == ((Loc)o).getX()) && (this.y == ((Loc)o).getY());
 		}
 		return false;
 	}
 	
 	public int hashCode() {
 		return x;
 	}
 	
 
 }","package com.Garm;
 
 import java.io.FileNotFoundException;
 import java.util.HashMap;
 import java.util.Map;
 
 import com.korshyadoo.file.CJFileIO;
 
 public class Main {
 	public static final int RIGHT = 1;
 	public static final int RIGHT_DOWN = 5;
 	public static final int DOWN = 4;
 	public static final int DOWN_LEFT = 0;
 	public static final  int BOARD_SIZE = 4;
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			HashMap<Loc, Character> board = new HashMap<>();
 			CJFileIO io = new CJFileIO(CJFileIO.SMALL, false);
 			int numCases = io.getScanner().nextInt();		//Input the number of cases from inFile
 			io.getScanner().nextLine();
 			for(int currentCase = 0; currentCase < numCases; currentCase++) {			//For each case
 				boolean xWin = false;
 				boolean oWin = false;
 				
 				//Load board from inFile
 				Loc iter = new Loc(0,0);
 				String buffer;
 				for(int y = 0; y < BOARD_SIZE; y++) {											//For each line
 					buffer = io.getScanner().nextLine();								//Buffer the line
 					for(int n = 0; n < BOARD_SIZE; n++) {										//For each char in the line
 						board.put(new Loc(iter), new Character(buffer.charAt(n)));		//Put the char into the board
 						iter.inputIncrement(BOARD_SIZE);
 					}
 				}
 				if(io.getScanner().hasNextLine()) {
 					io.getScanner().nextLine();
 				}
 				
 				//Check for lines
 				//char test = board.get(iter).charValue();
 				iter.reset();
 				for(int p = 0; p < 7; p++) {							//For each check position
 					if(iter.getY() == 0) {
 						if(iter.getX() == 0) {
 							//Check right, right-down, and down
 							//Check right
 							switch(checkLine(iter, RIGHT, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 							
 							//Check right-down
 							switch(checkLine(iter, RIGHT_DOWN, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 							
 							//Check down
 							switch(checkLine(iter, DOWN, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 							
 							
 						} else if(iter.getX() == 1 || iter.getX() == 2) {
 							//Check down
 							switch(checkLine(iter, DOWN, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 						} else if(iter.getX() == 3) {
 							//Check down, down-left
 							//Check down
 							switch(checkLine(iter, DOWN, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 							
 							//Check down-left
 							switch(checkLine(iter, DOWN_LEFT, board)) {
 							case 1:
 								xWin = true;
 								break;
 							case 2:
 								oWin = true;
 								break;
 							}
 						}
 					} else {
 						//Check right
 						switch(checkLine(iter, RIGHT, board)) {
 						case 1:
 							xWin = true;
 							break;
 						case 2:
 							oWin = true;
 							break;
 						}
 					}
 					iter.ticNextDirection(BOARD_SIZE);
 				}
 				if(xWin == true) {
 					if(oWin == true) {
 						System.out.println(""Case #"" + (currentCase + 1) + "": "" + ""Draw"");
 						io.getPW().println(""Case #"" + (currentCase + 1) + "": "" + ""Draw"");
 					} else {
 						System.out.println(""Case #"" + (currentCase + 1) + "": "" + ""X won"");
 						io.getPW().println(""Case #"" + (currentCase + 1) + "": "" + ""X won"");
 					}
 				} else {
 					if(oWin == true) {
 						System.out.println(""Case #"" + (currentCase + 1) + "": "" + ""O won"");
 						io.getPW().println(""Case #"" + (currentCase + 1) + "": "" + ""O won"");
 					} else {
 						boolean draw = true;
 						iter.reset();
 						do {
 							if(board.get(iter).equals('.')) {
 								//Empty space left on board
 								draw = false;
 								break;
 							}
 						} while(iter.inputIncrement(BOARD_SIZE));
 						if(draw) {
 							System.out.println(""Case #"" + (currentCase + 1) + "": "" + ""Draw"");
 							io.getPW().println(""Case #"" + (currentCase + 1) + "": "" + ""Draw"");
 						} else {
 							System.out.println(""Case #"" + (currentCase + 1) + "": "" + ""Game has not completed"");
 							io.getPW().println(""Case #"" + (currentCase + 1) + "": "" + ""Game has not completed"");
 						}
 					}
 				}
 				
 				
 				
 				
 				
 			}
 			
 			
 			
 			
 			
 			io.getPW().close();
 		} catch(FileNotFoundException e) {
 			e.printStackTrace();
 		}
 
 	}
 	
 	/**
 	 * Check if l1 and l2 are the same Character or if l2 is 'T'
 	 * @param l1
 	 * @param l2
 	 * @param map
 	 * @return
 	 */
 	public static boolean match(Loc l1, Loc l2, HashMap<Loc, Character> map) {
 		//If either is empty, return false; if either is 'T', return true
 		if(map.get(l1).equals('.') || map.get(l2).equals('.')) {
 			return false;
 		} else if(map.get(l1).equals('T') || map.get(l2).equals('T')) {
 			return true;
 		} 
 			
 		//If they match, return true; if not, return false
 		if(map.get(l1).equals(map.get(l2))) {
 			return true;
 		} else {
 			return false;
 		}
 	}
 	
 
 	/**
 	 * 
 	 * @param iter
 	 * @param direction 1 = right, 5 = right-down, 4 = down, 0 = down-left 
 	 * @param board
 	 * @return 0 for no win, 1 for xWin, 2 for oWin
 	 */
 	public static int checkLine(Loc iter, int direction, HashMap<Loc, Character> board) {
 		if(iter.equals('.')) {
 			return 0;
 		}
 		Loc buffer = new Loc(iter);
 		int lineLen = BOARD_SIZE;
 		
 		//If the line starts with a T, move iter ahead a position and reduce lineLen by one
 		if(board.get(iter).equals('T')) {
 			if(direction > 0) {
 				for(int n = 0; n < direction; n++) {
 					iter.inputIncrement(4);
 				}
 			} else {
 				iter.setX(iter.getX() - 1);
 				iter.setY(iter.getY() + 1);
 			}
 			lineLen--;
 		}
 		
 		boolean xWin = false;
 		boolean oWin = false;
 		
 		//Set direction for iter2
 		Loc iter2 = new Loc(iter);
 		if(direction > 0) {
 			for(int n = 0; n < direction; n++) {
 				iter2.inputIncrement(4);
 			}
 		} else {
 			iter2.setX(iter2.getX() - 1);
 			iter2.setY(iter2.getY() + 1);
 		}
 		
 		int count = 1;
 		do {
 			if(match(iter, iter2, board)) {
 				count++;
 				if(count == lineLen) {
 					if(board.get(iter).equals('X')) {
 						xWin = true;
 					} else {
 						oWin = true;
 					}
 				}
 			} else {
 				break;
 			}
 			//Increment iter2 based on direction
 			if(direction > 0) {
 				for(int n = 0; n < direction; n++) {
 					iter2.inputIncrement(4);
 				}
 			} else {
 				iter2.setX(iter2.getX() - 1);
 				iter2.setY(iter2.getY() + 1);
 			}
 		} while(count < lineLen);
 		iter.set(buffer);
 		if(xWin == true) {
 			return 1;
 		} else if(oWin == true) {
 			return 2;
 		} else {
 			return 0;
 		}
 	}
 }
",1
291,13269,"import java.util.Arrays;
 import java.util.Scanner;
 
 
 public class A {
 	int[] S;
 	void run() {
 		Scanner in = new Scanner(System.in);
 		int T = in.nextInt();
 		for (int t=1; t<=T; t++) {
 			int N = in.nextInt();
 			int X = in.nextInt();
 			S = new int[N];
 			for (int i=0; i<N; i++) {
 				S[i] = in.nextInt();
 			}
 			Arrays.sort(S);
 			int res = 0;
 			int p = 0;
 			int q = N-1;
 			for (; p <= q;) {
 				int sml = S[p];
 				p++;
 				for (; q>=p;) {
 					int lag = S[q];
 					q--;
 					if (sml + lag <= X) {
 						break;
 					}
 					//System.out.println(""cub"");
 					res++;
 				}
 				//System.out.println(""cua"");
 				res++;
 			}
 			System.out.println(""Case #"" + t + "": "" + res);
 		}
 	}
 
 	static public void main(String[] args) {
 		new A().run();
 	}
 }
","package com.test.common;
 
 public interface OutputObject {
 
 }
",0
292,13334,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package codejam2013;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Stack;
 
 /**
  *
  * @author Rumesh
  */
 public class Round1A_QC_2013 {
 
     public static void main(String args[]) {
         try {
             File input = new File(""C:\\Users\\Rumesh\\Desktop\\code\\C-small-attempt0.in"");
             FileReader fr = new FileReader(input);
             BufferedReader br = new BufferedReader(fr);
             PrintWriter out = new PrintWriter(new File(""C:\\Users\\Rumesh\\Desktop\\code\\QCoutputsmall.out""));
             int number = Integer.parseInt(br.readLine());
             //System.out.println(""Nu : ""+number);
             for (int h = 0; h <= number - 1; h++) {
                 String answer = """";
 
                 String line = br.readLine().trim();
                 int i1= Integer.parseInt(line.split("" "")[0]);
                 int i2 = Integer.parseInt(line.split("" "")[1]);
                 
                 //System.out.println(""i1 : ""+i1+"" i2 : ""+i2);
                 
                 int count = 0;
                 for(int i = i1; i <=i2;i++){
                     if(isSquare(i) && isPalindrome(i)){
                         if(isPalindrome((int)Math.sqrt(i))){
                             count++;
                         }
                     }
                 
                 }
                 
                 String ans = ""Case #"" + (h+1) + "": "" + count;
                 System.out.println(ans);
 
                 out.println(ans);
                 out.flush();
 
             }
 
             br.close();
             out.close();
 
         } catch (IOException e) {
             e.printStackTrace();
 
         }
     }
     
     static boolean isPalindrome(int i){
         String num = """"+i;
         //System.out.println(""putting num ""+num);
         Stack<Character> s = new Stack<Character>();
         for (int j = 0; j < num.length(); j++) {
             s.push(num.charAt(j));            
         }
         
         String num2="""";
         while (!s.isEmpty()) {            
             num2 = num2+""""+s.pop();
         }
         
         return num.equalsIgnoreCase(num2);
         
     }
     
     static boolean isSquare(int num){
         double num2 = Math.sqrt(num);
         double num2rounded = Math.round(num2);
         if(num2rounded-num2 == 0.0){
             return true;
         }
         return false;
     }
 }
 
","import java.io.*;
 import java.util.*;
 
 public class ReNum {
 
 	static BufferedReader br;
 	static PrintWriter pw;
 	
     public static void main(String args[]) {
         try {
             br = new BufferedReader(new FileReader(""C-large.in""));
 			pw = new PrintWriter(new File(""ReNumAns.out""));
 			String no = br.readLine();
             int number = Integer.parseInt(no);
             for (int h = 0; h <= number - 1; h++) {
                 int finAns =0;
                 String nos = br.readLine();
                 String[] n = nos.split("" "");
                 int num1 = Integer.parseInt(n[0]);
                 int e = Integer.parseInt(n[1]);
                 int size = n[0].length();
                
                 
                 for (int i=num1;i<=e;i++){
                     String t = Integer.toString(i);
                     for (int j = 1;j<size;j++){
                         t= t.substring(1,size)+t.substring(0,1);
                         
                         int num2 = Integer.parseInt(t);
                         if (num2>i && num2<=e && num2>=num1){
                             finAns++;
                             
                             
                         }
                                                 
                     }
                 }
 
                 int caseNo = 1 + h;
                 String ans = ""Case #"" + caseNo + "": "" + finAns;
                 pw.println(ans);
                 pw.flush();
 
             }
 
 
         } catch (IOException e) {
             e.printStackTrace();
 
         }
     }
 
 }
",1
293,16513,"import java.util.*;
 import java.io.*;
 public class pA {
     static int disMin = 0, costoMin;
     public static void main(String[] args) {
         Scanner leer = null;
         PrintWriter pw = null;
         try {
             leer = new Scanner(new File(""A-large.in""));
             pw = new PrintWriter(""A.out"");
         } catch (IOException e) {
         }
         int nCasos = leer.nextInt();
         for(int i=0;i<nCasos;i++){
             int N= leer.nextInt();
             int M= leer.nextInt();
             ArrayList<String> dir= new ArrayList<String>();
             for(int j=0;j<N;j++){
                 String str2= leer.next();
                 String cam[]=str2.split(""/"");
                 String str=cam[1]+""/"";
                 for(int k=1;k<cam.length;k++){
                     if(k>1){
                         str+=cam[k]+""/"";
                         if(!dir.contains(str))
                             dir.add(str);
                     }
                     else if(!dir.contains(cam[k]+""/"")){
                         dir.add(cam[k]+""/"");
                     }
                 }
             }
             int total=0;
             for(int j=0;j<M;j++){
                 String crear= leer.next();
 
                 String cam[]=crear.split(""/"");
                 String str=cam[1]+""/"";
                 for(int k=1;k<cam.length;k++){
                     if(k>1){
                         str+=cam[k]+""/"";
                         if(!dir.contains(str)){
                             dir.add(str);
                             total++;
                         }
                     }
                     else if(!dir.contains(cam[k]+""/"")){
                         dir.add(cam[k]+""/"");
 
                             total++;
                     }
                 }
             }
             pw.println(""Case #""+(i+1)+"": ""+total);
         }
         pw.close();
     }
 }
","package Main;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class Solution {
 
     static BufferedReader br;
     static BufferedWriter bw;
 
     public static void main(String[] args) {
         try {
 
             readInputFile();
             createOutputFile();
 
             String line1 = br.readLine();
             int testCases = Integer.parseInt(line1);
 
             int testIndex = 0;
 
             while (testCases != testIndex) {
 
                 String answer = checkGameStatus();
                 bw.write(""Case #"" + ++testIndex + "": "" + answer+""\n"");
 
             }
 
             bw.close();
             br.close();
             System.out.println(""Done"");
 
         } catch (FileNotFoundException e) {
             throw new RuntimeException(""File not found."");
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 
     private static String checkGameStatus() throws IOException {
 
         int[] diagonal1 = new int[] { 0, 0 };
         int[] diagonal2 = new int[] { 0, 0 };
         int[][] columns = new int[][] { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };
         int[][] rows = new int[][] { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };
 
         boolean completeBoard = true;
 
         for (int i = 0; i < 4; i++) {
             char[] markings = br.readLine().toCharArray();
             for (int j = 0; j < 4; j++) {
                 int index = -1;
                 boolean hasT = false;
                 switch (markings[j]) {
                 case '.':
                     completeBoard = false;
                     break;
                 case 'X':
                     index = 0;
                     break;
                 case 'O':
                     index = 1;
                     break;
                 case 'T':
                     hasT = true;
                     break;
                 }
                 if (hasT) {
                     rows[i][0]++;
                     rows[i][1]++;
                     columns[j][0]++;
                     columns[j][1]++;
                     if (i == j) {
                         diagonal1[0]++;
                         diagonal1[1]++;
                     }
                     if (i + j == 3) {
                         diagonal2[0]++;
                         diagonal2[1]++;
                     }
                 } else if (index != -1) {
                     rows[i][index]++;
                     columns[j][index]++;
                     if (i == j) {
                         diagonal1[index]++;
                     }
                     if (i + j == 3) {
                         diagonal2[index]++;
                     }
 
                 }
 
             }
         }
 
         br.readLine();
 
         for (int k = 0; k < 4; k++) {
             if (rows[k][0] == 4 || columns[k][0] == 4) {
                 return ""X won"";
             }
             if (rows[k][1] == 4 || columns[k][1] == 4) {
                 return ""O won"";
             }
         }
         if (diagonal1[0] == 4 || diagonal2[0] == 4) {
             return ""X won"";
         }
         if (diagonal1[1] == 4 || diagonal2[1] == 4) {
             return ""O won"";
         }
         if (completeBoard) {
             return ""Draw"";
         } else
             return ""Game has not completed"";
 
     }
 
     private static void readInputFile() throws IOException {
 
         br = new BufferedReader(new FileReader(""files/A-large (1).in""));
     }
 
     private static void createOutputFile() throws IOException {
 
         int counter = 0;
         File outputFile;
         while ((outputFile = new File(""files/output"" + counter + "".txt""))
                 .exists()) {
             counter++;
         }
 
         outputFile.createNewFile();
 
         FileWriter fw = new FileWriter(outputFile.getAbsoluteFile());
         bw = new BufferedWriter(fw);
     }
 
 }
",0
294,20570,"package gcj13.oneb;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 /**
  *
  * @author Johan Sannemo
  */
 public class Falling {
 
     public static void main(String[] args) throws FileNotFoundException {
         System.setIn(new FileInputStream(""C:\\Users\\Johan Sannemo\\Downloads\\B-small-attempt0.in""));
         System.setOut(new PrintStream(""C:\\Users\\Johan Sannemo\\Downloads\\B-small.out""));
 
         Scanner sc = new Scanner(System.in);
 
         int t = sc.nextInt();
         for (int i = 1; i <= t; ++i) {
             System.out.print(""Case #""+i+"": "");
             solve(sc);
         }
     }
 
     private static final double calcProb(int height, int need, int events) {
         double[][] dp = new double[events + 1][need + 1];
         dp[events][need] = 1;
         for (int i = events; i > 0; --i) {
             for (int j = need; j > 0; --j) {
                 if ((events - i) - (need - j) == height) {
                     dp[i - 1][j - 1] += dp[i][j];
                 } else {
                     dp[i - 1][j] += dp[i][j] * 0.5;
                     dp[i - 1][j - 1] += dp[i][j] * 0.5;
                 }
             }
             dp[i - 1][0] += dp[i][0];
         }
         double sum = dp[0][0];
         return sum;
     }
 
     private static final void solve(Scanner sc) {
         int n = sc.nextInt();
         int x = Math.abs(sc.nextInt());
         int y = sc.nextInt();
         if (y < 0) {
             System.out.println(""0"");
             return;
         }
         int layer = (x + y) / 2;
         int acc = 0;
         for (int i = 0;; i++) {
             acc += 4 * i + 1;
             if (layer == i) {
                 if (acc <= n) {
                     System.out.println(""1"");
                 } else {
                     int left = n - (acc - (4 * i + 1));
                     int height = 2 * i + 1;
                     if (height - 1 + y + 1 <= left) {
                         System.out.println(""1"");
                     } else {
                         if (y == height - 1) {
                             System.out.println(""0"");
                         } else {
                             System.out.println(calcProb(height - 1, y + 1, left));
                         }
                     }
                 }
                 break;
             }
             if (acc >= n) {
                 System.out.println(""0"");
                 break;
             }
         }
     }
 }
","import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.math.BigInteger;
 import java.util.Scanner;
 
 public class ProblemA {
 
     static int T = 1;
     static long P, Q;
 
     public static void main(String args[]) throws Exception {
         Scanner scanner = new Scanner(new FileReader(""inputA.txt""));
         FileWriter fileWriter = new FileWriter(""outputA.txt"");
         BufferedWriter bw = new BufferedWriter(fileWriter);
 
         T = scanner.nextInt();
         scanner.nextLine();
         for (int testNumber = 1; testNumber <= T; ++testNumber) {
             String s = scanner.nextLine();
             int index = s.indexOf(""/"");
 
             P = Long.parseLong(s.substring(0, index));
             Q = Long.parseLong(s.substring(index + 1, s.length()));
 
             long q = Q;
             while (q % 2 == 0) {
                 q = q / 2;
             }
 
             if (P % q == 0) {
                 P = P / q;
                 Q = Q / q;
 
                 int answer = 0;
                 while (P < Q) {
                     answer++;
                     P = P * 2;
                 }
                 bw.write(""Case #"" + testNumber + "": "" + answer);
                 bw.newLine();
                 System.out.println(""Case #"" + testNumber + "": "" + answer);
             } else {
                 bw.write(""Case #"" + testNumber + "": impossible"");
                 bw.newLine();
                 System.out.println(""Case #"" + testNumber + "": impossible"");
             }
 
         }
         bw.close();
     }
 }",0
295,11868,"package codejam.main;
 
 import codejam.io.InputParser;
 import codejam.io.OutputWriter;
 
 public class SolutionB {
 	private String FILE_NAME = ""B-small-attempt0"";
 	private int TEST_CASE_LINES_COUNT = 1;
 
 	public void startAlgorithm() throws Exception {
 		InputParser parser = new InputParser(FILE_NAME, TEST_CASE_LINES_COUNT);
 		OutputWriter writer = new OutputWriter(FILE_NAME);
 		try {
 			parser.initParser();
 			writer.initWriter();
 			String caseInputs[] = new String[parser.getTestCaseLinesCount()];
 			int cnt = 1;
 			while ((caseInputs = parser.readTestCase()) != null) {
 				// Parse case inputs
 				String s[] = caseInputs[0].split("" "");
 				long A = Long.parseLong(s[0]);
 				long B = Long.parseLong(s[1]);
 				long K = Long.parseLong(s[2]);
 				int m = 0;
 				for (long i=0l; i<A; i++) {
 					for (long j=0l; j<B; j++) {
 						long x = i & j;
 						if (x>=0 && x<K)
 							m++;
 					}
 				}
 				// Execution logic
 				writer.writeCaseOutput(cnt, """"+m);
 				cnt++;
 			}
 		} catch (Exception e) {
 			throw e;
 		} finally {
 			parser.close();
 			writer.close();
 		}
 	}
 
 	public static void main(String[] args) throws Exception {
 		SolutionB b = new SolutionB();
 		b.startAlgorithm();
 	}
 
 }
","package codejam.fileop;
 
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
 
 public class OutputFileWriter {
 	public static final String DEFAULT_RESOURCE_LOCATION = ""/Users/shaktiprakash.das/workspace/CodeJam/resources/"";
 	public static final String DEFAULT_OUTPUT_FILE = ""output.txt"";
 	public static final String DEFAULT_ENCODING = ""UTF-8"";
 	
 	private String outputDir = DEFAULT_RESOURCE_LOCATION;
 	private String outputFileName = DEFAULT_OUTPUT_FILE;
 	private PrintWriter writer = null;
 
 	public OutputFileWriter() {
 		this(DEFAULT_RESOURCE_LOCATION, DEFAULT_OUTPUT_FILE);
 	}
 	
 	public OutputFileWriter(String outputFileName) {
 		this(DEFAULT_RESOURCE_LOCATION, outputFileName);
 	}
 	
 	public OutputFileWriter(String outputDir, String outputFileName) {
 		this.outputDir = outputDir;
 		this.outputFileName = outputFileName;
 	}
 	
 	public void initWriter() throws FileNotFoundException, UnsupportedEncodingException {
 		if(!outputDir.endsWith(""/""))
 			outputDir += ""/"";
 		writer = new PrintWriter(outputDir+outputFileName, DEFAULT_ENCODING);
 	}
 	
 	public void write(String str) {
 		writer.print(str);
 		writer.flush();
 	}
 
 	public void writeLine(String line) {
 		writer.println(line);
 		writer.flush();
 	}
 	
 	public void writeCaseOutput(int caseCount, String output) {
 		writeLine(""Case #""+caseCount+"": ""+output);
 		writer.flush();
 	}
 	
 	public void close() {
 		writer.close();
 	}
 
 }
",1
296,4074,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 
 public class SwingingWild {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(args[0]));
 			PrintWriter pw = new PrintWriter(args[1]);
 			String line = br.readLine();
 			System.out.println(line);
 			int T = Integer.valueOf(line.trim());
 			for (int i=0; i<T; i++)
 			{
 				line = br.readLine().trim();
 				System.out.println(line);
 				int n = Integer.valueOf(line);
 				int[] d = new int[n];
 				int[] l = new int[n];
 				for(int j=0; j<n; j++)
 				{
 					line = br.readLine().trim();
 					System.out.println(line);
 					String[] dl = line.split("" "");
 					d[j] = Integer.valueOf(dl[0].trim());
 					l[j] = Integer.valueOf(dl[1].trim());
 				}
 				
 				line = br.readLine().trim();
 				System.out.println(line);
 				int des = Integer.valueOf(line);
 				
 				int[] reach = new int[n];
 				if(d[0]>l[0])
 				{
 					System.out.println(""Error"");
 					System.exit(-1);
 				}
 				boolean reachable = false;
 				
 				reach[0] = d[0] * 2;
 				if(reach[0]>=des)
 					reachable = true;
 				for(int j=1; j<n; j++)
 				{
 					reach[j] = 0;
 					for(int k=j-1; k>=0; k--)
 					{
 						if(reach[k]>=d[j])
 						{
 							int tmp = d[j] - d[k];
 							tmp = tmp<l[j]?tmp:l[j];
 							tmp+=d[j];
 							
 							if(tmp>reach[j])
 								reach[j] = tmp;
 						}
 					}
 					if(reach[j]>=des)
 						reachable = true;
 				}
 				
 				if(reachable)
 				{
 					pw.println(""Case #""+(i+1)+"": YES"");
 					System.out.println(""Case #""+(i+1)+"": YES"");
 				}
 				else
 				{
 					pw.println(""Case #""+(i+1)+"": NO"");
 					System.out.println(""Case #""+(i+1)+"": NO"");
 				}
 			}
 			pw.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 
 }
","package com.google.jam2013.QR;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 public class TicTacToeTomek {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		// TODO Auto-generated method stub
 		BufferedReader br = new BufferedReader(new FileReader(args[0]));
 		PrintWriter pw = new PrintWriter(new File(args[1]));
 		int T = Integer.valueOf(br.readLine());
 		for (int i = 0; i < T; i++) {
 			char[][] board = new char[4][4];
 			for (int j = 0; j < 4; j++) {
 				String row = br.readLine();
 				for (int k = 0; k < 4; k++) {
 					board[j][k] = row.charAt(k);
 				}
 			}
 			br.readLine();
 			String status = process(board);
 			pw.println(""Case #"" + (i+1) + "": "" + status);
 		}
 		pw.close();
 		br.close();
 	}
 	public static char get(int i, int j, char[][] board) {
 		if (i < 4) {
 			return board[i][j];
 		} else if (i < 8) {
 			return board[j][i-4];
 		} else if (i == 8) {
 			return board[j][j];
 		} else {
 			return board[3-j][j];
 		}
 	}
 	public static String process(char[][] board) {
 		boolean vak = false;
 		for (int i = 0 ; i < 10; i++) {
 			char current = 'T';
 			for (int j = 0; j < 4; j++) {
 				int c = get(i, j, board);
 				if (c == '.') {
 					current = '.';
 					vak = true;
 					break;
 				}
 				else if (c == 'X') {
 					if (current == 'O') {
 						current = '.';
 						break;
 					}
 					current = 'X';
 				} else if (c == 'O') {
 					if (current == 'X') {
 						current = '.';
 						break;
 					}
 					current = 'O';
 				}
 			}
 			
 			switch (current) {
 			case 'X' :
 				return ""X won"";
 			case 'O' : 
 				return ""O won"";
 			default :
 				break;
 			}
 		}
 		
 		if (vak) {
 			return ""Game has not completed"";
 		} else {
 			return ""Draw"";
 		}
 		
 	}
 
 }
",1
297,17850,"package meir.codeJam;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 public class C {
 	public static void main(String[] args) {
 		try {
 			InputStreamReader a=new InputStreamReader(System.in);
 			BufferedReader in=new BufferedReader(a);
 			int N=Integer.parseInt(in.readLine());
 			for (int i=0;i<N;++i) {
 				System.out.printf(""Case #%d: %s\n"",i+1,
 						processTest(in));
 			}
 		
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 		}	
 
 	}
 	
 	private static String processTest(BufferedReader in) throws NumberFormatException, IOException {
 		String a[]=in.readLine().split("" "");
 		int N=Integer.parseInt(a[0]);
 		a=in.readLine().split("" "");
 		int sum=0;
 		int min=Integer.MAX_VALUE;
 		int xor=0;
 		int candy[]=new int[N];
 		for (int i = 0; i < candy.length; i++) {
 			int cur=Integer.parseInt(a[i]);
 			candy[i]=cur;
 			sum+=cur;
 			xor=xor^cur;
 			min=(min>cur?cur:min);
 		}
 
 		return (xor!=0)?""NO"":String.valueOf(sum-min);
 	}
 }
","import java.util.*;
 import static java.lang.Math.*;
 
 public class ProblemC {
     int MAX = 1000000000;
     double EPS = 0.00001;
 
     void run() {
         Scanner sc = new Scanner(System.in);
         int numCases = sc.nextInt();
         for (int caseNum = 1; caseNum <= numCases; caseNum++) {
             int N = sc.nextInt();
             int[] peaks = new int[N-1];
             for (int i = 0; i < N-1; ++i) {
                 peaks[i] = sc.nextInt() - 1;
             }
             int[] heights = solve(N, peaks);
             if (heights.length > 0 && !valid(N, peaks, heights)) {
                 //p(""FAIL!!!!\n"");
             }
             if (heights.length == 0) {
                 System.out.printf(""Case #%d: %s\n"", caseNum, ""Impossible"");
             }
             else {
                 System.out.printf(""Case #%d: "", caseNum);
                 for (int i = 0; i < N; ++i) {
                     System.out.printf(""%d"", heights[i]);
                     if (i == N-1) {
                         System.out.printf(""\n"");
                     }
                     else {
                         System.out.printf("" "");
                     }
                 }
             }
         }
     }
 
     int[] solve(int N, int[] peaks) {
         boolean possible = true;
         int[] heights = new int[N];
 
         for (int i = 0; i < N-1; ++i) {
             for (int j = i+1; j < N-1; ++j) {
                 if (j < peaks[i] && peaks[i] < peaks[j]) {
                     possible = false;
                 }
 
             }
         }
         if (!possible) {
             return new int[] {};
         }
         for (int i = 0; i < N - 1; ++i) {
             int p = peaks[i];
             if (heights[p] > 0) {
                 continue;
             }
             int h = -1;
             for (int j = 0; j < i; ++j) {
                 int q = peaks[j];
                 if (q > p) {
                     double dy = heights[q] - heights[i];
                     double dx = q - i;
                     double m = dy / dx;
                     double y = heights[i] + m * (p - i) + EPS;
                     int yy = ((int) y) + 1;
                     if (yy > MAX) {
                         d(""failed at"", i, j);
                     }
                     h = max(h, yy);
                 }
             }
             h = h > 0 ? h : MAX;
             heights[p] = h;
         }
         return heights;
     }
 
     boolean valid(int N, int[] peaks, int[] heights) {
         for (int i = 0; i < N; ++i) {
             int h = heights[i];
             if (h < 0 || h > MAX) {
                 return false;
             }
         }
         for (int i = 0; i < N - 1; ++i) {
             long best_dy = -(MAX + 1);
             long best_dx = 1;
             int best_j = -1;
             for (int j = i+1; j < N; ++j) {
                 long dy = heights[j] - heights[i];
                 long dx = j - i;
                 if (dx * best_dy < dy * best_dx) {
                     best_dx = dx;
                     best_dy = dy;
                     best_j = j;
                 }
             }
             if (peaks[i] != i + best_dx) {
                 d(""fail"", i, best_dx);
                 return false;
             }
         }
         return true;
     }
 
     boolean debug = false;
     void p(String f, Object...params) {
         System.out.printf(f, params);
     }
     void d(Object...params) {
         if (debug) {
             p(""DEBUG: %s\n"", Arrays.deepToString(params));
         }
     }
     public ProblemC(String[] args) {
         if (args.length > 0 && args[0].equals(""debug"")) {
             debug = true;
         }
     }
     public static void main(String[] args) {
         new ProblemC(args).run();
     }
 }
",0
298,2552,"package actual;
 import java.io.*;
 import java.util.*;
 
 public class C
 {
 	String line;
 	StringTokenizer inputParser;
 	BufferedReader is;
 	FileInputStream fstream;
 	DataInputStream in;
 	
 	void openInput(String file)
 	{
 
 		//is = new BufferedReader(new InputStreamReader(System.in));//stdin
 		try{
 			fstream = new FileInputStream(file);
 			in = new DataInputStream(fstream);
 			is = new BufferedReader(new InputStreamReader(in));
 		}catch(Exception e)
 		{
 			System.err.println(e);
 		}
 
 	}
 	
 	void readNextLine()
 	{
 		try {
 			line = is.readLine();
 			inputParser = new StringTokenizer(line, "" "");
 			//System.err.println(""Input: "" + line);
 		} catch (IOException e) {
 			System.err.println(""Unexpected IO ERROR: "" + e);
 		}	
 		
 	}
 	
 	int NextInt()
 	{
 		String n = inputParser.nextToken();
 		int val = Integer.parseInt(n);
 		
 		//System.out.println(""I read this number: "" + val);
 		return val;
 	}
 	
 	long NextLong()
 	{
 		String n = inputParser.nextToken();
 		long val = Long.parseLong(n);
 		
 		//System.out.println(""I read this number: "" + val);
 		return val;
 	}
 	
 	String NextString()
 	{
 		String n = inputParser.nextToken();
 		return n;
 	}
 	
 	void closeInput()
 	{
 		try {
 			is.close();
 		} catch (IOException e) {
 			System.err.println(""Unexpected IO ERROR: "" + e);
 		}
 			
 	}
 	
 	public static void main(String [] argv)
 	{
 		new C(argv[0]);
 	}
 	
 	
 	public C(String inputFile)
 	{
 		openInput(inputFile);
 		readNextLine();
 
 		int TC = NextInt();
 		
 		for(int t=0; t<TC; t++)
 		{	
 			
 			readNextLine();
 			int N=NextInt();
 			int M=NextInt();
 			int K=NextInt();
 			
 			int ret=solve(N, M, K);
 			
 			//System.out.println(line);
 			
 			System.out.println(""Case #""+(t+1)+"": ""+ret);
 		}
 		closeInput();
 	}
 
 	private int solve(int N, int M, int K) {
 		if(N>M)
 		{
 			int tm=N;
 			N=M;
 			M=tm;
 		}
 		
 		if(K<5)return K;
 		
 		if(N<3)return K;
 		int X=N*M;
 		
 		int d=5,ret=4;
 		while(d<K)
 		{
 			if(d+1==K)return ret+1;
 			if(d+2==K)return ret+2;
 			ret+=2;
 			d+=3;
 		}
 		if(K+4>X)
 		{
 			ret=N*2;
 			ret+=2*(M-2);
 			ret-=(N*M)-K;
 		}
 		return ret;
 	}
 
 
 	
 	
 }
 
","import java.io.*;
 import java.util.*;
 
 public class ALarge {
 	private static boolean _WRITE_TO_FILE = true;
 	private static String _INPUT_FILE = ""A-large.in"";
 	private static String _OUTPUT_FILE = ""out.txt"";
 	private static Scanner in;
 	private static long MODULO;
 	private static long n;
 	
 	static class Pair implements Comparable<Pair>{
 		long stop;
 		long add;
 		public Pair(long stop, long add) {
 			this.stop = stop;
 			this.add = add;
 		}
 		public int compareTo(Pair o) {
 			if (this.stop != o.stop)
 				return (int) (this.stop - o.stop);
 			return (int) (o.add - this.add);
 		}
 		public String toString() {
 			return ""("" + stop + "", "" + add + "")"";
 		}
 	}
 	
 	private static void core() {
 		int ntest = in.nextInt();
 		MODULO = 1000002013;
 		
 		for (int test = 0; test < ntest; test++) {
 			writeCase(test);
 			n = in.nextLong();
 			
 			int m = in.nextInt();
 			long totalCost = 0;
 			ArrayList<Pair> list = new ArrayList<Pair>();
 			for (int i = 0; i < m; i++) {
 				long entry = in.nextLong();
 				long exit = in.nextLong();
 				long cnt = in.nextLong();
 				list.add(new Pair(entry, cnt));
 				list.add(new Pair(exit, -cnt));
 				long cost = calc(entry, exit, cnt);
 				totalCost = addModulo(totalCost, cost);
 			}
 			
 			Collections.sort(list);
 			long bestCost = solve(list);
 			long res = addModulo(totalCost, MODULO - bestCost);
 
 			System.out.println(res);
 			
 			System.out.flush();
 		}
 	}
 	private static long calc(long entry, long exit, long cnt) {
 		long cost = calculateCost(entry, exit);
 		return multiplyModulo(cost, cnt);
 	}
 	private static long solve(ArrayList<Pair> list) {
 		LinkedList<Pair> queue = new LinkedList<Pair>();
 		long bestCost = 0;
 		for (Pair pair : list) {
 			if (pair.add > 0) {
 				queue.add(new Pair(pair.stop, pair.add));
 			}
 			else {
 				long getOff = -pair.add;
 				while(getOff > 0) {
 					Pair last = queue.getLast();
 					if (last.add <= getOff) {
 						long thisCost = calc(last.stop, pair.stop, last.add);
 						bestCost = addModulo(bestCost, thisCost);
 						queue.removeLast();
 						getOff -= last.add;
 					}
 					else {
 						long thisCost = calc(last.stop, pair.stop, getOff);
 						bestCost = addModulo(bestCost, thisCost);
 						Pair newLast = new Pair(last.stop, last.add - getOff);
 						getOff = 0;
 						queue.removeLast();
 						queue.add(newLast);
 					}
 				}
 			}
 		}
 		return bestCost;
 	}
 	
 	private static long inverse(long a) {
 		long[] g = gcd(a, MODULO);
 		long res = g[0];
 		res = res + MODULO;
 		return res % MODULO;
 	}
 	private static long[] gcd(long a, long b) {
 		long x = 0, lastx = 1;
 		long y = 1, lasty = 0;
 		while(b != 0) {
 			long q = a / b;
 			
 			long temp = b;
 			b = a % b;
 			a = temp;
 			
 			temp = x;
 			x = lastx - q * x;
 			lastx = temp;
 			
 			temp = y;
 			y = lasty - q * y;
 			lasty = temp;
 		}
 		return new long[] {lastx, lasty};
 	}
 	private static long addModulo(long totalCost, long multiplyModulo) {
 		return ((totalCost % MODULO) + (multiplyModulo % MODULO)) % MODULO;
 	}
 	private static long multiplyModulo(long cost, long cnt) {
 		return ((cost % MODULO) * (cnt % MODULO)) % MODULO;
 	}
 	private static long calculateCost(long entry, long exit) {
 		long dist = exit - entry;
 		if (dist == 0)
 			return 0;
 		long res = 0;
 		if (dist % 2 == 0) 
 			res = multiplyModulo(dist / 2, dist - 1);
 		else
 			res = multiplyModulo(dist, (dist - 1) / 2);
 		long prod = multiplyModulo(n, dist);
 		return addModulo(MODULO - res, prod);
 	}
 	private static long power(long e, long i) {
 		if (i == 1)
 			return (e % MODULO);
 		if (i == 0)
 			return (1 % MODULO);
 		long half = power(e, i / 2);
 		long res = multiplyModulo(half, half);
 		if (i % 2 == 0)
 			return res;
 		else
 			return multiplyModulo(res, e);
 	}
 	private static void writeCase(int test) {
 		System.out.printf(""Case #%d: "", test+1);
 	}
 	static void debug(Object...os) {
 		System.out.println(Arrays.deepToString(os));
 	}
 	public static void main(String[] args) throws FileNotFoundException {
 		System.setIn(new FileInputStream(_INPUT_FILE));
 		if (_WRITE_TO_FILE) 
 			System.setOut(new PrintStream(new BufferedOutputStream(
 					new FileOutputStream(_OUTPUT_FILE))));
 		in = new Scanner(System.in);
 		core();
 		System.out.close();
 	}
 	static class Scanner {
 		BufferedReader reader;
 		StringTokenizer tokenizer;
 		public Scanner(InputStream in) {
 			reader = new BufferedReader(new InputStreamReader(in));
 			tokenizer = new StringTokenizer("""");
 		}
 		public String next() {
 			try {
 				while(!tokenizer.hasMoreElements())
 					tokenizer = new StringTokenizer(reader.readLine());
 				return tokenizer.nextToken();
 			} catch (Exception e) {
 				e.printStackTrace();
 				throw new RuntimeException(e);
 			}
 		}
 		public int nextInt() {
 			return Integer.parseInt(next());
 		}
 		public long nextLong() {
 			return Long.parseLong(next());
 		}
 		public double nextDouble() {
 			return Double.parseDouble(next());
 		}
 	}
 }
",0
299,6415,"import java.util.*;
 
 public class Main {
 	static Scanner in = new Scanner(System.in);
 	static int[][] a, b;
 	static int n;
 	static boolean check(int[][] a, int k) {
 		for(int i=0; i<n; ++i) {
 			for(int j=0; j<n; ++j) {
 					int x, y;
 					x = i-(i+j-k+1); y = j-(i+j-k+1);
 					if(0<=x&&x<n&&0<=y&&y<n&&a[i][j]!=a[x][y]) {
 						return false;
 					}
 				}
 			}
 			return true;
 	}
 	static void rot() {
 		b = new int[n][n];
 		for(int i=0; i!=n; ++i)
 			for(int j=0; j!=n; ++j) b[i][j] = a[n-j-1][i];
 	}
 	public static void main(String[] args) {
 		int t = in.nextInt();
 		for(int ca=1; ca<=t; ++ca) {
 			n = in.nextInt();
 			int ans = Integer.MAX_VALUE;
 			a = new int[n][n];
 			for(int i=0; i!=2*n+1; ++i) {
 				for(int j=Math.max(0, i-n+1); j<Math.min(n, i+1); ++j) {
 					a[i-j][j] = in.nextInt();
 				}
 			}
 			rot();
 			int x=0, y=0;
 			for(int i=0; i<=n; ++i) {
 				if(check(a, n-i)||check(a, n+i)) {
 					x = n+i;
 					break;
 				}
 			}
 			for(int i=0; i<=n; ++i) {
 				if(check(b, n-i)||check(b, n+i)) {
 					y = n+i;
 					break;
 				}
 			}
 			x += y-n;
 			System.out.println(""Case #""+ca+"": ""+(x*x-n*n));
 		}
 	}
 }
","import java.util.*;
 
 public class Main {
 	static Scanner in = new Scanner(System.in);
 	static class Node {
 		int x1, y1, x2, y2;
 		boolean flag;
 	}
 	static Node node[];
 	static int mx, my, l;
 	static void dfs(int x) {
 		node[x].flag = false;
 		mx = Math.max(mx, node[x].x2);
 		my = Math.max(my, node[x].y2);
 		l = Math.min(l, node[x].x1+node[x].y1);
 		for(int i=0; i!=node.length; ++i) {
 			if(!node[i].flag) continue;
 			int cnt = 0;
 			if(node[i].x2<node[x].x1&&node[i].y2<node[x].y1) continue;
 			if(node[x].x2<node[i].x1&&node[x].y2<node[i].y1) continue;
 			if(node[i].x2+1<node[x].x1) continue;
 			if(node[i].y2+1<node[x].y1) continue;
 			if(node[i].x1>node[x].x2+1) continue;
 			if(node[i].y1>node[x].y2+1) continue;
 			dfs(i);
 		}
 	}
 	public static void main(String[] args) {
 		int t = in.nextInt();
 		for(int ca=1; ca<=t; ++ca) {
 			int n = in.nextInt();
 			node = new Node[n];
 			for(int i=0; i!=n; ++i) {
 				node[i] = new Node();
 				node[i].x1 = in.nextInt();
 				node[i].y1 = in.nextInt();
 				node[i].x2 = in.nextInt();
 				node[i].y2 = in.nextInt();
 				node[i].flag = true;
 			}
 			int ans = 0;
 			for(int i=0; i!=n; ++i) {
 				if(node[i].flag) {
 					mx = 0;
 					my = 0;
 					l = Integer.MAX_VALUE;
 					dfs(i);
 					ans = Math.max(ans, mx+my-l);
 				}
 			}
 			System.out.println(""Case #""+ca+"": ""+(ans+1));
 		}
 	}
 }
",1
300,19588,"import java.io.*;
 import java.util.*;
 import java.lang.*;
 
 public class ChargingChaos {
 	public static void main(String[] args) throws IOException {
 		Scanner input = new Scanner(new File(""ChargingChaos.in""));
 		System.setOut(new PrintStream(new File(""ChargingChaos.out"")));
 		
 		int sets = input.nextInt();
 		for(int s = 0; s < sets; s++) {
 			int num = input.nextInt(), len = input.nextInt(); input.nextLine();
 			String[] current = new String[num];
 			String[] needed = new String[num];
 			
 			for(int a = 0; a < num; a++)
 				current[a] = input.next();
 			input.nextLine();
 			for(int a = 0; a < num; a++)
 				needed[a] = input.next();
 			
 			Arrays.sort(needed);
 			
 			int res = trySolve(current, needed);
 			
 			System.out.print(""Case #"" + (s + 1) + "": "");
 			System.out.println(res == -1 ? ""NOT POSSIBLE"" : res);
 		}
 
 		input.close();
 		System.out.close();
 	}
 	
 	public static int trySolve(String[] curr, String[] needed) {
 		int best = -1;
 		for(String shift : curr) {
 			boolean[] diff = diff(shift, needed[0]);
 			int count = 0;
 			for(boolean b : diff) if(b) count++;
 			
 			String[] res = change(curr, diff(shift, needed[0]));
 			if(Arrays.equals(res, needed))
 				best = (best == -1 ? count : Math.min(best, count));
 		}
 		
 		return best;
 	}
 	
 	public static boolean[] diff(String base, String other) {
 		boolean[] res = new boolean[base.length()];
 		for(int x = 0; x < base.length(); x++)
 			if(base.charAt(x) != other.charAt(x)) res[x] = true;
 		return res;
 	}
 	
 	public static String[] change(String[] curr, boolean[] diff) {
 		String[] res = new String[curr.length];
 		int index = 0;
 		for(String s : curr) {
 			StringBuilder newStr = new StringBuilder();
 			for(int x = 0; x < s.length(); x++) {
 				newStr.append(diff[x] ? flop(s.charAt(x)) : s.charAt(x));
 			}
 			res[index++] = newStr.toString();
 		}
 		
 		Arrays.sort(res);
 		return res;
 	}
 	
 	public static char flop(char current) {
 		return current == '0' ? '1' : '0';
 	}
 }","import java.awt.geom.*;
 import java.io.*;
 import java.math.*;
 import java.util.*;
 import java.util.regex.*;
 import static java.lang.Math.*;
 import static java.lang.System.*;
 public class B {
 
     void solve(int caseNum) {
         double c = in.nextDouble();
         double f = in.nextDouble();
         double x = in.nextDouble();
 
         double r = 2;
         double lapse = 0;
         double ans = 1<<28;
         for (int i=0; ; i++) {
             double time = x/r+lapse;
             ans = min(ans, time);
             lapse += c/r;
             if (lapse>ans) break;
             r += f;
         }
         out.println(ans);
     }
 
     // {{{
     Scanner in = new Scanner(System.in);
     public B() throws Exception {
         int caseCount = in.nextInt();
         for (int caseNum=1; caseNum<=caseCount; caseNum++) {
             out.printf(""Case #%d: "", caseNum);
             solve(caseNum);
         }
     }
     public static void main(String[] args) throws Exception {
         new B();
     }
     public static void debug(Object... arr) {
         System.err.println(Arrays.deepToString(arr));
     }
     // }}}
 }
",0
301,17984,"import java.awt.Container;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 import javax.swing.JButton;
 import javax.swing.JFrame;
 import javax.swing.JTextArea;
 
 
 public class Tongues extends JFrame
 {
 	private final int WIDTH = 800;
 	private final int HEIGHT = 400;
 	private Container pane; 
 	
 	private String[] unformatted;
 	private String[] formatted;
 	private char[][] formattedCharArray;
 	
 	private int numberOfLines;
 	
 	private JTextArea input, output;
 	private JButton newMapping;
 	
 	
 	
 	private Scanner scanner;
 	private PrintWriter out;
 	
 	
 	public Tongues() throws IOException
 	{
 		pane = new Container();
 		pane = getContentPane();
 		
 		scanner = new Scanner(new File(""input.in""));
 		out = new PrintWriter(new FileWriter(""c:/users/Christopher/Desktop/output.out"")); 
 		
 		numberOfLines = Integer.parseInt(scanner.nextLine());
 		
 		
 		unformatted = new String[numberOfLines];
 		formatted = new String[numberOfLines];
 		formattedCharArray = new char[numberOfLines][];
 		
 		
 		
 		input = new JTextArea(100, numberOfLines);
 		input.setSize(300,200);
 		input.setLocation (10, 10);
 		
 		output = new JTextArea(120, numberOfLines);
 		output.setSize(300,200);
 		output.setLocation(410, 10);
 		
 		pane.setLayout(null);
 		pane.add(input);
 		pane.add(output);
 		
 		
 		
 		for (int i = 0; i < numberOfLines; i++)
 		{
 			unformatted[i] = scanner.nextLine();
 			input.append(unformatted[i] + ""\n"");
 			
 			formattedCharArray[i] = unformatted[i].toCharArray();
 			
 			for (int j = 0; j < formattedCharArray[i].length; j++)
 			{
 				formattedCharArray[i][j] = charConversion(unformatted[i].charAt(j));
 			}
 		}
 		
 		
 		
 		
 		for (int i = 0; i < numberOfLines; i++)
 		{
 			formatted[i] = new String(formattedCharArray[i]);
 			formatted[i] = ""Case #"" + (i + 1) + "": "" + formatted[i];
 			output.append(formatted[i] + ""\n"");
 			out.println(formatted[i]);
 		}
 		
 		scanner.close();
 		out.close();
 		
 		setVisible(true);
 		setSize(WIDTH, HEIGHT);
 		setTitle(""Tongues"");
 		setDefaultCloseOperation(EXIT_ON_CLOSE);
 		
 		
 	}
 	
 	public static void main(String args[]) throws IOException
 	{
 		Tongues awesome = new Tongues();
 	}
 	
 	char charConversion(char a)
 	{
 		if (a == 'a')
 			return 'y';
 		else if (a == 'b')
 			return 'h';
 		else if (a == 'c')
 			return 'e';
 		else if (a == 'd')
 			return 's';
 		else if (a == 'e')
 			return 'o';
 		else if (a == 'f')
 			return 'c';
 		else if (a == 'g')
 			return 'v';
 		else if (a == 'h')
 			return 'x';
 		else if (a == 'i')
 			return 'd';
 		else if (a == 'j')
 			return 'u';
 		else if (a == 'k')
 			return 'i';
 		else if (a == 'l')
 			return 'g';
 		else if (a == 'm')
 			return 'l';
 		else if (a == 'n')
 			return 'b';
 		else if (a == 'o')
 			return 'k';
 		else if (a == 'p')
 			return 'r';
 		else if (a == 'q')
 			return 'z';
 		else if (a == 'r')
 			return 't';
 		else if (a == 's')
 			return 'n';
 		else if (a == 't')
 			return 'w';
 		else if (a == 'u')
 			return 'j';
 		else if (a == 'v')
 			return 'p';
 		else if (a == 'w')
 			return 'f';
 		else if (a == 'x')
 			return 'm';
 		else if (a == 'y')
 			return 'a';
 		else if (a == 'z')
 			return 'q';
 		else if (a == ' ')
 			return ' ';
 		return ' ';
 	}
 }
","import java.io.*;
 
 public class Consonants {
 
 	public static void main(String[] args) {
 		// Set up files
 		File file = new File(""input.txt"");
 		File outfile = new File(""output.txt"");
 		if(!file.exists()) {
 			System.err.println(""File doesn't exist!"");
 			return;
 		}
 		// Set up data
 		int T;
 		
 		try {
 			// Set up streams
 			BufferedReader fin = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
 			BufferedWriter fout = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outfile)));
 			
 			String line = fin.readLine();
 			T = Integer.parseInt(line.trim());
 			
 			for(int caseNum=0; caseNum<T; ++caseNum) {
 				line = fin.readLine();
 				String[] vals = line.split("" "");
 				String name = vals[0].toLowerCase();
 				int N = Integer.parseInt(vals[1]);
 				int nValue = 0;
 				
 				for(int i=N; i<=name.length(); ++i) {
 					for(int j=0; (j+i)<=name.length(); ++j) {
 						if(containsNConsecutiveConsonants(name.substring(j, j+i), N))
 							++nValue;
 					}
 				}
 				
 				System.out.println(""Case #"" + (caseNum+1) + "": "" + nValue);
 				fout.write(""Case #"" + (caseNum+1) + "": "" + nValue + ""\n"");
 			}
 			
 			// Clean up streams
 			fin.close();
 			fout.close();
 		}
 		catch(Exception e) {
 			e.printStackTrace();
 		}		
 	}
 
 	public static boolean containsNConsecutiveConsonants(String name, int N) {
 		int count = 0;
 		for(int i=0; i<name.length(); ++i) {
 			if(name.charAt(i) != 'a' 
 					&& name.charAt(i) != 'e' 
 					&& name.charAt(i) != 'i' 
 					&& name.charAt(i) != 'o' 
 					&& name.charAt(i) != 'u') {
 				++count;
 				if(count >= N)
 					return true;
 			}
 			else
 				count = 0;
 		}
 		return false;
 	}
 }
",0
302,3492,"package codejam.round1;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
 public class ProblemB {
 	public static void main(String[] args) throws Exception {
 		BufferedReader reader = new BufferedReader(new FileReader(args[0]));
 		PrintStream out = new PrintStream(args[1]);
 
 		int testsCount = Integer.parseInt(reader.readLine());
 		for (int test = 1; test <= testsCount; test++) {
 			String input = reader.readLine();
 			StringTokenizer tokenizer = new StringTokenizer(input);
 			int N = Integer.parseInt(tokenizer.nextToken());
 			int S = Integer.parseInt(tokenizer.nextToken());
 			int p = Integer.parseInt(tokenizer.nextToken());
 			List<Integer> nonSurprisingExceedingP = new ArrayList<Integer>();
 			List<Integer> suprisingExceedingP = new ArrayList<Integer>();
 			for (int i = 0; i < N; i++) {
 				int ti = Integer.parseInt(tokenizer.nextToken());
 				if (bestNonSuprisingSolution(ti) >= p) {
 					nonSurprisingExceedingP.add(i);
 				}else if(hasSuprisingSolution(ti) && bestSuprisingSolution(ti) >=p) {
 					suprisingExceedingP.add(i);
 				}
 			}
 			int googlersCount = nonSurprisingExceedingP.size() + Math.min(S, suprisingExceedingP.size());
 			out.println(String.format(""Case #%s: %s"", test, googlersCount));
 		}
 
 		out.close();
 		reader.close();
 	}
 
 	private static int nearestUpperMultipleOfThree(int a) {
 		if (a == 0 || a % 3 == 0) {
 			return a;
 		}
 		return a + (3 - (a % 3));
 	}
 
 	private static int nearestMultipleOfThree(int a) {
 		if (a == 0 || a % 3 == 0) {
 			return a;
 		}
 		if (a % 3 == 1) {
 			return a - 1;
 		}
 		return a + 1;
 	}
 
 	private static int bestNonSuprisingSolution(int total) {
 		return nearestUpperMultipleOfThree(total) / 3;
 	}
 
 	private static boolean hasSuprisingSolution(int total) {
 		return total > 1;
 	}
 
 	private static int bestSuprisingSolution(int total) {
 		return (nearestMultipleOfThree(total) / 3) + 1;
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
 public class SeanPatrick {
 	public static void main(String[] args) throws Exception {
 		BufferedReader in = new BufferedReader(new FileReader(""testcase.txt""));
 		PrintStream out = new PrintStream(new FileOutputStream(""out.txt""));
 		Integer testCaseCount = Integer.parseInt(in.readLine());
 		for (int testCase = 1; testCase <= testCaseCount; testCase++) {
 			String currentNumberOfCandies = in.readLine();
 			String currentCandiesValuesLine = in.readLine();
 
 			int numberOfCandies = Integer.parseInt(currentNumberOfCandies);
 
 			List<Integer> candiesValues = new ArrayList<Integer>();
 			StringTokenizer valuesTokenizer = new StringTokenizer(currentCandiesValuesLine);
 			for (int i = 0; i < numberOfCandies; i++) {
 				candiesValues.add(Integer.parseInt(valuesTokenizer.nextToken()));
 			}
 
 			long numberOfPilePossibilties = (long) Math.pow(2, numberOfCandies);
 			int maximumValueForSean = -1;
 			for (int currentPileDistribution = 0; currentPileDistribution < numberOfPilePossibilties; currentPileDistribution++) {
 				String binaryRepresentationOfPossibility = Integer.toBinaryString(currentPileDistribution);
 				Integer patrickPileValue = 0;
 				Integer patrickPileValueInPatricksEyes = 0;
 				Integer seanPileValue = 0;
 				Integer seanPileValueInPatricksEyes = 0;
 				for (int i = 0; i < numberOfCandies; i++) {
 					char currentBitValue = i < binaryRepresentationOfPossibility.length() ? binaryRepresentationOfPossibility.charAt(i) : '0';
 					if (currentBitValue == '0') {
 						seanPileValue += candiesValues.get(i);
 						seanPileValueInPatricksEyes = sloppySum(seanPileValueInPatricksEyes, candiesValues.get(i));
 					} else {
 						patrickPileValueInPatricksEyes = sloppySum(patrickPileValueInPatricksEyes, candiesValues.get(i));
 						patrickPileValue += candiesValues.get(i);
 					}
 				}
 				if (patrickPileValueInPatricksEyes != 0 && patrickPileValueInPatricksEyes == seanPileValueInPatricksEyes && seanPileValue > patrickPileValue && seanPileValue > maximumValueForSean) {
 					maximumValueForSean = seanPileValue;
 				}
 			}
 
 			if (maximumValueForSean != -1) {
 				out.println(""Case #"" + testCase + "": "" + maximumValueForSean);
 			} else {
 				out.println(""Case #"" + testCase + "": NO"");
 			}
 		}
 		out.close();
 		in.close();
 	}
 
 	private static Integer sloppySum(Integer patrickPileValue, Integer integer) {
 		String toAddAsBinary = Integer.toBinaryString(integer);
 		String pileValueAsBinary = Integer.toBinaryString(patrickPileValue);
 		String sum = """";
 		int pileValueStringLength = pileValueAsBinary.length();
 		int addValueStringlength = toAddAsBinary.length();
 		int minLength = Math.min(addValueStringlength, pileValueStringLength);
 		for (int i = 0; i < minLength; i++) {
 			char toAddCurrentBit = toAddAsBinary.charAt(i);
 			char pileValueCurrentBit = pileValueAsBinary.charAt(i);
 			if ((toAddCurrentBit == '0' && pileValueCurrentBit == '0') || (toAddCurrentBit == '1' && pileValueCurrentBit == '1')) {
 				sum = sum + ""0"";
 			} else {
 				sum = sum + ""1"";
 			}
 		}
 		for (int i = minLength; i < addValueStringlength; i++) {
 			sum = toAddAsBinary.charAt(i) + sum;
 		}
 
 		for (int i = Math.min(pileValueStringLength, pileValueStringLength); i < pileValueStringLength; i++) {
 			sum = toAddAsBinary.charAt(i) + sum;
 		}
 		return Integer.parseInt(sum, 2);
 	}
 
 }
",1
303,763,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package speedprogramming;
 
 import java.io.*;
 import java.util.*;
 
 /**
  *
  * @author Osama
  */
 public class A {
 
     public static void main(String args[]) {
         try {
             BufferedReader br = new BufferedReader(new FileReader(""inputs/A-large (1).in""));
             PrintWriter pw = new PrintWriter(new FileWriter(""outputs/Asample.out""));
             int noOfCases = Integer.parseInt(br.readLine());
 
             for (int i = 1; i <= noOfCases; i++) {
                 int N = Integer.parseInt(br.readLine());
                 int arr[][]=new int[N][N];
                 int gamesPlayed[]=new int[N];
 
                 for(int a=0;a<N;a++){
                     String s=br.readLine();
                     char c[]=s.toCharArray();
                     for(int b=0;b<N;b++){
                         switch(c[b]){
                             case '.':
                                 arr[a][b]=-1;
                                 break;
                             case '0':
                                 arr[a][b]=0;
                                 gamesPlayed[a]++;
                                 break;
                             case '1':
                                 arr[a][b]=1;
                                 gamesPlayed[a]++;
                                 break;
                         }
                     }
                 }
 
                 
                 double[] WP=new double[N];
                 for(int a=0;a<N;a++){
                     double sum=0;
                     //int games=0;
                     for(int b=0;b<N;b++){
                         if(arr[a][b]!=-1){
                             sum+=arr[a][b];
                             //games++;
                         }
                     }
                     WP[a]=sum/gamesPlayed[a];
                 }
 
                 
 
                 double[] OWP=new double[N];
                 for(int a=0;a<N;a++){
                     double sum=0;
                     for(int b=0;b<N;b++){
                         if(b!=a){
                             if(arr[b][a]!=-1){
                                 sum+=((WP[b]-((double)arr[b][a])/gamesPlayed[b]))*(double)gamesPlayed[b]/(gamesPlayed[b]-1);
                                 System.out.println(WP[b]+"",""+((double)arr[b][a])/gamesPlayed[b]);
                             }
                         }
                     }
                     
                     OWP[a]=sum/gamesPlayed[a];
                     //System.out.println(OWP[a]+"",""+sum+"",""+gamesPlayed[a]);
 
                 }
 
                 
                 double[] OOWP=new double[N];
                 for(int a=0;a<N;a++){
                     double sum=0;
                     for(int b=0;b<N;b++){
                         if(b!=a){
                             if(arr[b][a]!=-1){
                                 sum+=OWP[b];
                             }
                         }
                     }
                     OOWP[a]=sum/(gamesPlayed[a]);
 
                 }
                 pw.println(""Case #""+i+"":"");
                 for(int a=0;a<N;a++){
                     double RPI = 0.25 * WP[a] + 0.50 * OWP[a] + 0.25 * OOWP[a];
                     pw.println(RPI);
                 }
 
 
             }
             
             pw.close();
         }catch(Exception e){
             e.printStackTrace();            
         }
     }
 }
","package Y2014.Round1B;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class Prob1 {
     private static final String fwin = ""Fegla Won"";
     private static final String newLine = System.getProperty(""line.separator"");
     int T;
     int copy;
     BufferedWriter bw;
     {
 	try {
 	    bw = new BufferedWriter(new FileWriter(new File(""E:\\out""
 		    + System.currentTimeMillis() + "".t"")));
 	} catch (IOException e) {
 	    // TODO Auto-generated catch block
 	    e.printStackTrace();
 	}
     }
 
     public static void main(String[] args) throws IOException {
 	long b = System.currentTimeMillis();
 	Prob1 f = new Prob1();
 	f.do1();
 	long a = System.currentTimeMillis();
 	System.out.println(a - b);
 
     }
 
     private void do1() throws IOException {
 	Scanner sc = new Scanner(new File(""E:\\A-small-attempt0(1).in""));
 	// Scanner sc = new Scanner(System.in);
 	copy = sc.nextInt();
 	int N = 1;
 	T = copy;
 	while (T-- > 0) {
 	    int n = sc.nextInt();
 	    String[] s = new String[n];
 	    for (int i = 0; i < n; i++)
 		s[i] = sc.next();
 	    solve(N, n, s);
 	    N++;
 	}
 	// TODO Auto-generated method stub
 	sc.close();
 	bw.close();
 
     }
 
     private void solve(int N, int n, String[] s) throws IOException {
 	String a = s[0];
 	String b = s[1];
 	if (a.charAt(0) != b.charAt(0)) {
 	    resultPrint(N, fwin);
 	    return;
 	}
 	char c = a.charAt(0);
 	int i1 = 0;
 	int j1 = 0;
 	int ans = 0;
 	while (true) {
 	    int j = i1;
 	    while (j < a.length() && a.charAt(j) == c)
 		j++;
 	    int k = j1;
 	    while (k < b.length() && b.charAt(k) == c)
 		k++;
 	    ans += Math.abs((j - i1) - (k - j1));
 	    i1 = j;
 	    j1 = k;
 	    if ((i1 < a.length() && j1 < b.length() && a.charAt(i1) != b
 		    .charAt(j1))
 		    || (i1 >= a.length() && j1 < b.length())
 		    || (i1 < a.length() && j1 >= b.length())) {
 		resultPrint(N, fwin);
 		return;
 	    }
 	    if (i1 >= a.length() || j1 > b.length())
 		break;
 	    c = a.charAt(i1);
 	}
 	resultPrint(N, ans);
     }
 
     public void resultPrint(int n, Object res) throws IOException {
 	System.out.print(""Case #"" + n + "": "" + res + newLine);
 
 	/*
 	 * if (n == copy) // for last output ,we don't need newLine.
 	 * bw.write(""Case #"" + n + "": "" + res); else
 	 */
 	bw.write(""Case #"" + n + "": "" + res + newLine);
 
     }
 
 }
",0
304,476,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package GoogleCodeJam2013;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 
 /**
  *
  * @author g
  */
 public class FairAndSquare {
     
     public static int solve(long n, long m) {
         long left = (long) Math.ceil(Math.sqrt(n));
         long right = (long) Math.floor(Math.sqrt(m));
         int counter = 0;
         for (long i = left; i<=right; i++) {
             if (palindrome(i) & palindrome((long) Math.pow(i,2))) {
                 counter++;
                 //System.out.println(i);
             }
         }
         return counter;
     }
     
     public static boolean palindrome(long x) {
         String str = Long.toString(x);
         for (int i=0; i<str.length()/2; i++) {
             if (str.charAt(i) != str.charAt(str.length()-1-i)) {
                 return false;
             }
         }
         return true;
     }
     
     public static void main(String[] args) {
         try (BufferedReader reader = new BufferedReader(new FileReader(""C-small-attempt0.in""))) {
             int testCases = Integer.parseInt(reader.readLine());
             for (int i=0; i<testCases; i++) {
                 String[] size = reader.readLine().split("" "");
                 int n = Integer.parseInt(size[0]);
                 int m = Integer.parseInt(size[1]);
                 int x = solve(n, m); 
                 System.out.printf(""Case #%d: %d\n"", (i+1), x);
             }
         } catch (IOException e) {
             System.out.println(e);
         }
     }
 }
","import java.io.IOException;
 import java.util.InputMismatchException;
 import java.io.OutputStream;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.io.FileInputStream;
 import java.io.Writer;
 import java.math.BigInteger;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream;
 		try {
 			inputStream = new FileInputStream(""B-small-attempt1.in"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		OutputStream outputStream;
 		try {
 			outputStream = new FileOutputStream(""dancinggooglers.out"");
 		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		StreamInputReader in = new StreamInputReader(inputStream);
 		OutputWriter out = new OutputWriter(outputStream);
 		DancingGooglers solver = new DancingGooglers();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class DancingGooglers {
 	public void solve(int testNumber, StreamInputReader in, OutputWriter out) {
         out.print(""Case #"" + testNumber + "": "");
         
         int n = in.readInt(), s = in.readInt(), p = in.readInt();
         int res = 0;
         for(int i = 0; i < n; ++i) {
             int t = in.readInt();
             if (t >= 3 * Math.max(0, p-1) + 1 || t >= 3 * p || t >= Math.max(0, 3 * p - 1)) {
                 ++res;
             }
             else if (s > 0 && t >= 3 * Math.max(0, p-2) + 2) {
                 --s;
                 ++res;
             }
         }
         
         out.printLine(res);
 	}
 }
 
 class StreamInputReader extends InputReader {
     private InputStream stream;
     private byte[] buf = new byte[1024];
     private int curChar;
     private int numChars;
 
     public StreamInputReader(InputStream stream) {
         this.stream = stream;
     }
 
     public int read() {
         if (numChars == -1)
             throw new InputMismatchException();
         if (curChar >= numChars) {
             curChar = 0;
             try {
                 numChars = stream.read(buf);
             } catch (IOException e) {
                 throw new InputMismatchException();
             }
             if (numChars <= 0)
                 return -1;
         }
         return buf[curChar++];
     }
 
     }
 
 class OutputWriter {
 	private final PrintWriter writer;
 
 	public OutputWriter(OutputStream outputStream) {
 		writer = new PrintWriter(outputStream);
 	}
 
 	public OutputWriter(Writer writer) {
 		this.writer = new PrintWriter(writer);
 	}
 
 	public void print(Object...objects) {
 		for (int i = 0; i < objects.length; i++) {
 			if (i != 0)
 				writer.print(' ');
 			writer.print(objects[i]);
 		}
 	}
 
 	public void printLine(Object...objects) {
 		print(objects);
 		writer.println();
 	}
 
 	public void close() {
 		writer.close();
 	}
 }
 
 abstract class InputReader {
 
 	public abstract int read();
 
     public int readInt() {
         int c = read();
         while (isSpaceChar(c))
             c = read();
         int sgn = 1;
         if (c == '-') {
             sgn = -1;
             c = read();
         }
         int res = 0;
         do {
             if (c < '0' || c > '9')
                 throw new InputMismatchException();
             res *= 10;
             res += c - '0';
             c = read();
         } while (!isSpaceChar(c));
         return res * sgn;
     }
 
     public String readString() {
         int c = read();
         while (isSpaceChar(c))
             c = read();
         StringBuffer res = new StringBuffer();
         do {
             res.appendCodePoint(c);
             c = read();
         } while (!isSpaceChar(c));
         return res.toString();
     }
 
     public String next() {
         return readString();
     }
 
     protected boolean isSpaceChar(int c) {
         return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
     }
 
     }
 
",0
305,3488,"package gc.r3a.q3;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class Q3 {
 
 	public static String calc(int l, int h, int[] f) {
 
 		for (int i = l; i <= h; i++) {
 			boolean found = true;
 			for (int j = 0; j < f.length; j++) {
 				if (f[j] % i != 0 && i % f[j] != 0)
 					found = false;
 			}
 			if (found)
 				return """" + i;
 		}
 		return ""NO"";
 	}
 
 	public static void main(String[] args) throws Exception {
 		String input = ""c:/pws/gc/src/gc/r3a/q3/small.in"";
 		File inputFile = new File(input);
 
 		String output = inputFile.getName().split(""\\."")[0] + "".out"";
 		File outputFile = new File(inputFile.getParent() + File.separator
 				+ output);
 
 		FileWriter fw = new FileWriter(outputFile);
 		BufferedWriter bw = new BufferedWriter(fw);
 
 		FileReader fr = new FileReader(inputFile);
 		BufferedReader br = new BufferedReader(fr);
 		String line;
 		br.readLine();
 		int count = 1;
 		while ((line = br.readLine()) != null) {
 			System.err.println(line);
 			int n = Integer.parseInt(line.split("" "")[0]);
 			int l = Integer.parseInt(line.split("" "")[1]);
 			int h = Integer.parseInt(line.split("" "")[2]);
 
 			int[] freqs = new int[n];
 			line = br.readLine();
 			for (int i = 0; i < n; i++) {
 				freqs[i] = Integer.parseInt(line.split("" "")[i]);
 			}
 
 			String result = calc(l, h, freqs);
 			String resultStr = String.format(""Case #%d: %s"", count, result);
 			System.out.println(resultStr);
 			bw.write(resultStr);
 			bw.write(""\n"");
 			count++;
 		}
 		bw.flush();
 		fw.flush();
 		bw.close();
 		fw.close();
 		br.close();
 	}
 }
","package qulification.b;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class Magicka {
 
 	Map<String, Character> combain = new HashMap<String, Character>();
 	Map<Character, Set<Character>> oppose = new HashMap<Character, Set<Character>>();
 
 	char[] chars;
 
 	public static String reverse(String str) {
 		return new StringBuffer(str).reverse().toString();
 	}
 
 	public Magicka(String input) {
 		StringTokenizer st = new StringTokenizer(input, "" "");
 		int combains = Integer.parseInt(st.nextToken());
 		for (int i = 0; i < combains; i++) {
 			String combination = st.nextToken();
 			combain.put(combination.substring(0, 2), combination.substring(2)
 					.charAt(0));
 			combain.put(reverse(combination.substring(0, 2)), combination
 					.substring(2).charAt(0));
 		}
 
 		int opposes = Integer.parseInt(st.nextToken());
 		for (int i = 0; i < opposes; i++) {
 			String opp = st.nextToken();
 			char o1 = opp.charAt(0);
 			char o2 = opp.charAt(1);
 
 			if (oppose.containsKey(o1)) {
 				Set<Character> chars = oppose.get(o1);
 				chars.add(o2);
 				oppose.put(o1, chars);
 			} else {
 				Set<Character> chars = new HashSet<Character>();
 				chars.add(o2);
 				oppose.put(o1, chars);
 			}
 
 			if (oppose.containsKey(o2)) {
 				Set<Character> chars = oppose.get(o2);
 				chars.add(o1);
 				oppose.put(o2, chars);
 			} else {
 				Set<Character> chars = new HashSet<Character>();
 				chars.add(o1);
 				oppose.put(o2, chars);
 			}
 		}
 		st.nextToken();
 		chars = st.nextToken().toCharArray();
 	}
 
 	public String doTask() {
 		Deque<Character> output = new ArrayDeque<Character>();
 		for (char c : chars) {
 			if (!output.isEmpty()) {
 				char last = output.getLast();
 				String lastTwo = new String(new char[] { last, c });
 				if (combain.containsKey(lastTwo)) {
 					output.removeLast();
 					output.addLast(combain.get(lastTwo));
 				} else {
 					boolean cleared = false;
 					if (oppose.containsKey(c)) {
 						Set<Character> opposes = oppose.get(c);
 						for (Character oc : opposes) {
 							if (output.contains(oc)) {
 								output.clear();
 								cleared = true;
 								break;
 							}
 						}
 					}
 					if (!cleared)
 						output.add(c);
 				}
 			} else {
 				output.add(c);
 			}
 		}
 
 		return output.toString();
 
 	}
 
 	public static void main(String[] args) throws Exception {
 		FileReader fr = new FileReader(
 				""C:/pws/cj-2011/src/qulification/b/large.txt"");
 		BufferedReader br = new BufferedReader(fr);
 
 		int lines = Integer.parseInt(br.readLine());
 
 		for (int count = 1; count <= lines; count++) {
 			String line = br.readLine();
 			Magicka small = new Magicka(line);
 			// System.out.println(line);
 			System.out.println(""Case #"" + count + "": "" + small.doTask());
 		}
 
 		fr.close();
 		br.close();
 
 	}
 }
",1
306,13025,"package fr.flafla.codejam2011.round1B;
 
 import static java.lang.Math.min;
 
 import java.io.File;
 import java.util.Scanner;
 
 public class Pb3 {
 	public static void main(String[] args) throws Exception {
 		Scanner scan = new Scanner(new File(""C-small-attempt1.in""));
 //		Scanner scan = new Scanner(new File(""C-large.in""));
 //		Scanner scan = new Scanner(new File(""pb.in""));
 
 		int nbCase = scan.nextInt();
 		for (int cas = 1; cas <= nbCase; ++cas) {
 			final int N = scan.nextInt();
 			final int M = scan.nextInt();
 			
 			int [] u = new int[M];
 			int [] v = new int[M];
 			boolean [] W = new boolean[N];
 			for (int m = 0; m < M; ++m) {
 				u[m] = scan.nextInt();
 				W[u[m]-1] = true;
 			}
 			for (int m = 0; m < M; ++m) {
 				v[m] = scan.nextInt();
 				W[v[m]-1] = true;
 			}
 			
 			
 			
 			// Nb flavor
 			int nbFlavor = N;
 			for (int m = 0; m < M; ++m) {
 				int nbPilars = min(mod(u[m]-v[m], N), mod(v[m]-u[m], N))+1;
 				nbFlavor = min(nbFlavor, nbPilars);
 			}
 			
 			System.out.println(""Case #""+cas+"": ""+nbFlavor);
 			
 			
 			int f = 1;
 			System.out.print(f+"" "");
 			for (int n = 1; n < N; ++n) {
 				if (n == N-1)
 					f = nbFlavor;
 				else if (f < nbFlavor)
 					f++;
 				System.out.print(f+"" "");
 				if (W[n])
 					f = 0;
 			}
 			System.out.println();
 			
 		}
 	}
 	
 	public static int mod(int v, int m) {
 		int r = v%m;
 		if (r < 0)
 			r += m;
 		return r;
 	}
 }
","import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.StringTokenizer;
 
 
 public class sub {
 
 	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 	static StringTokenizer st = new StringTokenizer("""");
 
 	public static String next() throws Exception {
 		while (true) {
 			if (st.hasMoreTokens())
 				return st.nextToken();
 			String s = br.readLine();
 			if (s == null)
 				return null;
 			st = new StringTokenizer(s);
 		}
 	}
 	public static int nextInt() throws Exception {
 		return Integer.parseInt(next());
 	}
 
 	public static void main(String[] args) throws Exception {
 		 int T = nextInt();
 		 for(int it = 1 ; it <= T; it++){
 			 
 			 int n = nextInt();
 			 
 			 int [] num = new int[n];
 			 for(int i = 0 ; i < n; i++){
 				 num[i] = nextInt();
 			 }
 			 int sum[] = new int[(int)Math.pow(2, n)];
 			 HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();
 			 int curI = -1;
 			 int curI2 = -1;
 			 for(int i = 0 ; i < sum.length ; i ++){
 				 
 				 for(int j = 0 ; j < n ; j++){
 					 if( (i & (1 << j)) != 0){
 						 sum[i] += num[j]; 
 					 }
 				 }
 				if(map.containsKey(sum[i])){
 					curI2 = map.get(sum[i]);
 					curI = i;
 					break;
 				}else
 				map.put(sum[i], i);
 			 }
 			 System.out.println(""Case #""+it + "":"");
 			 if(curI == -1)
 				 System.out.println(""IMPOSSIBLE"");
 			 else{
 				 String s1 = """";
 				 for(int j = 0 ; j < n ; j++){
 					 if( (curI & (1 << j)) != 0){
 						 s1 += (num[j] + "" ""); 
 					 }
 				 }
 				 System.out.println(s1.trim());
 				 s1 = """";
 				 for(int j = 0 ; j < n ; j++){
 					 if( (curI2 & (1 << j)) != 0){
 						 s1 += num[j]+ "" ""; 
 					 }
 				 }
 				 System.out.println(s1.trim());
 			 }
 		 }
 		 
 		 
 	}
 }
",0
307,188,"import java.io.*;
 import java.util.*;
 
 public class Minez
 {
   public static void main (String [] args) throws IOException
   {
     BufferedReader read = new BufferedReader (new FileReader (""C-large.in""));
     PrintWriter print = new PrintWriter (new FileWriter (""output.txt""));
     int iterations = Integer.parseInt (read.readLine ());
     for (int count = 1; count <= iterations; count ++)
     {
       String [] variables = read.readLine ().split ("" "");
       int rows = Integer.parseInt (variables [0]);
       int columns = Integer.parseInt (variables [1]);
       int mines = Integer.parseInt (variables [2]);
       short [] [] minePlacements = new short [rows][columns];
       for (int x = 0; x < rows; x ++)
         for (int y = 0; y < columns; y ++)
         minePlacements [x][y] = 0;
       try
       {
          if (rows* columns - mines == 1)
         {
           for (int x = 0; x < columns; x ++)
             for (int y = 0; y < rows; y ++)
             minePlacements [y][x] = 1;
         }
         else if (rows == 1)
         {
           if ((rows == 2 && mines % 2 == 1)||(rows == 1 && mines > columns))
           {
             Integer.parseInt (""Force break"");
           }
           else 
           {
             for (int x = columns- 1; x >= columns - mines / rows; x --)
             {
               for (int y = 0; y < rows; y ++)
               {
                 minePlacements [y][x] = 1;
               }
             }
           }
         }
         else if (columns == 1)
         {
           if ((columns == 2 && mines % 2 == 1)||(columns == 1 && mines > rows))
           {
             Integer.parseInt (""Force break"");
           }
           else
           {
             for (int x = rows- 1; x >= rows - mines / columns; x --)
             {
               for (int y = 0; y < columns; y ++)
               {
                 minePlacements [x][y] = 1;
               }
             }
           }
         }
         else if (rows*columns - mines == 2)
         {
           Integer.parseInt (""Force Break"");
         }
         
         else if (rows == 2)
         {
           if ((rows == 2 && mines % 2 == 1)||(rows == 1 && mines > columns))
           {
             Integer.parseInt (""Force break"");
           }
           else 
           {
             for (int x = columns- 1; x >= columns - mines / rows; x --)
             {
               for (int y = 0; y < rows; y ++)
               {
                 minePlacements [y][x] = 1;
               }
             }
           }
         }
         else if (columns == 2)
         {
           if ((columns == 2 && mines % 2 == 1)||(columns == 1 && mines > rows))
           {
             Integer.parseInt (""Force break"");
           }
           else
           {
             for (int x = rows- 1; x >= rows - mines / columns; x --)
             {
               for (int y = 0; y < columns; y ++)
               {
                 minePlacements [x][y] = 1;
               }
             }
           }
         }
         else 
         {
           
           
           
           
           for (int y = columns - 1; y >= 0; y --)//columns first
           {
             
             
             
             /*if (count == 6)
             {
               System.out.println (""Case #"" + count + "":"" + mines);
               for (int x = 0; x < rows; x ++)
               {
                 for (int z = 0; z < columns; z ++)
                 {
                   if (x == 0 && z == 0)
                     System.out.print (""c"");
                   else if (minePlacements [x][z] == 0)
                     System.out.print (""."");
                   else 
                     System.out.print (""*"");
                 }
                 System.out.println ();
               }
             }*/
             
             
             if (mines == 0)
             {
               break;
             }
             else if (y < 2)
             {
               if (mines % 2 == 1)//make even
               {
                 if ((mines + 3) / 2 > rows - 3)
                   Integer.parseInt (""Derp"");
                 mines += minePlacements [0][2];
                 minePlacements [0][2] = 0;
                 mines += minePlacements [1][2];
                 minePlacements [1][2] = 0;
                 mines += minePlacements [2][2];
                 minePlacements [2][2] = 0;
               }
               
                 
                 int x = rows - 1;
                 while (true)
                 {
                   if (mines >= 2)
                   {
                     mines -= 2;
                     minePlacements [x][0] = 1;
                     minePlacements [x][1] = 1;
                   }
                   else
                     break;
                   x --;
                 }
             }
             else if (mines >= rows)
             {
               mines -= rows;
               for (int x = 0; x < rows; x++)
               {
                 minePlacements [x][y] = 1;
               }
             }
             else //if mines is less than rows
             {
               int constant = mines;
               for (int x = rows - 1; x >= rows - constant - 1; x --)
               {
                 if (mines == 2 && x == 2 && y == 2)
                 {
                   if (rows < 4)
                     Integer.parseInt (""Boo"");//case 75
                   mines -= 2;
                   minePlacements [rows - 1][y - 1] = 1;
                   minePlacements [rows - 1][y - 2] = 1;
                 }
                 if (mines == 1 && x == 1)
                 {
                   if (y == 2)
                     Integer.parseInt (""Shet yo"");
                   mines --;
                   minePlacements [rows - 1][y - 1] = 1;
                 }
                 else
                 {
                   if (mines == 0)
                     break;
                   mines --;
                   minePlacements [x][y] = 1;
                 }
               }
             }
             if (mines < 0)
               System.out.println (count + ""dammit"");
             
             
         
           }
         }
         print.println (""Case #"" + count + "":"");
         for (int x = 0; x < rows; x ++)
         {
           for (int y = 0; y < columns; y ++)
           {
             if (x == 0 && y == 0)
               print.print (""c"");
             else if (minePlacements [x][y] == 0)
               print.print (""."");
             else 
               print.print (""*"");
           }
           print.println ();
         }
       }
       catch (Exception e)
       {
         print.println (""Case #"" + count + "":"");
         if (mines != 0)
           print.println (""Impossible"");
         else
         {
           for (int x = 0; x < rows; x ++)
           {
             for (int y = 0; y < columns; y ++)
             {
               if (x == 0 && y == 0)
                 print.print (""c"");
               else if (minePlacements [x][y] == 0)
                 print.print (""."");
               else 
                 print.print (""*"");
             }
             print.println ();
           }
         }
       }
       
     }
     print.close ();
   }
 }
 
 
 
 
 
 
 
 
 
 
 
","
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Scanner;
 
 
 public class Main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws Exception {
 
         Scanner in = new Scanner(new FileInputStream(""in.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""out.txt""));
 
         int T = in.nextInt();
         for (int i = 0; i < T; i++) {
             int L = in.nextInt();
             int t = in.nextInt();
             int N = in.nextInt();
             int C = in.nextInt();
             int[] d = new int[C];
             for (int j = 0; j < C; j++) {
                 d[j] = in.nextInt();
             }
             ArrayList<Long> temp = new ArrayList<Long>();
             long[] spaces = new long[N];
             long sum = 0;
             for (int j = 0; j < N; j++) {
                 spaces[j] = 2 * d[j % C];
                 temp.add(new Long(d[j % C]));
                 sum += spaces[j];
             }
             Collections.sort(temp);
 
             if (L >  sum) {
                 System.out.println(""Case #""+(i+1)+"": ""+sum);
                 bw.write(""Case #""+(i+1)+"": ""+sum+""\n"");
                 continue;
             }
             long currentTime = sum;
 
             for (int j = N - 1; j >= 0; j--) {
                 long tem=spaces[j];
 
                 if (spaces[j] == temp.get(temp.size() - 1).longValue()*2) {
                     temp.remove(temp.size() - 1);
                     if (t < currentTime - spaces[j] && L > 0) {
                         spaces[j] = spaces[j] / 2;
                         L--;
                     } else if (spaces[j] > t && L > 0) {
                         spaces[j] = (spaces[j]+t)/2;
                     }
                 }
                 currentTime-=tem;
             }
             long ans = 0;
             //System.out.println("" "");
             for (int j = 0; j < spaces.length; j++) {
                 ans+= spaces[j];
                 //System.out.print(spaces[j]+"" "");
 
             }
             System.out.println(""Case #""+(i+1)+"": ""+ans);
             bw.write(""Case #""+(i+1)+"": ""+ans+""\n"");
         }
         bw.close();
 
     }
 }
",0
308,9082,"import java.util.*;
 import java.io.*;
 class Caso{
 	public int N;
 	public char[][]x;
 	public void leer(Scanner s){
 		N=s.nextInt();
 		x=new char[N][N];
 		for(int i=0;i<N;i++){
 			String c=s.next();
 			for(int j=0;j<c.length();j++){
 				x[i][j]=c.charAt(j);
 			}
 		}
 	}
 	public double wp(int a){
 		return wp(a,N+1);
 	}
 	public double wp(int a,int e){
 		double n=0;
 		double g=0;
 		for(int i=0;i<N;i++){
 			if(i!=e){
 				if(x[a][i]=='1'){
 					g++;
 					n++;
 				}
 				if(x[a][i]=='0'){
 					n++;
 				}
 			}
 		}
 		return g/n;
 	}
 	public double owp(int a){
 		double n=0;
 		double r=0;
 		for(int i=0;i<N;i++){
 			if(i!=a&&x[i][a]!='.'){
 				r+=wp(i,a);
 				n++;
 			}
 		}
 		return r/n;
 	}
 	public double oowp(int a){
 		double n=0;
 		double r=0;
 		for(int i=0;i<N;i++){
 			if(i!=a&&x[i][a]!='.'){
 				r+=owp(i);
 				n++;
 			}
 		}
 		return r/n;
 	}
 	public double rpi(int a){
 		double wp=wp(a);
 		double owp=owp(a);
 		double oowp=oowp(a);
 		double rpi=.25*wp+.5*owp+.25*oowp;
 		return rpi;
 	}
 	public Caso(){
 	}
 	public String obtenerRespuesta(){
 		String r="""";
 		for(int i=0;i<N;i++){
 			r+=""\n""+rpi(i);
 		}
 		return r;
 	}
 }
 public class RPI{
 	public void iniciar(){
 		Scanner s=null;
 		PrintStream ps=null;
 		try{
 			ps=new PrintStream(new FileOutputStream(new File(""output.txt"")));
 			s=new Scanner(new FileReader(""input.txt""));
 			StringBuffer entrada=new StringBuffer();
 			while(s.hasNextLine()){
 				entrada.append(s.nextLine()+""\n"");
 			}
 			s=new Scanner(entrada+"""");
 		}catch(Exception e){
 			e.printStackTrace();
 		}
 		int numeroCasos=s.nextInt();
 		Caso[]casos=new Caso[numeroCasos];
 		for(int i=0;i<numeroCasos;i++){
 			casos[i]=new Caso();
 		}
 		for(int k=0;k<numeroCasos;k++){
 			casos[k].leer(s);
 		}
 		for(int i=0;i<casos.length;i++){
 			ps.println(""Case #""+(i+1)+"": ""+casos[i].obtenerRespuesta());
 		}
 	}
 	public static void main(String[]args){
 		(new RPI()).iniciar();
 	}
 }","import java.util.*;
 import java.io.*;
 class Caso{
 	int n;
 	int s;
 	int p;
 	int[]t;	
 	public void leer(Scanner s){
 		n=s.nextInt();
 		this.s=s.nextInt();
 		p=s.nextInt();
 		t=new int[n];
 		for(int i=0;i<t.length;i++){
 			t[i]=s.nextInt();
 		}
 	}
 	public Caso(){
 	}
 	public String obtenerRespuesta(){
 		int ps=0;
 		int mx=0;
 		int c=s;
 		for(int i=0;i<t.length;i++){
 			ps=(int)Math.ceil(t[i]/3.);
 			if(ps>=p){
 				mx++;
 			}else{
 				if(t[i]<=28&&t[i]>1&&c>0){
 					if(ps+1>=p&&t[i]%3!=1){
 						mx++;
 						c--;
 					}
 				}
 			}
 		}
 		return mx+"""";
 	}
 }
 public class Caso1{
 	public void iniciar(){
 		Scanner s=null;
 		PrintStream ps=null;
 		try{
 			ps=new PrintStream(new FileOutputStream(new File(""output.txt"")));
 			s=new Scanner(new FileReader(""input.txt""));
 			StringBuffer entrada=new StringBuffer();
 			while(s.hasNextLine()){
 				entrada.append(s.nextLine()+""\n"");
 			}
 			s=new Scanner(entrada+"""");
 		}catch(Exception e){
 			e.printStackTrace();
 		}
 		int numeroCasos=s.nextInt();
 		Caso[]casos=new Caso[numeroCasos];
 		for(int i=0;i<numeroCasos;i++){
 			casos[i]=new Caso();
 		}
 		for(int k=0;k<numeroCasos;k++){
 			casos[k].leer(s);
 		}
 		for(int i=0;i<casos.length;i++){
 			ps.println(""Case #""+(i+1)+"": ""+casos[i].obtenerRespuesta());
 		}
 	}
 	public static void main(String[]args){
 		(new Caso1()).iniciar();
 	}
 }",1
309,2668,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.StringTokenizer;
 
 
 public class B {
 	public static final int O = 0;
 	public static final int B = 1;
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception {
 		BufferedReader bufferedReader = new BufferedReader(new FileReader(""D:\\Personal\\codejam\\B-small-attempt2.in""));
 		PrintStream File_Out = new PrintStream(new File(""D:\\Personal\\codejam\\B-small-attempt2.out""));
         String line = bufferedReader.readLine();
         
         int T = Integer.parseInt(line);
         
         for (int t = 0 ; t < T; t ++) {
         	line = bufferedReader.readLine();
         	
         	StringTokenizer stringTokenizer = new StringTokenizer(line);
         	
         	int C = Integer.parseInt(stringTokenizer.nextToken());
         	String[] combine = new String[C];
         	for (int c = 0; c < C; c ++) {
         		combine[c] = stringTokenizer.nextToken();
         	}
         	
         	int D = Integer.parseInt(stringTokenizer.nextToken());
         	String[] opposed = new String[D];
         	for (int d = 0; d < D; d ++) {
         		opposed[d] = stringTokenizer.nextToken();
         	}
         	
         	int N = Integer.parseInt(stringTokenizer.nextToken());
         	char[] invokeList = stringTokenizer.nextToken().toCharArray();
         	char[] resList = new char[invokeList.length];
         	int count = 0;
         	
         	for (int n = 0; n < N; n ++) {
         		if (count > 0) {
         			char x = lookUpCombine(combine, resList[count-1], invokeList[n]);
         			if (x != 0) {
         				resList[count-1] = x;
         			} else {
         				int c = 0;
         				
         				for (c = count - 1; c >= 0; c --) {
         					if (lookUpOpposed(opposed, resList[c], invokeList[n])) {
         						count = 0;
         						break;
         					}
         				}
         				
         				if (c < 0) {
         					resList[count ++] = invokeList[n];
         				}
         			}
         		} else {
         			resList[count ++] = invokeList[n];
         		}
         		
         	}
         	StringBuffer res = new StringBuffer();
         	res.append('[');
         	
         	for (int x = 0; x < count; x ++) {
         		if (x != 0) {
         			res.append("", "");
         		}
         		res.append(resList[x]);
         	}
         	
         	res.append(']');
         	
         	File_Out.println(""Case #"" + (t + 1) + "": "" + res);
         }	
 	}
 	
 	// TODO: Hash
 	
 	public static char lookUpCombine(String[] combine, char a, char b) {
 		for (int i = 0; i < combine.length; i ++) {
 			if (combine[i].charAt(0) == a && combine[i].charAt(1) == b) {
 				return combine[i].charAt(2);
 			} else if (combine[i].charAt(0) == b && combine[i].charAt(1) == a) {
 				return combine[i].charAt(2);
 			}
 		}
 		
 		return 0;
 	}
 	
 	public static boolean lookUpOpposed(String[] opposed, char a, char b) {
 		for (int i = 0; i < opposed.length; i ++) {
 			if (opposed[i].charAt(0) == a && opposed[i].charAt(1) == b) {
 				return true;
 			} else if (opposed[i].charAt(0) == b && opposed[i].charAt(1) == a) {
 				return true;
 			}
 		}
 		
 		return false;
 	}
 }
","package round2;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintStream;
 
 public class A {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception {
 		BufferedReader bufferedReader = new BufferedReader(new FileReader(""/home/administrator/codejam/A-small-attempt0.in""));
 		PrintStream File_Out = new PrintStream(new File(""/home/administrator/codejam/A-small-attempt0.out""));
         String line = bufferedReader.readLine();
         
         int T = Integer.parseInt(line);
         
         for (int t = 0 ; t < T; t ++) {
         	line = bufferedReader.readLine();
         	int N = Integer.parseInt(line);
         	char[][] matrix = new char[N][N];
         	float[] wins = new float[N];
         	int[] counts = new int[N];
         	for (int n = 0; n < N; n++) {
         		line = bufferedReader.readLine();
         		for (int x = 0; x < line.length(); x ++) {
         			matrix[n][x] = line.charAt(x);
         			if (matrix[n][x] == '1') {
         				wins[n] ++;
         				counts[n] ++;
         			} else if (matrix[n][x] == '0'){
         				counts[n] ++;
         			}
         		}
         	}
         	
         	float[] OWPS = new float[N];
         	for (int i = 0; i < N; i ++) {
         		OWPS[i] = OWP(matrix, wins, counts, i, N);
 //        		System.out.println(OWPS[i]);
         	}
         	
         	float[] OOWPS = new float[N];
         	for (int i = 0; i < N; i ++) {
         		OOWPS[i] = OOWP(matrix, OWPS, i, N);
         	}
         	
         	File_Out.println(""Case #"" + (t + 1) + "":"");
         	for (int n = 0; n < N; n++) {
         		File_Out.println(0.25 * (wins[n]/counts[n]) + 0.50 * OWPS[n] + 0.25 * OOWPS[n]);
         	}
         }
 	}
 	
 	public static float OWP(char[][] matrix, float[] wins, int[] counts, int n, int N) {
 		int o_count = 0;
 		float WP_SUM = 0f;
 		for (int i = 0; i < N; i ++) {
 			if (matrix[i][n] == '1') {
 				WP_SUM += (wins[i] - 1) / (counts[i] - 1);
 				o_count ++;
 			} else if (matrix[i][n] == '0'){
 				WP_SUM += wins[i] / (counts[i] - 1);
 				o_count ++;
 			}
 		}
 		
 		return WP_SUM/ o_count;
 	}
 	
 	public static float OOWP(char[][] matrix, float[] OWPS, int n, int N) {
 		int o_count = 0;
 		float WP_SUM = 0f;
 		for (int i = 0; i < N; i ++) {
 			if (matrix[i][n] == '1') {
 				WP_SUM += OWPS[i];
 				o_count ++;
 			} else if (matrix[i][n] == '0'){
 				WP_SUM += OWPS[i];
 				o_count ++;
 			}
 		}
 		
 		return WP_SUM/ o_count;
 	}
 }
",1
310,1289,"package adi.code.jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class Q3 {
 	public static void main (String[] args) {
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(""C-small-attempt0.in""));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(""output.txt""));
 
 			int cases = Integer.parseInt(br.readLine());
 			for (int x = 0; x < cases; x++) {
 				String[] lh = br.readLine().split("" "");
 				int low = Integer.parseInt(lh[0]);
 				int high = Integer.parseInt(lh[1]);
 				int count = 0;
 				for (int i = low; i <= high; i++) {
 					if (isPal(i)) {
 						if (isSq(i))
 							if (isPal((int)Math.sqrt(i)))
 								count++;
 					}
 				}
 				bw.write(""Case #"" + (x+1) + "": "" + count + ""\r\n"");
 			}
 			bw.close();
 			br.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (NumberFormatException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 
 		
 	}
 	
 	public static boolean isSq(int n)
 	{
 	    int z = n & 0xF; 
 	    if (z > 9)
 	        return false; 
 
 	    if ( z != 2 && z != 3 && z != 5 && z != 6 && z != 7 && z != 8 )
 	    {
 	        int t = (int) Math.floor( Math.sqrt((double) n) + 0.5 );
 	            return t*t == n;
 	    }
 	    return false;
 	}
 	
     public static boolean isPal(int n) {
         int pali = n; // copied number into variable
         int reverse = 0;
 
         while (pali != 0) {
             int remainder = pali % 10;
             reverse = reverse * 10 + remainder;
             pali /= 10;
         }
 
         // if original and reverse of number is equal means
         // number is palindrome in Java
         if (n == reverse) {
             return true;
         }
         return false;
     }
 
 }
 
","
 package codejam_2014_qualification_2;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.InputMismatchException;
 import java.util.Scanner;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 public class Codejam_2014_Qualification_2
 {
     private static int T;
     private static double Farm;
     private static double Added;
     private static double Target;
     private static final String filename = ""B-small-attempt0"";
     public static void main(String[] args)
     {
         String file_content = read_file(filename + "".in"");
         try
         {
             PrintWriter writer = new PrintWriter(filename + "".out"", ""UTF-8"");
             Scanner sc = new Scanner(file_content);
             T = sc.nextInt();
             for(int t=0; t<T; t++)
             {
                 Double Rate = 2.0;
                 Farm = sc.nextDouble();
                 Added = sc.nextDouble();
                 Target = sc.nextDouble();
                 Double last = Target/Rate;
                 Double curr = last-((Target-Farm)/Rate)+Target/(Rate+Added);
                 while(true)
                 {
                     if(curr>last)
                         break;
                     Rate+=Added;
                     last = curr;
                     curr = last-((Target-Farm)/Rate)+Target/(Rate+Added);
                 }
                 writer.println(""Case #"" + (t + 1) + "": "" + last);
             }
             writer.close();
             sc.close();
         } catch(InputMismatchException imme) {
         } catch(FileNotFoundException e) {
         } catch (UnsupportedEncodingException ex) {
             Logger.getLogger(Codejam_2014_Qualification_2.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
     private static String read_file(String f)
     {
         String file_content = """";
         try
         {
             BufferedReader br = new BufferedReader(new FileReader(f));
             StringBuilder sb = new StringBuilder();
             String line = br.readLine();
             while (line != null)
             {
                 sb.append(line);
                 sb.append(""\n"");
                 line = br.readLine();
             }
             file_content = sb.toString();
         } catch (FileNotFoundException e) {
         } catch (IOException ex) {
             Logger.getLogger(Codejam_2014_Qualification_2.class.getName()).log(Level.SEVERE, null, ex);
         }
         return file_content;
     }
 }
 
",0
311,4886,"
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
 
 /**
  * @author Ivan Pryvalov (ivan.pryvalov@gmail.com)
  *
  */
 public class GCJ_2013_Q__Problem_B implements Runnable{
 	
 	private void solve() throws IOException {
 		int T = scanner.nextInt(); //10^3
 		for (int test = 0; test < T; test++) {
 			int N = scanner.nextInt();
 			int M = scanner.nextInt();
 			int a[][] = new int[N][M];
 			for (int i = 0; i < N; i++) {
 				a[i] = scanner.loadIntArray(M);
 			}
 			
 			//solve
 			int[][] maxLeft = new int[N][M];
 			int[][] maxRight = new int[N][M];
 			int[][] maxUp = new int[N][M];
 			int[][] maxDown = new int[N][M];
 			
 			for(int i=0; i<N; i++){
 				for (int j = 0; j < M; j++) {
 					maxLeft[i][j] = a[i][j];
 					maxUp[i][j] = a[i][j];
 					if (i>0)
 						maxUp[i][j] = Math.max(maxUp[i-1][j], a[i][j]);
 					if (j>0)
 						maxLeft[i][j] = Math.max(maxLeft[i][j-1], a[i][j]);
 				}
 			}
 			
 			for(int i=N-1; i>=0; i--){
 				for (int j = M-1; j >=0; j--) {
 					maxRight[i][j] = a[i][j];
 					maxDown[i][j] = a[i][j];
 					if (i<N-1)
 						maxDown[i][j] = Math.max(maxDown[i+1][j], a[i][j]);
 					if (j<M-1)
 						maxRight[i][j] = Math.max(maxRight[i][j+1], a[i][j]);
 				}
 			}
 
 			boolean res = true; 
 			for (int i = 0; i < N && res; i++) {
 				for (int j = 0; j < M; j++) {
 					if (maxLeft[i][M-1]>a[i][j] && maxUp[N-1][j]>a[i][j]){
 						res = false;
 						break;
 					}
 				}
 			}
 			
 			String str = String.format(""Case #%d: %s"",test+1, res?""YES"":""NO"");
 			out.println(str);
 			
 			if (inputFromFile){
 				System.out.printf(""\t\tTest %d of %d done ==> \n"",test+1, T);
 				System.out.println(str);
 			}
 		}
 	}
 
 	/////////////////////////////////////////////////
 	final int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly
 	final int INPUT_BUFFER_SIZE = 1024 * 1024 * 8 ;
 	final int BUF_SIZE_INPUT = 1024;
 	
 	final int BUF_SIZE_OUT = 1024;
 	
 	boolean inputFromFile = true;
 //	String filenamePrefix = ""B-sample"";
 	String filenamePrefix = ""B-small-attempt2"";
 	String inSuffix = "".in"";
 	String outSuffix = "".out"";
 	
 	//InputStream bis;
 	//OutputStream bos;
 	PrintStream out;
 	ByteScanner scanner;
 	ByteWriter writer;
 	
 //	@Override
 	public void run() {
 		try{
 			InputStream bis = null;
 			OutputStream bos = null;
 			//PrintStream out = null;
 			if (inputFromFile){
 				File baseFile = new File(getClass().getResource(""/"").getFile());
 				bis = new BufferedInputStream(
 						new FileInputStream(new File(
 								baseFile, filenamePrefix+inSuffix)),
 								INPUT_BUFFER_SIZE);
 				bos = new BufferedOutputStream(
 						new FileOutputStream(
 								new File(baseFile, filenamePrefix+outSuffix)));
 				out = new PrintStream(bos);
 			}else{
 				bis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);
 				bos = new BufferedOutputStream(System.out);
 				out = new PrintStream(bos);
 			}
 			scanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);
 			writer = new ByteWriter(bos, BUF_SIZE_OUT);
 			
 			solve();
 			out.flush();
 		}catch (Exception e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 	
 	public interface Constants{
 		final static byte ZERO = '0';//48 or 0x30
 		final static byte NINE = '9';
 		final static byte SPACEBAR = ' '; //32 or 0x20
 		final static byte MINUS = '-'; //45 or 0x2d	
 		
 		final static char FLOAT_POINT = '.';
 	}
 	
 	public static class EofException extends IOException{
 	}
 	
 	public static class ByteWriter implements Constants {
 		
 		int bufSize = 1024;
 		byte[] byteBuf = new byte[bufSize];
 		OutputStream os;
 		
 		public ByteWriter(OutputStream os, int bufSize){
 			this.os = os;
 			this.bufSize = bufSize;
 		}
 		
 		public void writeInt(int num) throws IOException{
 	         int byteWriteOffset = byteBuf.length;
 	         if (num==0){
 	        	 byteBuf[--byteWriteOffset] = ZERO;
 	         }else{
 	        	 int numAbs = Math.abs(num);
 	        	 while (numAbs>0){
 	        		 byteBuf[--byteWriteOffset] = (byte)((numAbs % 10) + ZERO);
 	        		 numAbs /= 10;
 	        	 }
 	        	 if (num<0)
 	        		 byteBuf[--byteWriteOffset] = MINUS;
 	         }
 	         os.write(byteBuf, byteWriteOffset, byteBuf.length - byteWriteOffset);
 		}
 		
 		/**
 		 * Please ensure ar.length <= byteBuf.length!
 		 * 
 		 * @param ar
 		 * @throws IOException
 		 */
 		public void writeByteAr(byte[] ar) throws IOException{
 			for (int i = 0; i < ar.length; i++) {
 				byteBuf[i] = ar[i];
 			}
 			os.write(byteBuf,0,ar.length);
 		}
 		
 		public void writeSpaceBar() throws IOException{
 			byteBuf[0] = SPACEBAR;
 			os.write(byteBuf,0,1);
 		}
 		
 	}
 	
 	public static class ByteScanner implements Constants{
 		
 		InputStream is;
 		
 		public ByteScanner(InputStream is, int bufSizeInput, int bufSize){
 			this.is = is;
 			this.bufSizeInput = bufSizeInput;
 			this.bufSize = bufSize;
 			
 			byteBufInput = new byte[this.bufSizeInput];
 			byteBuf = new byte[this.bufSize];
 		}
 		
 		public ByteScanner(byte[] data){
 			byteBufInput = data;
 			bufSizeInput = data.length;
 			bufSize = data.length;
 			byteBuf = new byte[bufSize];
 			byteRead = data.length;
 			bytePos = 0;
 		}
 		
 		private int bufSizeInput;
 		private int bufSize;
 		
 		byte[] byteBufInput;
 		byte by=-1;
 		int byteRead=-1;
 		int bytePos=-1;
 
 		byte[] byteBuf;
 		int totalBytes;
 		
 		boolean eofMet = false;
 		
 		private byte nextByte() throws IOException{
 			
 			if (bytePos<0 || bytePos>=byteRead){
 				byteRead = is==null? -1: is.read(byteBufInput);
 				bytePos=0;
 				if (byteRead<0){
 					byteBufInput[bytePos]=-1;//!!!
 					if (eofMet)
 						throw new EofException();
 					eofMet = true;
 				}
 			}
 			return byteBufInput[bytePos++];
 		}
 		
 		/**
 		 * Returns next meaningful character as a byte.<br>
 		 * 
 		 * @return
 		 * @throws IOException
 		 */
 		public byte nextChar() throws IOException{
 			while ((by=nextByte())<=0x20);
 			return by;
 		}
 		
 		/**
 		 * Returns next meaningful character OR space as a byte.<br>
 		 * 
 		 * @return
 		 * @throws IOException
 		 */
 		public byte nextCharOrSpacebar() throws IOException{
 			while ((by=nextByte())<0x20);
 			return by;
 		}
 		
 	    /**
 	     * Reads line.
 	     * 
 	     * @return
 	     * @throws IOException
 	     */
 	    public String nextLine() throws IOException {
             readToken((byte)0x20);
             return new String(byteBuf,0,totalBytes);
 	    }
 	    
 	    public byte[] nextLineAsArray() throws IOException {
             readToken((byte)0x20);
             byte[] out = new byte[totalBytes];
             System.arraycopy(byteBuf, 0, out, 0, totalBytes);
             return out;
 	    }
 	    
 		
 	    /**
 	     * Reads token. Spacebar is separator char.
 	     * 
 	     * @return
 	     * @throws IOException
 	     */
 	    public String nextToken() throws IOException {
             readToken((byte)0x21);
             return new String(byteBuf,0,totalBytes);
 	    }
 	    
 	    /**
 	     * Spacebar is included as separator char
 	     * 
 	     * @throws IOException
 	     */
 	    private void readToken() throws IOException {	    	
             readToken((byte)0x21);
 	    }
 	    
 	    private void readToken(byte acceptFrom) throws IOException {
             totalBytes = 0;
             while ((by=nextByte())<acceptFrom);
             byteBuf[totalBytes++] = by;
             while ((by=nextByte())>=acceptFrom){
                 byteBuf[totalBytes++] = by;
             }
 	    }
 		
 	    public int nextInt() throws IOException{
 			readToken();
 			int num=0, i=0;
 			boolean sign=false;
 			if (byteBuf[i]==MINUS){
 				sign = true;
 				i++;
 			}
 			for (; i<totalBytes; i++){
 				num*=10;
 				num+=byteBuf[i]-ZERO;
 			}
 			return sign?-num:num;
 		}
 		
 		public long nextLong() throws IOException{
 			readToken();
 			long num=0;
 			int i=0;
 			boolean sign=false;
 			if (byteBuf[i]==MINUS){
 				sign = true;
 				i++;
 			}
 			for (; i<totalBytes; i++){
 				num*=10;
 				num+=byteBuf[i]-ZERO;
 			}
 			return sign?-num:num;
 		}
 		
 		/*
 		//TODO test Unix/Windows formats
 		public void toNextLine() throws IOException{
 			while ((ch=nextChar())!='\n');
 		}
 		*/
 		
 		public double nextDouble() throws IOException{
 			readToken();
 			char[] token = new char[totalBytes];
 			for (int i = 0; i < totalBytes; i++) {
 				token[i] = (char)byteBuf[i];
 			}
 			return Double.parseDouble(new String(token));
 		}
 		
 		public int[] loadIntArray(int size) throws IOException{
 			int[] a = new int[size];
 			for (int i = 0; i < a.length; i++) {
 				a[i] = nextInt();
 			}
 			return a;
 		}
 		
 		public long[] loadLongArray(int size) throws IOException{
 			long[] a = new long[size];
 			for (int i = 0; i < a.length; i++) {
 				a[i] = nextLong();
 			}
 			return a;
 		}
 	    
 	}
 	
 	public static abstract class Timing{
 		private static int counter = 0;
 		protected String name = ""Timing""+(++counter);
 		private boolean debug;
 		
 		public Timing(boolean debug) {
 			super();
 			this.debug = debug;
 		}
 		
 		public abstract void run();
 		public void start(){
 			long time1 = System.currentTimeMillis();
 			run();
 			long time2 = System.currentTimeMillis();
 			if (debug)
 				System.out.println(name+"" time = ""+(time2-time1)/1000.0+"" ms."");
 		}
 		
 	}
 	
 	public static class Alg{
 		public static interface BooleanChecker{
 			public boolean check(long arg);
 		}
 		
 		public static class BinarySearch{
 					
 			/**
 			 * This check returns boolean value, result of function.
 			 * It should be monotonic.
 			 * 
 			 * @return
 			 */
 			public BooleanChecker bc;
 			
 			
 			/**
 			 * Returns following element: <pre> 0 0 [1] 1 1</pre>
 			 */
 			public long search(long left, long right){
 				while (left<=right){
 					long mid = (left+right)/2;
 					if (bc.check(mid)){
 						right = mid-1;
 					}else{
 						left = mid+1;
 					}
 				}
 				return left;
 			}
 			
 			/**
 			 * Optional.<br>
 			 * Returns following element: <pre> 1 1 [1] 0 0</pre>
 			 */
 			public long searchInverted(long left, long right){
 				while (left<=right){
 					long mid = (left+right)/2;
 					if (!bc.check(mid)){
 						right = mid-1;
 					}else{
 						left = mid+1;
 					}
 				}
 				return left - 1; 
 			}
 		}
 	}
 	
 	public static class Modulo{
 		long mod = (long)1e9+7;
 		
 		public Modulo(long mod) {
 			super();
 			this.mod = mod;
 		}
 
 		public long inv(long a) {
 			long res =  pow(a, mod-2);
 			return res;
 		}
 
 		public long pow(long a, long x) {
 			if (x==0)
 				return 1;
 			long part = 1;
 			if ((x&1)!=0)
 				part = a;
 			return (part * pow((a*a)%mod, x>>1)) % mod;
 		}
 		
 		public long c(long n, long m){
 			long res = 1;
 			for(int i=1; i<=m; i++){
 				res = (res * (n-m+i)) % mod;
 				res = (res * inv(i)) % mod;
 			}
 			return res;
 		}
 		
 	}
 	
 	public static void main(String[] args) {
 		new GCJ_2013_Q__Problem_B().run();
 	}
 	
 }
","package com.zccicy;
 
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class Main {
  
 
  
  
 		
 		public static void main (String[] args)  throws Exception
 		{
 		 
 			FileWriter writer=new FileWriter(""d:/CCAOutput2.txt"");
 			Scanner scanner=new Scanner(new FileInputStream(""d:/B-large.in""));
 		    
 			double count_case_d = scanner.nextDouble();
 			
 			long count_case = (long)count_case_d;
 			
 			//System.out.println(""case count ""+count_case);
 			 
 			
 			for (long i =0;i<count_case;i++)
 			{
 				double c =  scanner.nextDouble();
 				double f =  scanner.nextDouble();
 				double x =  scanner.nextDouble();
 				double result = 0;
 
 				if (c>=x)
 				{
 					String result_s = String.format(""%.7f"", x/2); 
 					writer.write(""Case #""+(i+1)+"": ""+result_s+""\n"");
 					continue;
 				}
 				long n = 1;
 				double t = x/2;
 				double t_1 = 0;
 				double x_1 = x/2;
 				while (true)
 				{
 					t_1 = t;
 					t += c/(2+f*(n-1))+x/(2+f*n)-x_1;
 					x_1 = x/(2+f*n);
 					if (t_1 <= t)
 					{
 						String result_s = String.format(""%.7f"", t_1); 
 						writer.write(""Case #""+(i+1)+"": ""+result_s+""\n"");
 						break;
 					}
 					n++;
 				}
 				
 				
 				
 				 
 			 
 				 
 			    
 				
 			}
 			
 			writer.close();
 		}
 		
 
  
 
 }
",0
312,1347,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 
 
 
 public class GB1 {
 
 	class Testcase {
 		int ans = 0;
 		
 		public Testcase() {	
 		}
 		
 		public Testcase(int seed) {
 		}
 		
 		String s = ""YES"";
 		
 		int A;
 		int N;
 		int [] a;
 		public void loadInput(Scanner sc) {
 			A = sc.nextInt();
 			N = sc.nextInt();
 //			System.out.println(""A:"" + A + ""N:"" + N);
 			a = new int[N];
 			for(int i=0;i<N;i++)
 					a[i] = sc.nextInt();
 			Arrays.sort(a);
 			ans = N;
 		}
 		 
 		public void f(int index, int sum, int step){	
 			if(step>=N)
 				return;
 			if(index>=N){
 				if(step<ans)
 					ans = step;
 				return;
 			}
 			//absorb
 			if(sum>a[index]){
 				f(index+1,sum+a[index],step);
 			}
 			//remove
 			if(sum<=a[index]){
 				f(index+1,sum,step+1);
 			}
 			//add and absorb
 			if(sum<=a[index]  && (sum-1)>0 ){
 				while(sum<=a[index]){
 					sum += sum-1;
 					step++;
 				}
 				f(index+1, sum+a[index],step);
 			}
 		}
 		
 		public void solveFast() {
 			 f(0,A,0);
 		}
 		
 		 
 		
 		public void printSelf(PrintWriter pw) {
 //			System.out.println(ans);
 			pw.println(ans);
 		}
 		
 		public boolean sameAnswers(Testcase other) {
 			return false;
 		}
 	}
 	
 	final String AFTER_CASE = "" "";
 	
 	public void go() throws Exception {
 		
 		Scanner sc = new Scanner(new FileReader(""A-large.in""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""output1.txt""));
 		
 		int caseCnt = sc.nextInt();
 		sc.nextLine();
 		for (int caseNum = 0; caseNum < caseCnt; caseNum++) {
 			System.out.println(""solving case "" + caseNum);
 			
 			Testcase tc = new Testcase();
 			
 			tc.loadInput(sc);
 			tc.solveFast();
 			
 			pw.print(""Case #"" + (caseNum + 1) + "":"");
 			pw.print(AFTER_CASE);
 			
 			tc.printSelf(pw);
 		}
 		
 		pw.flush();
 		pw.close();
 		sc.close();
 //		System.err.println(""Finish!"");
 	}
 	
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception  {
 		// TODO Auto-generated method stub
 		new GB1().go();
 	}
 
 }
","package com.felarof.codejam;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 
 public class Main {
 	public static String test_case_result="""";
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		StringTokenizer st;
 
 		int num_test_cases = Integer.parseInt(br.readLine());
 		for(int i=1; i<=num_test_cases; i++)
 		{
 			int answer1;
 			int answer2;
 			int[] row1=new int[4];
 			int[] row2=new int[4];
 			answer1 = Integer.parseInt(br.readLine());
 			for(int r=1; r<=4; r++)
 			{
 				if(r==answer1)
 				{
 					st = new StringTokenizer(br.readLine());
 					for(int c=0; c<4; c++)
 					{
 						row1[c]=Integer.parseInt(st.nextToken());						
 					}
 				}
 				else
 					br.readLine();
 			}
 			answer2 = Integer.parseInt(br.readLine());
 			for(int r=1; r<=4; r++)
 			{
 				if(r==answer2)
 				{
 					st = new StringTokenizer(br.readLine());
 					for(int c=0; c<4; c++)
 					{
 						row2[c]=Integer.parseInt(st.nextToken());						
 					}
 				}
 				else
 					br.readLine();
 			}
 			//Find intersection between 2 rows
 			System.out.println(""Case #""+Integer.toString(i)+"": ""+findRowIntersection(row1, row2));
 			
 		}		
 	}
 	private static String findRowIntersection( int[] row1, int[] row2)
 	{
 		int num_intersections = 0;
 		int value_intersection = -1;
 		
 		String result="""";
 		outer: for(int i=0; i<row1.length; i++)
 		{
 			inner: for(int j=0; j<row2.length; j++)
 			{
 				if( row1[i] == row2[j])
 				{
 					if( ++num_intersections > 1 )
 					{
 						break outer;
 					}		
 					else
 						value_intersection = row1[i];
 				}
 			}
 		}
 		
 		if( num_intersections == 0)
 			result = ""Volunteer cheated!"";
 		else if( num_intersections==1 )
 			result = Integer.toString(value_intersection);
 		else
 			result = ""Bad magician!"";
 			
 		return( result );
 	}
 }
 
",0
313,3339,"import java.util.*;
 import java.io.*;
 
 class Node implements Comparable<Node>
 {
     int k;
     int dis;
 
     Node(int kk, int d)
     {
         k=kk;
         dis=d;
     }
 
     public int compareTo(Node b)
     {
         return dis<b.dis?-1:1;
     }
 }
 
 
 class DSolver
 {
     static String exampleInput=""D-example.txt"";
     
     int length;
     
     int[][] mem=new int[500][500];
     int[][] numshared=new int[500][500];
 
     int go(int cur, int prev)
     {
         if(cur==1)
             return 0;
         if(mem[cur][prev]!=-123456789)
             return mem[cur][prev];
         int res=-1000;
         for(int i=0;i<P;i++)
             if(dist[cur][i]==1&&mindis[cur]-mindis[i]==1)
                 res=Math.max(res,go(i,cur)+numbuur[cur]-numshared[cur][prev]);
         return mem[cur][prev]=res;
     }
 
     int[] mindis=new int[500];
     static int[][] dist=new int[500][500];
     int[] numbuur=new int[500];
     int P,W;
 
     int dijkstra(int from, int to)
     {
         Arrays.fill(mindis,1000000);
         PriorityQueue<Node> pq=new PriorityQueue<Node>();
         pq.offer(new Node(from,0));
         mindis[from]=0;
         while(!pq.isEmpty())
         {
             Node x=pq.poll();
             int k=x.k;
             int dis=x.dis;
             if(mindis[k]<dis)
                 continue;
             for(int i=0;i<P;i++)
             {
                 int ndis=dis+dist[k][i];
                 if(ndis<mindis[i])
                     pq.offer(new Node(i,mindis[i]=ndis));
             }
         }
         return mindis[to];
     }
 
     String solve(Scanner sc) throws IOException
     {
         P=sc.nextInt();
         W=sc.nextInt();
         for(int i=0;i<P;i++)
             Arrays.fill(dist[i],12345678);
         Arrays.fill(numbuur,0);
         for(int i=0;i<W;i++)
         {
             int a=sc.nextInt();
             int b=sc.nextInt();
             dist[a][b]=dist[b][a]=1;
             numbuur[a]++;
             numbuur[b]++;
         }
         length=dijkstra(1,0);
         int numconq=length-1;
         for(int i=0;i<P;i++)
             Arrays.fill(mem[i],-123456789);
         for(int i=0;i<P;i++)
         for(int j=i+1;j<P;j++)if(dist[i][j]==1)
         {
             for(int k=0;k<P;k++)
                 if(dist[i][k]==1&&dist[j][k]==1)
                     numshared[i][j]++;
             numshared[j][i]=numshared[i][j];
         }
         int best=0;
         for(int i=0;i<P;i++)
             if(dist[0][i]==1&&mindis[0]-mindis[i]==1)
                 best=Math.max(best,go(i,0)+numbuur[0]);
 
         String res=numconq+"" ""+(best-2*numconq);
         return """"+res;
     }
 
     public static void main(String[] args) throws IOException
     {
         Scanner sc=new Scanner(new File(args.length>=1?args[0]:exampleInput));
         PrintWriter out=null;
         if(args.length>=2)
             out=new PrintWriter(new File(args[1]));
         int numtests=Integer.parseInt(sc.nextLine().trim());
         for(int testid=1;testid<=numtests;testid++)
         {
             String res=(new DSolver()).solve(sc);
             System.out.println(""Case #""+testid+"": ""+res);
             if(out!=null)
                 out.write(""Case #""+testid+"": ""+res+""\n"");
         }
         sc.close();
         if(out!=null)
             out.close();
     }
 }
 
","// Time Remaining: 59min 14sec Rank: 1003 Score: 21
 // Let's start
 
 // Time Remaining: 14min 14sec Rank: 1672 Score: 21
 // For Small
 import java.util.*;
 import java.io.*;
 
 public class B
 {
     static final int INF=1<<29;
     static int h,n,m;
     static int[][] ceil=new int[104][104];
     static int[][] floor=new int[104][104];
 
     static int[][] mindis=new int[104][104];
     static boolean[][] done=new boolean[104][104];
 
     static int[] dx=new int[]{-1,1,0,0};
     static int[] dy=new int[]{0,0,-1,1};
 
     static void edsger()
     {
         while(true)
         {
             int bx=-1,by=-1;
             for(int i=2;i<n+2;i++)
             for(int j=2;j<m+2;j++)
                 if(!done[i][j]&&(bx==-1||mindis[i][j]<mindis[bx][by]))
                 {
                     bx=i;
                     by=j;
                 }
             if(bx==-1)
                 break;
             done[bx][by]=true;
 
             for(int r=0;r<4;r++)
             {
                 int nx=bx+dx[r];
                 int ny=by+dy[r];
                 if(floor[bx][by]+50>ceil[nx][ny]||floor[nx][ny]+50>ceil[nx][ny])
                     continue;
                 if(floor[nx][ny]+50>ceil[bx][by])
                     continue;
                 int curtime=Math.max(mindis[bx][by],h-(ceil[nx][ny]-50));
                 int curh=h-curtime;
                 int bij=100;
                 if(curh-floor[bx][by]>=20)
                     bij=10;
                 if(curtime==0)
                     bij=0;
                 mindis[nx][ny]=Math.min(mindis[nx][ny],curtime+bij);
             }
         }
     }
 
     public static void main(String[] args) throws IOException
     {
         Scanner sc=new Scanner(System.in);
         int t=sc.nextInt();
         for(int cas=1;cas<=t;cas++)
         {
             h=sc.nextInt();
             n=sc.nextInt();
             m=sc.nextInt();
             for(int i=0;i<n;i++)
                 for(int j=0;j<m;j++)
                     ceil[i+2][j+2]=sc.nextInt();
             for(int i=0;i<n;i++)
                 for(int j=0;j<m;j++)
                     floor[i+2][j+2]=sc.nextInt();
             for(int i=0;i<mindis.length;i++)
                 Arrays.fill(mindis[i],INF);
             mindis[2][2]=0;
             for(int i=0;i<mindis.length;i++)
                 Arrays.fill(done[i],false);
             edsger();
             double res=mindis[n+1][m+1]/10.0;
             System.out.println(""Case #""+cas+"": ""+res);
         }
     }
 }",1
314,20009,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 
 
 public class FairandSquare {
 	public static void main (String [] args) throws IOException{
 		FileReader r= new FileReader(""/Users/Nikhil/Desktop/Programs/Java Programs/FairandSqaure/src/C-large-1.in"");	
 		BufferedReader reader = new BufferedReader(r);
 
 		String line; 
 		int total; 
 		int count=0; 
 		int  lastmin; 
 		int lastmax;
 	long min=0; 
 		long max=1; 
 		line=reader.readLine(); 
 		total=Integer.valueOf(line);
 		ArrayList<Long> numbers=findAll();
 		for(int q=1; q<=total; q++){	
 			count=0; 
 			line = reader.readLine();
 			String[] firstnumbers=(line.split(""\\s+""));
 			for(int i=0; i<firstnumbers.length;i++){
 				if(i%2==0){
 					min=(Long.valueOf(firstnumbers[i]));
 				}
 				else {
 					max=(Long.valueOf(firstnumbers[i]));
 				}
 
 			}
 			for(int l=0; l<numbers.size(); l++){
 				long entry= numbers.get(l);
 				if(min<=entry&& max>=entry){
 					count++;
 				}
 				if(max<entry){
 					break;
 				}
 			}
 			System.out.println(""Case #"" +q +"": "" +count );
 		}
 
 	}
 	private static ArrayList<Long> findAll(){
 		ArrayList <Long> foundAll= new ArrayList <Long> ();
 		long end= 10000000;
 		long max= end*end;
 		for(long d=1; d<=end; d++){
 			long sq= d*d;
 			if(isPalindrome(d) && isPalindrome(sq) && 1 <= sq &&  max>=sq){
 				foundAll.add(sq);
 			}
 		}
 		return foundAll;
 	}
 	
 	private static boolean isPalindrome(long d) {
 		String original="""" +d; 
 		String reverse= (new StringBuffer(original)).reverse().toString();
 		return(original.equals(reverse)); 
 	}
 
 }
","package codejam;
 
 import java.io.RandomAccessFile;
 import java.util.StringTokenizer;
 
 public class PartElf {
 	long P,Q;
 	
 	public PartElf(RandomAccessFile rafin) throws Exception{
 		String inputline;
 		StringTokenizer st;
 		
 		inputline = rafin.readLine();
 		st = new StringTokenizer(inputline,""/"");
 		P = Long.parseLong(st.nextToken());
 		Q = Long.parseLong(st.nextToken());
 	}
 	
 	public PartElf() {
 		// TODO Auto-generated constructor stub
 	}
 	
 	public long biggestYue(long l1, long l2) {
 		//System.out.println(l1 + "", "" + l2);
 		long ans=1;
 		long lmin = Math.min(l1, l2);
 		long lmax = Math.max(l1, l2);
 		
 		boolean found;
 		while (lmin>1) {
 			found = false;
 			long lroot = 1L + (long)Math.sqrt(lmax);
 			for (long i=2; i<=Math.min(lmin,lroot); i++) {
 				//System.out.println(""i="" + i + "", lmin="" + lmin + "", lmax="" + lmax);
 				if (lmin%i==0 && lmax%i==0) {
 					found = true;
 					ans = ans*i;
 					lmin = lmin/i;
 					lmax = lmax/i;
 					break;
 				}
 			}
 			if (found==false)
 				break;
 		}
 		return ans;
 	}
 
 	public String getStatus() throws Exception{
 		long y = biggestYue(P,Q);
 		System.out.println(""yue="" + y);
 		if (y>1) {
 			P = P/y;
 			Q = Q/y;
 		}
 		long mask;
 		int a1 = -1;
 		int a2 = -1;
 		for (int i=0; i<=40; i++) {
 			mask = 1L<<i;
 			if (mask==Q) {
 				a1 = 40-i;
 				break;
 			}
 		}
 		System.out.println(""a1="" + a1);
 		if (a1 <0)
 			return ""impossible"";
 		
 		for (int i=40; i>=0; i--) {
 			mask = 1L<<i;
 			if ((P & mask)!=0) {
 				a2 = i;
 				break;
 			}
 		}
 		System.out.println(""a2="" + a2);
 		int ans = 40 - (a1+a2);
 		return """" + ans;
 	}
 	
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		try {
 
 			/*
 			long oldtime = System.currentTimeMillis();
 			readDictionary(""d:/codejam/data/dict.txt"");
 			System.out.println(maxLen);
 			long newtime = System.currentTimeMillis();
 			System.out.println((newtime-oldtime)/1000 + "" seconds."");
 			if (true) return;
 			*/
 			
 			String file_prefix = ""A-small-attempt0"";
 			//String file_prefix = ""A-large"";
 
 			String path=""d:/codejam/data/"";
 			String infilename = path + file_prefix+"".in"";
 			String outfilename = path + file_prefix+"".out"";
 			RandomAccessFile rafin = new RandomAccessFile(infilename, ""r"");
 			RandomAccessFile rafout = new RandomAccessFile(outfilename, ""rw"");
 			rafout.setLength(0);
 			
 			int count = Integer.parseInt(rafin.readLine().trim());
 			PartElf o;
 			System.out.println(count + "" cases."");
 			for (int i=1; i<=count; i++) {
 				o = new PartElf(rafin);
 				rafout.writeBytes(""Case #"" + i + "": "" + o.getStatus());
 				if (i<count)
 					rafout.writeBytes(""\r\n"");
 				System.out.println(""Case "" + i + "" dealed!\r\n"");
 				System.gc();
 			}
 			
 			rafin.close();
 			rafout.close();
 		} catch (Exception e) {
 			e.printStackTrace(System.out);
 		}
 
 	}
 
 }
",0
315,20146,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.math.BigInteger;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Scanner;
 
 
 public class MakingChessBoards {
 
 
 	public static boolean[][] makeChessBoard(int m, int n, BigInteger[] rows) {
 		boolean[][] board = new boolean[m][n];
 		for(int i=0;i<m;i++) {
 			for(int j=0;j<n;j++) {
 				board[i][j] = rows[i].testBit(n-j-1);
 			}
 		}
 		return board;
 	}
 	
 	public static void printBoard(boolean[][] board) {
 //		for(boolean[] row: board) {
 //			for(boolean col: row) {
 //				System.out.print(col?""*"":""."");
 //			}
 //			System.out.println();
 //		}
 	}
 	
 	
 	public static boolean isBoard(boolean[][] board, boolean[][] used, int row, int col, int size) {
 		boolean f = !board[row][col];
 		for(int y = row;y<row+size;y++) {
 			if(f==board[y][col]) return false;
 			f=!f;
 			boolean b = !board[y][col];
 			for(int x = col;x<col+size;x++) {
 				if(used[y][x]) return false;
 				if(b==board[y][x]) return false;
 				b=!b;
 			}
 		}
 		return true;
 	}
 	
 	
 	public static int[] solveBoard(boolean[][] board) {
 		int m = board.length;
 		int n = board[0].length;
 		boolean[][] used = new boolean[m][n];
 		
 		int sizes[] = new int[m+1];
 		
 	
 		boolean go = true;
 		while(go) {
 			int[] res = findNext(board,used,m,n);
 			int mx = res[0], my = res[1], size = res[2];
 			if(size==0) break;
 			sizes[size]++;
 			for(int x=mx;x<mx+size;x++)
 				for(int y=my;y<my+size;y++)
 					used[y][x] = true;
 			printBoard(used);
 		}
 		return sizes;
 	}
 	
 	public static int[] findNext(boolean[][] board, boolean[][] used, int m, int n) {
 		int biggestBoard = 0;
 		int mx = 0, my = 0;
 		for(int cx=0;cx<n;cx++) {
 			for(int cy=0;cy<m;cy++) {
 				if(used[cy][cx]) continue;
 				for(int s=biggestBoard;s<=Math.min(m-cy,n-cx);s++) {
 					if(isBoard(board,used,cy,cx,s)) {
 						if(s>biggestBoard) {
 							biggestBoard = s;
 							mx = cx;
 							my = cy;
 						}
 					} else break;
 				}
 			}
 		}
 		return new int[]{mx,my,biggestBoard};
 	}
 	
 	
 	public static void main(String[] args) throws Exception {
 		BufferedReader br = new BufferedReader(new FileReader(""a.in""));
 		BufferedWriter out = new BufferedWriter(new FileWriter(""a.out""));
 		Scanner s = new Scanner(br);
 		int caseCount = s.nextInt();
 		for(int i=0;i<caseCount;i++) {
 			int m = s.nextInt();
 			int n = s.nextInt();
 			BigInteger[] rows = new BigInteger[m];
 			for(int j=0;j<m;j++) {
 				BigInteger row = s.nextBigInteger(16);
 				rows[j] = row;
 			}
 			boolean[][] board = makeChessBoard(m,n,rows);
 			printBoard(board);
 			int[] sizes = solveBoard(board);
 			int f = 0;
 			for(int j = m;j>=0;j--) {
 				if(sizes[j]>0) f++;
 			}
 			out.write(""Case #""+(i+1)+"": ""+f+""\n"");
 			for(int j = m;j>=0;j--) {
 				if(sizes[j]>0) out.write(j+"" ""+sizes[j]+""\n"");
 			}
 		}
 		out.flush();
 		out.close();
 	}
 
 }
","package round1C.c;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 
 public class C {
 	static String inFile = ""src/round1C/c/C-small-attempt0.in"";
 	static String outFile = ""src/round1C/c/C.out"";
 	static int selectedTest = -1;
 
 
 	static String solve(Prerequisite p) throws Exception {
 
 		
 		Arrays.sort(p.tribes, new Comparator<Tribe>(){
 			@Override
 			public int compare(Tribe t1, Tribe t2) {
 				return t1.d - t2.d;
 			}
 		});
 		
 //		for(Tribe t : p.tribes)
 //			System.err.println(t);
 		
 //		System.err.println(p.maxDays);
 		
 		int[] wall = new int[501];
 		
 		//day to tribes;
 		Map<Integer, List<Attack>> attacks = new TreeMap<>();
 		
 		for(Tribe t : p.tribes)
 			for(int i = 0; i < t.n; i++){
 				int dayOfAttack = t.d + i * t.delta_d;
 				List<Attack> list;
 				if(!attacks.containsKey(dayOfAttack)){
 					attacks.put(dayOfAttack, list = new LinkedList<>());
 				} else
 					list = attacks.get(dayOfAttack);
 				list.add(new Attack(t, i));
 			}
 		
 //		System.err.println(attacks);
 				
 		for(Entry<Integer,List<Attack>> e : attacks.entrySet())
 			System.err.println(e.getValue());
 		int numAttacks = 0;
 		for(Entry<Integer,List<Attack>> e : attacks.entrySet()){
 			List<Attack> aN = e.getValue();
 			att: for(Attack a : aN){
 				Tribe t = a.t;
 				int[] aoa = t.attackAtDay(a.i);
 				for(int i = aoa[0] + 250 - 1; i < aoa[1] + 250 - 1; i++)
 					if(aoa[2] > wall[i]){
 						numAttacks++;
 						continue att;
 					}
 			}
 			
 			att: for(Attack a : aN){
 				Tribe t = a.t;
 				int[] aoa = t.attackAtDay(a.i);
 				for(int i = aoa[0] + 250 - 1; i < aoa[1] + 250 - 1; i++)
 					if(aoa[2] > wall[i]){
 						wall[i] = aoa[2];
 					}
 			}
 		}
 		
 		
 		
 		return String.valueOf(numAttacks);
 	}
 	
 	static class Attack {
 		Tribe t;
 		int i;
 		public Attack(Tribe t, int i){
 			this.t = t;
 			this.i = i;
 		}
 		
 		@Override
 		public String toString() {
 			return String.format(""(%s, %s)"", t, i);
 		}
 	}
 
 	static class Prerequisite {
 		Tribe[] tribes;
 		int maxDays;
 
 		public Prerequisite() throws IOException {
 			int length = Reader.nextInt();
 			tribes = new Tribe[length];
 			for(int i = 0; i < tribes.length; i++){
 				tribes[i] = new Tribe();
 				if(tribes[i].lastDay > maxDays)
 					maxDays = tribes[i].lastDay;
 			}
 		}
 	}
 	
 	static class Tribe {
 		int d, n, w, e, s, delta_d, delta_p, delta_s;
 		
 		int lastDay;
 		
 		public int[] attackAtDay(int i){
 			return new int[]{w + i * delta_p, e + i * delta_p, s + i * delta_s};
 		}
 
 		public Tribe() throws IOException {
 			//day of first attack
 			d = Reader.nextInt();
 			//number of attacks
 			n = Reader.nextInt();
 			
 			w = Reader.nextInt();
 			e = Reader.nextInt();
 			//strength
 			s = Reader.nextInt();
 			delta_d = Reader.nextInt();
 			delta_p = Reader.nextInt();
 			delta_s = Reader.nextInt();
 			
 			lastDay = d + (n-1) * delta_d;
 			
 			
 		}
 
 		@Override
 		public String toString() {
 			return String.format(""(%s %s %s %s %s %s %s %s"", d, n, w, e, s,
 					delta_d, delta_p, delta_s);
 		}
 	}
 
 	public static void init() {
 		try (Reader reader = new Reader(new FileInputStream(inFile));
 				PrintWriter out = new PrintWriter(new FileWriter(outFile));) {			String result;
 			long time, overallTime;
 
 			int tN = Reader.nextInt();
 			overallTime = System.currentTimeMillis();
 			for (int ti = 1; ti <= tN; ti++) {
 				Prerequisite p = new Prerequisite();
 
 				if (selectedTest > 0)
 					if (ti != selectedTest)
 						continue;
 
 				time = System.currentTimeMillis();
 				result = solve(p);
 				out.printf(""Case #%d: %s"", ti, result);
 
 				if (ti != tN)
 					out.println();
 
 				System.err.printf(""Case %-5s "", String.format(""#%d:"", ti));
 				System.err.printf(""%-8s"", result);
 				System.err.printf(""%6sms\n"", String.format("".. %.0f"",
 								(double) (System.currentTimeMillis() - time)));
 			}
 
 			System.err.printf(""%.4fs\n"",
 					(double) (System.currentTimeMillis() - overallTime) / 1000);
 			
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	static class Reader implements AutoCloseable {
 		static BufferedReader in;
 		static StringTokenizer tok;
 
 		public Reader(InputStream input) {
 			in = new BufferedReader(new InputStreamReader(input));
 			tok = new StringTokenizer("""");
 		}
 
 		@Override
 		public void close() throws IOException {
 			in.close();
 		}
 
 		static String next() throws IOException {
 			while (!tok.hasMoreTokens())
 				tok = new StringTokenizer(in.readLine());
 			return tok.nextToken();
 		}
 
 		static int nextInt() throws IOException {
 			return Integer.parseInt(next());
 		}
 
 		static long nextLong() throws IOException {
 			return Long.parseLong(next());
 		}
 
 		static double nextDouble() throws IOException {
 			return Double.parseDouble(next());
 		}
 	}
 
 	public static void main(String[] args) {
 		init();
 	}
 }
",0
316,16678,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 
 public class MainA {
 
 	final static String FNAME = ""A-small-attempt1"";
 
 	public BufferedReader in;
 
 	public PrintWriter out;
 
 	void open() throws IOException {
 		in = new BufferedReader(new FileReader(new File(FNAME + "".in"")));
 		out = new PrintWriter(new File(FNAME + "".out""));
 	}
 
 	void close() throws IOException {
 		out.close();
 	}
 
 	Integer count(String line, ArrayList<String> dic) {
 		int count = 0;
 		String temp = line.replace(""("", """");
 		String pices[] = temp.split(""\\)"");
 
 		System.out.println(pices.length);
 		for (String word : dic) {
 			Boolean flag = true;
 			
 			if (pices.length == 1) {
 				if (pices[0].equals(word))
 				{
 					count++;
 				}
 					 
 			} else {
 			
 				for (int i = 0; i < word.length() && flag == true; i++) {
 					String c = word.substring(i, i + 1);
 
 					if (!pices[i].contains(c)) {
 						flag = false;
 					}
 				}
 				if (flag == true) {
 					count++;
 				}
 			}
 		}
 
 		return count;
 	}
 	
 	boolean isRowWin(char[] arr,char player)
 	{
 		for(int i=0;i<4;i++)
 		{
 			if(arr[i]!=player&&arr[i]!='T') return false;
 		}
 		return true;
 	}
 	
 	char[] getCol(char[][] board,int i)
 	{
 		char[] res=new char[4];
 		for(int j=0;j<4;j++)
 		{
 			res[j]=board[j][i];
 		}
 		
 		return res;
 	}
 	
 	char[] getDia1(char[][] board)
 	{
 		char[] res=new char[4];
 		for(int j=0;j<4;j++)
 		{
 			res[j]=board[j][j];
 		}
 		
 		return res;
 	}
 	
 	char[] getDia2(char[][] board)
 	{
 		char[] res=new char[4];
 		
 		for(int j=0;j<4;j++)
 		{
 			res[j]=board[j][3-j];
 		}
 		
 		return res;
 	}
 	
 	boolean isWin(char[][] board,char player)
 	{
 		boolean res=false;
 		for(int i=0;i<4;i++)
 		{
 			res=res||isRowWin(board[i],player);
 		}
 		
 		
 		for(int i=0;i<4;i++)
 		{
 			res=res||isRowWin(getCol(board, i),player);
 		}
 		
 		res=res||isRowWin(getDia1(board),player)||isRowWin(getDia2(board),player);
 		
 		return res;
 	}
 	
 	boolean isEnded(char[][] board)
 	{
 		char sign;
 		for(int i=0;i<4;i++)
 		{
 			for(int j=0;j<4;j++)
 			{
 				sign =board[i][j];
 				if(sign!='X'&&sign!='O'&&sign!='T') return false;
 			}
 		}
 		return true;
 	}
 	
 	char[][] readBoard() throws IOException
 	{
 		char[][] board=new char[4][4];
 		for(int i=0;i<4;i++)
 		{
 			String line=in.readLine();
 			for(int j=0;j<4;j++)
 			{
 				board[i][j]=line.charAt(j);
 			}
 		}
 		in.readLine();
 			return board;
 	}
 
 	void run() throws IOException {
 		
 		Integer T=Integer.parseInt(in.readLine()) ;
 		
 		
 		for (int i = 1; i <= T; i++) {
 			StringBuffer res = new StringBuffer();
 			res.append(""Case #"" + i + "": "");
 			char[][] board=readBoard();
 						
 			if (isWin(board,'X'))
 			{
 				res.append(""X won"");
 			}
 			else if (isWin(board,'O'))
 			{
 				res.append(""O won"");
 			}
 			else if(isEnded(board))
 			{
 				res.append(""Draw"");
 			}
 			else
 			{
 				res.append(""Game has not completed"");
 			}
 			out.println(res.toString());
 		}
 	}
 
 	public static void main(String[] args) throws IOException {
 		new Thread() {
 
 			public void run() {
 				try {
 					MainA solution = new MainA();
 					solution.open();
 					solution.run();
 					solution.close();
 				} catch (Exception e) {
 					throw new RuntimeException(e);
 				}
 			}
 		}.start();
 	}
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
 
 public class MainA {
 
 	final static String FNAME = ""A-small-attempt0"";
 
 	public BufferedReader in;
 
 	public PrintWriter out;
 
 	void open() throws IOException {
 		in = new BufferedReader( new FileReader( new File( FNAME+"".in""  ) ) );
 		out = new PrintWriter( new File( FNAME + "".out"" ) );
 	}
 
 	void close() throws IOException {
 		out.close();
 	}
 
 	void run() throws IOException {
 
 		HashMap<Character,Character>map=new HashMap<Character, Character>();
 		map.put('a', 'y');
 		map.put('b', 'h');
 		map.put('c', 'e');
 		map.put('d', 's');
 		map.put('e', 'o');
 		map.put('f', 'c');
 		map.put('g', 'v');
 		map.put('h', 'x');
 		map.put('i', 'd');
 		map.put('j', 'u');
 		map.put('k', 'i');
 		map.put('l', 'g');
 		map.put('m', 'l');
 		map.put('n', 'b');
 		map.put('o', 'k');
 		map.put('p', 'r');
 		map.put('q', 'z');//------
 		map.put('r', 't');
 		map.put('s', 'n');
 		map.put('t', 'w');
 		map.put('u', 'j');
 		map.put('v', 'p');
 		map.put('w', 'f');
 		map.put('x', 'm');
 		map.put('y', 'a');
 		map.put('z', 'q');
 		map.put(' ', ' ');
 		
 		
 	
 		
 		Integer N=Integer.parseInt(in.readLine());
 
 		
 		for(int i=1;i<=N;i++)
 		{
 			StringBuffer res=new StringBuffer();
 			res.append(""Case #"" + i + "": "");
 			String line=in.readLine();
 		    char[] arr=line.toCharArray();
 			for(int j=0;j<arr.length;j++)
 			{	
 				res.append(map.get(arr[j]));
 			}
 			out.println(res.toString());
 		}
 	}
 
 	public static void main( String[] args ) throws IOException {
 		new Thread() {
 
 			public void run() {
 				try {
 					MainA solution = new MainA();
 					solution.open();
 					solution.run();
 					solution.close();
 				} catch ( Exception e ) {
 					throw new RuntimeException( e );
 				}
 			}
 		}.start();
 	}
 }
",1
317,2763,"import java.util.Scanner;
 
 public class CodeJam2013_TicTacToe {
 	final static int X = 'X';
 	final static int O = 'O';
 	final static int DRAW = 3;
 	final static int GAME = 4;
 
 	static boolean end;
 
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int counter=1;
 		int cases = Integer.parseInt(scan.nextLine());
 		char[][] array = new char[4][4];
 
 		while (cases-- > 0) {
 			int iT = -1, jT = -1;
 			for (int i = 0; i < array.length; i++) {
 				String s = scan.nextLine();
 				for (int j = 0; j < array.length; j++) {
 					array[i][j] = s.charAt(j);
 					if (s.charAt(j) == 'T') {
 						iT = i;
 						jT = j;
 					}
 				}
 			}
 
 			if (iT != -1 && jT != -1)
 				array[iT][jT] = 'X';
 			int res1 = winner(array);
 			if (iT != -1 && jT != -1)
 				array[iT][jT] = 'O';
 			int res2 = winner(array);
 			
 			System.out.print(""Case #"" + counter+++"": "");
 
 			if (res1 == X) {
 				System.out.println(""X won"");
 			} else if (res1 == O) {
 				System.out.println(""O won"");
 			} else if (res2 == X) {
 				System.out.println(""X won"");
 			} else if (res2 == O) {
 				System.out.println(""O won"");
 			} else if (res1 == DRAW || res2 == DRAW) {
 				System.out.println(""Draw"");
 			} else {
 				System.out.println(""Game has not completed"");
 			}
 			scan.nextLine();
 		}
 	}
 
 	public static char winner(char[][] array) {
 		for (int i = 0; i < array.length; i++) {
 			int count = 0;
 			for (int j = 0; j < array.length - 1; j++) {
 				if (array[i][j] == array[i][j + 1] && array[i][j] != '.') {
 					count++;
 				}
 			}
 			if (count == 3) {
 				return array[i][0];
 			}
 		}
 
 		for (int i = 0; i < array.length; i++) {
 			int count = 0;
 			for (int j = 0; j < array.length - 1; j++) {
 				if (array[j][i] == array[j + 1][i] && array[j][i] != '.') {
 					count++;
 				}
 			}
 			if (count == 3) {
 				return array[0][i];
 			}
 		}
 		if (array[0][0] == array[1][1] && array[1][1] == array[2][2]
 				&& array[2][2] == array[3][3] && array[0][0] != '.') {
 			return array[0][0];
 		}
 
 		if (array[0][3] == array[1][2] && array[1][2] == array[2][1]
 				&& array[2][1] == array[3][0] && array[0][3] != '.') {
 			return array[0][3];
 		}
 		for (int i = 0; i < array.length; i++) {
 			for (int j = 0; j < array.length; j++) {
 				if (array[i][j] == '.')
 					return GAME;
 			}
 		}
 		return DRAW;
 	}
 }","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class AMagicTrick {
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scan = new Scanner(new File(""a.in""));
 		PrintWriter output = new PrintWriter(""a.out"");
 		int cases = scan.nextInt();
 		for (int k = 0; k < cases; k++) {
 			int answer1 = scan.nextInt();
 			int[][] first = new int[4][4];
 			for (int i = 0; i < first.length; i++) {
 				for (int j = 0; j < first[i].length; j++) {
 					first[i][j] = scan.nextInt();
 				}
 			}
 			int answer2 = scan.nextInt();
 			int[][] second = new int[4][4];
 			for (int i = 0; i < second.length; i++) {
 				for (int j = 0; j < second[i].length; j++) {
 					second[i][j] = scan.nextInt();
 				}
 			}
 			int intersection = 0;
 			int index = -1;
 			for (int i = 0; i < first[answer1 - 1].length; i++) {
 				for (int j = 0; j < second[answer2 - 1].length; j++) {
 					if (first[answer1 - 1][i] == second[answer2 - 1][j]) {
 						intersection++;
 						index = i;
 					}
 				}
 			}
 			output.print(""Case #"" + (k + 1) + "": "");
 			if (intersection == 0) {
 				output.print(""Volunteer cheated!"");
 			} else if (intersection == 1) {
 				output.print(first[answer1 - 1][index]);
 			} else {
 				output.print(""Bad magician!"");
 			}
 			output.print(""\n"");
 		}
 		output.close();
 	}
 }
",1
318,15079,"package gcj.qual;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main {
 
 	static int[] pow = {1, 10, 100, 1000, 10000, 100000};
 
 	public static void main(String[] args) throws FileNotFoundException {
 		// 問題の読み込み
 		Scanner sc = new Scanner(new File(""src/gcj/qual/A-small-attempt1.in""));
 
 		int T = sc.nextInt();
 
 		int[] a1 = new int[4];
 		int[] a2 = new int[4];
 
 		int row;
 		int[][] card;
 
 		for (int i=0; i<T; i++) {
 			row = sc.nextInt();
 
 			card = new int[4][4];
 
 			for (int j=0; j<4; j++) {
 				for (int k=0; k<4; k++) {
 					card[j][k] = sc.nextInt();
 				}
 			}
 			a1 = card[row-1];
 
 			card = new int[4][4];
 
 			row = sc.nextInt();
 			for (int j=0; j<4; j++) {
 				for (int k=0; k<4; k++) {
 					card[j][k] = sc.nextInt();
 				}
 			}
 			a2 = card[row-1];
 
 			solve(i+1, a1, a2);
 		}
 	}
 
 	static void solve(int t, int[] a1, int[] a2) {
 		List<Integer> ans = new ArrayList<Integer>();
 
 		for (int i=0; i<4; i++) {
 			for (int j=0; j<4; j++) {
 				if(a1[i] == a2[j]) {
 					ans.add(a1[i]);
 				}
 			}
 		}
 
 		if (ans.size() == 0) {
 			output(t, ""Volunteer cheated!"");
 		} else if (ans.size() == 1) {
 			output(t, ans.get(0).toString());
 		} else {
 			output(t, ""Bad magician!"");
 		}
 	}
 
 	static void output(int i, String str) {
 		System.out.println(""Case #"" + i + "": "" + str);
 	}
 }","import java.util.HashSet;
 import java.util.Scanner;
 
 
 public class Pogo {
 		int[][] t= new int[250][250];
 		int N=1;
 		int S=2;
 		int E=3;
 		int W=4;
 		public int ind(int i){
 			
 			return i-210;
 		}
 		class Point{
 			@Override
 			public boolean equals(Object obj) {
 				Point p = (Point)obj;
 				return p.x==x&&p.y==y;
 			}
 			@Override
 			public int hashCode() {
 				return x*1000+y;
 			}
 
 			int x;
 			int y;
 			public Point(int x, int y, int step,String s) {
 				super();
 				this.x = x;
 				this.y = y;
 				this.s=s;
 				this.step = step;
 			}
 			
 			String s;
 			int step=0;
 		}
 		public String res(int a, int b){
 			Point p = new Point(0,0,0,"""");
 			HashSet<Point> l = new HashSet<Point>();
 			HashSet<Point> l2= new HashSet<Point>();
 			HashSet<Point> help;
 			l.add(p);
 			while(true){
 				for(Point q : l){
 					p=q;
 					if(p.x==a&&p.y==b)
 						return p.s;
 					int jmp=p.step+1;
 					//System.out.println(p.x+"" ""+p.y);
 					l2.add(new Point(p.x+jmp, p.y, jmp, p.s+""E""));
 					l2.add(new Point(p.x-jmp, p.y, jmp, p.s+""W""));
 					l2.add(new Point(p.x, p.y+jmp, jmp, p.s+""N""));
 					l2.add(new Point(p.x, p.y-jmp, jmp, p.s+""S""));
 				}
 				l.clear();
 				help=l;
 				l=l2;
 				l2=help;
 			}
 			
 		}
 		
 		public static void main(String[] args) {
 			
 			Pogo p = new Pogo();
 			//System.out.println(p.res(100,100));
 			//System.out.println(p.res(-3, 4));
 			Scanner scanner = new Scanner(System.in);
 			int t = scanner.nextInt();
 			scanner.nextLine();
 
 			for(int i = 1; i<=t; i++){
 				String[] w = scanner.nextLine().split("" "");
 				int a=Integer.parseInt(w[0]);
 				int b= Integer.parseInt(w[1]);
 				System.out.println(""Case #""+i+"": ""+p.res(a,b));
 
 			}
 		}
 
 	
 
 }
",0
319,12504,"import java.util.*;
 
 public class CodeC{
 	public static void main(String[] args){
 		Scanner sc=new Scanner(System.in);
 		int tcase;
 		int numCandy;
 		int[] candy;
 		int bigValue, smallValue;
 		int realValue;
 		int lowerBound;
 		
 		tcase=sc.nextInt();
 		for(int q=1;q<=tcase;q++){
 			numCandy=sc.nextInt();
 			candy=new int[numCandy];
 			for(int i=0;i<numCandy;i++){
 				candy[i]=sc.nextInt();
 			}
 			Arrays.sort(candy,0,numCandy);
 			
 			lowerBound=1;
 			bigValue=candy[numCandy-1];
 			smallValue=candy[0];
 			realValue=candy[numCandy-1];
 			
 			while(bigValue!=smallValue && lowerBound!=numCandy){
 				bigValue=candy[numCandy-1];
 				smallValue=candy[0];
 				realValue=candy[numCandy-1];
 				for(int i=lowerBound;i<numCandy-1;i++){
 					bigValue=bigValue^candy[i];
 					realValue+=candy[i];
 				}
 				for(int i=1;i<lowerBound;i++){
 					smallValue=smallValue^candy[i];
 				}
 				lowerBound++;
 			}
 			if(smallValue!=bigValue){
 				System.out.println(""Case #""+q+"": NO"");
 			}
 			else{
 				System.out.println(""Case #""+q+"": ""+realValue);
 			}
 		}
 	}
 }","import java.io.BufferedReader;
 
 
 public class ManageYourEnergy {
 	public static void run(BufferedReader br) throws Exception{
 		int testcase = Integer.parseInt(br.readLine());
 		
 		for(int i=0; i<testcase; i++){
 			String ern = br.readLine();
 			long eMax = Long.parseLong(ern.split("" "")[0]);
 			long r = Long.parseLong(ern.split("" "")[1]);
 			int n = Integer.parseInt(ern.split("" "")[2]);
 			long e = eMax;
 			
 			long max = -1;
 			
 			String viStr = br.readLine();
 			String[] viArr = viStr.split("" "");
 			long[] vi = new long[n];
 			for(int j=0;j<n;j++){
 				vi[j] = Long.parseLong(viArr[j]);
 				if(vi[j]>max) max = vi[j];
 			}
 			
 			int score = 0 ;
 			boolean maxUsed = false;
 			
 			for(int j=0;j<n;j++){
 				if(vi[j]!=max){
 					long use = (e>r)?r: e;
 
 					if(e!=eMax && !maxUsed){
 						use -= (((eMax-e)/r)+1); 
 					}
 					
 					if(r>1){
 						long futureSum = 0;
 						int k=j+1;
 						for(;k<j+use+1&&k<n;k++){
 							futureSum += vi[k];
 							//System.out.println(""futureSum(""+k+"") :: ""+futureSum);
 						}
 						
 						if(vi[j]>futureSum && futureSum!=0){
 							use = (k-j); 
 						}
 					}
 					
 					score += (vi[j]*use);
 					e -= use;
 				}
 				else{
 					maxUsed = true;
 					score += (vi[j]*e);
 					e = 0;
 				}
 				
 				e+=r;
 			}
 			
 			
 			System.out.println(""Case #""+(i+1)+"": ""+score);
 		}
 	}
 }
",0
320,16942,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class QualC {
 
 	private final static boolean printOut = true;
 	private final static String inputFile = ""C-small-attempt0.in"";
 	private final static String outputFile = ""output.txt"";
 
 	public static void main(String[] args) {
 		try {
 			BufferedWriter out = new BufferedWriter(new FileWriter(outputFile));
 
 			Scanner in = new Scanner(new File(inputFile));
 			int numCases = in.nextInt();
 
 			for (int caseNum = 1; caseNum <= numCases; caseNum++) {
 				// Parse each line as necessary, then call an appropriate method
 				// passing the needed data
 				int A = in.nextInt();
 				int B = in.nextInt();
 
 				int result = calculateResult(A, B);
 
 				String output = ""Case #"" + caseNum + "": "" + result;
 
 				out.write(output + ""\n"");
 
 				if (printOut) {
 					System.out.println(output);
 				}
 			}
 
 			in.close();
 			out.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	public static int calculateResult(int A, int B) {
 		int count = 0;
 		for (int i=A;i<=B;i++) {
 			if (isFairAndSquare(i)) {
 				count++;
 			}
 		}
 		return count;
 	}
 	
 	public static boolean isPalindrome(int num){
 		String numString = """" +num;
 		for (int i=0;i<(numString.length()/2);i++){
 			if (numString.charAt(i)!=numString.charAt(numString.length()-i-1)){
 				return false;
 			}
 		}
 		return true;
 	}
 	
 	public static boolean isFairAndSquare(int num) {
 		if (isPalindrome(num)) {
 			double sqrDouble = Math.sqrt(num);
 			int sqrInt = (int) sqrDouble;
 			if ((sqrInt*sqrInt)==num) {
 				return isPalindrome(sqrInt);
 			}
 		}
 		
 		return false;
 	}
 
 }","/**
  * @(#)Googlerese.java
  *
  *
  * @author Evan Forbes
  * @version 1.00 2012/4/13
  */
 
 import java.util.Scanner;
 import java.io.FileReader;
 import java.io.IOException;
 public class Recycle {
 
 	static int caseNum=0;
 	static int numCases;
 
     public static void main(String[] args)
     {
     	try{
 	    	Scanner in=new Scanner(new FileReader(""C-small-attempt3.in""));
 	    	//Scanner in=new Scanner(new FileReader(""sample_recycled.txt""));
 	   		while (in.hasNextLine()) //go through all lines of file
 			{
 				String current=in.nextLine();
 				String output="""";
 				if (caseNum==0)
 				{
 					numCases=Integer.parseInt(current);
 				}
 				else
 				{
 					output=""Case #""+caseNum+"": "";
 					int mode=0;
 					String As=""""; //number of scores
 					int A=0;
 					String Bs=""""; //num of suprising scores
 					int B=0;
 
 					for (int i=0;i<current.length();i++)
 					{
 						char currentChar=current.charAt(i);
 						switch(mode)
 						{
 							case 0:
 								if (currentChar==' ')
 								{
 									mode++;
 									A=Integer.parseInt(As);
 								}
 								else
 									As=As+currentChar;
 							break;
 							case 1:
 								Bs=Bs+currentChar;
 						}
 					}
 					B=Integer.parseInt(Bs);
 					//System.out.println(""A: ""+A+"" B: ""+B);
 					int count=0;
 					if (A==B) count=0;
 						else
 						{
 							for (int n=A;n<(B-1);n++)
 							{
 
 								for (int m=n+1;m<=B;m++)
 								{
 									//System.out.println(""Testing: ""+n+"", ""+m);
 									if (isRecycled(n,m)) count++;
 								}
 							}
 						}
 
 
 					System.out.println(output+count);
 				}
 				caseNum++;
 			}
     	}
 		catch(IOException ex){
 		}
 		//System.out.println(isRecycled(12345,34512));
     }
 	static boolean isRecycled(int in, int im)
 	{
 		boolean found=false;
 		String n=in+"""";
 		String m=im+"""";
 		for (int i=n.length()-1;i>0;i--)
 		{
 			String cut=n.substring(i);
 			String compare=cut+n.substring(0,i);
 			//System.out.println(""cut: ""+cut+"" compare: ""+compare);
 			if (compare.equals(m)) found=true;
 		}
 		return found;
 	}
 
 }",1
321,12045,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package codejam;
 
 import java.io.BufferedWriter;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 /**
  *
  * @author Chameera Wijebandara
  */
 public class Lawnmower {
     public static void main(String[] args) throws IOException {
         //java.io.BufferedReader in = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
         java.io.BufferedReader in = new java.io.BufferedReader(new java.io.FileReader(""C:\\Users\\Chameera Wijebandara\\Desktop\\input.in""));
         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""C:\\Users\\Chameera Wijebandara\\Desktop\\output.out"")));
         
         int n  =Integer.parseInt(in.readLine());
         StringTokenizer st;
         for (int i = 0; i < n; i++) {
             System.out.print(""Case #""+(i+1)+"": "");
             out.print(""Case #""+(i+1)+"": "");
             st =new StringTokenizer(in.readLine());
             
             int a =Integer.parseInt(st.nextToken());
             int b =Integer.parseInt(st.nextToken());
             
             int data[][]=new int [a][b];
             boolean q=false;
             
             for (int j = 0; j < a; j++) {
                 st =new StringTokenizer(in.readLine());
                 
                 for (int k = 0; k < b; k++) {
                     data[j][k]=Integer.parseInt(st.nextToken());
                 }
             }
             for (int j = 0; j < a; j++) {
                 for (int k = 0; k < b; k++) {
                     boolean p1 =true,p2=true;
                     
                     for (int l = 0; l < b; l++) {
                         if(data[j][l]>data[j][k])
                         {
                            p1=false;
                            break;
                         }
                     }                    
                     for (int l = 0; l < a; l++) {
                         if(data[l][k]>data[j][k])
                         {
                            p2=false;
                            break;
                         }
                     }
                     //System.out.println(p1+"" ""+p2);
                     if(p1==false && p2==false)
                     {
                         System.out.println(""NO"");
                         out.println(""NO"");
                         q=true;
                         break;
                         
                     }
                 }
                 if(q)
                 {
                     break;
                 }
             }
             if(!q)
             {
                 System.out.println(""YES"");
                 out.println(""YES"");
             }
         }
         out.close();
         
     }
     
 }
","package Round1A;
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class B {
     public static String filename = ""B-small-attempt0 (1)"";
     public static Scanner scanner;
     public static PrintWriter writer;
     public static void main(String[] args) throws Exception {
         scanner = new Scanner(new File(filename + "".in""));
         writer = new PrintWriter(filename + "".out"");
         int iterations = scanner.nextInt();
         scanner.nextLine();
         for (int iter = 1; iter <= iterations; iter++) {
             print(""Case #"" + iter + "": "");
             solve();
             flush();
         }
     }
     
     public static void solve() {
         int E = scanner.nextInt();
         int R = scanner.nextInt();
         int N = scanner.nextInt();
         int[] activities = new int[N];
         for (int i = 0; i < N; i++) {
             activities[i] = scanner.nextInt();
         }
         
         int[][] dp  = new int[N][E+1];
         for (int i = 0; i <= E; i++) {
             dp[0][i] = activities[0] * (E-i);
         }
         
         for (int i = 1; i < activities.length; i++) {
             int best = -1;
             for (int j = E; j >= E-R; j--) {
                 best = Math.max(best, dp[i-1][j]);
             }
             dp[i][E] = best;
             for(int j = E-1; j>=0; j--) {
                 dp[i][j] = Math.max(dp[i][j+1] + activities[i], dp[i-1][Math.max(j-R,0)]);
             }
         }
         int best = -1;
         for (int j = 0; j <= E; j++) {
             best = Math.max(best, dp[N-1][j]);
         }
         println(""""+best);
     }
     
     public static void print(String string) {
         System.out.print(string);
         writer.print(string);
     }
     
     public static void println(String string) {
         System.out.println(string);
         writer.println(string);
     }
     
     public static void flush() {
         System.out.flush();
         writer.flush();
     }
 }
",0
322,9016,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package Qual2012;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 /**
  *
  * @author Mostafa
  */
 public class A {
     public static void main(String[] args) throws IOException{
         BufferedReader in = new BufferedReader(new FileReader(""A.in""));
         PrintWriter out = new PrintWriter(new FileWriter(""A.out""));
 //
         char [] ch = new char[26];
         ch[0] = 'y';
         ch[1] = 'h';
         ch[2] = 'e';
         ch[3] = 's';
         ch[4] = 'o';
         ch[5] = 'c';
         ch[6] = 'v';
         ch[7] = 'x';
         ch[8] = 'd';
         ch[9] = 'u';
         ch[10] = 'i';
         ch[11] = 'g';
         ch[12] = 'l';
         ch[13] = 'b';
         ch[14] = 'k';
         ch[15] = 'r';
         ch[16] = 'z';
         ch[17] = 't';
         ch[18] = 'n';
         ch[19] = 'w';
         ch[20] = 'j';
         ch[21] = 'p';
         ch[22] = 'f';
         ch[23] = 'm';
         ch[24] = 'a';
         ch[25] = 'q';
 
         int n = Integer.parseInt(in.readLine());
         StringBuilder ot;
         String s;
         for (int i = 0; i < n; i++) {
             ot = new StringBuilder();
             ot.append(""Case #"").append(i+1).append("": "");
             s = in.readLine();
             for (int j = 0; j < s.length(); j++) {
                 if(s.charAt(j)==' ')ot.append(' ');
                 else
                     ot.append(ch[s.charAt(j)-'a']);
             }
             out.println(ot.toString());
         }
         out.close();
     }
 
 }
","import java.util.List;
 import java.util.ArrayList;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.HashSet;
 import java.io.*;
 
 public class Rec {
 	public static void main(String args[]) throws IOException {
 		//Scanner in = new Scanner(System.in);
 		//int n = in.nextInt();
 		//in.nextLine();
 		
 		BufferedReader br = new BufferedReader(new FileReader(""C-large.in""));
 		PrintWriter pw = new PrintWriter(""output1.in"");
 		
 		String sss = """";
 		sss = br.readLine();
 		
 		int num = Integer.parseInt(sss);
 		
 		List<String> l = new ArrayList<String>();
 		
 		while((sss = br.readLine()) != null)
 			l.add(sss);
 		
 		int count = 0;
 		
 		for (String s : l) {
 			count++;
 			
 			Set<String> set = new HashSet<String>();
 			
 			String val[] = s.split("" "");
 			int rear = Integer.parseInt(val[0]);
 			int max = Integer.parseInt(val[1]);
 			
 			if (String.valueOf(rear).length() == 1) {
 				if (count == 0)
 					pw.print(""Case #"" + count + "": "" + 0);
 					//System.out.print(""Case #"" + count + "": "" + 0);
 				else
 					pw.print(""\n"" + ""Case #"" + count + "": "" + 0);
 					//System.out.print(""\n"" + ""Case #"" + count + "": "" + 0);
 			} else {
 				int len = String.valueOf(rear).length();
 				
 				for (int c = rear; c <= max; c++) {
 					String ss = String.valueOf(c);
 					for (int u = 1; u < len; u++) {
 						String sub = ss.substring(u);
 						int f_s = Integer.parseInt(String.valueOf(sub.charAt(0)));
 						
 						if (f_s > Integer.parseInt(String.valueOf(String.valueOf(max).charAt(0))))
 							continue;
 						if (f_s == 0)
 							continue;
 							
 						sub = sub.concat(ss.substring(0,u));
 						
 						if ((Integer.parseInt(sub) > c) && (Integer.parseInt(sub) <= max))
 							if (c < Integer.parseInt(sub) && c >= rear) {
 								set.add(String.format(""%s %s"", c, sub));
 							}
 					}
 				}
 				
 				if (count == 0)
 					pw.print(""Case #"" + count + "": "" + set.size());
 					//System.out.print(""Case #"" + count + "": "" + set.size());
 				else
 					pw.print(""\n"" + ""Case #"" + count + "": "" + set.size());
 					//System.out.print(""\n"" + ""Case #"" + count + "": "" + set.size());
 				pw.flush();
 			}
 		}
 		
 		pw.close();
 		
 	}
 }",0
323,19959,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
  
 public class War {
  
 	public static void main(String[] args) {
  
 		BufferedReader br = null;
  
 		try {
  
 			String sCurrentLine;
  
 			br = new BufferedReader(new FileReader(""input.txt""));
 
 			int T = Integer.valueOf(br.readLine());
 			
 			for(int t=0;t<T;t++){
 				int N = Integer.valueOf(br.readLine());
 				
 				String arrayA[]= br.readLine().split("" "");
 				String arrayB[]= br.readLine().split("" "");
 				
 				double A[]= new double[N];
 				double B[]= new double[N];
 				
 				for(int j=0;j<N;j++){
 					A[j]=Double.valueOf(arrayA[j]);
 					B[j]=Double.valueOf(arrayB[j]);
 				}
 				
 				sort(A);
 				sort(B);
 			
 				int x=0,y=0;
 				int war_count=0;
 				
 				while(y!=N){				
 					if(A[x]<=B[y]){
 						war_count++;
 						x++;
 						y++;
 						continue;
 					}
 					y++;
 				}
 				
 				x=0;y=0;
 				int dwar_count=0;
 				while(x!=N){
 					if(A[x]>B[y]){
 						dwar_count++;
 						x++;
 						y++;
 						continue;
 					}
 					x++;
 				}
 				
 				System.out.println(""Case #""+(t+1)+"": ""+dwar_count+"" ""+(N-war_count));
 				
 			}
  
 		} catch (IOException e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (br != null)br.close();
 			} catch (IOException ex) {
 				ex.printStackTrace();
 			}
 		}
  
 	}
 	
 	    public static void sort(double[] arr)
 
     {
 
         quickSort(arr, 0, arr.length - 1);
 
     }
 
     /** Quick sort function **/
 
     public static void quickSort(double arr[], int low, int high) 
 
     {
 
         int i = low, j = high;
 
         double temp;
 
         double pivot = arr[(low + high) / 2];
 
  
 
         /** partition **/
 
         while (i <= j) 
 
         {
 
             while (arr[i] < pivot)
 
                 i++;
 
             while (arr[j] > pivot)
 
                 j--;
 
             if (i <= j) 
 
             {
 
                 /** swap **/
 
                 temp = arr[i];
 
                 arr[i] = arr[j];
 
                 arr[j] = temp;
 
  
 
                 i++;
 
                 j--;
 
             }
 
         }
 
  
 
         /** recursively sort lower half **/
 
         if (low < j)
 
             quickSort(arr, low, j);
 
         /** recursively sort upper half **/
 
         if (i < high)
 
             quickSort(arr, i, high);
 
     }
 }","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.HashMap;
 import java.util.Map;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
  
 public class Repeat {
  
 	public static void main(String[] args) {
  
 		BufferedReader br = null;
 		BufferedWriter bw = null;
 
 		try {
  
 			String sCurrentLine;
 				
 			File file = new File(""out.txt"");
 			FileWriter fw = new FileWriter(file.getAbsoluteFile());
 			bw = new BufferedWriter(fw);
  
 			br = new BufferedReader(new FileReader(""input.txt""));
  
 			int T = Integer.valueOf(br.readLine());
 			
 			for(int t=1;t<=T;t++){
 				String line[] = br.readLine().split("" "");
 				int A = Integer.valueOf(line[0]);
 				int B = Integer.valueOf(line[1]);
 				int K = Integer.valueOf(line[2]);
 				
 				int min = Math.min(A,B);
 				
 				if(min<=K){
 					bw.write(""Case #""+t+"": ""+A*B+""\n"");
 				}
 				else{
 					int count=0;
 					for(int i=K;i<A;i++){
 						for(int j=K;j<B;j++){
 							if((i&j)<K)
 								count++;
 						}
 					}
 					count+=A*K+K*B-K*K;
 					bw.write(""Case #""+t+"": ""+count+""\n"");
 				}
 			}
 		
 		} catch (Exception e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (br != null)br.close();
 				bw.close();
 			} catch (Exception ex) {
 				ex.printStackTrace();
 			}
 		}
 		
 	}
 }",1
324,5864,"package round1b;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class A {
 	private ArrayList<String> dirs;
 	private int count;
 
 	public static void main(String args[]) throws IOException{
 		new A().doIt();
 	}
 
 	public void doIt() throws IOException {
 		Scanner in = new Scanner(new File(""A-small.in""));
 		PrintStream out = new PrintStream(new File(""A-small.out""));
 //		Scanner in = new Scanner(System.in);
 //		PrintStream out = System.out;
 
 		int tc = Integer.parseInt(in.nextLine());
 		int m, n;
 		dirs = new ArrayList<String>();
 		String str;
 		for(int c = 1; c <= tc; c++) {
 			dirs.clear();
 			count = 0;
 
 			str = in.nextLine();
 			n = Integer.parseInt(str.split("" "")[0]);
 			m = Integer.parseInt(str.split("" "")[1]);
 
 			for(int i=0; i<n; i++) {
 				createStructure("""", in.nextLine(), false);
 			}
 
 			for(int i=0; i<m; i++) {
 				createStructure("""", in.nextLine(), true);
 			}
 
 			out.printf(""Case #%d: %d\n"", c, count);
 		}
 	}
 
 	public void createStructure(String prefix, String rest, boolean increment) {
 //		System.out.println(""."" + rest + ""."");
 		if(rest.indexOf(""/"", 1) == -1) {
 			prefix += rest;
 			rest = """";
 		} else {
 			prefix += rest.substring(0, rest.indexOf(""/"", 1));
 			rest = rest.substring(rest.indexOf(""/"", 1));
 		}
 
 //		System.out.println(dirs + ""\t"" + prefix);
 
 		if(dirs.contains(prefix)) {
 			if(!rest.equals(""""))
 				createStructure(prefix, rest, increment);
 			return;
 		}
 		if(increment)
 			count++;
 		dirs.add(prefix);
 		
 		if(rest.equals(""""))
 			return;
 
 		while(!rest.equals("""") && rest.indexOf(""/"", 1) != -1) {
 			if(increment)
 				count++;
 			prefix += rest.substring(0, rest.indexOf(""/"", 1));
 			dirs.add(prefix);
 			rest = rest.substring(rest.indexOf(""/"", 1));
 		}
 		prefix += rest;
 		dirs.add(prefix);
 		if(increment)
 			count++;
 
 //		System.out.println(count);
 	}
 }","package round1b;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class A {
 	private ArrayList<String> dirs;
 	private int count;
 
 	public static void main(String args[]) throws IOException{
 		new A().doIt();
 	}
 
 	public void doIt() throws IOException {
 		Scanner in = new Scanner(new File(""A-large.in""));
 		PrintStream out = new PrintStream(new File(""A-large.out""));
 //		Scanner in = new Scanner(System.in);
 //		PrintStream out = System.out;
 
 		int tc = Integer.parseInt(in.nextLine());
 		int m, n;
 		dirs = new ArrayList<String>();
 		String str;
 		for(int c = 1; c <= tc; c++) {
 			dirs.clear();
 			count = 0;
 
 			str = in.nextLine();
 			n = Integer.parseInt(str.split("" "")[0]);
 			m = Integer.parseInt(str.split("" "")[1]);
 
 			for(int i=0; i<n; i++) {
 				createStructure("""", in.nextLine(), false);
 			}
 
 			for(int i=0; i<m; i++) {
 				createStructure("""", in.nextLine(), true);
 			}
 
 			out.printf(""Case #%d: %d\n"", c, count);
 		}
 	}
 
 	public void createStructure(String prefix, String rest, boolean increment) {
 //		System.out.println(""."" + rest + ""."");
 		if(rest.indexOf(""/"", 1) == -1) {
 			prefix += rest;
 			rest = """";
 		} else {
 			prefix += rest.substring(0, rest.indexOf(""/"", 1));
 			rest = rest.substring(rest.indexOf(""/"", 1));
 		}
 
 //		System.out.println(dirs + ""\t"" + prefix);
 
 		if(dirs.contains(prefix)) {
 			if(!rest.equals(""""))
 				createStructure(prefix, rest, increment);
 			return;
 		}
 		if(increment)
 			count++;
 		dirs.add(prefix);
 		
 		if(rest.equals(""""))
 			return;
 
 		while(!rest.equals("""") && rest.indexOf(""/"", 1) != -1) {
 			if(increment)
 				count++;
 			prefix += rest.substring(0, rest.indexOf(""/"", 1));
 			dirs.add(prefix);
 			rest = rest.substring(rest.indexOf(""/"", 1));
 		}
 		prefix += rest;
 		dirs.add(prefix);
 		if(increment)
 			count++;
 
 //		System.out.println(count);
 	}
 }",1
325,15026,"package round1b;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.Writer;
 import java.util.Scanner;
 
 public class RPI {
 
 	public static int maxS;
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception {
 		String fileName = args.length == 0 ? ""input.in"" : args[0];
 		File inputFile = new File(fileName);
 		File outputFile = new File(inputFile.getAbsolutePath().replace("".in"",
 				"".out""));
 		Scanner scanner = new Scanner(inputFile);
 
 		Writer writer = new FileWriter(outputFile);
 		int numCases = Integer.parseInt(scanner.nextLine());
 
 		for (int t = 1; t <= numCases; t++) {
 			int numTeams = Integer.parseInt(scanner.nextLine());
 
 			char[][] teams = new char[numTeams][numTeams];
 
 			for (int i = 0; i < numTeams; i++) {
 				String line = scanner.nextLine();
 				teams[i] = line.toCharArray();
 			}
 
 			double[] wp = new double[numTeams];
 			int[] numWins = new int[numTeams];
 			int[] numPlayed = new int[numTeams];
 			double[] owp = new double[numTeams];
 			double[] oowp = new double[numTeams];
 
 			double rpi = 0;
 			for (int i = 0; i < numTeams; i++) {
 				int numWin = 0;
 				int total = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (teams[i][j] == '1') {
 						numWin++;
 						total++;
 					} else if (teams[i][j] == '0')
 						total++;
 				}
 				numWins[i] = numWin;
 				numPlayed[i] = total;
 				wp[i] = numWin * 1.0 / total;
 			}
 
 			for (int i = 0; i < numTeams; i++) {
 				double curOwp = 0;
 				int count = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (i == j)
 						continue;
 					if (teams[i][j] == '.')
 						continue;
 
 					int win = 0;
 					if (teams[i][j] == '0')
 						win = numWins[j] - 1;
 					else
 						win = numWins[j];
 
 					curOwp += win * 1.0 / (numPlayed[j] - 1);
 					count++;
 				}
 				owp[i] = curOwp / count;
 			}
 
 			String output = ""Case #"" + t + "":\n"";
 			for (int i = 0; i < numTeams; i++) {
 				double curOowp = 0;
 				int count = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (i == j)
 						continue;
 					if (teams[i][j] == '.')
 						continue;
 					curOowp += owp[j];
 					count++;
 				}
 
 				oowp[i] = curOowp / count;
 				rpi = 0.25 * wp[i] + 0.5 * owp[i] + 0.25 * oowp[i];
 				output += rpi + ""\n"";
 			}
 
 			System.out.print(output);
 			writer.write(output);
 		}
 		writer.close();
 	}
 }","package round1b;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.Writer;
 import java.util.Scanner;
 
 public class RPI {
 
 	public static int maxS;
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception {
 		String fileName = args.length == 0 ? ""input.in"" : args[0];
 		File inputFile = new File(fileName);
 		File outputFile = new File(inputFile.getAbsolutePath().replace("".in"",
 				"".out""));
 		Scanner scanner = new Scanner(inputFile);
 
 		Writer writer = new FileWriter(outputFile);
 		int numCases = Integer.parseInt(scanner.nextLine());
 
 		for (int t = 1; t <= numCases; t++) {
 			int numTeams = Integer.parseInt(scanner.nextLine());
 
 			char[][] teams = new char[numTeams][numTeams];
 
 			for (int i = 0; i < numTeams; i++) {
 				String line = scanner.nextLine();
 				teams[i] = line.toCharArray();
 			}
 
 			double[] wp = new double[numTeams];
 			int[] numWins = new int[numTeams];
 			int[] numPlayed = new int[numTeams];
 			double[] owp = new double[numTeams];
 			double[] oowp = new double[numTeams];
 
 			double rpi = 0;
 			for (int i = 0; i < numTeams; i++) {
 				int numWin = 0;
 				int total = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (teams[i][j] == '1') {
 						numWin++;
 						total++;
 					} else if (teams[i][j] == '0')
 						total++;
 				}
 				numWins[i] = numWin;
 				numPlayed[i] = total;
 				wp[i] = numWin * 1.0 / total;
 			}
 
 			for (int i = 0; i < numTeams; i++) {
 				double curOwp = 0;
 				int count = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (i == j)
 						continue;
 					if (teams[i][j] == '.')
 						continue;
 
 					int win = 0;
 					if (teams[i][j] == '0')
 						win = numWins[j] - 1;
 					else
 						win = numWins[j];
 
 					curOwp += win * 1.0 / (numPlayed[j] - 1);
 					count++;
 				}
 				owp[i] = curOwp / count;
 			}
 
 			String output = ""Case #"" + t + "":\n"";
 			for (int i = 0; i < numTeams; i++) {
 				double curOowp = 0;
 				int count = 0;
 				for (int j = 0; j < numTeams; j++) {
 					if (i == j)
 						continue;
 					if (teams[i][j] == '.')
 						continue;
 					curOowp += owp[j];
 					count++;
 				}
 
 				oowp[i] = curOowp / count;
 				rpi = 0.25 * wp[i] + 0.5 * owp[i] + 0.25 * oowp[i];
 				output += rpi + ""\n"";
 			}
 
 			System.out.print(output);
 			writer.write(output);
 		}
 		writer.close();
 	}
 }",1
326,629,"
 
 import java.util.Scanner;
 
 public class p2 {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 
 
 		String[] board = new String[4];
 		Scanner sc = new Scanner(System.in);
 		int n = sc.nextInt();
 		for(int k=0;k<n;k++)
 		{
 
 			for(int i=0;i<4;i++)
 			{
 				board[i]=sc.next();
 			}
 			
 			boolean oplayer = false;
 			boolean xplayer = false;
 
 			for(int i=0;i<4;i++)
 			{
 				xplayer = IsXPlayerWinner(board[i]);
 				oplayer = IsOPlayerWinner(board[i]);
 
 				if(xplayer || oplayer)
 					break;
 			}
 
 			if(!(xplayer||oplayer))
 			{
 				for(int i=0;i<4;i++)
 				{
 					String s1="""";
 					for(int j=0;j<4;j++)
 					{
 						s1=s1+board[j].charAt(i);
 					}
 					xplayer = IsXPlayerWinner(s1);
 					oplayer = IsOPlayerWinner(s1);
 
 					if(xplayer || oplayer)
 						break;
 				}
 			}
 
 			if(!(xplayer||oplayer))
 			{
 				String s1 = board[0].charAt(0)+""""+board[1].charAt(1)+""""+board[2].charAt(2)+""""+board[3].charAt(3)+"""";
 				xplayer = IsXPlayerWinner(s1);
 				oplayer = IsOPlayerWinner(s1);
 
 			}
 
 			if(!(xplayer||oplayer))
 			{
 				String s1 = board[0].charAt(3)+""""+board[1].charAt(2)+""""+board[2].charAt(1)+""""+board[3].charAt(0)+"""";
 				xplayer = IsXPlayerWinner(s1);
 				oplayer = IsOPlayerWinner(s1);
 
 			}
 
 			if(!(xplayer||oplayer))
 			{
 				int flag=0;
 				for(int i=0;i<4;i++)
 				{
 					if(board[i].contains("".""))
 					{
 						flag=1;
 						break;
 					}
 				}
 
 				if(flag==1)
 					System.out.println(""Case #""+(k+1)+"": Game has not completed"");
 				else
 					System.out.println(""Case #""+(k+1)+"": Draw"");
 			}
 			else
 			{
 				if(xplayer)
 					System.out.println(""Case #""+(k+1)+"": X won"");
 				else
 					System.out.println(""Case #""+(k+1)+"": O won"");
 			}
 		}
 		
 
 	}
 
 	public static boolean IsXPlayerWinner(String pattern)
 	{
 		if(pattern.equals(""XXXX"") || pattern.equals(""TXXX"") || pattern.equals(""XTXX"")|| pattern.equals(""XXTX"") || pattern.equals(""XXXT""))
 			return true;
 		else
 			return false;
 	}
 
 	public static boolean IsOPlayerWinner(String pattern)
 	{
 		if(pattern.equals(""OOOO"") || pattern.equals(""TOOO"") || pattern.equals(""OTOO"")|| pattern.equals(""OOTO"") || pattern.equals(""OOOT""))
 			return true;
 		else
 			return false;
 	}
 
 }
","package magic_trick;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Solution {
 	private Scanner scanner;
 	private PrintWriter writer;
 
 	public Solution(String sin, String sout) throws FileNotFoundException {
 		File in = new File(sin);
 		File out = new File(sout);
 		scanner = new Scanner(in);
 		writer = new PrintWriter(out);
 	}
 
 	public void solve() {
 		// Read # of tests
 		int n = Integer.valueOf(scanner.nextLine());
 
 		// Read and solve for each test
 		for (int i = 1; i <= n; i++) {
 
 			int[] numbers1 = new int[4];
 			int[] numbers2 = new int[4];
 			String row = new String();
 
 			int line1 = Integer.valueOf(scanner.nextLine());
 			for (int j = 1; j <= 4; j++) {
 				row = scanner.nextLine();
 				if (j == line1) {
 					numbers1 = getNumbers(row);
 				}
 			}
 
 			int line2 = Integer.valueOf(scanner.nextLine());
 			for (int j = 1; j <= 4; j++) {
 				row = scanner.nextLine();
 				if (j == line2) {
 					numbers2 = getNumbers(row);
 				}
 			}
 
 			String s = magicCompare(numbers1, numbers2);
 
 			writer.write(""Case #"");
 			writer.write(i + "": "");
 			writer.write(s);
 			writer.write(""\n"");
 		}
 		writer.close();
 	}
 
 	private int[] getNumbers(String row) {
 		String[] ss = row.split("" "");
 		int[] res = new int[4];
 		for (int i = 0; i < 4; i++) {
 			res[i] = Integer.valueOf(ss[i]);
 		}
 		return res;
 	}
 
 	private String magicCompare(int[] numbers1, int[] numbers2) {
 		int count = 0;
 		int common = 0;
 		for (int i = 0; i < 4; i++) {
 			for (int j = 0; j < 4; j++) {
 				if (numbers1[i] == numbers2[j]) {
 					if (count == 0) {
 						common = numbers1[i];
 					} else {
 						return ""Bad magician!"";
 					}
 					count++;
 				}
 			}
 		}
 
 		if (count == 0) {
 			return ""Volunteer cheated!"";
 		} else {
 			return String.valueOf(common);
 		}
 	}
 }
",0
327,12664,"import java.io.*;
 import java.util.Scanner;
 
 public class LawnmowerSmall{
 	public static void main(String[] args){
 		Scanner inputFile;
 		PrintWriter outputFile;
 		String inputFileName;
 		String outputFileName;
 		int testcase;
 		int n,m;
 		int[][] lawn;
 		Scanner fromStandardInput = new Scanner(System.in);
 		inputFileName = fromStandardInput.nextLine();
 		outputFileName = inputFileName.substring(0,inputFileName.length()-3)+"".out"";
 		try {
 			inputFile = new Scanner(new File(inputFileName));
 		}
 		catch (FileNotFoundException e){
 			System.out.println(""File not found..."");
 			return;
 		}
 		try {
 			outputFile = new PrintWriter(new FileWriter(outputFileName));
 		}
 		catch (IOException e){
 			System.out.println(""Cannot create/open output file..."");
 			inputFile.close();
 			return;
 		}
 		testcase = inputFile.nextInt();
 		for (int i = 1; i <=  testcase; i++){
 			n = inputFile.nextInt();
 			m = inputFile.nextInt();
 			lawn = new int[n][m];
 			for (int j = 0; j < n; j++){
 				for (int k = 0; k < m; k++){
 					lawn[j][k] =  inputFile.nextInt();
 				}
 			}
 			outputFile.println(""Case #""+i+"": ""+checkPattern(lawn, n, m));
 		}
 		inputFile.close();
 		outputFile.close();
 	}
 	
 	static String checkPattern(int[][] l, int n, int m){
 		int min;
 		boolean checkRow = true;
 		boolean checkColumn = true;
 		boolean valid = true;
 		for (int i = 0; i < n; i++){
 			for (int j = 0; j < m; j++){
 				if ((l[0][j] <= l[n-1][j]) && (l[0][j] <= l[i][0]) && (l[0][j] <= l[i][m-1])){
 					min = l[0][j];
 				}
 				else if ((l[n-1][j] <= l[0][j]) && (l[n-1][j] <= l[i][0]) && (l[n-1][j] <= l[i][m-1])){
 					min = l[n-1][j];
 				}
 				else if ((l[i][0] <= l[0][j]) && (l[i][0] <= l[n-1][j]) && (l[i][0] <= l[i][m-1])){
 					min = l[i][0];
 				}
 				else {
 					min = l[i][m-1];
 				}
 				if ((l[i][j] < l[0][j] && l[i][j] < l[n-1][j]) && (l[i][j] < l[i][0] && l[i][j] < l[i][m-1])){
 					return ""No"";
 				}
 				else if(l[i][j] == min){
 					if (l[i][j] == l[0][j] && l[i][j] == l[n-1][j]){
 						for (int k = 0; k < n; k++){
 							if (l[k][j] > l[i][j]){
 								if (l[i][j] == l[i][0] && l[i][j] == l[i][m-1]){
 									for (int x = 0; x < m; x++){
 										if (l[i][x] > l[i][j]){
 											return ""No"";
 										}
 									}
 								}
 								else {
 									return ""No"";
 								}
 							}
 						}
 					}
 					else {
 						if (l[i][j] == l[i][0] && l[i][j] == l[i][m-1]){
 							for (int k = 0; k < m; k++){
 								if(l[i][k] > l[i][j])
 								return ""No"";
 							}
 						}
 						else {
 							return ""No"";
 						}
 					}
 				}
 			}
 		}
 		return ""Yes"";
 	}
 }","import java.util.Scanner;
 
 public class NewLottery
 {
 	public static void main(String[] args)
 	{
 		Scanner reader = new Scanner(System.in);
 		int t = reader.nextInt();
 		for (int i = 1; i <= t; i++)
 		{
 			int a = reader.nextInt();
 			int b = reader.nextInt();
 			int k = reader.nextInt();
 			System.out.printf(""Case #%s: %s%n"", i, solve(a,b,k));
 		}
 	}
 
 	public static int solve(int a, int b, int k)
 	{
 		int count = 0;
 		for (int i = 0; i < a; i++)
 			for (int j = 0; j < b; j++)
 				if ((i & j) < k) count++;
 		return count;
 	}
 }",1
328,4456,"import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.Arrays;
 import java.util.Comparator;
 
 
 public class Round1A_B {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		Round1A_B main = new Round1A_B();
 		try {
 			BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
 			String line = bf.readLine();
 			int T = Integer.parseInt(line);
 			for (int testcaseIndex=0; testcaseIndex<T; testcaseIndex++) {
 				String testCase = bf.readLine();
 				int N = Integer.parseInt(testCase);
 				Level[] levels = new Level[N];
 				for (int i=0; i<N; i++) {
 					testCase = bf.readLine();
 					String[] array = testCase.split("" "");
 					int a = Integer.parseInt(array[0]);
 					int b = Integer.parseInt(array[1]);
 					levels[i] = new Level(a, b, 0);
 				}
 				int out = main.solve(N, levels);
 				if (out != -1) {
 					System.out.print(""Case #""+(testcaseIndex+1)+"": "");
 					System.out.println(out);
 				} else {
 					System.out.println(""Case #""+(testcaseIndex+1)+"": Too Bad"");
 				}
 				
 			}
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private int solve(int N, Level[] levels) {
 		int ret = 0;
 		int star = 0;
 		Arrays.sort(levels, new Comparator<Level>() {
 			@Override
 			public int compare(Level o1, Level o2) {
 				return o1.two - o2.two;
 			}
 		});
 		Level[] twostar = Arrays.copyOf(levels, levels.length);
 		Arrays.sort(levels, new Comparator<Level>() {
 			@Override
 			public int compare(Level o1, Level o2) {
 				return o2.two - o1.two;
 			}
 		});
 		Level[] onestar = Arrays.copyOf(levels, levels.length);
 		
 		int twoIndex = 0;
 		while (true) {
 			while (twoIndex < N) {
 				Level level = twostar[twoIndex];
 				if (star >= level.two) {
 					star += (2 - level.clear);
 					level.clear = 2;
 					ret++;
 					//System.out.println(""two ""+twoIndex +"" star=""+star);
 					twoIndex++;
 				} else {
 					break;
 				}
 			}
 
 			boolean end = true;
 			for (int i=0; i<N; i++) {
 				if (levels[i].clear < 2) {
 					end = false;
 					break;
 				}
 			}
 			if (end) {
 				break;
 			}
 
 			boolean bad = true;
 			for (int oneIndex = 0; oneIndex<N; oneIndex++) {
 				Level level = onestar[oneIndex];
 				if (star >= level.one && level.clear == 0) {
 					star += 1;
 					level.clear = 1;
 					ret++;
 					bad = false;
 					//System.out.println(""one ""+oneIndex +"" star=""+star);
 					break;
 				}
 			}
 			
 			if (bad) {
 				return -1;
 			}
 
 		}
 		
 		return ret;
 	}
 	
 	
 	static class Level {
 		int one;
 		int two;
 		int clear;
 		
 		public Level(int o, int t, int c) {
 			one = o;
 			two = t;
 			clear = c;
 		}
 		
 		@Override
 		public String toString() {
 			return """"+one+"" ""+two+"" ""+clear;
 		}
 	}
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package d;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  *
  * @author julio
  */
 public class D {
 
     static Map<String, AtomicInteger> keys;
     //static Chest[] chests;
     static Map<String, Collection<Chest>> chestByKey;
     static TreeSet openChest = new TreeSet();
     static TreeSet closedChest = new TreeSet();
     static HashSet<Integer> fail;
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws FileNotFoundException, IOException {
         String caseName = ""small"";
 
         BufferedReader reader = new BufferedReader(new FileReader(""in."" + caseName));
 
 
         int T = Integer.parseInt(reader.readLine());
         for (int caseT = 0; caseT < T; caseT++) {
             String[] KN = reader.readLine().split("" "");
             int K = Integer.parseInt(KN[0]);
             int N = Integer.parseInt(KN[1]);
             keys = new HashMap<>();
             openChest = new TreeSet<>();
             closedChest = new TreeSet<>();
             chestByKey = new HashMap<>();
             fail = new HashSet<>();
 
             for (String key : reader.readLine().split("" "")) {
                 addKey(key, keys);
                 chestByKey.put(key, new TreeSet<Chest>());
             }
 
             for (int i = 0; i < N; i++) {
                 String[] tmp = reader.readLine().split("" "");
                 Chest c = new Chest();
                 c.keyOpen = tmp[0];
                 c.number = i + 1;
                 int Ki = Integer.parseInt(tmp[1]);
                 c.keyContains = Arrays.copyOfRange(tmp, 2, tmp.length);
                 closedChest.add(c);
                 if (chestByKey.containsKey(c.keyOpen)) {
                     chestByKey.get(c.keyOpen).add(c);
                 } else {
                     TreeSet<Chest> newarray = new TreeSet<>();
                     newarray.add(c);
                     chestByKey.put(c.keyOpen, newarray);
                 }
             }
 
 
             String track = """";
 
 //            for (String key : keys.keySet()) {
 //                track = canOpenAll(key, track);
 //                if (!track.isEmpty()) {
 //                    break;
 //                }
 //
 //            }
             for (Chest c : new ArrayList<Chest>(closedChest)) {
                 track = canOpenAll(c, track);
                 if (!track.isEmpty()) {
                     break;
                 }
 
             }
 
             if (track.isEmpty()) {
                 track = ""IMPOSSIBLE"";
             }
 
             //System.out.println(N + ""x"" + M);
             System.out.println(""Case #"" + (caseT + 1) + "": "" + track);
         }
 
 
     }
 
     private static String canOpenAll(String key, String track) {
         for (Chest c : getChestsByKey(key)) {
             if (open(c)) {
                 if (allOpen()) {
                     return track + "" "" + c.number;
                 }
                 List<String> currentKeys = new ArrayList(keys.keySet());
 
                 for (String key2 : currentKeys) {
                     String tracknew = canOpenAll(key2, track + "" "" + c.number);
                     if (!tracknew.isEmpty()) {
                         return tracknew;
                     }
                 }
 
                 close(c);
             }
         }
 
         return """";
     }
 
     private static Collection<Chest> getChestsByKey(String key) {
         if (!chestByKey.containsKey(key)) {
             chestByKey.put(key, new TreeSet<Chest>());
         }
         return chestByKey.get(key);
     }
 
     private static boolean open(Chest c) {
         if (!c.open && keys.get(c.keyOpen) != null && keys.get(c.keyOpen).get() > 0) {
             //we have a key to open, lets open
             removeKey(c.keyOpen, keys);
             c.open = true;
             openChest.add(c);
             closedChest.remove(c);
 
             //add the found keys
             for (String key : c.keyContains) {
                 addKey(key, keys);
             }
             return true;
         }
         return false;
     }
 
     private static boolean close(Chest c) {
         if (c.open) {
             //return the keys
             for (String key : c.keyContains) {
                 removeKey(key, keys);
             }
 
             //lets close it
             c.open = false;
             addKey(c.keyOpen, keys);
 
             closedChest.add(c);
             openChest.remove(c);
 
             return true;
         }
         return false;
     }
     
     private static boolean isFail(){
         HashSet<Integer> tmp = new HashSet<>();
         tmp.add(closedChest.hashCode());
         tmp.add(keys.hashCode());
         return fail.contains(tmp.hashCode());
     }
 
     private static void recordFail(){
         HashSet<Integer> tmp = new HashSet<>();
         tmp.add(closedChest.hashCode());
         tmp.add(keys.hashCode());
         fail.add(tmp.hashCode());
     }
     
     private static boolean allOpen() {
         return closedChest.isEmpty();
     }
 
     private static String canOpenAll(Chest current, String track) {
 
 
 //        System.out.println(""try "" + (current.number));
 //        System.out.println(track);
 //        System.out.println(keys + ""\n"");
 
 
         if (open(current)) {
             
             if(isFail()){
                 return """";
             }
 
             if (allOpen()) {
                 return track + (current.number);
             }
 
             for (Chest sub : new ArrayList<Chest>(closedChest)) {
 
                 String can = canOpenAll(sub, track + (current.number) + "" "");
                 if (!can.isEmpty()) {
                     return can;
 
                 }
             }
 
             close(current);
 
         }
         recordFail();
         return """";
     }
 
     private static void addKey(String key, Map<String, AtomicInteger> keys) {
         if (keys.containsKey(key)) {
             keys.get(key).incrementAndGet();
         } else {
             keys.put(key, new AtomicInteger(1));
         }
     }
 
     private static void removeKey(String key, Map<String, AtomicInteger> keys) {
         if (keys.containsKey(key) && keys.get(key).decrementAndGet() == 0) {
             keys.remove(key);
         }
     }
 
     private static class Chest implements Comparable<Chest> {
 
         public String keyOpen;
         public String[] keyContains;
         public int number;
         public boolean open = false;
 
         public Chest() {
         }
 
         @Override
         public String toString() {
             return ""Chest "" + number + "" opens with: "" + keyOpen + "" contains: "" + Arrays.toString(keyContains);
         }
 
         @Override
         public int compareTo(Chest o) {
             return this.number - o.number;
         }
     }
 }
",0
329,12107,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 
 public class SpeakingInTongues {
 
 	int C; 
 	int N;
 	int T;
 	ArrayList<Integer> O = new ArrayList<Integer>();
 	ArrayList<Integer> B =  new ArrayList<Integer>();
 	Object[][] seq;
 
 	char[] english =  new char[27];
 	char[] googlerese =  new char[27];
 	char[] googlerese2 =  new char[27];
 
 	public static void main(String[] args) {
 
 		SpeakingInTongues b = new SpeakingInTongues();
 
 		int k=97;
 		for(int i=1;i<=26;i++) 
 			b.english[i] = (char)(k++);
 
 
 		try {
 			FileReader r=new FileReader(""mapping.conf"");
 			FileReader r2=new FileReader(""input1.txt"");
 			FileWriter w=new FileWriter(""output1.txt"");
 
 			BufferedReader br = new BufferedReader(r);
 			BufferedReader br2 = new BufferedReader(r2);
 			BufferedWriter bw = new BufferedWriter(w);
 
 			char[] inputChar1 = br.readLine().toCharArray();
 			char[] inputChar2 = br.readLine().toCharArray();
 
 			char[] english2 =  new char[27];
 
 			for(int i=0;i<inputChar1.length;i++){
 				char char1 = inputChar1[i];
 				char char2 = inputChar2[i];
 
 				if(b.googlerese[(int)char1 - 96] == '\u0000') {
 					b.googlerese[(int)char1 - 96] = char2;
 					english2[(int)char1 - 96]='a';
 				}
 
 			}
 
 			b.googlerese[(int)'q' - 96] = 'z';
 			b.googlerese[(int)'z' - 96] = 'q';
 
 			/*for(int i=1;i<b.googlerese.length;i++) {
 				System.out.println((char)(i+96)+ "" "" + b.googlerese[i]);
 			}
 			 */
 
 
 			b.T =  Integer.parseInt(br2.readLine());
 
 			for(int i=0;i<b.T;i++) {
 
 				char[] input = br2.readLine().toCharArray();
 				char[] output = new char[input.length];
 				for(int j=0;j<input.length;j++){
 					if(input[j] != ' ') {
 						output[j] = b.googlerese[(int)input[j] - 96];
 					} else
 						output[j] = ' ';
 
 				}
 
 				String toWrite = ""Case "" + ""#"" + (i+1) + "": "";
 				bw.write(toWrite);
 				bw.write(output);
 				bw.newLine();
 				bw.flush();
 
 
 			}
 			br.close();
 			br2.close();
 			bw.close();
 		}catch(Exception e){  
 			e.printStackTrace();
 		}
 	}
 
 }","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.StringTokenizer;
 import java.util.Arrays;
 
 public class SquareTiles {
 
 	int T; 
 	int N;
 	ArrayList<Integer> O = new ArrayList<Integer>();
 	ArrayList<Integer> B =  new ArrayList<Integer>();
 	Object[][] seq;
 	char[][] tile;
 	private int R;
 	private int C;
 
 	public static void main(String[] args) {
 
 		SquareTiles b = new SquareTiles();
 
 		try {
 			FileReader r=new FileReader(""input1.txt"");
 			FileWriter w=new FileWriter(""output1.txt"");
 
 			BufferedReader br = new BufferedReader(r);
 			BufferedWriter bw = new BufferedWriter(w);
 
 			b.T = Integer.parseInt(br.readLine());
 			System.out.println(""T ""+ b.T );
 			for(int i=0;i<b.T;i++) {
 				int count =0;
 
 				System.out.println("" "");
 
 				String  inLine = br.readLine();
 				StringTokenizer st = new StringTokenizer(inLine);
 				b.R = Integer.parseInt(st.nextToken());
 				b.C = Integer.parseInt(st.nextToken());
 
 				System.out.println(""R =""  + b.R);
 				System.out.println(""C =""  + b.C);
 
 				System.out.println(""you are here"");
 				b.tile = new char[b.R][b.C];
 
 				for(int j=0;j<b.R;j++){
 					char[] inLine2 = br.readLine().toCharArray();
 
 					for(int k=0;k<b.C;k++) {
 
 						char x = inLine2[k];
 						if( x == '#')
 							count++;
 
 						b.tile[j][k] = x;
 					}
 
 				}
 
 
 
 				/*	for(int j=0; j< b.R ; j++) {
 					for(int k=0;k<b.C;k++)
 						System.out.print( "" "" +  b.tile[j][k]);
 					System.out.println("" "");
 				}
 				 */
 
 				if (count%2  != 0) {
 					String output = ""Case "" + ""#"" + (i+1) + "": "";
 					bw.write(output);
 					bw.newLine();
 					bw.flush();
 					System.out.println(""u r here 1"");
 					output = ""Impossible"";
 					bw.write(output);
 					bw.newLine();
 					bw.flush();
 				}
 				else {								
 					char[][] result =  b.calculate();
 					if(result != null){
 						String output = ""Case "" + ""#"" + (i+1) + "": "";
 						bw.write(output);
 						bw.newLine();
 						bw.flush();
 
 						System.out.println(""you are here 1"");
 						for(int j=0; j< b.R ; j++) {
 							output = """";
 							for(int k=0;k<b.C;k++)
 								output = output + b.tile[j][k];
 							bw.write(output);
 							bw.newLine();
 							bw.flush();
 						}
 
 
 
 
 					} else {
 						String output = ""Case "" + ""#"" + (i+1) + "": "";
 						bw.write(output);
 						bw.newLine();
 						bw.flush();
 						System.out.println(""u r here 2"");
 						output = ""Impossible"";
 						bw.write(output);
 						bw.newLine();
 						bw.flush();
 
 					}
 
 
 				}
 				//System.out.println(st.nextToken());
 
 
 				//bw.write(output);
 				//bw.newLine();
 				//bw.flush();
 
 			}
 			br.close();
 		}catch(Exception e){  
 			System.out.println(e.toString());
 		}
 	}
 
 	private char[][] calculate() {
 
 		for(int j =0 ; j< R ; j++) {
 			for(int k =0 ; k< C ; k++) {
 				char c= tile[j][k]; 
 				System.out.println(""u r here 3"");
 				if(c == '#') {
 					System.out.println(""u r h 1"");
 					tile[j][k] = '/';
 
 					System.out.println(""u r here 4"");
 					if(j+1 < R){
 						if(tile[j+1][k] == '#') {
 							System.out.println(""u r h 2"");
 							tile[j+1][k] = '\\';
 						}
 						else 
 							return null;
 					}
 					else
 						return null;
 
 					if(k+1 < C){
 						if(tile[j][k+1] == '#') {
 							System.out.println(""u r h 3"");
 							tile[j][k+1] = '\\';
 						}
 						else 
 							return null;
 					}
 					else
 						return null;
 
 					if((j+1 < R) && (k+1 < C)){
 						if(tile[j+1][k+1] == '#') {
 							System.out.println(""u r h 4"");
 							tile[j+1][k+1] = '/';
 						}
 						else 
 							return null;
 					}
 					else
 						return null;
 
 				}
 			}
 		}
 
 		return tile;
 
 	}
 
 }",1
330,15561,"import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 public class B {
 
 	private static String problem = ""bl"";
 	private static String inputFile = ""input/"" + problem + "".in"";
 	private static String outputFile = ""output/"" + problem + "".out"";
 
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner(new File(inputFile));
 		PrintWriter out = new PrintWriter(new File(outputFile));
 
 		int nbTest = in.nextInt();
 		for (int testCase = 1; testCase <= nbTest; testCase++) {
 			char[][] combine = new char[30][30];
 			boolean[][] oposite = new boolean[30][30];
 
 			int comC = in.nextInt();
 			for (int i = 0; i < comC; i++) {
 				String s = in.next().toUpperCase();
 				int a = s.charAt(0) - 'A';
 				int b = s.charAt(1) - 'A';
 				char c = s.charAt(2);
 				combine[a][b] = c;
 				combine[b][a] = c;
 			}
 
 			int opoC = in.nextInt();
 			for (int i = 0; i < opoC; i++) {
 				String s = in.next().toUpperCase();
 				int a = s.charAt(0) - 'A';
 				int b = s.charAt(1) - 'A';
 				oposite[a][b] = true;
 				oposite[b][a] = true;
 			}
 			int n = in.nextInt();
 			String s = in.next().toUpperCase();
 			LinkedList<Character> queue = new LinkedList<Character>();
 			for (int i = 0; i < n; i++) {
 				queue.addFirst(s.charAt(i));
 				if (queue.size() > 1) {
 					int c1 = queue.get(0) - 'A';
 					int c2 = queue.get(1) - 'A';
 					if (combine[c1][c2] != 0) {
 						queue.removeFirst();
 						queue.removeFirst();
 						queue.addFirst(combine[c1][c2]);
 					} else {
 						Iterator<Character> iterator = queue.iterator();
 						iterator.next();
 						for (; iterator.hasNext();) {
 							int cc = iterator.next() - 'A';
 							if (oposite[c1][cc]) {
 								queue.clear();
 								break;
 							}
 						}
 					}
 				}
 			}
 			Collections.reverse(queue);
 			out.print(""Case #"" + testCase + "": "");
 			out.println(queue);
 		}
 
 		in.close();
 		out.close();
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class A {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		Scanner scanner = new Scanner(new File(""A-small-attempt0.in""));
 		FileOutputStream fos = new FileOutputStream(""A-small-attempt0.out"");
 		
 		int test_case = scanner.nextInt();
 		for (int t = 1; t <= test_case; t++) {
 			int a[][] = new int[5][5];
 			int b[][] = new int[5][5];
 			boolean p[] = new boolean[17];
 			
 			int m = scanner.nextInt();
 			for (int i = 1; i <= 4; i++) {
 				for (int j = 1; j <= 4; j++) {
 					a[i][j] = scanner.nextInt();
 				}
 			}
 			
 			int n = scanner.nextInt();
 			for (int i = 1; i <= 4; i++) {
 				for (int j = 1; j <= 4; j++) {
 					b[i][j] = scanner.nextInt();
 				}
 			}
 			
 			for (int i = 1; i <= 16; i++)
 				p[i] = false;
 			for (int i = 1; i <= 4; i++)
 				p[a[m][i]] = true;
 			
 			int count = 0;
 			int ans = 0;
 			for (int i = 1; i <= 4; i++) {
 				if (p[b[n][i]]) {
 					count++;
 					ans = b[n][i];
 				}
 			}
 			
 			String tmp = """";
 			switch (count) {
 				case 0:
 					tmp = ""Volunteer cheated!"";
 					break;
 				case 1:
 					tmp = new Integer(ans).toString();
 					break;
 				default:
 					tmp = ""Bad magician!"";
 					break;
 			}
 			String result = String.format(""Case #%d: %s\n"", t, tmp);
 			fos.write(result.getBytes());
 		}
 		fos.flush();
 		scanner.close();
 		fos.close();
 
 	}
 
 }
",0
331,6092,"package com.codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class ProblemB {
 
     public static void main(String[] args) throws FileNotFoundException {
 
         Scanner sc = new Scanner(new File(""B-large.in""));
         int T = sc.nextInt();
         sc.nextLine();
 
         for (int i = 0; i < T; i++) {
             int N = sc.nextInt();
             int S = sc.nextInt();
             int p = sc.nextInt();
 
             int[] t = new int[N];
             for (int j = 0; j < N; j++) {
                 t[j] = sc.nextInt();
             }
 
             System.out.println(""Case #"" + (i + 1) + "": "" + solve(N, S, p, t));
 
         }
 
     }
 
     private static int solve(int N, int S, int p, int[] t) {
 
         int countA = 0, countB1 = 0, countB2 = 0, countC1 = 0, countC2 = 0, count = 0;
         for (int i = 0; i < N; i++) {
             int r = t[i] % 3, d = t[i] / 3;
             switch (r) {
             case 1:
                 if (d + 1 >= p) {
                     countA++;
                 }
                 break;
             case 0:
                 if (d == 0) {
                     if (d >= p) {
                         countB1++;
                     }
                 } else if (d >= 10) {
                     if (d >= p) {
                         countB1++;
                     }
                 } else if (d >= p) {
                     countB1++;
                 } else if (d + 1 == p && d > 0) {
                     countB2++;
                 }
                 break;
             case 2:
                 if (d >= 9) {
                     if (d + 1 >= p) {
                         countC1++;
                     }
                 } else if (d + 1 >= p) {
                     countC1++;
                 } else if (d + 2 == p) {
                     countC2++;
                 }
                 break;
             default:
                 break;
             }
         }
 
         count = countA + countB1 + countC1 + Math.min(countB2 + countC2, S);
         return count;
     }
 
 }
","package com.codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Rope {
 
 	private static PrintWriter pw;
 
 	public static void main(String[] args) throws FileNotFoundException {
 
 		Scanner sc = new Scanner(new File(""A-large (2).in""));
 		pw = new PrintWriter((new File(""output-a.txt"")));
 
 		int c = sc.nextInt();
 		for (int i = 0; i < c; i++) {
 			print(""Case #"" + (i + 1) + "": "");
 
 			sc.nextLine();
 			int n = sc.nextInt();
 			int[] a = new int[n], b = new int[n];
 
 			for (int j = 0; j < n; j++) {
 				sc.nextLine();
 				a[j] = sc.nextInt();
 				b[j] = sc.nextInt();
 			}
 
 			int result = solve(a, b, n);
 			println(String.valueOf(result));
 		}
 
 		pw.close();
 		sc.close();
 	}
 
 	private static int solve(int[] a, int[] b, int n) {
 		int count = 0;
 		for (int i = 0; i < n; i++) {
 			for (int j = i + 1; j < n; j++) {
 				if ((a[i] > a[j]) != (b[i] > b[j])) {
 					count++;
 				}
 			}
 		}
 		return count;
 	}
 
 	private static void print(String string) {
 		System.out.print(string);
 		pw.print(string);
 	}
 
 	private static void println(String string) {
 		System.out.println(string);
 		pw.println(string);
 	}
 
 }
",1
332,18690,"import java.io.FileReader;
 import java.util.Scanner;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 
 public class Problem1 {
 	
 	public static void main(String[] args) throws Exception {
 		Scanner scanner = new Scanner(new FileReader(""problem1.txt""));
 		
 		int tests = scanner.nextInt();		
 		for(int i = 1; i <= tests; i++) {
 			int N = scanner.nextInt();
 			
 			String[] strings = new String[N];
 			for(int j = 0; j < N; j++) {
 				strings[j] = scanner.next();
 			}
 			
 			int best = getMinMoves(strings);
 			
 			if(best == Integer.MAX_VALUE) {
 				System.out.printf(""Case #%d: Fegla Won\n"", i);
 			} else {
 				System.out.printf(""Case #%d: %d\n"", i, best);
 			}
 			
 		}
 		
 		scanner.close();
 		
 		System.exit(0);
 	}
 	
 	
 	public static int getMinMoves(String[] strings) {
 		char[] groups = getGroups(strings[0]);
 		
 		int moves = 0;
 		for(int i = 0; i < groups.length; i++) {
 			//System.out.println(""====="" + groups[i] + ""====="");
 			//Check if the first character is the group char
 			for(String s : strings) {
 				if(s.length() == 0 || s.charAt(0) != groups[i]) {
 					return Integer.MAX_VALUE;
 				}
 			}
 			
 			moves += getMinMoves(strings, groups[i]);
 		}
 		
 		for(String s : strings) {
 			if(s.length() != 0) {
 				return Integer.MAX_VALUE;
 			}
 		}
 		
 		return moves;
 	}
 	
 	public static int getMinMoves(String[] strings, char c) {
 		int moves = 0;
 		String pattern = ""^("" + c + ""*)"";
 		//System.out.println(pattern);
 		Pattern r = Pattern.compile(pattern);
 		
 		int min = Integer.MAX_VALUE;
 		int max = Integer.MIN_VALUE;
 		int[] lengths = new int[strings.length]; 
 		for(int i = 0; i < strings.length; i++) {
 			//System.out.println(""testing "" + strings[i]);
 			Matcher m = r.matcher(strings[i]);
 			if(m.find()) {
 				lengths[i] = m.group(1).length();
 				/*while(strings[i].charAt(0) == c) {
 					strings[i] = strings[i].substring(1);
 					System.out.println(""** "" + strings[i]);
 				}*/
 				strings[i] = strings[i].replaceFirst(""^"" + c + ""*"", """");
 			
 				if(lengths[i] < min) min = lengths[i];
 				if(lengths[i] > max) max = lengths[i];
 			} else {
 				return Integer.MAX_VALUE;
 			}
 		}
 		
 		int best = Integer.MAX_VALUE;
 		for(int a = min; a <= max; a++) {
 			int test = 0;
 			for(int i = 0; i < lengths.length; i++) {
 				test += Math.abs(a - lengths[i]);
 				//System.out.println(""*** "" + test);
 			}
 			if(test < best) best = test;
 		}
 		
 		return best;
 	}
 	
 	public static char[] getGroups(String s) {
 		char[] groups = new char[100];
 		
 		char[] chars = s.toCharArray();
 		
 		groups[0] = s.toCharArray()[0];
 		int groupIdx = 0;
 		for(char c : chars) {
 			if(c != groups[groupIdx]) {
 				groupIdx++;
 				groups[groupIdx] = c;
 			}
 		}
 		groupIdx++;
 		
 		char[] rtn = new char[groupIdx];
 		for(int i = 0; i < groupIdx; i++) {
 			rtn[i] = groups[i];
 			//System.out.print(rtn[i]);
 		}
 		
 		return rtn;
 	}
 	
 
 
 }
","package qual2012.C;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.HashSet;
 import java.util.Scanner;
 
 public class RecycledNumbers {
 
     //private static String inputFileName = ""sample.in"";
     //private static String inputFileName = ""C-small-attempt0.in"";
     private static String inputFileName = ""C-large.in"";
     //private static String outputFileName = ""sample.out"";
     //private static String outputFileName = ""C-small.out"";
     private static String outputFileName = ""C-large.out"";
 
     private static int nbrOfTests;
     private static String inputFolder = ""input/"";
     private static String outputFolder = ""output/"";
 
     /**
      * @param args
      */
     public static void main(String[] args) {
 
         RecycledNumbers mainDefault = new RecycledNumbers();
 
         MyTestCase[] input = mainDefault.readInputCodeJam(inputFileName);
         StringBuffer output = mainDefault.createOutput(input);
         printToFile(output, outputFileName);
     }
 
     public MyTestCase[] readInputCodeJam(String fileName) {
         MyTestCase[] testCases = null;
         File file = new File(inputFolder + fileName);
         try {
             Scanner scanner = new Scanner(file);
 
             nbrOfTests = Integer.valueOf(scanner.nextLine());
             testCases = new MyTestCase[nbrOfTests];
 
             for (int i = 0; i < nbrOfTests; i++) {
                 String tmp = scanner.nextLine();
 
                 String[] testCaseInput = tmp.split("" "");
                 MyTestCase obj = new MyTestCase(testCaseInput);
 
                 testCases[i] = obj;
             }
 
             scanner.close();
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
         return testCases;
     }
 
     public StringBuffer createOutput(MyTestCase[] myTestCases) {
         StringBuffer buffer = new StringBuffer();
         int count = 1;
         for (int i = 0; i < nbrOfTests; i++) {
             buffer.append(""Case #"" + count++ + "": "");
 
             MyTestCase myTestCase = myTestCases[i];
             buffer.append(myTestCase.getAnswer());
 
             buffer.append(""\n"");
         }
         return buffer;
     }
 
     public static void printToFile(StringBuffer output, String fileName) {
         try {
             FileWriter fstream = new FileWriter(outputFolder + fileName);
             BufferedWriter out = new BufferedWriter(fstream);
             out.write(output.toString());
             out.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 
     class MyTestCase {
         private String answer;
         private BigInteger second;
         private BigInteger first;
 
         public MyTestCase(String[] input) {
             first = new BigInteger(input[0]);
             second = new BigInteger(input[1]);
             int sum = 0;
             BigInteger value = first;
             while (value.compareTo(second) <= 0) {
                 sum += solve(value);
                 value = value.add(BigInteger.ONE);
             }
             answer = String.valueOf(sum);
         }
 
         public String getAnswer() {
             return answer;
         }
 
         private int solve(BigInteger value) {
             HashSet<String> uniquePairs = new HashSet<String>();
             String inputValue = value.toString();
             if (inputValue.length() <= 1) {
                 return 0;
             }
             for (int i = 1; i < inputValue.length(); i++) {
                 String tmp = inputValue;
                 int split = i;
                 String firstPart = tmp.substring(0, split);
                 String secondPart = tmp.substring(split);
                 String connected = secondPart + firstPart;
                 if (inputValue.compareTo(connected) < 0) {
                     BigInteger tmp2 = new BigInteger(connected);
                     if (tmp2.compareTo(second) <= 0) {
                         // System.out.println(inputValue + "" => "" + connected);
                         uniquePairs.add(inputValue + connected);
                     }
                 }
             }
             return uniquePairs.size();
         }
     }
 }
",0
333,3401,"package com.geekforbes.codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Writer;
 import java.util.LinkedList;
 import java.util.Queue;
 
 public class ThemePark {
 	public static void main(String[] args) {
 		String fileIn = ""C-small-attempt1.in"";
 		String fileOut = ""C-small-attempt1.out"";
 		
 		if(args.length > 0) {
 			fileIn = args[0];
 		}
 		
 		File fin = new File(fileIn);
 		File fout = new File(fileOut);
 		FileInputStream fis = null;
 		Writer output = null;
 		BufferedReader br = null;
 		
 		try {
 			fis = new FileInputStream(fin);
 			br = new BufferedReader(new InputStreamReader(fis));
 			output = new BufferedWriter(new FileWriter(fout));
 			int T = Integer.parseInt(br.readLine());
 			
 			for(int i=1; i <= T; i++) {
 				/* each case consists of 2 lines */
 				String line1[] = br.readLine().split("" "");
 				String line2[] = br.readLine().split("" "");
 				
 				/* Line 1 */
 				/* R = runs per day */
 				int R = Integer.parseInt(line1[0]);
 				/* k = space per ride */
 				int k = Integer.parseInt(line1[1]);
 				/* N = number of groups on next line */
 				int N = Integer.parseInt(line1[2]);
 				
 				/* Line 2 */
 				Queue<Integer> queue = new LinkedList<Integer>();
 				Queue<Integer> riding = new LinkedList<Integer>();
 				
 				int euros = 0;
 				int space_left = k;
 				
 				for(int j=0; j < N; j++) {
 					// Queue is FIFO, add in order it appears
 					queue.add(Integer.parseInt(line2[j]));
 				}
 				
 				/* for each ride */
 				for(int j=0; j < R; j++) {
 					/* reset space available */
 					space_left = k;
 					/* While the space left is greater or equal to the next in queue */
 					while(space_left >= queue.element()) {
 						//System.out.println(""Space left: "" + space_left + ""; Next Group: "" + queue.element());
 						/* remove the next in queue */
 						int tmp = queue.remove();
 						/* remove that amount of space */
 						space_left -= tmp;
 						/* add it to the currently riding list */
 						riding.add(tmp);
 						/* increase the euros made for this element */
 						euros += tmp;
 						/* if nobody left in the queue, start ride */
 						if(queue.isEmpty()) {
 							break;
 						}
 					}
 					
 					/* at the end of the ride, put the riding groups back in the queue */
 					int current_ride = riding.size();
 					for(int l=0; l < current_ride; l++) {
 						//System.out.println(""Moving riding back to queue: "" + riding.size());
 						queue.add(riding.remove());
 					}
 				}
 				
 				System.out.println(""Case #"" + i + "": "" + euros);
 				output.write(""Case #"" + i + "": "" + euros + ""\n"");
 			}
 
 			
 			/* cleanup */
 			fis.close();
 			br.close();
 			output.close();
 			
 			/* notify of completion */
 			System.out.println(""Done executing"");
 		} catch (FileNotFoundException e) {
 			System.err.println(""File not found:"");
 			e.printStackTrace();
 		} catch (IOException e) {
 			System.err.println(""IO Exception:"");
 			e.printStackTrace();
 		}
 	}
 
 }","package com.geekforbes.codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Writer;
 import java.util.LinkedList;
 import java.util.Queue;
 
 public class ThemePark {
 	public static void main(String[] args) {
 		String fileIn = ""C-small-attempt1.in"";
 		String fileOut = ""C-small-attempt1.out"";
 		
 		if(args.length > 0) {
 			fileIn = args[0];
 		}
 		
 		File fin = new File(fileIn);
 		File fout = new File(fileOut);
 		FileInputStream fis = null;
 		Writer output = null;
 		BufferedReader br = null;
 		
 		try {
 			fis = new FileInputStream(fin);
 			br = new BufferedReader(new InputStreamReader(fis));
 			output = new BufferedWriter(new FileWriter(fout));
 			int T = Integer.parseInt(br.readLine());
 			
 			for(int i=1; i <= T; i++) {
 				/* each case consists of 2 lines */
 				String line1[] = br.readLine().split("" "");
 				String line2[] = br.readLine().split("" "");
 				
 				/* Line 1 */
 				/* R = runs per day */
 				int R = Integer.parseInt(line1[0]);
 				/* k = space per ride */
 				int k = Integer.parseInt(line1[1]);
 				/* N = number of groups on next line */
 				int N = Integer.parseInt(line1[2]);
 				
 				/* Line 2 */
 				Queue<Integer> queue = new LinkedList<Integer>();
 				Queue<Integer> riding = new LinkedList<Integer>();
 				
 				int euros = 0;
 				int space_left = k;
 				
 				for(int j=0; j < N; j++) {
 					// Queue is FIFO, add in order it appears
 					queue.add(Integer.parseInt(line2[j]));
 				}
 				
 				/* for each ride */
 				for(int j=0; j < R; j++) {
 					/* reset space available */
 					space_left = k;
 					/* While the space left is greater or equal to the next in queue */
 					while(space_left >= queue.element()) {
 						//System.out.println(""Space left: "" + space_left + ""; Next Group: "" + queue.element());
 						/* remove the next in queue */
 						int tmp = queue.remove();
 						/* remove that amount of space */
 						space_left -= tmp;
 						/* add it to the currently riding list */
 						riding.add(tmp);
 						/* increase the euros made for this element */
 						euros += tmp;
 						/* if nobody left in the queue, start ride */
 						if(queue.isEmpty()) {
 							break;
 						}
 					}
 					
 					/* at the end of the ride, put the riding groups back in the queue */
 					int current_ride = riding.size();
 					for(int l=0; l < current_ride; l++) {
 						//System.out.println(""Moving riding back to queue: "" + riding.size());
 						queue.add(riding.remove());
 					}
 				}
 				
 				System.out.println(""Case #"" + i + "": "" + euros);
 				output.write(""Case #"" + i + "": "" + euros + ""\n"");
 			}
 
 			
 			/* cleanup */
 			fis.close();
 			br.close();
 			output.close();
 			
 			/* notify of completion */
 			System.out.println(""Done executing"");
 		} catch (FileNotFoundException e) {
 			System.err.println(""File not found:"");
 			e.printStackTrace();
 		} catch (IOException e) {
 			System.err.println(""IO Exception:"");
 			e.printStackTrace();
 		}
 	}
 
 }",1
334,2008,"package qualif.question2;
 
 import java.util.ArrayList;
 
 public class LawnMowerPatern {
 
 	private int MAX_HEIGHT = 2;
 	
 	private final Integer lines;
 	private  String[] shape;
 	private final Integer columns;
 
 	public LawnMowerPatern(Integer lines, Integer columns, ArrayList<String> square) {
 		this.lines = lines;
 		this.columns = columns;
 		prepareShape(square);
 	}
 
 	private void prepareShape(ArrayList<String> square) {
 		String fulllines = """";
 		for(int i = 0 ; i < square.size() ; i++){
 			fulllines+="" ""+square.get(i);
 		}
 		shape = fulllines.trim().split("" "");
 	}
 	
 	public String isThePatternPossible(){
 		Boolean isPossible = tryToShape();
 		return getPatternResponse(isPossible );
 	}
 
 	private Boolean tryToShape() {
 		for(int i = 0 ; i < shape.length ; i++){
 			Integer expectedH = new Integer(shape[i]);
 			if(expectedH < MAX_HEIGHT){
 				Boolean shapePossible = checkIfNeighboursInLineAreAsLowAsMe(i);
 				if(!shapePossible){
 					return false;
 				}
 			}
 		}
 		return true;
 	}
 
 	private Boolean checkIfNeighboursInLineAreAsLowAsMe(int myPosition) {
 		Integer myValue = new Integer (shape[myPosition]);
 		
 		Boolean shapePossible = checkHorizontalNeighbours(myPosition, myValue);
 		if(shapePossible){
 			return true;
 		}
 		
 		shapePossible = checkVerticalNeighbours(myPosition, myValue);
 		if(shapePossible){
 			return true;
 		}
 		
 		return false;		
 	}
 
 	private Boolean checkVerticalNeighbours(int myPosition, int myValue) {
 		Integer myColumn = myPosition%columns;
 
 		for(int i = 0 ; i < lines; i++){
 			Integer currentValue = new Integer (shape[i*columns + myColumn]);
 			if(myValue < currentValue){
 				return false;
 			}
 		}
 		return true;
 	}
 
 	private Boolean checkHorizontalNeighbours(int myPosition, int myValue) {
 
 		Integer myLine = myPosition/columns;		
 		int startIndex = myLine*columns;
 
 		for(int i = startIndex ; i < startIndex+columns; i++){
 			Integer currentValue = new Integer (shape[i]);
 			if(myValue < currentValue){
 				return false;
 			}
 		}
 		return true;
 	}
 
 	private String getPatternResponse(Boolean isPossible) {
 		if(isPossible){
 			return ""YES"";
 		}
 		return ""NO"";
 	}
 }
","package qualif;
 
 import java.util.Scanner;
 
 import qualif.io.ReadWrite;
 import qualif.problem1.SpeakingInTongue;
 
 public class Main {
 	
 	private static String pathToFile = ""resource/"";
 	private static String fileName = ""A-small"";
 	private static String outputName = ""output"";
 	private static String googleInput = ""inputGoogle.txt"";
 	private static String englishInput = ""inputEnglish.txt"";
 	private static String filePath  = pathToFile + fileName + "".txt"";
 	private static String outputPath  = pathToFile + outputName + "".txt"";
 	
 	public static void main(String[] arg){
 
 		
 		ReadWrite reader = new ReadWrite();
 		SpeakingInTongue speakingInTongue = new SpeakingInTongue(reader.read(filePath));
 		
 		Scanner google = reader.read(pathToFile + googleInput);
 		Scanner english = reader.read(pathToFile + englishInput);	
 		speakingInTongue.initialiseMap(google, english);
 		
 		String[] outputs = speakingInTongue.process();
 		reader.write(outputPath, outputs);
 	}
 	
 	
 }
",1
335,5157,"import static java.lang.Math.*;
 import static java.util.Arrays.*;
 import static java.util.Collections.reverse;
 import static java.lang.Integer.*;
 import static java.lang.Long.parseLong;
 import java.util.*;
 import java.util.concurrent.*;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.awt.geom.*;
 import java.io.*;
 
 //// Apache Jakarta Common Lang : http://commons.apache.org/lang/
 //import org.apache.commons.lang.builder.*;
 
 // java -Xmx1024m -Xss5m
 @SuppressWarnings(""unchecked"")
 public class B {
 //    private static final String IMPOSSIBLE = ""IMPOSSIBLE"";
     private static final String NO = ""IMPOSSIBLE"";
     public static final long MAX = Long.MAX_VALUE;
     public static final int INF = 1000000000;
     public static final int MOD = 9901; 
     public static final int UNDEF = -3;
     private static final int N = 0;
 
     /*
      * problem
      * 
      * 
      */
     /*
      * solution
      * 
      * 
      */
     private void run(int caseNumber) throws Exception {
         int A = INT();
         int B = INT();
         int K = INT();
         
         /// reading input done
         if(caseNumber<caseStart||caseNumber>caseEnd) {
             System.out.println(""### skip case ""+caseNumber);
             return;
         }
 
         
         /// start solving problem
         A--;
         B--;
         K--;
 //        long ret = small(A,B,K);
         long ret = big(A,B,K);
         
         out.printf(""Case #%d: %s\n"", caseNumber, ret);
 //        out.printf(""Case #%d:"", caseNumber);
 //        out.println();
     }
 
 
     int[] a;
     int[] b;
     int[] k;
     long[][][][] dp; 
     long big(int A, int B, int K) {
         a=bits(A);
         b=bits(B);
         k=bits(K);
         dp = new long[a.length][2][2][2];
         for (int i = 0; i < dp.length; i++) {
             for (int j = 0; j < dp[i].length; j++) {
                 for (int x = 0; x < dp[i][j].length; x++) {
                     for (int y = 0; y < dp[i][j][x].length; y++) {
                         dp[i][j][x][y]=-1;
                     }
                 }
             }
         }
         long ret=num(a.length-1,1,1,1);
 //        long ans=small(A,B,K);
 //        if (ans!=ret) {
 //            System.exit(1);
 //        }
         return ret;
     }
     
     long num(int i, int eqA, int eqB, int eqK) {
         if (i<0) {
             return 1;
         }
         
         if (dp[i][eqA][eqB][eqK]>=0) {
             return dp[i][eqA][eqB][eqK];
         }
         
         long ret=0;
         int max1=eqA>0?a[i]:1;
         int max2=eqB>0?b[i]:1;
 //        if (eqK>0) {
         {
             for (int x1 = 0; x1 <= max1; x1++) {
                 int nEqA = eqA&(x1==a[i]?1:0);
                 for (int x2 = 0; x2 <= max2; x2++) {
                     int nEqB = eqB&(x2==b[i]?1:0);
                     int x=x1&x2;
                     int nEqK = eqK&(x==k[i]?1:0);
                     if (eqK==0 || x<=k[i]) {
                         ret += num(i-1, nEqA, nEqB, nEqK);
                     }
                 }
             }
         }
         dp[i][eqA][eqB][eqK] = ret;
         return ret;
     }
 
 
     static int[] bits(int x) {
         int[] a = new int[31];
         for (int i = 0; i < a.length; i++) {
             if ((x&(1<<i))!=0) {
                 a[i]=1;
             }
         }
         return a;
     }
 
 
     static long small(int A, int B, int K) {
         long r=0;
         for (int i = 0; i <= A; i++) {
             for (int j = 0; j <= B; j++) {
                 if ((i&j)<=K) {
                     r++;
                 }
             }
         }
         return r;
     }
 
 
     static boolean printInput=false;
 //    static boolean printInput=true; // print input case
 
     static boolean printDoubleCheck=true;
 //    static boolean printDoubleCheck=false;
     
     static boolean redirectStdoutToFile=false;
 //    static boolean redirectStdoutToFile=true; // redirect all STDOUT to ""output.txt""
 
     
     static boolean writeToFile=true;
 //    static boolean writeToFile=false;
     
 //    static String testFilename=null;
 //    static String testFilename=""B-test.in"";
 //    static String testFilename=""B-small-attempt0.in"";
 //    static String testFilename=""B-small-practice.in"";
     static String testFilename=""B-large.in"";
 //    static String testFilename=""B-large-practice.in"";
     
     static int THREAD=1;
 //    static int THREAD=3;
     
     static BufferedReader in;
     static StringTokenizer inTok = new StringTokenizer("""");
 
 //    static Scanner in;
     static PrintWriter out;
 
     //control the cases to run : [caseStart..csaeEnd]
     static int caseStart=1;
 //    static int caseStart=1;
     static int caseEnd=Integer.MAX_VALUE;
 //    static int caseEnd=caseStart+0;
     
     public static void main(String[] args) throws Exception {
         String resultFilename=testFilename+""-res.txt"";
         long start = System.currentTimeMillis();
 
         // $0 inputFile caseStart caseEnd
         if(args.length>0) {
             testFilename = args[0];
         }
         if(args.length>1) {
             caseStart=parseInt(args[0]);
         }
         if(args.length>2) {
             caseEnd=parseInt(args[1]);
         }
         
         // redirect sys out
         if(redirectStdoutToFile) {            
             String filename = ""output.txt"";
             System.out.println(""NOTE: redirect stdout to file ""+filename);
             FileOutputStream fos = new FileOutputStream(filename);
             PrintStream ps = new PrintStream(fos,true);
             System.setOut(ps);
         }
         
 //        myTest();
         
         if(testFilename==null) {
             myTest();
         } else {
 //          in = new BufferedReader(new InputStreamReader(System.in));
             in = new BufferedReader(new FileReader(testFilename));
             int NN=INT();
 //            in = new Scanner(System.in);
 //            in = new Scanner(new File(testFilename));
 //            int NN=in.nextInt();
             out = writeToFile ? new PrintWriter(new FileWriter(resultFilename),true) 
                               : new PrintWriter(System.out, true);
             if (THREAD>1) {                
                 parallelSolve(NN);            
             } else {                
                 for (int i = 1; i <= NN; i++) {
 //                    out.printf(""Case #%d: "", i);
                     if (printInput) System.out.println(""\n### Case ""+i);                
                     new B().run(i);
                 }
             }
             in.close();
             
             if(writeToFile) {
                 out.close();
             }
         }
         
         System.out.println(""\nTime taken: ""+((System.currentTimeMillis()-start)/1000.0)+"" sec"");
         
         if(writeToFile) {
             File ans=new File(testFilename+""-ans.txt"");
             if(ans.exists()&&ans.length()>0) {
                 boolean same=sameFileContent(ans, new File(resultFilename), true);
                 if(same) {
                     System.out.println(""Answer correct :)"");
                     System.out.println(""Answer match file ""+ans);
                 } else {
                     System.out.println(""ERROR : Answer not matched"");
                     
                     // check other possible answer file
                     for (int i = 1; i < 9; i++) {
                         ans=new File(testFilename+""-ans""+i+"".txt"");
                         if (ans.exists() && ans.length()>0) {                            
                             same=sameFileContent(ans, new File(resultFilename), false);
                             if (same) {
                                 System.out.println(""\nAnswer correct :)"");
                                 System.out.println(""Answer match file ""+ans);
                                 break;
                             }
                         }
                     }
                 }
             }            
         }
     }
     static void parallelSolve(int totalCase) throws Exception {
         int th = Math.min(THREAD, Runtime.getRuntime().availableProcessors());
         System.out.println(""thread = ""+th);
         ExecutorService executor = Executors.newFixedThreadPool(th);
         List<Solver> solvers = new ArrayList<Solver>();
         for (int i = 1; i <= totalCase; i++) {
             if (printInput) System.out.println(""\n### Case ""+i);
 
             solvers.add(new Solver());
         }
 
         List <Future<Object>> results = executor.invokeAll(solvers);
             
         int caseNumber=1;
         for (Future<Object> result : results) {
             out.printf(""Case #%d: %s\n"", caseNumber, result.get());
             caseNumber++;
         }
         executor.shutdown();
     }
     static class Solver implements Callable<Object> {
         final int n;
 
         // Do all input reading here!!
         public Solver() throws IOException {
             n = INT();
             throw new RuntimeException(""TODO: do reading/solving in Solver()"");
         }
 
         // Do no reading here! This is run async!
         // Solve the actual problem here
         public Object call() throws Exception {
             return n;
         }
     }
     
     private static boolean sameFileContent(File ansFile, File resFile, boolean showInfo) throws IOException {
         if (showInfo) {
             System.out.println();
         }
         
         BufferedReader ans = new BufferedReader(new FileReader(ansFile));
         BufferedReader res = new BufferedReader(new FileReader(resFile));
         boolean ok=true;
         List<Integer> wrong = new ArrayList<Integer>();
         int ln=1;
         while(true) {
             String sAns=ans.readLine(); 
             String sRes=res.readLine();
             if(sAns==null) {
                 if(sRes!=null) {
                     if (showInfo) {                        
                         System.out.println(""### result has more lines than answer"");
                         do {
                             System.out.println(sRes);
                         } while ((sRes=res.readLine())!=null);
                         System.out.println();
                     }
                     ok=false;
                 }
                 break;
             }
             if(sRes==null) {
                 if(sAns!=null && !sAns.isEmpty()) {
                     if (showInfo) {                        
                         System.out.println(""### answer has more lines than result"");
                         do {
                             System.out.println(sAns);
                         } while ((sAns=ans.readLine())!=null);
                         System.out.println();
                     }
                     ok=false;
                 }
                 break;
             }
             String tAns = sAns.trim();
             String tRes = sRes.trim();
             if(!tAns.equals(tRes)) {
                 if (matchDouble(tAns,tRes, showInfo && printDoubleCheck)) {
                     if (showInfo && printDoubleCheck) {                            
                         System.out.println(""### line ""+ln+"" pass double check:"");
                         System.out.println(""ans = ""+sAns);
                         System.out.println(""res = ""+sRes);
                         System.out.println();
                     }                    
                 } else {
                     if (showInfo) {                        
                         System.out.println(""### line ""+ln+"" not match:"");
                         System.out.println(""ans = ""+sAns);
                         System.out.println(""res = ""+sRes);
                         System.out.println();
                     }
                     ok=false;
                     wrong.add(ln);
                 }
             }
             ln++;
         }
         if(!ok && showInfo) {
             System.out.println(""wrong : ""+wrong.size()+"" lines, lines start from 1: ""+wrong);
             System.out.println(""total : ""+ln+"" lines"");
         }
         ans.close();
         res.close();
         return ok;
     }    
     private static boolean matchDouble(String tAns, String tRes, boolean showInfo) {
         final double tol = 1e-6;
         
         if (!tAns.matches("".*[0-9]+\\.[0-9]+.*"") || !tRes.matches("".*[0-9]+\\.[0-9]+.*"")) {
             // no 123.456 pattern
             return false;
         }
         
         String[] sa= tAns.split("" "");
         String[] sr= tRes.split("" "");
         if (sa.length!=sr.length) {
             return false;
         }
         for (int i = 0; i < sr.length; i++) {
             if (sa[i].equals(sr[i])) continue; 
             
             try {                    
                 double a = Double.parseDouble(sa[i]);
                 double r = Double.parseDouble(sr[i]);
                 if (abs(a-r)>tol) {
                     if (showInfo) {                        
                         System.out.println(i+""-th ans!=res: ""+sa[i]+"" != ""+sr[i]);
                     }
                     return false;
                 }
             } catch (NumberFormatException e) {
                 return false;
             }
         }
         return true;
     }
 
 
     private static void myTest() throws Exception {
 //        int num=-1000;
         int num=100000;
         int max=10000;
 //        int max=1000000000;
         for (int i = 1; i <= num; ++i) {
 //            int A=Rn.i(1,max);
 //            int B=Rn.i(1,max);
 //            int K=Rn.i(1,max);
 //            
 //            System.out.println(i+"" : ""+new B().big(A,B,K));
         }
     }
 
     static String LINE() throws IOException {
         String s=in.readLine();
         if (printInput) System.out.println(s);
         return s;
     }
     static String STR() throws IOException {
         while (!inTok.hasMoreTokens()) {
             String line = LINE();
             if (line == null) {
                 return null;
             }
             inTok = new StringTokenizer(line);
         }
         return inTok.nextToken();
     }
 
     static int INT() throws IOException { return Integer.parseInt(STR()); }
     static long LONG() throws IOException { return Long.parseLong(STR()); }
     static double DOUBLE() throws IOException { return Double.parseDouble(STR()); }
     
     static int INT(String s) { return Integer.parseInt(s); }
     static double DOUBLE(String s) { return Double.parseDouble(s); }
     static long LONG(String s) { return Long.parseLong(s); }
 }
","import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Main {
 
 	public static void main(String[] args) {
 		Scanner sc = null;
 		PrintWriter out = null;
 
 		try {
 			sc = new Scanner(new FileReader(""input1.txt""));
 			out = new PrintWriter(new FileWriter(
 					""C:\\Users\\M&M\\workspace\\Lawnmower\\output1.txt""));
 		} catch (FileNotFoundException e) {
 			System.out.println(""File not found"");
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.out.println(""error"");
 		}
 
 		int numberOfCases = sc.nextInt();
 		sc.nextLine();
 		int i = 0;
 		System.out.println(numberOfCases);
 		System.out.println();
 		while (sc.hasNext()) {
 			int N = sc.nextInt();
 			int M = sc.nextInt();
 
 			// System.out.println(N);
 			// System.out.println(M);
 
 			int[][] grid = new int[N][M];
 			// System.out.println(grid.length);
 			// System.out.println(grid[0].length);
 
 			for (int j = 0; j < grid.length; j++) {
 				for (int j2 = 0; j2 < grid[0].length; j2++) {
 					grid[j][j2] = sc.nextInt();
 				}
 
 			}
 			for (int ii = 0; ii < N; ii++) {
 				for (int jj = 0; jj < M; jj++) {
 					System.out.print(grid[ii][jj] + "" "");
 				}
 				System.out.print(""\n"");
 			}
 			solve(grid, i+1, out);
 			i++;
 		}
 		out.close();
 	}
 
 	public static void solve(int[][] grid, int caseNr, PrintWriter out) {
 		boolean horiz = true;
 		boolean vert = true;
 		for (int i = 0; i < grid.length; i++) { // iterates over N
 			for (int j = 0; j < grid[0].length; j++) { // iterates over M
 				horiz = true;
 				vert = true;
 				int grassHight = grid[i][j];
 				for (int k = 0; k < grid[i].length; k++) {
 					if (grid[i][k] > grassHight) {
 						vert = false;
 						break;
 					}
 				}
 				for (int l = 0; l < grid.length; l++) {
 
 					if (grid[l][j] > grassHight) {
 						horiz = false;
 						break;
 					}
 				}
 
 				if (!vert && !horiz) {
 					System.out.println(""Case #"" + caseNr + "": NO"");
 					out.println(""Case #"" + caseNr + "": NO"");
 					return;
 				}
 			}
 		}
 		System.out.println(""Case #"" + caseNr + "": YES"");
 		out.println(""Case #"" + caseNr + "": YES"");
 		return;
 	}
 }",0
336,15282,"import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.Scanner;
 
 public class ProblemB {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			Scanner in = new Scanner(new File(""D:\\Downloads\\B-small-attempt0.in""));
 			FileWriter out = new FileWriter(""D:\\Downloads\\B.out"");
 
 			int n = in.nextInt();
 
 			for (int i = 0; i < n; i++) {
 				double c = in.nextDouble();
 				double f = in.nextDouble();
 				double x = in.nextDouble();
 
 				double spent = 0;
 				double rate = 2;
 				double next = c / rate + x / (rate + f);
 
 				while (next < x / rate) {
 					spent += c / rate;
 					rate += f;
 					next = c / rate + x / (rate + f);
 				}
 
 				spent += x / rate;
 
 				DecimalFormat decimalFormat = new DecimalFormat("".0000000"");
 				String resultString = ""Case #"" + (i + 1) + "": ""
 						+ decimalFormat.format(spent);
 				out.write(resultString + ""\n"");
 			}
 			out.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
","import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class R2B {
 
 	public static void main(String[] args) {
 		try {
 			Scanner in = new Scanner(new File(""D:\\Downloads\\B-small-attempt0 (1).in""));
 			FileWriter out = new FileWriter(""D:\\Downloads\\B.out"");
 
 			int t = in.nextInt();
 
 			for (int i = 0; i < t; i++) {
 				int a = in.nextInt();
 				int b = in.nextInt();
 				int c = in.nextInt();
 
 				int count = 0;
 				for (int j = 0; j < a; j++) {
 					for (int k = 0; k < b; k++) {
 						if ((j & k) < c) {
 							count++;
 						}
 					}
 				}
 
 				String resultString = ""Case #"" + (i + 1) + "": "" + count;
 				out.write(resultString + ""\n"");
 			}
 			out.close();
 			in.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 	}
 }
",1
337,12030,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.PriorityQueue;
 import java.util.Scanner;
 
 import org.w3c.dom.ranges.RangeException;
 
 public class Main implements Runnable {
 
 	public static void main(String[] args) throws IOException {
 		new Thread(new Main()).start();
 	}
 	
 	public void run() {
 		try {
 			run1();
 		} catch (IOException e) {
 			throw new RuntimeException();
 		}
 	}
 	
 	public void run1() throws IOException {
 		Scanner sc = new Scanner(new FileReader(""input.txt""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""output.txt""));
 		int tN = sc.nextInt();
 		sc.nextLine();
 		for (int tn = 0; tn < tN; tn++) {
 			System.out.println(""oppa"");
 			int n = sc.nextInt();
 			int[] res = new int[n];
 			int[] len = new int[n];
 			int[] d = new int[n];
 			for(int i = 0; i < n; i++) {
 				d[i] = sc.nextInt();
 				len[i] = sc.nextInt();
 			}
 			res[0] = d[0];
 			int max = 2 * res[0];
 			for(int i = 1; i < n; i++) {
 				for(int j = 0; j < i; j++) {
 					if(res[j] > 0 && res[j] >= d[i] - d[j]) {
 						res[i] = Math.min(len[i], d[i] - d[j]);
 						break;
 					}
 				}
 				if(res[i] > 0) {
 					max = Math.max(max, d[i] + res[i]);
 				}
 			}
 			if(max >= sc.nextInt()) {
 				pw.println(""Case #"" + (tn + 1) + "": YES"");
 			} else {
 				pw.println(""Case #"" + (tn + 1) + "": NO"");
 			}
 		}
 		pw.close();
 	}
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main implements Runnable {
 
 	public static void main(String[] args) throws IOException {
 		new Thread(new Main()).start();
 	}
 	
 	public void run() {
 		try {
 			run1();
 		} catch (IOException e) {
 			throw new RuntimeException();
 		}
 	}
 	
 	boolean find(int l, int r, int lh, int rh, int[] res, int[] next) {
 		List<Integer> oppa = new ArrayList<Integer>();
 		int cur = l;
 		oppa.add(l);
 		while(cur < r) {
 			cur = next[cur];
 			oppa.add(cur);
 		}
 		if(cur > r)
 			return false;
 		int step = (rh - lh + r - l + 1) / (r - l + 1);
 //		System.out.println(l + "" "" + r + "" "" + lh + "" "" + rh + "" "" + step);
 		for(int i = 0; i + 1 < oppa.size(); i++) {
 //			System.out.println(oppa.get(i));
 			res[oppa.get(i)] = rh - step * (r - oppa.get(i));
 		}
 		for(int i = 1; i < oppa.size(); i++) {
 			if(oppa.get(i) > oppa.get(i - 1) + 1)
 				if(!find(oppa.get(i - 1) + 1, oppa.get(i), res[oppa.get(i - 1)], res[oppa.get(i)], res, next))
 					return false;
 		}
 		return true;
 	}
 	
 	public void run1() throws IOException {
 		Scanner sc = new Scanner(new FileReader(""input.txt""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""output.txt""));
 		int tN = sc.nextInt();
 		sc.nextLine();
 		for (int tn = 0; tn < tN; tn++) {
 			System.out.println(""oppa"");
 			int n = sc.nextInt();
 			int[] next = new int[n];
 			for(int i = 0; i + 1 < n; i++) {
 				next[i] = sc.nextInt() - 1;
 			}
 			next[n - 1] = n;
 			int[] res = new int[n];
 			res[n - 1] = 800000000;
 			boolean op = find(0, n - 1, 800000001, 800000000, res, next);
 			if(!op) {
 				pw.println(""Case #"" + (tn + 1) + "": Impossible"");
 			} else {
 				pw.print(""Case #"" + (tn + 1) + "":"");
 				for(int i = 0; i < n; i++) {
 					pw.print("" "" + res[i]);
 				}
 				pw.println();
 			}
 		}
 		pw.close();
 	}
 }
",1
338,16624,"import java.io.File;
 import java.io.FileOutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 
 public class Problem2 {
 	private static final String INPUT = ""d:/input.txt"";
 	
 	private static final String OUTPUT = ""d:/output.txt"";
 	
 	private static PrintWriter output;
 	
 	private static Scanner input;
 	
 	private static class Group {
 		double position;
 		int count;
 		int maxSpeed;
 		int minSpeed;
 		@Override
 		public String toString() {
 			return ""["" + position + ""]["" + count + ""]["" + maxSpeed + ""]["" + minSpeed +""]"";
 		}
 	}
 	
 	private static void exec() throws Exception {
 		int n = input.nextInt();
 		int k = input.nextInt();
 		int b = input.nextInt();
 		int t = input.nextInt();
 		int[] x = new int[n];
 		int[] v = new int[n];
 		int count = 0;
 		for (int i = 0; i < n; i++)
 			x[i] = input.nextInt();
  		for (int i = 0; i < n; i++) {
 			v[i] = input.nextInt();
  		}
  		boolean ok = false;
  		for (int w = 0; w < t; w++) {
  			for (int j = 0; j < n; j++) {
  				x[j] += v[j];
  			}
  			for (int j = n - 2; j >= 1; j--) {
  				if (x[j] > x[j + 1]) {
  					x[j] = x[j + 1];
  				}
  			}
 /* 			for (int j = 0; j < n; j++) {
  				System.out.print(x[j] + "" "");
  			}
  			System.out.println();*/
  			
  			if (w == t - 1) {
  				int pp = 0;
  				for (int j = 0; j < n; j++) {
  					if (x[j] >= b) {
  						pp++;
  					}
  				}
  				if (pp >= k) {
  					ok = true;
  				}
  				break;
  			}
  			
  			int p = 1, q = 0, max = v[0];
  			while (p < n && x[p] <= x[0]) {
  				if (v[p] > max)
  					max = v[p];
  				p++;
  				q++;
  				count++;
  			}
  			int m = n - q;
  			int[] xx = new int[m];
  			int[] vv = new int[m];
  			for (int j = p, s = 1; j < n; j++, s++) {
  				xx[s] = x[j];
  				vv[s] = v[j];
  			}
  			xx[0] = x[0];
  			vv[0] = max;
  			n = m;
  			x = xx;
  			v = vv;
  		}
  		if (!ok) {
  			output.print(""IMPOSSIBLE"");
  		} else {
  			output.print(count);
  		}
  		
 	}
 	
 	public static void main(String[] args) throws Exception {
 		input = new Scanner(new File(INPUT));
 		output = new PrintWriter(new OutputStreamWriter(new FileOutputStream(OUTPUT)));
 		int n = input.nextInt();
 		for (int i = 0; i < n; i++) {
 			output.print(""Case #"" + (i + 1) + "": "");
 			exec();
 			output.println();
 		}
 		output.close();
 		input.close();
 	}
 
 
 }
","/*
 GCJ2011-Round 1C
 
 */
 
 import java.io.*;
 import java.util.*;
 import java.math.*;
 
 public class A2011R1C {
 	static BufferedReader fin;
     static PrintWriter fout;
     // chnage numefile
     static String file=""a1"";
     static String infile=file+"".in"";
     static String outfile=file+"".out"";
     //
   	static char[][] t;
   	static int R, C;
 	// write result to output file
 	private static void writetestresult(int test, String ret){
 		fout.println(""Case #""+test+"":"");
 	}
 	
 	// open files
 	private static void openfiles() throws IOException{
 		fin = new BufferedReader(new FileReader(infile));
 	    fout = new PrintWriter(new BufferedWriter(new FileWriter(outfile)));
 	}
 	
 	// close files
 	private static void closefiles() throws IOException{
 		fin.close();
 		fout.close();
 	}
 	private static boolean inside (int x, int y){
 		if (x>=0 && x<R && y>=0 && y<C) return true;
 		return false;
 		
 	}
 	 // solve test no. ""test""
 	private static String solvetest(int test) throws IOException{
 		// System.out.println("">>>Solving test...""+test);
 		// Parse input for test no. test
 		String imp=""Impossible"";
 		String pos="" "";
 		String a=fin.readLine();	
 		String[] as=a.split("" "");
 		int r=Integer.parseInt(as[0]); R=r;
 		int c=Integer.parseInt(as[1]); C=c;
 		 t=new char[r][c];
 		//rt=new char[r][c];
 		for (int i=0; i<r; i++) {
 			String row=fin.readLine();
 			for (int j=0; j<c; j++) t[i][j]=row.charAt(j);
 		}
 		for (int i=0; i<r; i++)
 			for (int j=0; j<c; j++)
 				if (t[i][j]=='#') {
 					boolean ok1=false, ok2=false, ok3=false;
 					t[i][j]='/';
 					if (inside(i, j+1)) if(t[i][j+1]=='#') {t[i][j+1]='\\'; ok1=true;} else return imp;
 					if (inside(i+1, j+1)) if(t[i+1][j+1]=='#') {t[i+1][j+1]='/'; ok2=true;}else return imp;
 					if (inside(i+1, j)) if(t[i+1][j]=='#') {t[i+1][j]='\\'; ok3=true;} else return imp;
 					if (!(ok1 && ok2 && ok3)) return imp;
 				}
 		return pos;
 		
 	
 	}
 	
 	// main here
 	public static void main(String[] args) throws IOException{
 		// open files
 		openfiles();
 		// read first line, usually representing no. of tests
 		String line=fin.readLine();
 		int T=Integer.parseInt(line);    
 		// solve T tests
 		for (int test=1; test<=T; test++) {	    	
 			//long stime=System.currentTimeMillis();
 			
 			String ret=solvetest(test);
 			if (ret==""Impossible"") {
 				writetestresult(test, ret);
 				fout.println(ret);
 			} else {
 				writetestresult(test, ret);
 				for (int i=0; i<R; i++){
 					String ol=new String(t[i]);
 					fout.println(ol);
 					
 				}
 			}
 			
 			
 			//long etime=System.currentTimeMillis();
 	    	//long dtime=(etime-stime);
 	    	//System.out.println(""Test ""+test+"": ""+dtime+""ms"");
 		}	    
 		// close files
 		closefiles();
 	}
 }
",0
339,20152,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Arrays;
 
 
 public class DeceitfulWar {
 	
 	private String filename;
 	
 	public DeceitfulWar(String filename){
 		this.filename = filename;
 	}
 	
 	public void run() throws IOException{
 		BufferedReader in = new BufferedReader(new FileReader(new File(filename)));
 		int cases = new Integer(in.readLine());
 		String res = """";
 		for(int i = 1; i <= cases; i++){
 			res += ""Case #""+i+"": "";
 			double[] naomi, ken;
 			in.readLine();
 			naomi = fillArray(in.readLine());
 			ken = fillArray(in.readLine());
 			res += playDeceitfulWar(naomi.clone(), ken.clone())+"" "";
 			res += playWar(naomi, ken);
 			res += ""\n"";
 		}
 		System.out.println(res);
 		BufferedWriter out = new BufferedWriter(new FileWriter(new File(""out.txt"")));
 		out.write(res);
 		out.flush();
 		out.close();
 		in.close();
 	}
 
 	private int playDeceitfulWar(double[] naomi, double[] ken) {
 		int pNaomi = 0;
 		int index = naomi.length-1;
 		double val = naomi[index--];
 		for(int i = ken.length - 1; i >= 0 ; i--){
 			if(ken[i] < val){
 				if(i != 0){
 					val = naomi[index--];
 				}
 				pNaomi++;
 			}
 		}			
 		return pNaomi;
 	}
 
 	private int playWar(double[] naomi, double[] ken) {
 		int pNaomi = 0;
 		for(int i = naomi.length - 1; i >= 0 ; i--){
 			double val = naomi[i];
 			pNaomi++;
 			for(int j = 0; j < ken.length; j++){
 				if(ken[j] > val){
 					ken[j] = 0;
 					pNaomi--;
 					break;
 				}
 			}
 			
 		}
 		return pNaomi;
 	}
 
 	private double[] fillArray(String line) {
 		String[] elements = line.split("" "");
 		double[] values = new double[elements.length];
 		for(int i = 0; i < elements.length; i++)
 			values[i] = new Double(elements[i]);
 		Arrays.sort(values);
 		return values;
 	}
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 */
 	public static void main(String[] args) throws IOException {
 		new DeceitfulWar(""D-small-attempt0.in"").run();
 	}
 
 }
","import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.math.BigInteger;
 import java.util.Scanner;
 
 public class SolverC {
 
     private static final String fileName = ""C-small-0"";
     private static final BigInteger two = BigInteger.valueOf(2);
 
     private Writer out;
 
     private Scanner in;
     private String chars;
     private int charsPos;
 
     private int T;
     private int case_;
 
     public static void main(String[] args) throws IOException {
         new SolverC().solve();
     }
 
     public void solve() throws IOException {
         in = new Scanner(new File(fileName + "".in""));
         out = new FileWriter(fileName + "".out"");
         T = in.nextInt();
 
         int lastProgress = 0;
         for (case_ = 0; case_ < T; case_++) {
             int progress = case_ * 10 / T;
             if (progress > lastProgress) {
                 System.out.println(progress + ""0%, "" + case_ + ""/"" + T);
                 lastProgress = progress;
             }
 
             BigInteger A = in.nextBigInteger();
             BigInteger B = in.nextBigInteger();
             BigInteger res = BigInteger.ZERO;
             while(A.compareTo(B) <= 0) {
                 if (isPalindrome(A)) {
                     BigInteger s = sqrRoot(A);
                     if (s != null) {
                         if (isPalindrome(s)) {
                             res = res.add(BigInteger.ONE);
                         }
                     }
                 }
                 A = A.add(BigInteger.ONE);
             }
             result(res.toString());
         }
         out.close();
     }
 
     private BigInteger sqrRoot(BigInteger i) {
         if (i.compareTo(BigInteger.ONE) <= 0) {
             return i;
         }
         BigInteger j;
         for (j = i.divide(two);
              j.compareTo(i.divide(j)) > 0;
              j = ((i.divide(j)).add(j)).divide(two));
         return i.compareTo(j.multiply(j)) == 0 ? j : null;
     }
 
     private boolean isPalindrome(BigInteger bi) {
         String s = bi.toString();
         int j = s.length();
         int end = j / 2;
         for (int i = 0; i < end; i++) {
             if (s.charAt(i) != s.charAt(--j)) {
                 return false;
             }
         }
         return true;
     }
 
     private void result(String res) throws IOException {
         out.write(""Case #"" + (case_ + 1) + "": "" + res + ""\n"");
     }
 
     private char nextChar() {
         if (chars == null) {
             chars = in.next();
             charsPos = 0;
         } else {
             charsPos++;
         }
         return chars.charAt(charsPos);
 
     }
 
     private void endChars() {
         if (chars.length() > charsPos + 1) {
             throw new RuntimeException(""String wasn't read fully: "" + chars + "", pos: "" + charsPos);
         }
         chars = null;
     }
 }
",0
340,2661,"import java.io.BufferedReader;
 import java.io.IOException;
 import java.util.Scanner;
 
 
 public class InputType {
 	int numberOfCombinations;
 	int numberOfOppositions;
 	int numberOfElements;
 
 	String[] combinations;
 	String[] oppositions;
 	String elements;
 	
 	public InputType() {
 		super();
 	}
 
 	public InputType(int numberOfCombinations, int numberOfOppositions,
 			int numberOfElements) {
 		super();
 		this.numberOfCombinations = numberOfCombinations;
 		this.numberOfOppositions = numberOfOppositions;
 		this.numberOfElements = numberOfElements;
 	}
 
 	public int getNumberOfCombinations() {
 		return numberOfCombinations;
 	}
 
 	public void setNumberOfCombinations(int numberOfCombinations) {
 		this.numberOfCombinations = numberOfCombinations;
 	}
 
 	public int getNumberOfOppositions() {
 		return numberOfOppositions;
 	}
 
 	public void setNumberOfOppositions(int numberOfOppositions) {
 		this.numberOfOppositions = numberOfOppositions;
 	}
 
 	public int getNumberOfElements() {
 		return numberOfElements;
 	}
 
 	public void setNumberOfElements(int numberOfElements) {
 		this.numberOfElements = numberOfElements;
 	}
 
 	
 	public String[] getCombinations() {
 		return combinations;
 	}
 
 	public void setCombinations(String[] combinations) {
 		this.combinations = combinations;
 	}
 
 	public String[] getOppositions() {
 		return oppositions;
 	}
 
 	public void setOppositions(String[] oppositions) {
 		this.oppositions = oppositions;
 	}
 
 	public String getElements() {
 		return elements;
 	}
 
 	public void setElements(String elements) {
 		this.elements = elements;
 	}
 
 	public int elementInOpposition(char element1, char element2){
 		StringBuffer combi = new StringBuffer (""""+element1+element2);
 		for (int i=0;i<numberOfOppositions;++i){
 			if (oppositions[i].contains(combi)||oppositions[i].contains(combi.reverse())){
 				return i;
 			}
 		}
 		return -1;
 	}
 	
 	public boolean checkOppositionExists (String currentElementList, char elementToBeAdded){
 		for (int i=0;i<currentElementList.length();++i){
 			if (-1 != elementInOpposition(currentElementList.charAt(i), elementToBeAdded)){
 				return true; 
 			}
 		}
 		return false;
 	}
 	
 	public char getCombinationCharacter (char lastElementInList, char elementToBeAdded){
 		StringBuffer combi = new StringBuffer (""""+lastElementInList+elementToBeAdded);
 		String substr;
 		for (int i=0;i<combinations.length;++i){
 			substr = combinations[i].substring(0, 2);
 			if (substr.contains(combi)|| substr.contains(combi.reverse())){
 				if(0!=combinations[i].length())
 					return combinations[i].charAt(2);
 			}
 		}
 		return '0';
 	}
 	
 	public void populate(BufferedReader reader ) throws IOException{
 		String line;
 		String[] splitInput;
 		line = reader.readLine();
 		splitInput = line.split("" "");
 		int i=0;
 		numberOfCombinations = Integer.parseInt(splitInput[i++]);
 	//	System.out.println(""numberOf combis :""+(i-1) +"" ""+numberOfCombinations);
 		combinations = new String[numberOfCombinations];
 		for (int j =0;j<numberOfCombinations;++j){
 			combinations[j]=splitInput[i++];
 	//		System.out.println(j +"") ""+ combinations[j]);
 		}
 		numberOfOppositions = Integer.parseInt(splitInput[i++]);
 	//	System.out.println(""number of oppos: ""+ numberOfOppositions);
 		oppositions = new String [numberOfOppositions];
 		for (int j =0;j<numberOfOppositions;++j){
 			oppositions[j]=splitInput[i++];
 	//		System.out.println(j +"") ""+ oppositions[j]);
 		}
 		numberOfElements = Integer.parseInt(splitInput[i++]);
 	//	System.out.println(""number of elements : ""+numberOfElements);
 		elements = splitInput[i];
 	//	System.out.println(elements);
 	}
 	
 	@Override
 	protected Object clone() throws CloneNotSupportedException {
 		// TODO Auto-generated method stub
 		return super.clone();
 	}
 
 	@Override
 	public String toString() {
 		// TODO Auto-generated method stub
 		return super.toString();
 	}
 
 }
","import java.util.ArrayDeque;
 import java.util.BitSet;
 import java.util.HashSet;
 import java.util.Queue;
 import java.util.Scanner;
 
 
 public class ChargingChaos {
 
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		
 		int T = in.nextInt();
 		for (int caseNo = 1; caseNo <= T; caseNo++)
 		{
 			int N = in.nextInt(),
 				L = in.nextInt();
 			
 			BitSet[] outlets = new BitSet[N];
 			HashSet<BitSet> devices = new HashSet<BitSet>();
 			for (int i = 0; i < N; i++)
 			{
 				outlets[i] = new BitSet(L);
 				String s = in.next();
 				for (int j = 0; j < L; j++)
 				{
 					if (s.charAt(j) == '1')
 					{
 						outlets[i].set(j, true);
 					}
 				}
 			}
 			for (int i = 0; i < N; i++)
 			{
 				BitSet device = new BitSet(L);
 				String s = in.next();
 				for (int j = 0; j < L; j++)
 				{
 					if (s.charAt(j) == '1')
 					{
 						device.set(j, true);
 					}
 				}
 				devices.add(device);
 			}
 			
 			
 			BitSet switches = new BitSet(L);
 			HashSet<BitSet> visited = new HashSet<BitSet>();
 			visited.add(switches);
 			Queue<BitSet> q = new ArrayDeque<BitSet>();
 			q.add(switches);
 			boolean possible = false;
 			
 			while (!q.isEmpty())
 			{
 				BitSet flips = q.poll();
 				boolean chargeAll = true;
 				for (int i = 0; i < N; i++)
 				{
 					BitSet flippedOutlet = (BitSet) outlets[i].clone();
 					flippedOutlet.xor(flips);
 					if (!devices.contains(flippedOutlet))
 					{
 						chargeAll = false;
 						break;
 					}
 				}
 				
 				if (chargeAll)
 				{
 					System.out.println(""Case #"" + caseNo + "": "" + flips.cardinality());
 					possible = true;
 					break;
 				}
 				
 				for (int i = 0; i < L; i++)
 				{
 					BitSet newFlip = (BitSet) flips.clone();
 					newFlip.set(i, true);
 					if (!visited.contains(newFlip))
 					{
 						visited.add(newFlip);
 						q.add(newFlip);
 					}
 				}
 			}
 			
 			if (!possible)
 			{
 				System.out.println(""Case #"" + caseNo + "": NOT POSSIBLE"");
 			}
 		}
 	}
 
 }
",0
341,15557,"package com.hunorkovacs.fairandsquare;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Reader {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(Reader.class);
     private static final String INPUT_FILE = ""C-small-attempt0.in"";
 
     public List<Case> read() throws IOException {
         BufferedReader fileReader = new BufferedReader(new FileReader(INPUT_FILE));
 
         String line = fileReader.readLine();
         LOGGER.debug(""Read from file, line: {}"", line);
         int nCases = new Integer(line);
         List<Case> cases = new ArrayList<Case>();
         for (int caseIndex = 0; caseIndex < nCases; caseIndex++) {
 
             line = fileReader.readLine();
             LOGGER.debug(""Read from file, line: {}"", line);
             int low = new Integer(line.split("" "")[0]);
             int high = new Integer(line.split("" "")[1]);
 
             cases.add(new Case(low, high));
         }
         fileReader.close();
         return cases;
     }
 }
","package com.google.codejam.qualification;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 public class TicTacToe {
 
 	/**
 	 * @param args
 	 * @throws IOException 
 	 * @throws NumberFormatException 
 	 */
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		BufferedReader br = new BufferedReader(new FileReader(""C:\\Users\\Dhruv Chaudhary\\Desktop\\A-small-attempt1.in""));
 		int testCases = Integer.parseInt(br.readLine().trim());
 		int board[][] = new int[4][4];
 		String message = """";
 		int num = 0;
 		while(num++ < testCases) {
 			message = null;
 			for(int i=0; i < 4; i++) {
 				String line = br.readLine();
 				for(int j = 0; j < 4; j++) {
 					switch(line.charAt(j)){
 					case 'X': 
 						board[i][j] = 1;
 						break;
 					case 'T':
 						board[i][j] = 100;
 						break;
 					case 'O': 
 						board[i][j] = 0;
 						break;
 					case '.':
 						board[i][j] = 10;
 						break;
 					}
 				}
 			}
 			
 			int sumRow[] = new int[4];
 			int sumCol[] = new int[4];
 			int sumLeadDiag = 0;
 			int sumTrailDiag = 0;
 			
 			for(int i = 0; i < 4; i++) {
 				for(int j = 0; j < 4; j++) {
 					sumRow[i] += board[i][j];
 					sumCol[j] += board[i][j];
 					
 					if(i == j)
 						sumLeadDiag += board[i][j];
 					else {
 						if(( i == 0 && j == 3)
 								|| (i == 1 && j == 2)
 								|| (i == 2 && j == 1)
 								|| (i == 3 && j == 0)) {
 							sumTrailDiag += board[i][j];
 						}
 					}
 				}
 			}
 			
 			boolean empty = false;
 			if(sumLeadDiag == 0 || sumTrailDiag == 0 || sumLeadDiag == 100 || sumTrailDiag == 100) {
 				message = ""Case #"" + (num ) + "": O won"";
 			} else if(sumLeadDiag == 4 || sumTrailDiag == 4 || sumLeadDiag == 103 || sumTrailDiag == 103) {
 				message = ""Case #"" + (num + 1) + "": X won"";
 			} else {
 				for(int i=0;i<4;i++) {
 					if(sumRow[i] == 4 || sumRow[i] == 103 || sumCol[i] == 4 || sumCol[i] == 103) {
 						message = ""Case #"" + (num ) + "": X won"";
 					} else if(sumRow[i] == 0 || sumRow[i] == 100 || sumCol[i] == 0 || sumCol[i] == 100) {
 						message = ""Case #"" + (num ) + "": O won"";
 					} else if((sumCol[i] >= 10 && sumCol[i] <= 40) || (sumRow[i] >=10 && sumRow[i] <= 40)) {
 						empty = true;
 					}
 				}
 			}
 			
 			if(message == null) {
 				if(empty) {
 					message = ""Case #"" + (num ) + "": Game has not completed"";
 				} else {
 					message = ""Case #"" + (num ) + "": Draw"";
 				}
 			} 
 
 			System.out.println(message);
 			br.readLine();
 		}
 	}
 
 }
 
",0
342,14826,"package code_jam;
 
 import java.io.*;
 import java.util.*;
 
 public class d {
   public static void main(String[] args) throws Exception{
     Scanner inf = new Scanner(new FileReader(""D-large.in""));
    
     int nn = inf.nextInt();
     for (int ii = 0; ii < nn; ii++) {
 
       int n = inf.nextInt();
       double[] a = new double[n];
       double[] b = new double[n];
       for (int i=0; i<n; i++) 
         a[i] = inf.nextDouble();
       Arrays.sort(a);
       for (int i=0; i<n; i++)
         b[i] = inf.nextDouble();
       Arrays.sort(b);
       
       int ansa=0, ansb=0;
       int l=0, r=n-1;
       for (int i=n-1; i>=0; i--) {
         if (a[i]>b[r]) {
           ansa++;
           l++;
         } else r--;
       }
       
       l=0; 
       r=n-1;
       for (int i=n-1; i>=0; i--) {
         //System.out.println(b[i]+""\t""+a[r]);
         if (b[i]>a[r])
           l++;
         else {
           ansb++;
           r--;
         }
       }
       System.out.println(""Case #"" + (ii+1) + "": "" + ansb + "" "" + ansa);
     }
     inf.close();
   }
 }
","package code_jam;
 
 import java.io.*;
 import java.util.*;
 
 public class b {
   static boolean[][][] f = new boolean[51][][];
   static int[][][] use = new int[51][][];
   static int r, c;
   public static void output(FileWriter outf, int i, int j, int k) throws Exception{
     System.out.println(i+""\t""+j+""\t""+k +""\t""+ use[i][j][k]);
     for (int l=0; l<j; l++) 
       if (i == r-1 && l==0) outf.write('c'); else outf.write('.');
     for (int l=j; l<c; l++)
       outf.write('*');
     outf.write('\n');
     if (i>0) output(outf, i-1, use[i][j][k], k-j);
   }
   
   public static void main(String[] args) throws Exception{
     Scanner inf = new Scanner(new FileReader(""in.txt""));
     FileWriter outf = new FileWriter(""out.txt"");
 
     for (int i=0; i<=50; i++) {
       f[i] = new boolean[51][];
       use[i] = new int[51][];
       for (int j=0; j<51; j++) {
         f[i][j] = new boolean[2500];
         use[i][j] = new int[2500];
       }
     }
     
     int nn = inf.nextInt();
     for (int ii = 0; ii < nn; ii++) {
       System.out.println(""Case #"" + (ii+1) + "":\n"");
       outf.write(""Case #"" + (ii+1) + "":\n"");
       r = inf.nextInt();
       c = inf.nextInt();
       int m = inf.nextInt();
       if (r * c - 1 == m) {
         outf.write(""c"");
         for (int i=0; i<r; i++) {
           for (int j=0; j<c; j++)
             if (i + j > 0) outf.write(""*"");
           outf.write(""\n"");
         }
         continue;
       }
       if (r == 1 || c == 1) {
         for (int i=0; i<m; i++)
           if (r==1) outf.write(""*""); else outf.write(""*\n"");
         for (int i=m; i<r-1 || i<c-1; i++)
           if (r==1) outf.write('.'); else outf.write("".\n""); 
         outf.write(""c\n"");
         continue;
       }
       int e = c*r - m;
       for (int i=0; i<=c; i++) {
         for (int j=0; j<=e; j++)
           f[0][i][i] = false;
         if (i!=1) f[0][i][i] = true;
       }
       f[0][0][0] = true;
       
       
       for (int i=1; i<r; i++)
         for (int j=0; j<=c; j++)
           for (int k=j; k<=e; k++) {
             if (j==1) {
               f[i][j][k]=false;
               continue;
             }
             if (i<r-1) {
               for (int last=0; last<=j; last++) 
                 if (f[i-1][last][k-j]) {
                   f[i][j][k] = true;
                   use[i][j][k] = last;
                   break;
                 }
             } else {
               f[i][j][k] = f[i-1][j][k-j];
               use[i][j][k] = j;
             }
           }
       boolean flag = true;
       for (int i=2; i<=c; i++)
         if (f[r-1][i][e]) {
           output(outf, r-1, i, e);
           flag = false;
           break;
         }
       if (flag) outf.write(""Impossible\n"");
     }
     inf.close();
     outf.close();
   }
 }
",1
343,8919,"package lawnmower;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         File archivoEntrada = new File(""C:\\Users\\Jonnathan\\Downloads\\B-large.in"");
         File archivoSalida = new File(""C:\\Users\\Jonnathan\\Downloads\\B-large.txt"");
 
         PrintWriter salida;
         InputStream entrada = new FileInputStream(archivoEntrada);
         Scanner cin = new Scanner(entrada);
 
         int cases;
         List<String> results = new ArrayList<>();
         if (archivoSalida.exists()) {
             archivoSalida.delete();
         }
         salida = new PrintWriter(archivoSalida);
         int lowest = 100;
         if (cin.hasNextInt()) {
             cases = cin.nextInt();
             for (int k = 0; k < cases; k++) {
                 int rows = cin.nextInt();
                 int cols = cin.nextInt();
                 int m[][] = new int[rows][cols];
                 for(int i=0; i < rows; i++){
                     for(int j=0; j < cols; j++){
                         m[i][j] = cin.nextInt();
                         if(m[i][j] < lowest){
                             lowest = m[i][j];
                         }
                     }
                 }
                 results.add(testPattern(k+1,m,rows,cols,lowest));
             }
         }
         for (String r : results) {
             System.out.println(r);
             salida.println(r);
         }
         salida.close();
         entrada.close();
     }
     
     private static String testPattern(int caseNumber, int m[][], int rows, int cols, int lowest){
         StringBuilder sb = new StringBuilder(""Case #"");
         sb.append(caseNumber);
         sb.append("": "");
         
         boolean possible = true;
         
         for(int i=0; i < rows; i++){
             for(int j=0; j < cols; j++){
                 if(m[i][j] == lowest){
                     if(!isRowPossible(lowest,m[i],cols) && !isColPossible(lowest,m,j,rows)){
                         possible = false;
                         break;
                     }
                 }
             }
             if(!possible){
                 break;
             }
         }
         
         if(possible){
             sb.append(""YES"");
         } else {
             sb.append(""NO"");
         }
         
         return sb.toString();
     }
     
     private static boolean isRowPossible(int lowest, int[] row, int length){
         for(int i=0; i < length; i++){
             if(row[i] != lowest){
                 return false;
             }
         }
         return true;
     }
     
     private static boolean isColPossible(int lowest, int m[][], int col, int rows){
         for(int i=0; i < rows; i++){
             if(m[i][col] != lowest){
                 return false;
             }
         }
         return true;
     }
     
 }
","package tic.tac.toe.tomek;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class Main {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
         File archivoEntrada = new File(""C:\\Users\\Jonnathan\\Downloads\\A-large.in"");
         File archivoSalida = new File(""C:\\Users\\Jonnathan\\Downloads\\A-large.txt"");
 
         PrintWriter salida;
         InputStream entrada = new FileInputStream(archivoEntrada);
         Scanner cin = new Scanner(entrada);
 
         int cases;
         List<String> results = new ArrayList<>();
         if (archivoSalida.exists()) {
             archivoSalida.delete();
         }
         salida = new PrintWriter(archivoSalida);
         if (cin.hasNextInt()) {
             cases = cin.nextInt();
             for (int i = 0; i < cases; i++) {
                 cin.nextLine();
                 String input[] = new String[4];
                 for (int j = 0; j < 4; j++) {
                     input[j] = cin.nextLine();
                 }
                 results.add(findResult(i + 1, input));
             }
         }
         for (String r : results) {
             System.out.println(r);
             salida.println(r);
         }
         salida.close();
         entrada.close();
     }
 
     private static String findResult(int caseNumber, String input[]) {
         StringBuilder sb = new StringBuilder(""Case #"");
         sb.append(caseNumber);
         sb.append("": "");
 
         boolean end = false;
 
         String input2[] = new String[4];
         //turn matrix 90º
         for (int i = 0; i < 4; i++) {
             StringBuilder s = new StringBuilder();
             for (int j = 0; j < 4; j++) {
                 s.append(input[j].charAt(i));
             }
             input2[i] = s.toString();
         }
         
         //this is for diagonal, there are only 2
         String input3[] = new String[2];
         StringBuilder tmp = new StringBuilder();
         for(int i=0; i < 4; i++){
             tmp.append(input[i].charAt(i));
         }
         input3[0] = tmp.toString();
         tmp = new StringBuilder();
         for(int i=0; i < 4; i++){
             tmp.append(input[i].charAt(3-i));
         }
         input3[1] = tmp.toString();
 
         final String match1 = ""[TX][TX][TX][TX]"";
         final String match2 = ""[TO][TO][TO][TO]"";
 
         //test if X won - row
         for (String s : input) {
             if (s.matches(match1)) {
                 end = true;
                 sb.append(""X won"");
                 break;
             }
         }
 
         if (!end) {
             //test if X won - column
             for (String s : input2) {
                 if (s.matches(match1)) {
                     end = true;
                     sb.append(""X won"");
                     break;
                 }
             }
         }
         
         if(!end){
             //test if X won diags
             for (String s : input3) {
                 if (s.matches(match1)) {
                     end = true;
                     sb.append(""X won"");
                     break;
                 }
             }
         }
 
         if (!end) {
             //test if O won - row
             for (String s : input) {
                 if (s.matches(match2)) {
                     end = true;
                     sb.append(""O won"");
                     break;
                 }
             }
         }
         
         if(!end){
             //test if O won - column
             for (String s : input2) {
                 if (s.matches(match2)) {
                     end = true;
                     sb.append(""O won"");
                     break;
                 }
             }
         }   
         
         if(!end){
             //test if O won diags
             for (String s : input3) {
                 if (s.matches(match2)) {
                     end = true;
                     sb.append(""O won"");
                     break;
                 }
             }
         }
         
         if(!end){
             for (String s : input3) {
                 if (s.contains(""."")) {
                     end = true;
                     sb.append(""Game has not completed"");
                     break;
                 }
             }
         } 
         
         if(!end){
             sb.append(""Draw"");
         }
 
         return sb.toString();
     }
 }",1
344,1093,"import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class TicTacToe {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception{
 		Scanner sc  = new Scanner(new FileReader(""A-large.in""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""output.out""), true);	
 		int T = Integer.parseInt(sc.nextLine());
 		
 		outer:for(int t=1;t<=T;t++){
 			char[][] board = new char[4][4];
 			//int ti=0, tj=0;
 			boolean foundDot=false;
 			for(int i=0;i<4;i++){
 				String temp = sc.nextLine();
 				for(int j=0;j<4;j++){
 					board[i][j] = temp.charAt(j);
 //					if(board[i][j]=='T'){
 //						ti=i;
 //						tj=j;
 //					}
 					if(board[i][j]=='.'){
 						foundDot = true;
 					}
 				}
 			}
 			if(t!=T)sc.nextLine();
 		
 			for(int i=0;i<4;i++){
 				boolean same = true;
 				char prev = board[i][0];
 				if(prev=='T'){
 					prev = board[i][1];
 				}
 				if(prev=='.'){
 					continue;
 				}
 				for(int j=1;j<4;j++){
 					if(board[i][j]!=prev && board[i][j]!='T'){
 						same = false;
 						break;
 					}
 				}
 				if(same){
 					char c = prev;
 					pw.println(""Case #""+t+"": ""+c+"" won"");
 					continue outer;
 				}
 				
 			}
 			for(int i=0;i<4;i++){
 				boolean same = true;
 				char prev = board[0][i];
 				if(prev=='T'){
 					prev = board[1][i];
 				}
 				if(prev=='.'){
 					continue;
 				}
 				for(int j=1;j<4;j++){
 					if(board[j][i]!=prev && board[j][i]!='T'){
 						same = false;
 						break;
 					}
 				}
 				if(same){
 					char c = prev;
 					pw.println(""Case #""+t+"": ""+c+"" won"");
 					continue outer;
 				}
 				
 			}
 			char prev = board[0][0];
 			if(prev=='T'){
 				prev = board[1][1];
 			}
 			
 			boolean same = true;
 			for(int i=1,j=1;i<4 && j<4;i++,j++){
 				if(prev=='.'){
 					same =false;
 					break;
 				}
 				if(board[i][j]!=prev && board[i][j]!='T'){
 					same = false;
 					break;
 				}
 			}
 			if(same){
 				char c = prev;
 				pw.println(""Case #""+t+"": ""+c+"" won"");
 				continue outer;
 			}
 			prev = board[0][3];
 			if(prev=='T'){
 				prev = board[1][2];
 			}
 			same = true;
 			for(int i=1,j=2;i<4 && j>=0;i++,j--){
 				if(prev=='.'){
 					same=false;
 					break;
 				}
 				if(board[i][j]!=prev && board[i][j]!='T'){
 					same = false;
 					break;
 				}
 			}
 			if(same){
 				char c = prev;
 				pw.println(""Case #""+t+"": ""+c+"" won"");
 				continue outer;
 			}
 			
 			if(!foundDot){
 				pw.println(""Case #""+t+"": Draw"");
 			}else{
 				pw.println(""Case #""+t+"": Game has not completed"");
 			}
 		}
 		pw.close();
 
 	}
 
 }
","import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class MainClass {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws IOException {
 		// TODO Auto-generated method stub
 		Scanner sc = new Scanner(new File(""B-large.in""));
 		PrintWriter out = new PrintWriter(new File(""Dancing-large.out""));
 
 		int T = sc.nextInt();
 		for (int i = 0; i < T; i++) {
 			int ans = 0;
 
 			int N = sc.nextInt(), S = sc.nextInt(), p = sc.nextInt();
 			ArrayList<Integer> sums = new ArrayList<Integer>();
 			for (int j = 0; j < N; j++) {
 				sums.add(sc.nextInt());
 			}
 			for (int j = 0; j < N; j++) {
 				int tempP = p;
 
 				int sum = sums.get(j);
 				int sumBackup = sum;
 				while (tempP <= 10 && tempP <= sumBackup) {
 					sum = sums.get(j);
 					sum -= tempP;
 					int half = sum / 2;
 					int half2 = sum - half;
 
 					if ((Math.abs(half2 - half) <= 1)
 							&& (Math.abs(half2 - tempP) <= 1)
 							&& (Math.abs(tempP - half) <= 1)) {
 						ans++;
 						int test = sums.remove(j);
 						// System.out.println(test + ""\t "" + tempP + ""\t"" + half
 						// + ""\t"" + half2);
 						j--;
 						N--;
 						break;
 					}
 					tempP++;
 
 				}
 
 			}
 			// System.out.println(S);
 			outer: for (int j = 0; j < N; j++) {
 				int tempP = p;
 
 				int sum = sums.get(j);
 				int sumBackup = sum;
 				while (tempP <= 10 && tempP <= sumBackup) {
 					sum = sums.get(j);
 					sum -= tempP;
 					int half = sum / 2;
 					int half2 = sum - half;
 					if ((Math.abs(half2 - half) <= 2)
 							&& (Math.abs(half2 - tempP) <= 2)
 							&& Math.abs(tempP - half) <= 2) {
 						if (S != 0) {
 
 							ans++;
 							S--;
 
 							int test = sums.remove(j);
 							// System.out.println(test + ""\t "" + tempP + ""\t""
 							// + half + ""\t"" + half2 + ""\t"" + S);
 
 							j--;
 							N--;
 							break;
 						}
 						if (S == 0) {
 							// System.out.println(""broke"");
 							break outer;
 						}
 					}
 					tempP++;
 
 				}
 
 			}
 			/* System.out.println(sums); */
 			out.println(""Case #"" + (i + 1) + "": "" + ans);
 		}
 		out.close();
 
 	}
 }
",1
345,3221,"package com.gplex.year2014.world;
 
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import com.gplex.Utils;
 
 
 public class Round_0_Task_4 {
 	private static final Logger logger = LoggerFactory.getLogger(Round_0_Task_4.class);
 	private static final String INPUT_FILE =  new File(""src/main/resources/2014/world/00-4-S.in"").getAbsolutePath();
 	private static final String OUTPUT_FILE = Utils.getOutputFileName(INPUT_FILE);
 
 	public static void main(String[] args) throws Throwable{
 		
 		logger.debug(""{}"", new Object[]{});
 		
 		Scanner sc = new Scanner(new FileReader(INPUT_FILE));
 	    PrintWriter pw = new PrintWriter(new FileWriter(OUTPUT_FILE));
 		
 		
 		int numberOfTestCases =  sc.nextInt(10);
 		//numberOfTestCases = 1;
 		
 		for(int caseNum=0;caseNum<numberOfTestCases;caseNum++){
 			int blocks =   sc.nextInt(10);
 			 double[] naomiBlocks = new double[blocks];
 			 double[] kenBlocks = new double[blocks];
 				
 			 for(int i = 0; i<blocks; i ++){
 				naomiBlocks[i] = sc.nextDouble();
 			}
 			 for(int i = 0; i<blocks; i ++){
 					kenBlocks[i] = sc.nextDouble();
 				}
 			Arrays.sort(naomiBlocks);
 			Arrays.sort(kenBlocks);
 			double[] naomiBlocksCopy = Arrays.copyOf(naomiBlocks, naomiBlocks.length);
 			double[] kenBlocksCopy = Arrays.copyOf(kenBlocks, kenBlocks.length);
 			
 			logger.debug(""\nNaomi blocks:\t{}\nKen Blocks:\t{}"", new Object[]{naomiBlocks, kenBlocks});
 			int naomiWinsCount = 0;
 			for(int i = 0 ; i< blocks; i ++){
 				if(playWar(naomiBlocks, kenBlocks, i)){
 					naomiWinsCount++;
 				};
 				
 			}
 			
 			
 			int naomiDecWinsCount = 0;
 			for(int i = blocks-1 ; i>= 0; i --){
 				if(playDeseitfulWar(naomiBlocksCopy, kenBlocksCopy, i)){
 					naomiDecWinsCount++;
 				};
 				
 			}
 			
 			
 			
 			
 			String result = String.format(""Case #%d: %d %d"", caseNum+1,naomiDecWinsCount, naomiWinsCount);
 			
 			pw.println(result);
 			logger.debug(""{}\n\n"", new Object[]{result});
 		
 		}
 		
 		pw.flush();
 		pw.close();
 		sc.close();
 		
 	}
 	/**
 	 * 
 	 * @param arr
 	 * @param num
 	 * @return
 	 */
 	public static int positionOfFirstGreater(double[] arr, double num){
 		for(int i =0; i<arr.length;i++){
 			if(arr[i] == 0d) continue;
 			if(arr[i]>num) return i;
 		}
 		return -1;
 	}
 	/**
 	 * 
 	 * @param naomi
 	 * @param ken
 	 * @param pos
 	 * @return
 	 */
 	public static boolean playDeseitfulWar(double[] naomi, double[] ken, int i ){
 		int pos = 0;
 		
 	
 			double kenNum = ken[i];
 
 			
 				logger.debug(""selected kens {}"", new Object[]{ken[i]});
 				pos = positionOfFirstGreater(naomi, kenNum);
 				if (pos > -1) {
 					logger.debug(""Naomi won choosing "" + naomi[pos]);
 					naomi[pos] = 0;
 					return true;
 				} else {
 					logger.debug(""pretendign that naoimi said ""	+ (ken[i] - 0.0000001));
 
 					for (int a = 0; a < naomi.length; a++) {
 						if (naomi[a] > 0) {
 							logger.debug(""but put "" + naomi[a]);
 							naomi[a] = 0;
 							return false;
 						}
 					}
 
 				}
 			
 		
 			
 		
 		return false;
 	}
 	
 	
 	public static boolean playWar(double[] naomi, double[] ken, int pos){
 		
 		double num = naomi[pos];
 		naomi[pos] = 0d;
 		logger.debug(""selected naomis {}"", new Object[]{num});
 		Integer minKen = null;
 		for(int i = 0; i < ken.length; i++){
 			double kenNum = ken[i];
 			if(minKen == null && kenNum>0){
 				minKen = i;
 			}
 			if(kenNum>num){
 				logger.debug(""selected kens {}"", new Object[]{kenNum});
 				ken[i] = 0;
 				return false;
 			}
 		}
 		logger.debug(""KEN LOSSES POINT. selected kens {}"", new Object[]{ken[minKen]});	
 	    ken[minKen] = 0;
 	    return true;
 	}
 
 
 }
","package com.gplex.year2014.world;
 
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import com.gplex.Utils;
 
 
 public class Round_0_Task_2 {
 	private static final Logger logger = LoggerFactory.getLogger(Round_0_Task_2.class);
 	private static final String INPUT_FILE =  new File(""src/main/resources/2014/world/00-2-S.in"").getAbsolutePath();
 	private static final String OUTPUT_FILE = Utils.getOutputFileName(INPUT_FILE);
 
 	public static void main(String[] args) throws Throwable{
 		
 		logger.debug(""{}"", new Object[]{});
 		
 		Scanner sc = new Scanner(new FileReader(INPUT_FILE));
 	    PrintWriter pw = new PrintWriter(new FileWriter(OUTPUT_FILE));
 		
 		
 		int numberOfTestCases =  sc.nextInt(10);
 		//numberOfTestCases = 1;
 		
 		for(int caseNum=0;caseNum<numberOfTestCases;caseNum++){
 			
 			double farmCost =  sc.nextDouble();
 			double morePerFarm =  sc.nextDouble();
 			double goal =  sc.nextDouble();
 			double firstResult = 1;
 			double secondResult = 0;
 		    int farms = 0;
 		    double farmTime = 0;
 		    while(secondResult<firstResult){
 				firstResult =  farmTime+ solve(morePerFarm, farms, goal);
 				farmTime += solve(morePerFarm, farms, farmCost);
 				secondResult =  farmTime+solve(morePerFarm, farms+1, goal);
 		     farms++;
 		    }  	
 		    
 		    logger.debug(""1:{}   2:{} farms:{}"", new Object[]{firstResult, secondResult, farms});
 		    
 			
 			String result = String.format(""Case #%d: %s"", caseNum+1,String.format( ""%.7f"", firstResult ));
 			pw.println(result);
 			logger.debug(""{}\n\n"", new Object[]{result});
 		
 		}
 		
 		pw.flush();
 		pw.close();
 		sc.close();
 		
 	}
 
 	public static double solve(double morePerFarm, int farms, double goal){
 		return goal/(farms*morePerFarm + 2D);
 	}
 	
 
 
 }
",1
346,11573,"import java.io.BufferedReader;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.NoSuchElementException;
 import java.util.StringTokenizer;
 
 
 public class Harmony
 {
 	public static void main(String [] args)
 	{
 		Harmony h = new Harmony();
 	}
 	private ArrayList<Integer> list;
 	public Harmony()
 	{
 		list = new ArrayList<Integer>();
 		readFile(""Files/Harmony0.in"");
 	}
 
 	public void readFile(String file)
 	{
 		int c = 1;
 		try{
 			FileInputStream fstream = new FileInputStream(file);
 			DataInputStream in = new DataInputStream(fstream);
 			BufferedReader br = new BufferedReader(new InputStreamReader(in));
 			String strLine = """";	
 			StringTokenizer tok;
 			br.readLine();
 			while ((strLine = br.readLine()) != null)  
 			{
 				list.clear();
 				int players,low,high;
 				tok = new StringTokenizer(strLine);
 				players = Integer.parseInt(tok.nextToken());
 				low = Integer.parseInt(tok.nextToken());
 				high = Integer.parseInt(tok.nextToken());
 				tok = new StringTokenizer(br.readLine());
 				while(tok.hasMoreElements())
 				{
 					list.add(Integer.parseInt(tok.nextToken()));
 				}
 				int index = 0;
 				loop:while(index == 0)
 				{
 					int x;
 					for(x = low;x <=high;x++)
 					{
 						if(isMultiple(x))
 						{
 							System.out.printf(""Case #%d: %d\n"",c++,x);
 							break loop;
 						}
 					}
 					System.out.printf(""Case #%d: NO\n"",c++);
 					break loop;
 				}
 			}
 
 
 			in.close();
 		}catch (Exception e){
 			e.printStackTrace();
 			System.err.println(""Error: "" + e.getMessage());
 		}
 	}
 	public boolean isMultiple(int a)
 	{
 		for(int x = 0;x < list.size();x++)
 		{
 			if(list.get(x) % a != 0 && a % list.get(x) != 0)
 				return false;
 		}
 		return true;
 	}
 
 }
 
","package p3;
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
 class MyClass{
 	
 	private String fileName=""C-small-attempt0"";
 	
 	private String getTestResult() throws Exception{
 		int n=getInt();
 		List<Integer> numList=new ArrayList<Integer>();
 		for(int i=0;i<n;i++){
 			numList.add(getInt());
 		}
 		long[] bs=new long[32];
 		long base=1;
 		for(int i=0;i<32;i++){
 			bs[i]=base;
 			base*=2;
 		}
 		int[] cnts=new int[32];
 		for(int num:numList){
 			for(int j=0;j<32;j++){
 				if((num&bs[j])!=0){
 					cnts[j]++;
 				}
 			}
 		}
 		boolean work=true;
 		for(int i=0;i<32;i++){
 			if(cnts[i]%2==1){
 				work=false;
 				break;
 			}
 		}
 		if(!work){
 			return ""NO"";
 		}
 		long sum=0;
 		int min=Integer.MAX_VALUE;
 		for(int num:numList){
 			sum+=(long)num;
 			if(num<min){
 				min=num;
 			}
 		}
 		return """"+(sum-min);
 	}
 	
 	void run() throws Exception{
 		int m=getInt();
 		for(int nt=1;nt<=m;nt++){
 			String res=getTestResult();
 			writer.write(""Case #""+nt+ "": ""+res+""\n"");
 		}
 		
 		reader.close();
 		writer.close();
 	}
 	
 	private BufferedReader reader;
 	private PrintWriter writer;
 	private StringTokenizer token = null;
 	
 	private String inputFilePath=fileName+"".in"";
 	private String outputFilePath=fileName+"".out"";
 	
 	public MyClass() throws Exception{
 		if(fileName.isEmpty()){
 			reader= new BufferedReader(new InputStreamReader(System.in));
 			writer=new PrintWriter(System.out);
 		}else{
 			reader= new BufferedReader(new InputStreamReader(new FileInputStream(inputFilePath)));
 			writer=new PrintWriter(new FileWriter(outputFilePath,false));
 		}
 	}
 	
 	
 	public int getInt() throws Exception {
 		return Integer.valueOf(getStringTokenizer().nextToken());
 	}
 
 	public long getLong() throws Exception {
 		return Long.valueOf(getStringTokenizer().nextToken());
 	}
 
 	public double getDouble() throws Exception {
 		return Double.valueOf(getStringTokenizer().nextToken());
 	}
 
 	public String getString() throws Exception{
 		return getStringTokenizer().nextToken();
 	}
 
 	public String getLine() throws Exception {
 		return reader.readLine();
 	}
 
 	public StringTokenizer getStringTokenizer() throws Exception {
 		if (token == null || !token.hasMoreTokens()) {
 			String str = reader.readLine();
 			token = new StringTokenizer(str);
 		}
 		return token;
 	}
 }
 
 public class P3 {
 
 	public static void main(String[] args) throws Exception{
 		new MyClass().run();
 	}
 }",0
347,5110,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 /**
  *
  * @author Kovid
  */
 import java.io.*;
 import java.util.*;
 
 public class ProblemC {
 
     public static void main(String args[]) throws FileNotFoundException, IOException {
 
         String filename = ""C:\\Users\\Kovid\\input-small.txt"";
         FileInputStream fstream_in = new FileInputStream(filename);
         DataInputStream in = new DataInputStream(fstream_in);
         BufferedReader br = new BufferedReader(new InputStreamReader(in));
 
         FileWriter fstream = new FileWriter(""out.txt"");
         PrintWriter output = new PrintWriter(fstream);
 
         int n_test = Integer.parseInt(br.readLine());
         for (int i_test = 0; i_test < n_test; i_test++) {
             int n_candies = Integer.parseInt(br.readLine());
             String line_input = br.readLine();
             String[] word_input = line_input.split("" "");
             int[] numbers = new int[word_input.length];
             for (int i = 0; i < word_input.length; i++) {
                 numbers[i] = Integer.parseInt(word_input[i]);
             }
 
             int xor_sum = 0;
             int sum_numbers=0;
             int smallest_number = numbers[0];   //check for possible problem here
             for (int i = 0; i < numbers.length; i++) {
                 xor_sum = xor_sum ^ numbers[i];
 
                 if(numbers[i] < smallest_number) {
                     smallest_number = numbers[i];
                 }
 
                 sum_numbers += numbers[i];
             }
 
             if (xor_sum != 0) {
                 System.out.println(""Case #"" + (i_test + 1) +"": NO"");
                 String txt = ""Case #"" + (i_test + 1) + "": "";
                 output.print(txt);
                 output.println(""NO"");
             } else {
                 int max_poss = sum_numbers - smallest_number;
                 System.out.println(""Case #"" + (i_test + 1) + "": "" + max_poss);
                 String txt = ""Case #"" + (i_test + 1) + "": "";
                 output.print(txt);
                 output.println(max_poss);
             }
         }
         output.close();
     }
 }
","import java.util.*;
 import java.io.*;
 
 public class cj_1A_problemA {
 	
 	
 	public static void main(String args[]) throws IOException {
 		FileInputStream fstream = new FileInputStream(""input-small.txt"");
 		// Get the object of DataInputStream
 		DataInputStream in = new DataInputStream(fstream);
 		BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		
 		 File flt = new File(""result.txt"");
 		 PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(flt)));
 		
 		int n = Integer.parseInt(br.readLine());
 		for(int i=0; i<(n); i++){
 			
 			String[]  words = br.readLine().split("" "");
 			long N = Long.valueOf(words[0]);
 			int Pd = Integer.parseInt(words[1]);
 			int Pn = Integer.parseInt(words[2]);
 			
 			boolean found=false;
 			
 			for(int j=1; j<=N; j++){
 				double f1 = (Pd*j);///100;
 				double f = f1/100.0;
 				
 				int nnn = (int) f;
 				String input = """" + f;
 						
 				if(nnn == f){
 					
 					//System.out.println(""check "" + j + "":"" + f);
 					
 					if(((Pn != 100) && (Pn!=0)) || (Pn==Pd)){
 						//System.out.println(""check "" + j + "":"" + f);
 						System.out.println(""Case #"" + (i+1) + "": "" + ""Possible"");
 						found=true;
 						break;
 					}
 					else{
 						continue;
 						//System.out.println(""Case #"" + (i+1) + "": "" + ""Possible"");
 					}
 				}
 			}
 			
 			if(!found){
 				System.out.println(""Case #"" + (i+1) + "": "" + ""Broken"");
 			}
 			
 			//System.out.println(""Case #"" + (i+1) + "": "" + this_ans);
 		}
 		
 		out.close();
 	}
 }
",1
348,20634,"package codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 /**
  *
  * @author XpGG
  */
 public class Harmony {
 
     public static void solve() throws FileNotFoundException {
         int T;
         int N;
         long L, H;
         long NOTES[];
         Scanner scanner = new Scanner( new File(""C-small-attempt0.in"") );
         T = scanner.nextInt();
         for (int t = 0; t < T; t++) {
             N = scanner.nextInt();
             L = scanner.nextLong();
             H = scanner.nextLong();
             NOTES = new long[ N ];
             for (int n = 0; n < N; n++) {
                 NOTES[ n] = scanner.nextLong();
             }
             System.out.println(""Case #"" + (t + 1) + "": "" + easy( NOTES, L, H ));
             
         }
     }
     
     public static String easy( long [] NOTES, long L, long H  ){
         int N = NOTES.length;
         boolean alltrue = true;
         for( long i = L; i <= H; i ++ ){
             alltrue = true;
             for( int j = 0; j < N; j ++ ){
                 if( !( NOTES [j] % i == 0 || i % NOTES [j] == 0 )  ){
                     alltrue = false;
                     continue;
                 }
             }
             if( alltrue ){
                 return """" + i;
             }
         } 
         return ""NO"";
     }
 }
","import java.io.*;
 
 public class Tomek {
     private static void checkBoard(String[] board, BufferedWriter bw, int caseNumber) throws IOException {
         int emptyCount = 0;
         
         for (int x = 0; x < 4; x++) {
             int Xcount = 0;
             int Ocount = 0;
 
             for (int y = 0; y < 4; y++) {
                 char c = board[x].charAt(y);
                 if (c == '.') {
                     emptyCount++;
                 } else if (c == 'T') {
                     Xcount++;
                     Ocount++; 
                 } else if (c == 'X') {
                     Xcount++;
                 } else if (c == 'O') {
                     Ocount++;
                 } 
             }
             if (Xcount == 4) {
                 bw.write(""Case #"" + caseNumber + "": X won"");
                 bw.newLine();
                 return;
             } else if (Ocount == 4) {
                 bw.write(""Case #"" + caseNumber + "": O won"");
                 bw.newLine();
                 return;
             }
         } 
 
         for (int y = 0; y < 4; y++) {
             int Xcount = 0;
             int Ocount = 0;
 
             for (int x = 0; x < 4; x++) {
                 char c = board[x].charAt(y);
                 if (c == 'T') {
                     Xcount++;
                     Ocount++; 
                 } else if (c == 'X') {
                     Xcount++;
                 } else if (c == 'O') {
                     Ocount++;
                 }
             }
             if (Xcount == 4) {
                 bw.write(""Case #"" + caseNumber + "": X won"");
                 bw.newLine();
                 return;
             } else if (Ocount == 4) {
                 bw.write(""Case #"" + caseNumber + "": O won"");
                 bw.newLine();
                 return;
             }
         }
 
         int Xcount = 0;
         int Ocount = 0;
 
         for (int i = 0; i < 4; i++) {
             char c = board[i].charAt(i);
             if (c == 'T') {
                 Xcount++;
                 Ocount++; 
             } else if (c == 'X') {
                 Xcount++;
             } else if (c == 'O') {
                 Ocount++;
             }
         }
 
         if (Xcount == 4) {
             bw.write(""Case #"" + caseNumber + "": X won"");
             bw.newLine();
             return;
         } else if (Ocount == 4) {
             bw.write(""Case #"" + caseNumber + "": O won"");
             bw.newLine();
             return;
         }
 
         Xcount = 0;
         Ocount = 0;
 
         for (int i = 0; i < 4; i++) {
             char c = board[3 - i].charAt(i);
             if (c == 'T') {
                 Xcount++;
                 Ocount++; 
             } else if (c == 'X') {
                 Xcount++;
             } else if (c == 'O') {
                 Ocount++;
             }
         }
 
         if (Xcount == 4) {
             bw.write(""Case #"" + caseNumber + "": X won"");
             bw.newLine();
             return;
         } else if (Ocount == 4) {
             bw.write(""Case #"" + caseNumber + "": O won"");
             bw.newLine();
             return;
         }
 
         if (emptyCount == 0) {
             bw.write(""Case #"" + caseNumber + "": Draw"");
         } else {
             bw.write(""Case #"" + caseNumber + "": Game has not completed"");
         }
         bw.newLine();
     }
 
     public static void main(String[] args) {
         BufferedReader br = null;
         BufferedWriter bw = null;
 
         try {
             File outputFile = new File(""./Tomek_out.txt"");
             br = new BufferedReader(new FileReader(""./Tomek_in.txt""));
 
             if (!outputFile.exists()) {
               outputFile.createNewFile();
             }
 
             bw = new BufferedWriter(new FileWriter(outputFile));
 
             String currentLine;
 
             currentLine = br.readLine();
             int T = Integer.valueOf(currentLine);
 
             for (int t = 1; t <= T; t++) {
                 String[] board = new String[4];
                 for (int j = 0; j < 4; j++) {
                     currentLine = br.readLine();
                     board[j] = currentLine;
                 }
                 checkBoard(board, bw, t);
                 br.readLine(); // Get rid of extra line;
             }
             bw.flush();
         } catch (IOException e) {
             e.printStackTrace();
         } finally {
             try {
                 if (br != null) {
                     br.close();
                 }
                 if (bw != null) {
                     bw.close();
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             } 
         }
     }
 }
",0
349,16866,"package problem3;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class Candy {
 	private int total = 0;
 	private int mask = 0;
 	private int min = -1;
 
 	private void add(int current) {
 		//System.out.println(Integer.toBinaryString(current));
 		total += current;
 		mask = mask ^ current;
 		if (min < 0 || current < min) {
 			min = current;
 		}
 	}
 
 	private String getResult() {
 		if (mask == 0) {
 			return String.valueOf(total - min);
 		} else {
 			return ""NO"";
 		}
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		File f = new File(args[0]);
 		Scanner sc = new Scanner(f);
 		int T = sc.nextInt();
 		for (int tc = 1; tc <= T; tc++) {
 			int N = sc.nextInt();
 			Candy cdy = new Candy();
 			for (int nn = 0; nn < N; nn++) {
 				cdy.add(sc.nextInt());
 			}
 			System.out.println(""Case #"" + tc + "": "" + cdy.getResult());
 		}
 
 	}
 }
","// Problem B
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class B {
 	
 	private void processInput(String filename) throws IOException {
 		Scanner in = new Scanner(new File(filename));
 		int idxp = filename.lastIndexOf('.');
 		PrintWriter out = new PrintWriter(filename.substring(0, idxp) + "".out"");
 		
 		int C = in.nextInt();
 		
 		for (int testCase = 1; testCase <= C; testCase++) {
 			int N = in.nextInt();
 			BigDecimal[] str = new BigDecimal[N];
 			for (int i = 0; i < N; i++) {
 				str[i] = new BigDecimal(in.next());
 			}
 
 			String res = go(str);
 
 			out.printf(Locale.ENGLISH, ""Case #%d: %s\n"", testCase, res);
 			System.out.printf(Locale.ENGLISH, ""Case #%d: %s\n"", testCase, res);			
 		}
 		
 		out.flush();
 		out.close();
 		in.close();
 	}
 	
 	private String go(BigDecimal[] val) {
 		
 		BigDecimal[] tmp = new BigDecimal[val.length - 1];
 		Arrays.sort(val);
 		for (int i = 0; i < tmp.length; i++) {
 			tmp[i] = val[i+1].subtract(val[i]).abs();
 		}
 		
 		BigDecimal res = new BigDecimal(0);
 		
 		while (tmp.length > 1) {
 			int n = tmp.length / 2;
 			if (tmp.length % 2 == 1) {
 				n++;
 			}
 			BigDecimal[] tmp1 = new BigDecimal[n];
 			for (int i = 0; i < tmp.length / 2; i++) {
 				tmp1[i] = gcd(tmp[2*i], tmp[2*i+1]);
 			}
 			if (tmp.length % 2 == 1) {
 				tmp1[tmp1.length - 1] = tmp[tmp.length - 1];
 			}
 			tmp = tmp1;
 		}
 
 		BigDecimal T = tmp[0];
 		BigDecimal rr = val[0].divide(T, 0, BigDecimal.ROUND_UP);
 		res = T.multiply(rr).subtract(val[0]);
 		return res.toString();
 	}
 	
 	public BigDecimal gcd(BigDecimal a, BigDecimal b) {
 	   if (BigDecimal.ZERO.equals(b)) return a;
 	   return gcd(b, a.remainder(b));
 	}
 	
 	public static void main(String[] args) throws Exception {
 		B temp = new B();
 		if (args.length < 1) {
 			System.out.println(""Wrong number of parameters: java B filename"");
 			System.exit(-1);
 		}
 		temp.processInput(args[0]);
 	}
 }
",0
350,10682,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 
 public class A {
 
 	/**
 	 * @param args
 	 * @throws IOException
 	 * @throws NumberFormatException
 	 */
 	public static void main(String[] args) throws NumberFormatException,
 			IOException {
 		BufferedReader rd = new BufferedReader(new FileReader(""asin.txt""));
 		PrintWriter p = new PrintWriter(new File(""aso.txt""));
 		int n = Integer.parseInt(rd.readLine());
 		for (int i = 1; i <= n; i++) {
 			char[][] map = new char[4][4];
 			for (int j = 0; j < 4; j++) {
 				map[j] = rd.readLine().toCharArray();
 			}
 			boolean coplete = true, xw = false, ow = false;
 
 			for (int j = 0; j < 4; j++) {
 				int x = 0, o = 0, t = 0, dot = 0;
 				if (!xw && !ow) {
 					for (int k = 0; k < 4; k++) {
 						if (map[j][k] == 'X')
 							x++;
 						else if (map[j][k] == 'O')
 							o++;
 						else if (map[j][k] == 'T')
 							t++;
 						else if (map[j][k] == '.')
 							dot++;
 					}
 					if (dot > 0) {
 						coplete = false;
 						// continue;
 					}
 					if (x == 3 && t == 1 || x == 4) {
 						xw = true;
 						break;
 					}
 					if (o == 3 && t == 1 || o == 4) {
 						ow = true;
 						break;
 					}
 				}
 			}
 			if (!xw && !ow)
 				for (int k = 0; k < 4; k++) {
 					int x = 0, o = 0, t = 0, dot = 0;
 					if (!xw && !ow) {
 						for (int j = 0; j < 4; j++) {
 							if (map[j][k] == 'X')
 								x++;
 							else if (map[j][k] == 'O')
 								o++;
 							else if (map[j][k] == 'T')
 								t++;
 							else if (map[j][k] == '.')
 								dot++;
 						}
 						if (dot > 0) {
 							coplete = false;
 							// continue;
 						}
 						if (x == 3 && t == 1 || x == 4) {
 							xw = true;
 							break;
 						}
 						if (o == 3 && t == 1 || o == 4) {
 							ow = true;
 							break;
 						}
 					}
 				}
 			if (!xw && !ow) {
 				int x = 0, o = 0, t = 0, dot = 0;
 
 				for (int j = 0; j < 4; j++) {
 					if (map[j][j] == 'X')
 						x++;
 					else if (map[j][j] == 'O')
 						o++;
 					else if (map[j][j] == 'T')
 						t++;
 					else if (map[j][j] == '.')
 						dot++;
 				}
 				if (dot > 0) {
 					coplete = false;
 				}
 				if (x == 3 && t == 1 || x == 4) {
 					xw = true;
 //					break;
 				}
 				if (o == 3 && t == 1 || o == 4) {
 					ow = true;
 //					break;
 				}
 			}
 			if (!xw && !ow) {
 				int x = 0, o = 0, t = 0, dot = 0;
 
 				for (int j = 0; j < 4; j++) {
 					if (map[3 - j][j] == 'X')
 						x++;
 					else if (map[3 - j][j] == 'O')
 						o++;
 					else if (map[3 - j][j] == 'T')
 						t++;
 					else if (map[3 - j][j] == '.')
 						dot++;
 				}
 				if (dot > 0) {
 					coplete = false;
 				}
 				if (x == 3 && t == 1 || x == 4) {
 					xw = true;
 //					break;
 				}
 				if (o == 3 && t == 1 || o == 4) {
 					ow = true;
 //					break;
 				}
 			}
 			p.print(""Case #"" + i + "": "");
 			if (xw)
 				p.println(""X won"");
 			else if (ow)
 				p.println(""O won"");
 			else if (coplete)
 				p.println(""Draw"");
 			else
 				p.println(""Game has not completed"");
 			rd.readLine();
 		}
 		rd.close();
 		p.close();
 	}
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class B {
 
 	/**
 	 * @param args
 	 * @throws IOException
 	 */
 	public static void main(String[] args) throws IOException {
 		BufferedReader rd = new BufferedReader(new FileReader(""csin.txt""));
 		PrintWriter p = new PrintWriter(new File(""cso.txt""));
 		int t = Integer.parseInt(rd.readLine());
 		for (int i = 1; i <= t; i++) {
 			StringTokenizer to = new StringTokenizer(rd.readLine(), "" "");
 			int a = Integer.parseInt(to.nextToken()), b = Integer.parseInt(to
 					.nextToken());
 			int[][] land = new int[a][b];
 			for (int j = 0; j < a; j++) {
 				to = new StringTokenizer(rd.readLine(), "" "");
 				for (int k = 0; k < b; k++) {
 					land[j][k] = Integer.parseInt(to.nextToken());
 				}
 			}
 			boolean yes = true;
 			for (int j = 1; j < a - 1; j++) {
 				for (int k = 1; k < b - 1; k++) {
 					if (!((land[j][k] == land[0][k] && land[j][k] == land[a - 1][k]) || (land[j][k] == land[j][0] && land[j][k] == land[j][b - 1]))) {
 						yes = false;
 						break;
 					}
 				}
 			}
 			p.println(""Case #"" + i + "": "" + (yes ? ""YES"" : ""NO""));
 		}
 		p.close();
 		rd.close();
 	}
 }
",1
351,13333,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.util.Scanner;
 
 
 public class Main {
 
 	/**
 	 * @param args
 	 */
 	
 	public static int numShift(int A, int digit){
 
 		int num = 0, div;
 		num = A %10;
 		div = A /10;
 		for(int i=1; i < digit ; i++)
 		{
 			num = num*10;
 		}
 		num = num + div;
 		return num;
 	}
 	
 
 	public static int recycleCount(int A, int B)
 	{
 		int count = 0;
 		int num = A;
 		String digit = """" + A;
 		do
 		{
 			num = numShift(num, digit.length());
 			if(num > A && num <= B)
 				count++;
 		}while(num != A);
 		
 		//System.out.print(""Count: "" + count + ""\n"");
 		return count;
 	}
 	
 	public static void runCase(int A, int B, int casenum)
 	{
 		int count =0;
 		for(int i=A; i<B; i++)
 		{
 			count += recycleCount(i, B);
 		}
 		System.out.print(""Case #"" + casenum + "": "" + count + ""\n"");
 	}
 	
 	public static void main(String[] args) throws FileNotFoundException {
 		File ffile = new File(args[0]);
 		Scanner scanner;
 		scanner = new Scanner(new FileReader(ffile));
 		
 		int N = scanner.nextInt();
 		int A, B;
 		for(int i =0; i<N; i++)
 		{
 			A = scanner.nextInt();
 			B = scanner.nextInt();
 			runCase(A, B, i+1);
 		}
 		
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.util.Scanner;
 
 
 public class Tounge {
 
 	public static char Googlerese(char data)
 	{
 		switch(data) {
 		case 'a': data = 'y';  break;
 		case 'b': data = 'h';  break;
 		case 'c': data = 'e';  break;
 		case 'd': data = 's';  break;
 		case 'e': data = 'o';  break;
 		case 'f': data = 'c';  break;
 		case 'g': data = 'v';  break;
 		case 'h': data = 'x';  break;
 		case 'i': data = 'd';  break;
 		case 'j': data = 'u';  break;
 		case 'k': data = 'i';  break;
 		case 'l': data = 'g';  break;
 		case 'm': data = 'l';  break;
 		case 'n': data = 'b';  break;
 		case 'o': data = 'k';  break;
 		case 'p': data = 'r';  break;
 		case 'q': data = 'z';  break;
 		case 'r': data = 't';  break;
 		case 's': data = 'n';  break;
 		case 't': data = 'w';  break;
 		case 'u': data = 'j';  break;
 		case 'v': data = 'p';  break;
 		case 'w': data = 'f';  break;
 		case 'x': data = 'm';  break;
 		case 'y': data = 'a';  break;
 		case 'z': data = 'q';  break;
 		}
 		return data;
 	}
 	
 	public static void convertString(String G, int casenum) {
 		String S="""";
 		for(int i=0; i<G.length(); i++)
 		{
 			char data = Googlerese(G.charAt(i));;
 			S = S + data;
 		}
 		System.out.print(""Case #"" + casenum + "": ""+S +""\n"");
 	}
 	
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		
 			
 		File ffile = new File(args[0]);
 		Scanner scanner;
 		scanner = new Scanner(new FileReader(ffile));
 		
 		int N = scanner.nextInt();
 		String data;
 		data = scanner.nextLine();
 		for (int i = 0; i<N; i++)
 		{
 			data = scanner.nextLine();
 			convertString(data, i+1);
 		
 		}
 	}
 
 }
",1
352,9689,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 public class TicTacToeTomek {
 	public static void main(String[] args) throws NumberFormatException,
 			IOException {
 		BufferedReader buf = new BufferedReader(new FileReader(""A-large.in""));
 		PrintWriter writer = new PrintWriter(new File(""A-large.out""));
 
 		int t = Integer.parseInt(buf.readLine().trim());
 		for (int i = 1; i <= t; i++) {
 			char[][] c = new char[4][4];
 			for (int j = 0; j < 4; j++)
 				c[j] = buf.readLine().trim().toCharArray();
 			if (check(c, 0))
 				writer.printf(""Case #%d: X won\n"", i);
 			else if (check(c, 1))
 				writer.printf(""Case #%d: O won\n"", i);
 			else if (check2(c))
 				writer.printf(""Case #%d: Draw\n"", i);
 			else
 				writer.printf(""Case #%d: Game has not completed\n"", i);
 			buf.readLine();
 		}
 		writer.close();
 	}
 
 	private static boolean check2(char[][] c) {
 		for (int i = 0; i < c.length; i++)
 			for (int j = 0; j < c[0].length; j++)
 				if (c[i][j] == '.')
 					return false;
 		return true;
 	}
 
 	private static boolean check(char[][] c, int k) {
 		char player = (k == 0) ? 'X' : 'O';
 		for (int i = 0; i < 4; i++) {
 			int cnt1 = 0;
 			int cnt2 = 0;
 			for (int j = 0; j < 4; j++) {
 				if (c[i][j] == player)
 					cnt1++;
 				else if (c[i][j] == 'T')
 					cnt2++;
 			}
 			if (cnt1 + cnt2 == 4)
 				return true;
 			cnt1 = 0;
 			cnt2 = 0;
 			for (int j = 0; j < 4; j++) {
 				if (c[j][i] == player)
 					cnt1++;
 				else if (c[j][i] == 'T')
 					cnt2++;
 				if (cnt1 + cnt2 == 4)
 					return true;
 			}
 		}
 		int cnt1 = 0;
 		int cnt2 = 0;
 		for (int i = 0; i < 4; i++) {
 			if (c[i][i] == player)
 				cnt1++;
 			else if (c[i][i] == 'T')
 				cnt2++;
 		}
 		if (cnt1 + cnt2 == 4)
 			return true;
 		cnt1 = 0;
 		cnt2 = 0;
 		for (int i = 0; i < 4; i++) {
 			if (c[i][4 - i - 1] == player)
 				cnt1++;
 			else if (c[i][4 - i - 1] == 'T')
 				cnt2++;
 		}
 		if (cnt1 + cnt2 == 4)
 			return true;
 		return false;
 	}
 }
","import java.util.*;
 import java.io.*;
 
 public class T
 {
     public static void main(String[] args) throws Exception
     {
 
         Scanner sc = new Scanner(new FileReader(""A-small-attempt3.in""));
         PrintWriter pw = new PrintWriter(new FileWriter(""output.txt""));
         String dummy;
         
         String vc = ""Volunteer cheated!"", bm = ""Bad magician!"", ans = "":P"";
         int ar[][] = new int[4][4];
         int r1,r2;
         
         int cases = Integer.parseInt(sc.nextLine());
         for (int i = 0; i < cases; i++)
         {
             r1 = sc.nextInt();
             for(int j = 0; j<4; j++)
             {
                 for(int k = 0; k<4; k++)
                 {
                     ar[j][k] = sc.nextInt();
                 }
             }
             String s1 = "" "" + ar[r1-1][0] + "" "" + ar[r1-1][1] + "" "" +ar[r1-1][2] + "" "" +ar[r1-1][3] + "" "";
             
             r2 = sc.nextInt();
             for(int j = 0; j<4; j++)
             {
                 for(int k = 0; k<4; k++)
                 {
                     ar[j][k] = sc.nextInt();
                 }
             }
             
             int in[] = new int[4];
             ans = "":P"";
             for(int j = 0; j<4; j++)
             {
                 in[j] = s1.indexOf("" "" + ar[r2-1][j] + "" "");
                 if(j == 3 && in[3] == -1 && s1.indexOf(ans) == -1)
                 {
                     ans = vc;
                 }
                 else if(in[j] == -1) continue;
                 else
                 {
                     if(j!=0 && (!ans.equals("":P"")) && in[j]!= -1)
                     {
                         ans = bm; break;
                     }
                     //else if((!ans.equals("":P"")) && in[j]!=-1) {ans = bm; break;}
                     else
                     {
                         if(s1.indexOf(ans) != -1) {ans = bm; break;}
                         ans = ar[r2-1][j] + """";
                         System.out.println(""Case #"" + (i + 1) + "": "" + ans);
                     }
                 }
             }
             
             pw.print(""Case #"" + (i + 1) + "": "" + ans);
             if(!(i == cases-1))pw.println();
             
         }
         
         pw.flush();
         pw.close();
         sc.close();
     }
 }",0
353,13580,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package candysplitting;
 
 /**
  *
  * @author Vinay
  */
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Scanner;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 public class Main {
     /**
      * @param args the command line arguments
      */
     FileReader file;
     Scanner scan;
     FileOutputStream fop;
 
     public void start() {
         init();
         int n = scan.nextInt();
         for(int iii = 1; iii <= n ; iii++) {
             int cc = scan.nextInt();
             int []C = new int[cc];
             for(int ii = 0; ii < cc; ii++) {
                 C[ii] = scan.nextInt();
             }
             Arrays.sort(C);
             int psum = 0;
             int pos = -1;
             int num = 1;
             for(int ii = 0; ii < cc-1 && pos == -1; ii++) {
                 psum = psum ^ C[ii];
                 int ssum = 0;
                 for(int jj = ii+1; jj < cc; jj++) {
                     ssum = ssum ^ C[jj];
                 }
                 if(psum == ssum)
                     pos = ii+1;
             }
             if(pos == -1) {
                 System.out.println(""Case #""+iii+"": ""+""NO"");
                 createOutput(""Case #""+iii+"": ""+""NO""+""\n"");
             }
             else {
                 psum = 0;
                 for(int ii = pos ; ii < cc; ii++)
                     psum += C[ii];
                 System.out.println(""Case #""+iii+"": ""+psum);
                 createOutput(""Case #""+iii+"": ""+psum+""\n"");
             }
 
             //createOutput(""Case #""+iii+"": ""+temp+""\n"");
         }
     }
 
     public void createOutput(String str) {
         try {
             fop.write(str.getBytes());
         } catch (IOException ex) {
             Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
 
     public void init() {
         try {
             String filename = ""C-large"";
             File f = new File(filename+"".in"");
             file = new FileReader(f);
             scan = new Scanner(file);
             f = new File(filename+"".out"");
             fop=new FileOutputStream(f);
         } catch (FileNotFoundException ex) {
             Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
         } catch (IOException ex) {
                 Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
 
     public static void main(String[] args) {
         // TODO code application logic here
         new Main().start();
     }
 }
","import java.io.BufferedReader;
 import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.*;
 
 
 public class B {
 
     /**
      * @param args the command line arguments
      */
     public static int getsmallLargeArray(int[]xdash,int[]ydash,int xdashNum,int ydashNum)
     {
 		int count = 0;
 		for(int ii=0;ii<xdash.length;ii++)
 		{
 			System.out.println(xdash[ii]+""  ""+xdashNum +""  ""+ ydash[ii]+""  ""+ydashNum);
 			if(xdash[ii]>xdashNum && ydash[ii]<ydashNum)
 			{
 				count++;
 				System.out.println(count);
 			}
 		}
 		return count;
 	}
     public static void main(String[] args) {
         // TODO code application logic here
         try {
         File f = new File(""B-small-attempt0.in"");
             FileInputStream fileIn = new FileInputStream(f);
             DataInputStream data = new DataInputStream(fileIn);
             BufferedReader bf = new BufferedReader(new InputStreamReader(data));
 
 
             long maxCases = Integer.parseInt(bf.readLine());
             //System.out.println(maxCases);
             for (long caseNum = 1; caseNum <= maxCases; caseNum++)
             {
                 String str = bf.readLine().trim();
                 String str1 = str.substring(0,str.indexOf("" ""));
                 String str2 = str.substring(str.indexOf("" "")+1,str.lastIndexOf("" ""));
                 String str3 = str.substring(str.lastIndexOf("" "")+1);
                 int L = Integer.parseInt(str1);
                 int P = Integer.parseInt(str2);
                 int C = Integer.parseInt(str3);
                 int target = L;
                 int count = 0;
                 while(target<P)
                 {
 					int check = target*C;
 					P = P - check;
 
 					//if(check < P)
 						count++;
 					//P = P - target;
 				}
                 String resultStr ="""";
 
                 FileOutputStream out = new FileOutputStream(""B-small-attempt0.out"",true);
 
                 //Long sunI = sum;
                 String outsum = ""Case #""+caseNum+"": ""+count;
                 out.write(outsum.getBytes());
                 System.out.println(outsum);
                 out.write(""\r\n"".getBytes());
                 //out.newLine();
                 out.close();
             }
             bf.close();
             fileIn.close();
             data.close();
         } catch (FileNotFoundException ex) {
             Logger.getLogger(B.class.getName()).log(Level.SEVERE, null, ex);
         } catch (IOException ex) {
             Logger.getLogger(B.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
 
 }
",1
354,1040,"import java.io.*;
 import java.util.*;
 
 
 public class ProblemB {
 	final static String PROBLEM_NAME = ""/Users/autobee/work/gcj/problem_b"";
 	final static String FILE_NAME_IN =  ""B-small-attempt0 (1).in"";
 	final static String FILE_NAME_OUT =  ""B-small-attempt0 (1).out"";
 	
 	/**
 	 * @param args
 	 */
 	
 	int a, b, c;
 	
 	void solve(Scanner sc, PrintWriter pw) {
 		a = sc.nextInt();
 		b = sc.nextInt();
 		c = sc.nextInt();
 		
 		int counter = 0;
 		for (int i = 0; i < a; i++) {
 			for (int j = 0; j < b; j++) {
 				if ((i & j) < c) {
 					counter++;
 				}
 			}
 		}
 		
 		pw.println(counter);
 	}
 	
 	
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new FileReader(PROBLEM_NAME + ""/"" + FILE_NAME_IN));
         PrintWriter pw = new PrintWriter(new FileWriter(PROBLEM_NAME + ""/"" + FILE_NAME_OUT));
         int caseCnt = sc.nextInt();
         for (int caseNum=0; caseNum<caseCnt; caseNum++) {
             System.out.println(""Processing test case "" + (caseNum + 1));
             pw.print(""Case #"" + (caseNum+1) + "": "");
             new ProblemB().solve(sc, pw);
         }
         pw.flush();
         pw.close();
         sc.close();
 
 	}
 
 }
","import java.util.*;
 import java.io.*;
 
 public class Q2 {
 
 	static int m1(String st) {
 		Scanner sc=new Scanner(st);
 		int nG=sc.nextInt();
 		int nS=sc.nextInt();
 		int p=sc.nextInt();
 		int count=0;
 		int[] maxG=new int[nG];
 		for (int i=0; i<nG; i++)
 			maxG[i]=sc.nextInt();
 		int[] m=new int[nG];
 		int[] mS=new int[nG];
 		for (int i=0; i<nG; i++) {
 			m[i]=-1; mS[i]=-1;
 		}
 		for (int i=0; i<nG; i++)
 			for (int x=0; x<=10; x++)
 				for (int y=0; y<=10; y++)
 					for (int z=0; z<=10; z++)
 						if ((x+y+z==maxG[i]) && Math.abs(x-y)<=2 && Math.abs(x-z)<=2 && Math.abs(y-z)<=2)
 							if (Math.max(x, Math.max(y, z))>=p)
 								if (Math.abs(x-y)<2 && Math.abs(x-z)<2 && Math.abs(y-z)<2)
 									m[i]=Math.max(m[i], Math.max(x, Math.max(y, z)));
 								else
 									mS[i]=Math.max(mS[i], Math.max(x, Math.max(y, z)));
 		
 		for (int a:m)
 			if (a>-1)
 				count++;
 		for (int i=0; i<nG; i++)
 			if (mS[i]>-1)
 				if (nS>0 && m[i]==-1)
 				{
 					count++;
 					nS--;
 				}
 		return count;
 	}
 	public static void main(String[] args) throws IOException {
 		File inFile=new File(""B-small-attempt1.in"");
 		File outFile=new File(""B-small-attempt1.out"");
 		BufferedReader br=new BufferedReader(new FileReader(inFile));
 		PrintWriter out=new PrintWriter(new FileWriter(outFile));
 		StringBuilder sb=new StringBuilder();
 		int ntc=Integer.parseInt(br.readLine());
 		for (int tc=1; tc<=ntc; tc++)
 		{
 			String s=br.readLine();
 			sb.append(""Case #""+tc+"": ""+m1(s)+""\n"");
 		}
 		out.write(sb.toString());
 		br.close();
 		out.close();
 	}
 }
",0
355,16691,"import java.io.*;
 import java.util.StringTokenizer;
 
 public class A implements Runnable {
     private static BufferedReader reader;
     private static StringTokenizer st;
 
     public static void main(String[] args) {
         new Thread(new A()).start();
     }
 
     @Override
     public void run() {
         try {
             solve();
         } catch (IOException e) {}
     }
 
     private void solve() throws IOException {
         reader = new BufferedReader(new FileReader(""a.in""));
         PrintWriter writer = new PrintWriter(new FileWriter(""a.out""));
 
         int n = nextInt();
         for (int i = 1; i <= n; i++) {
             int alreadyTyped = nextInt();
             int wholeLength = nextInt();
             double[] typed = new double[alreadyTyped];
             for (int j = 0; j < alreadyTyped; j++) {
                 typed[j] = nextDouble();
             }
             double ans = calcAns(alreadyTyped, wholeLength, typed);
             writer.println(""Case #"" + i + "": "" + ans);
         }
 
         writer.close();
     }
 
     static String nextToken() throws IOException {
         while (st == null || !st.hasMoreTokens()) {
             st = new StringTokenizer(reader.readLine());
         }
         return st.nextToken();
     }
 
     static int nextInt() throws IOException {
         return Integer.parseInt(nextToken());
     }
 
     static double nextDouble() throws IOException {
         return Double.parseDouble(nextToken());
     }
 
     static double calcAns(int alreadyTyped, int wholeLength, double[] t) {
         int numOfVariants = (1 << alreadyTyped);
         Variant[] variants = new Variant[numOfVariants];
         switch (alreadyTyped) {
             case 1:
                 variants[0] = new Variant(wholeLength, new int[] {}, t);
                 variants[1] = new Variant(wholeLength, new int[] {0}, t);
                 break;
             case 2:
                 variants[0] = new Variant(wholeLength, new int[] {}, t);
                 variants[1] = new Variant(wholeLength, new int[] {0}, t);
                 variants[2] = new Variant(wholeLength, new int[] {1}, t);
                 variants[3] = new Variant(wholeLength, new int[] {0, 1}, t);
                 break;
             case 3:
                 variants[0] = new Variant(wholeLength, new int[] {}, t);
                 variants[1] = new Variant(wholeLength, new int[] {0}, t);
                 variants[2] = new Variant(wholeLength, new int[] {1}, t);
                 variants[3] = new Variant(wholeLength, new int[] {0, 1}, t);
                 variants[4] = new Variant(wholeLength, new int[] {2}, t);
                 variants[5] = new Variant(wholeLength, new int[] {0, 2}, t);
                 variants[6] = new Variant(wholeLength, new int[] {1, 2}, t);
                 variants[7] = new Variant(wholeLength, new int[] {0, 1, 2}, t);
                 break;
         }
         double min = wholeLength + 2;
         for (int i = 0; i <= alreadyTyped; i++) {
             double ans = 0;
             for (Variant a : variants) {
                 ans += a.getProbability(i);
             }
             if (ans < min) {
                 min = ans;
             }
         }
 
         return min;
     }
 
     static class Variant {
         int len;
         int wholeLen;
         int[] indexes;
         double chance;
 
         public Variant(int wholeLen, int[] indexes, double[] probabilities) {
             this.wholeLen = wholeLen;
             this.len = probabilities.length;
             this.indexes = indexes;
             chance = 1;
             int indexesCnt = 0;
             for (int i = 0; i < len; i++) {
                 if (indexes.length > 0 && i == indexes[indexesCnt]) {
                     if (indexesCnt < indexes.length - 1) {
                         indexesCnt++;
                     }
                     chance *= (1 - probabilities[i]);
                 }
                 else {
                     chance *= probabilities[i];
                 }
             }
         }
 
         public int getNumOfSteps(int removeElements) {
             if (indexes.length != 0 && indexes[0] < len - removeElements) {
                 return 2 * removeElements + 2 * wholeLen - len + 2;
             } else {
                 return 2 * removeElements + wholeLen - len + 1;
             }
         }
 
         public double getProbability(int removeElements) {
             return chance * getNumOfSteps(removeElements);
         }
 
     }
 
 }","import static java.util.Arrays.deepToString;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 
 
 public class A {
 	public BufferedReader in;
 	public PrintWriter out;
 
 	void debug(Object...os) {
 		System.err.println(deepToString(os));
 	}
 	static void pl(Object s)	{
 		System.out.println(s);
 	}
 	static void p(Object s)	{
 		System.out.print(s);
 	}
 	
 	public int getBestCand(ArrayList<ArrayList<String>> existA, ArrayList<String> t)	{
 		int i,match,globmatch = 0;
 		int tsize = t.size();
 		for(ArrayList<String> s : existA)	{
 			if (s.size() < tsize)	{
 				match = 0;
 				for(i = 0;i<s.size();++i)	{
 //					p(s+"" | "");
 //					pl(t);
 					if (s.get(i).equals(t.get(i)))	{
 						++match;
 					} else break;
 //					pl(s.get(i)+"" | ""+s.get(i)+"" id:""+i+"" match:""+match);
 				}
 				if (match > globmatch){
 					globmatch = match;
 				}
 //				pl(""globmatch:""+globmatch);
 //				pl(""id:""+id);
 			}
 //			pl("""");
 		}
 		return globmatch;
 	}
 
 	public int addEntry(ArrayList<ArrayList<String>> existA, ArrayList<String> exist,ArrayList<String> t,int deep)	{
 		int i = 0;
 		ArrayList<String> newbase = new ArrayList<String>();
 		for(;i<deep;++i)	{
 			newbase.add(t.get(i));
 		}
 		for(;i<t.size();++i)	{
 			newbase.add(t.get(i));
 			String s = """";
 			for(String st : newbase)
 				s+=""/""+st;
 			s = s.substring(1);
 			existA.add(new ArrayList<String>(newbase));
 			exist.add(s);
 		}
 		return t.size() - deep;
 	}
 	public void run() throws Exception	{
 		int T,N,M;
 		ArrayList<String> exist,test;
 		ArrayList<ArrayList<String>> existA,testA;
 		String line;String[] tok;
 		in = new BufferedReader(new FileReader(new File(""A-small-attempt2.in"" ) ) );
 		out = new PrintWriter(new File(""A-small-attempt2.out""));
 		T = new Integer(in.readLine());
 		int cost,best;
 		for(int t=1;t<=T;++t)	{
 			cost = 0;
 			line = in.readLine();
 			tok = line.split("" "");
 			N = new Integer(tok[0]);
 			M = new Integer(tok[1]);
 			exist = new ArrayList<String>(N);
 			existA = new ArrayList<ArrayList<String>>(N);
 			for(int n=0;n<N;++n)	{
 				line = in.readLine();
 				line = line.substring(1);
 				exist.add(line);
 				existA.add(new ArrayList<String>(Arrays.asList(line.split(""/""))));
 			}
 			test = new ArrayList<String>(M);
 			testA = new ArrayList<ArrayList<String>>(M);
 			for(int m=0;m<M;++m)	{
 				line = in.readLine();
 				line = line.substring(1);
 				test.add(line);
 				testA.add(new ArrayList<String>(Arrays.asList(line.split(""/""))));
 			}
 			for(int m=0;m<M;++m)	{
 //				pl(""candidate""+testA.get(m));
 				if (exist.contains(test.get(m)))	continue;
 				best = getBestCand(existA, testA.get(m));
 //				pl(""existA B""+existA);
 				cost += addEntry(existA,exist,testA.get(m),best);
 //				pl(""existA A""+existA);
 //				pl(""cost""+cost);
 //				pl(""--------------------------"");
 			}
 			pl(""Case #"" + t + "": "" + cost);
 			out.println(""Case #"" + t + "": "" + cost);
 		}
 		in.close();out.close();		
 	}
 	public static void main(String[] args) {
 		try {
 			java.util.Date t1 = new java.util.Date();
 			new A().run();
 			java.util.Date t2 = new java.util.Date();
 			long diff = (t2.getTime() - t1.getTime());
 			System.out.println(""Time: ""+(((float)diff)/1000));
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 }
",0
356,8486,"package tic_tac_toe_tomek;
 
 import java.io.*;
 
 public class Tic_Tac_Toe_Tomek {
     
     public Tic_Tac_Toe_Tomek(){
         int T,i,j,k;
         try {
             FileInputStream fis=new FileInputStream(""A-large.in"");
             DataInputStream dis=new DataInputStream(fis);
             T=Integer.parseInt(dis.readLine());
             String s="""";
             for(i=1;i<=T;i++){
                 int min=0,data[][]=new int[5][5];
                 String win=""Draw"";
                 for(j=0;j<4;j++){
                     char c[]=dis.readLine().toCharArray();
                     for(k=0;k<4;k++){
                         data[j][k]=(int)c[k] - 79;
                         if(min==0 && data[j][k]<0) {
                             min=-1;
                         }
 //                        System.out.print(data[j][k]+ "" "");
                     }
                     data[j][4]=data[j][0]+data[j][1]+data[j][2]+data[j][3];
                 }
                 for(j=0;j<4;j++){
                     data[4][j]=data[0][j]+data[1][j]+data[2][j]+data[3][j];
                 }
                 dis.readLine();
                 for(j=0;j<4;j++){
                         if(data[4][j]==0 ||data[j][4]==0 ||data[4][j]==5 ||data[j][4]==5) {
                         win=""O won"";
                     }
                         else if(data[4][j]==32 ||data[j][4]==32 ||data[4][j]==36 ||data[j][4]==36) {
                         win=""X won"";
                     }                           
                 }
                 if(win.equalsIgnoreCase(""Draw""))
                 {
                     int temp1=data[0][0]+data[1][1]+data[2][2]+data[3][3];
                     int temp2=data[3][0]+data[2][1]+data[1][2]+data[0][3];
                     if(temp1==0 || temp1==5 || temp2==0 || temp2==5) {
                         win=""O won"";
                     }
                     else if(temp1==32 || temp1==36 || temp2==32 || temp2==36) {
                         win=""X won"";
                     }
                     else if(min<0) {
                         win=""Game has not completed"";
                     }
                 }
                 s+=""Case #""+i+"": ""+win+""\n"";
             }
 //            System.out.println(s);
             FileOutputStream fos = new FileOutputStream(""A-large.out"");
             DataOutputStream dos=new DataOutputStream(fos);
             dos.writeBytes(s);
             fos.close();
             fis.close();
         } catch (IOException ex) { 
             System.out.println(""Error: ""+ex);
         }
    }
 
     public static void main(String[] args) {
        new Tic_Tac_Toe_Tomek();
     }
 }
","package dance_comp;
 
 import java.io.*;
 
 public class Dance_Comp {
     int N,count=0;
     String s="""",temp[];
     public Dance_Comp() {
         try {
             FileInputStream fis=new FileInputStream(""B-large.in"");
             DataInputStream dis=new DataInputStream(fis);
             FileOutputStream fos = new FileOutputStream(""B-large.out"");
             DataOutputStream dos=new DataOutputStream(fos);
             N=Integer.parseInt(dis.readLine());
             for(int i=1;i<=N;i++)
             {
                 s=dis.readLine();
                 count=0;
                 temp=s.split("" "");
                 int dancer=Integer.valueOf(temp[0]),surp=Integer.valueOf(temp[1]),cut_of=Integer.valueOf(temp[2]);
                 int mrk;
                 for(int j=0;j<dancer;j++)
                 {
                     mrk=Integer.valueOf(temp[3+j]);
                     int r=mrk%3;
                     mrk=mrk/3;
                     if(mrk>=cut_of || (mrk==(cut_of-1) && r>0))
                     {
                         count++;
                     }
                     else if(surp>0 && ((mrk==(cut_of-2) && r==2) || (mrk==(cut_of-1) && mrk>0)))
                     {
                         count++;
                         surp--;
                     }
                 }
                 
                 s=""Case #""+i+"": ""+count;
                 if(i!=N)
                 {
                     s=s+""\n"";
                 }
 //                System.out.println(s);
                 dos.writeBytes(s);
             }
             fis.close();
             fos.close();
             }catch(Exception e){
                 System.out.println(""Error: ""+e);
             }
     }
 
     public static void main(String[] args) {
         new Dance_Comp();
     }
 }
",1
357,1439,"import java.io.*;
 import java.util.*;
 import java.util.regex.*;
 
 import static java.lang.Math.*;
 
 public class C {
 	public static void main(String[] args) throws Exception {
 
 		Scanner in = (args.length > 0) ? new Scanner(new File(args[0]))
 				: new Scanner(System.in);
 		int T = in.nextInt();
 		for (int zz = 1; zz <= T; zz++) {
 			System.err.format(""#%d\n"", zz);
 			System.out.format(""Case #%d: "", zz);
 
 			int A = in.nextInt();
 			int B = in.nextInt();
 			int y = 0;
 
 			Set<String> pairs = new HashSet<String>();
 
 			int D = (int) Math.log10(A);
 			long p0 = 10;
 			long p1 = (long) Math.pow(10, D);
 
 			for (int d = 1; d <= D; d++) {
 				for (long n = A; n <= B; n++) {
 					long m = ((n % p1) * p0) + (n / p1);
 					if (m > n && m <= B && !pairs.contains(n + "":"" + m)) {
 						y++;
 						pairs.add(n + "":"" + m);
 					}
 				}
 				p0 *= 10;
 				p1 /= 10;
 			}
 
 			System.out.format(""%d\n"", y);
 		}
 	}
 }
","import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class B {
 
 	/**
 	 * @param args
 	 * @throws IOException
 	 */
 	public static void main(String[] args) throws IOException {
 		// BufferedReader read = new BufferedReader(new InputStreamReader(
 		// new FileInputStream(
 		// ""C:/Users/Ortiga/Downloads/B-small-attempt0.in"")));
 
 		BufferedWriter write = new BufferedWriter(new OutputStreamWriter(
 				new FileOutputStream(
 						""C:/Users/Ortiga/Downloads/outputBlarg.txt"")));
 		Scanner sc = new Scanner(new InputStreamReader(new FileInputStream(
 				""C:/Users/Ortiga/Downloads/B-large.in"")));
 		byte length = sc.nextByte();
 		for (byte i = 0; i < length; i++) {
 			byte t = sc.nextByte(), s = sc.nextByte(), p = sc.nextByte(), max = 0, getDuringSurp = 0;
 			String rit = ""Case #"" + (i + 1) + "": "";
 			byte[] t_i = new byte[t];
 			for (byte j = 0; j < t; j++)
 				t_i[j] = sc.nextByte();
 			Arrays.sort(t_i);
 			int sCounter = 0;
 			for (byte j = 0; j < t; j++) {
 				byte currT_i = t_i[j];
 				if (currT_i == 0 && p > 0)
 					continue;
 				if (sCounter < s) {
 					if ((currT_i - 2) % 3 == 0) {
 						if ((((currT_i - 2) / 3) + 2 >= p)) {
 							max++;
 							getDuringSurp++;
 						}
 						sCounter++;
 						continue;
 					} else if ((currT_i - 3) % 3 == 0) {
 						if ((((currT_i - 3) / 3) + 2 >= p)) {
 							max++;
 							getDuringSurp++;
 						}
 						sCounter++;
 						continue;
 					}
 				}
 				if ((currT_i - 1) % 3 == 0) {
 					if ((((currT_i - 1) / 3) + 1 >= p))
 						max++;
 					else if (currT_i + 4 / 3 >= p && getDuringSurp < sCounter) {
 						sCounter--;
 						j--;
 					}
 				} else if ((currT_i - 2) % 3 == 0) {
 					if ((((currT_i - 2) / 3) + 1 >= p))
 						max++;
 					else if (currT_i + 4 / 3 >= p && getDuringSurp < sCounter) {
 						sCounter--;
 						j--;
 					}
 				} else {
 					if (currT_i / 3 >= p)
 						max++;
 					else if (currT_i + 4 / 3 >= p && getDuringSurp < sCounter) {
 						sCounter--;
 						j--;
 					}
 				}
 			}
 			rit += max;
 			write.write(rit);
 			if (i < length - 1)
 				write.newLine();
 		}
 		sc.close();
 		write.close();
 	}
 }
",0
358,2179,"import java.io.*;
 import java.util.Locale;
 import java.util.Scanner;
 
 //Problem A. Tic-Tac-Toe-Tomek
 public class Main {
 
     // system
     public static String charset = ""UTF-8"";
     public static Locale locale = new Locale(""en"", ""US"");
     public static PrintWriter stdOut, fileOut;
     public static Scanner stdIn, fileIn;
 
     // task
     public static char[][] board;
 
     public static void main(String[] args) {
         setIO(""A-large.in"", ""output.out"");
         Scanner input = fileIn;
         PrintWriter output = fileOut;
 
         board = new char[4][4];
 
         int T = input.nextInt();
         for (int i = 1; i <= T; i++) {
             for (int j = 0; j < 4; j++) {
                 String s = input.next();
                 for (int k = 0; k < 4; k++) {
                     board[j][k] = s.charAt(k);
                 }
             }
             input.nextLine();
             String resStr = ""Case #"" + i + "": "" + solve();
             output.println(resStr);
             stdOut.println(resStr);
         }
 
         input.close();
         output.close();
     }
 
     // task
     public static String solve() {
         int x, o, empty;
         boolean isWin = false;
         x = o = empty = 0;
 
         // horizontally
         for (int i = 0; i < 4; i++) {
             x = o = 0;
             for (int j = 0; j < 4; j++) {
                 char c = board[i][j];
                 if      (c == 'X') x++;
                 else if (c == 'O') o++;
                 else if (c == 'T') {x++; o++;}
                 else               empty++;
             }
             if (x == 4 || o == 4) {
                 isWin = true;
                 break;
             }
         }
 
         if (!isWin) {
             // vertically
             for (int i = 0; i < 4; i++) {
                 x = o = 0;
                 for (int j = 0; j < 4; j++) {
                     char c = board[j][i];
                     if      (c == 'X') x++;
                     else if (c == 'O') o++;
                     else if (c == 'T') {x++; o++;}
                     else               empty++;
                 }
                 if (x == 4 || o == 4) {
                     isWin = true;
                     break;
                 }
             }
         }
 
         if (!isWin) {
             // diag 1
             x = o = 0;
             for (int i = 0; i < 4; i++) {
                 char c = board[i][i];
                 if      (c == 'X') x++;
                 else if (c == 'O') o++;
                 else if (c == 'T') {x++; o++;}
                 else               empty++;
             }
             if (x == 4 || o == 4) {
                 isWin = true;
             } else {
                 // diag 2
                 x = o = 0;
                 for (int i = 0; i < 4; i++) {
                     char c = board[4-i-1][i];
                     if      (c == 'X') x++;
                     else if (c == 'O') o++;
                     else if (c == 'T') {x++; o++;}
                     else               empty++;
                 }
                 if (x == 4 || o == 4) {
                     isWin = true;
                 }
             }
         }
 
         if (isWin) {
             if (x == 4) return ""X won"";
             else        return ""O won"";
         } else {
             if (empty == 0) return ""Draw"";
             else            return ""Game has not completed"";
         }
     }
 
     // system
     public static void setIO(String fileInName, String fileOutName) {
         // Standard input
         stdIn = new Scanner(new BufferedInputStream(System.in), charset);
         stdIn.useLocale(locale);
 
         // Standard output
         try {
             stdOut = new PrintWriter(new OutputStreamWriter(System.out, charset), true);
         }
         catch (UnsupportedEncodingException e) {
             System.err.println(e);
         }
 
         // File input
         if (fileInName != null) {
             try {
                 File file = new File(fileInName);
                 if (file.exists()) {
                     fileIn = new Scanner(file, charset);
                     fileIn.useLocale(locale);
                  }
             }
             catch (IOException ioe) {
                 System.err.println(""Could not open "" + fileInName);
             }
         }
 
         // File output
         if (fileOutName != null) {
             try {
                 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(fileOutName), charset);
                 fileOut = new PrintWriter(osw, true);
             }
             catch (IOException e) {
                 System.err.println(e);
             }
         }
     }
 }
","import java.io.*;
 import java.util.Locale;
 import java.util.Scanner;
 
 //Problem A. Tic-Tac-Toe-Tomek
 public class Main {
 
     // system
     public static String charset = ""UTF-8"";
     public static Locale locale = new Locale(""en"", ""US"");
     public static PrintWriter stdOut, fileOut;
     public static Scanner stdIn, fileIn;
 
     // task
     public static char[][] board;
 
     public static void main(String[] args) {
         setIO(""A-large.in"", ""output.out"");
         Scanner input = fileIn;
         PrintWriter output = fileOut;
 
         board = new char[4][4];
 
         int T = input.nextInt();
         for (int i = 1; i <= T; i++) {
             for (int j = 0; j < 4; j++) {
                 String s = input.next();
                 for (int k = 0; k < 4; k++) {
                     board[j][k] = s.charAt(k);
                 }
             }
             input.nextLine();
             String resStr = ""Case #"" + i + "": "" + solve();
             output.println(resStr);
             stdOut.println(resStr);
         }
 
         input.close();
         output.close();
     }
 
     // task
     public static String solve() {
         int x, o, empty;
         boolean isWin = false;
         x = o = empty = 0;
 
         // horizontally
         for (int i = 0; i < 4; i++) {
             x = o = 0;
             for (int j = 0; j < 4; j++) {
                 char c = board[i][j];
                 if      (c == 'X') x++;
                 else if (c == 'O') o++;
                 else if (c == 'T') {x++; o++;}
                 else               empty++;
             }
             if (x == 4 || o == 4) {
                 isWin = true;
                 break;
             }
         }
 
         if (!isWin) {
             // vertically
             for (int i = 0; i < 4; i++) {
                 x = o = 0;
                 for (int j = 0; j < 4; j++) {
                     char c = board[j][i];
                     if      (c == 'X') x++;
                     else if (c == 'O') o++;
                     else if (c == 'T') {x++; o++;}
                     else               empty++;
                 }
                 if (x == 4 || o == 4) {
                     isWin = true;
                     break;
                 }
             }
         }
 
         if (!isWin) {
             // diag 1
             x = o = 0;
             for (int i = 0; i < 4; i++) {
                 char c = board[i][i];
                 if      (c == 'X') x++;
                 else if (c == 'O') o++;
                 else if (c == 'T') {x++; o++;}
                 else               empty++;
             }
             if (x == 4 || o == 4) {
                 isWin = true;
             } else {
                 // diag 2
                 x = o = 0;
                 for (int i = 0; i < 4; i++) {
                     char c = board[4-i-1][i];
                     if      (c == 'X') x++;
                     else if (c == 'O') o++;
                     else if (c == 'T') {x++; o++;}
                     else               empty++;
                 }
                 if (x == 4 || o == 4) {
                     isWin = true;
                 }
             }
         }
 
         if (isWin) {
             if (x == 4) return ""X won"";
             else        return ""O won"";
         } else {
             if (empty == 0) return ""Draw"";
             else            return ""Game has not completed"";
         }
     }
 
     // system
     public static void setIO(String fileInName, String fileOutName) {
         // Standard input
         stdIn = new Scanner(new BufferedInputStream(System.in), charset);
         stdIn.useLocale(locale);
 
         // Standard output
         try {
             stdOut = new PrintWriter(new OutputStreamWriter(System.out, charset), true);
         }
         catch (UnsupportedEncodingException e) {
             System.err.println(e);
         }
 
         // File input
         if (fileInName != null) {
             try {
                 File file = new File(fileInName);
                 if (file.exists()) {
                     fileIn = new Scanner(file, charset);
                     fileIn.useLocale(locale);
                  }
             }
             catch (IOException ioe) {
                 System.err.println(""Could not open "" + fileInName);
             }
         }
 
         // File output
         if (fileOutName != null) {
             try {
                 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(fileOutName), charset);
                 fileOut = new PrintWriter(osw, true);
             }
             catch (IOException e) {
                 System.err.println(e);
             }
         }
     }
 }
",1
359,8545,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class Googlers {
 	public static void main(String[] args) throws FileNotFoundException {
 
 		Scanner in = new Scanner(new FileReader(new File(""B-large.in"")));
 		
 		PrintWriter out = new PrintWriter(new File(""B-large.out""));
 		
 		int t = in.nextInt();
 		in.nextLine();
 		
 		for(int i=0; i<t; i++) {
 			int n = in.nextInt();
 			int s = in.nextInt();
 			int p = in.nextInt();
 			
 			int r = 0;
 			
 			System.out.println(""s=""+s+"", p=""+p);
 			
 			for(int k=0; k<n; k++) {
 				int c = in.nextInt();
 				
 				int v1 = (int)Math.round(c / 3.0);
 				int v2 = v1;
 				int v3 = c - v1 - v2;
 			
 				System.out.print(v1+""+""+v2+""+""+ v3 + "" = "" + c + ""\t"");
 				if (v1>=p || v3>=p) { 
 					System.out.println("" >=p"");
 					r++;
 				}
 				else {
 					if (s>0) {
 						if (v1+1>=p && v1-1>=0) {
 							System.out.println("" special"");
 							
 							r++;
 							s--;
 						} else {
 							System.out.println("" can't make special"");
 						}
 					} else {
 						System.out.println("" no more spec"");	
 					}
 				} 
 			}
 
 			System.out.println(""------------"");
 			System.out.println(""r="" + r);
 			System.out.println(""============"");
 
 			
 			in.nextLine();
 			
 			out.println(""Case #"" + (i+1)+ "": "" + r);
 		}
 		out.close();
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.Vector;
 
 
 public class Recycled {
 	public static void main(String[] args) throws FileNotFoundException {
 
 		Scanner in = new Scanner(new FileReader(new File(""C-small-attempt0.in"")));
 		
 		PrintWriter out = new PrintWriter(new File(""C-small-attempt0.out""));
 		
 		int t = in.nextInt();
 		in.nextLine();
 		
 		for(int i=0; i<t; i++) {
 			int a = in.nextInt();
 			int b = in.nextInt();
 			int l = Integer.toString(a).length();
 			int r = 0;
 			
 
 //			System.out.println(""a=""+a+""\tb=""+b);
 			
 			Vector<Integer> sub = new Vector<Integer>(20); 
 			
 			for(int c=a; c<=b; c++) {
 				String cs = Integer.toString(c);
 				
 				sub.removeAllElements();
 
 				for(int k=1; k<l;k++) {
 					cs = cs.substring(1) + cs.charAt(0);
 					if (cs.charAt(0) == '0') continue;
 
 					int ns = Integer.parseInt(cs);
 					if (ns > c && ns <= b && !sub.contains(ns)) {
 						sub.add(ns);
 						r++;
 //						System.out.println(c+"" -> ""+ns);
 					}
 				}
 //				System.out.println(""......"");
 			}
 			
 			System.out.println(""Case #"" + (i+1)+ "" of ""+t+"": "" + r);
 //			System.out.println(""=================="");
 			
 			out.println(""Case #"" + (i+1)+ "": "" + r);
 		}
 		out.close();
 	}
 }
",1
360,7870,"
 import java.util.*;
 import java.io.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 public class BSmall {
 
     static int[] m = null;
     static int ct = 0;
 
     public static void main(String[] args) {
         Scanner sc = null;
         PrintWriter out = null;
 
         try {
             sc = new Scanner(new File(""B-small-attempt1.in""));
             out = new PrintWriter(new BufferedWriter(new FileWriter(""B-small.out"")));
 
         } catch (IOException ex) {
             Logger.getLogger(BSmall.class.getName()).log(Level.SEVERE, null, ex);
         }
         int cas = sc.nextInt();
         sc.nextLine();
         for (int zz = 0; zz < cas; zz++) {
             int ans = 0;
             ct=0;
             int p = sc.nextInt();
             int l = 1 << p;
             m = new int[l];
             for (int i = 0; i < l; i++) {
                 m[i] = p-sc.nextInt();
             }
             for (int i = 0; i < l - 1; i++) {
                 sc.nextInt();
             }
             rec(0, l);
             ans = ct;
             out.println(""Case #"" + (zz + 1) + "": "" + ans);
         }
         out.close();
     }
 
     private static void rec(int a, int b) {
 
         int d = a + (b - a) / 2;
         int min = 0;
         for (int i = a; i < b; i++) {
             min = Math.max(min, m[i]);
         }
         if (min > 0) {
             ct++;
             for (int i = a; i < b; i++) {
                 m[i]--;
             }
         }
         if(a==d) return;
         rec(a,d);
         rec(d,b);
 
     }
 }
","
 import java.util.*;
 import java.io.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 public class Magicka {
 
     public static void main(String[] args) {
         Scanner sc = null;
         PrintWriter out = null;
 
         try {
             sc = new Scanner(new File(""B-large.in""));
             out = new PrintWriter(new BufferedWriter(new FileWriter(""B-large.out"")));
 
         } catch (IOException ex) {
             Logger.getLogger(Magicka.class.getName()).log(Level.SEVERE, null, ex);
         }
         int cas = sc.nextInt();
         sc.nextLine();
         for (int zz = 0; zz < cas; zz++) {
             
             Map<String, String> combi = new HashMap<String, String>();
             Set<String> oppose = new HashSet<String>();
             Set<Character> bases = new HashSet<Character>();
 
             int cN = sc.nextInt();
             for(int i=0; i< cN; i++){
                 String st = sc.next();
                 combi.put(st.substring(0, 2), """"+st.charAt(2));
             }
 
             int cO = sc.nextInt();
             for(int i=0; i<cO; i++){
                 String st = sc.next();
                 oppose.add(st);
             }
 
             int N = sc.nextInt();
             char[] in = sc.next().toCharArray();
             Vector<Character> vector = new Vector<Character>();
 
             for(int i =0; i<N; i++){
                 vector.add(in[i]);
                 int l = vector.size();
                 if(l>=2){
                     String c1 = ("""" + vector.get(l-1)) + vector.get(l-2);
                     String c2 = ("""" + vector.get(l-2)) + vector.get(l-1);
                     String comb;
 
                     if(combi.containsKey(c1)) comb = combi.get(c1);
                     else if(combi.containsKey(c2)) comb = combi.get(c2);
                     else comb = null;
 
                     if(comb!=null){
                         vector.removeElementAt(l-1);
                         vector.removeElementAt(l-2);
                         vector.add(comb.charAt(0));
                     }
                     else{
                         for(int j=0; j<l-1; j++){
                             String cc1 = ("""" + vector.get(l-1)) + vector.get(j);
                             String cc2 = ("""" + vector.get(j)) + vector.get(l-1);
                             if(oppose.contains(cc1) || oppose.contains(cc2)){
                                 vector.clear();
                                 break;
                             }
                         }
                     }
 
                 }
             }
 
             String ret = ""["";
             for(int i=0; i<vector.size(); i++){
                 ret+= vector.get(i);
                 if(i+1 < vector.size()) ret+= "", "";
             }
             ret+=""]"";
 
             out.println(""Case #""+(zz+1)+"": ""+ret);
         }
         out.close();
     }
 }
",1
361,19793,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class DancingWithGooglers {
 
 	public int max(int s, int q, int[] score){
 		int pass = 0, fail = 0, pos = 0;
 		for(int sc : score){
 			if(sc == 0){
 				if(q == 0)
 					pass++;
 				else fail++;
 			}
 			else if(sc == 1){
 				if(q <= 1)
 					pass++;
 				else fail++;	
 			}
 			else if( (sc + 2) / 3 >= q)
 				pass++;
 			else if( (sc +1) / 3 +1 < q)
 				fail++;
 			else 
 				pos++;
 		}
 		
 		return pass + Math.min(pos, s);
 		
 	}
 	
 	
 	public static void main(String[] args) throws FileNotFoundException {
 		DancingWithGooglers d = new DancingWithGooglers();
 //		int[] c1 = {15,13,11};
 //		System.out.println(d.max(1,5,c1));
 //		
 //		int[] c2 = {23,22,21};
 //		System.out.println(d.max(0,8,c2));
 //		
 //		int[] c3 = {8, 0};
 //		System.out.println(d.max(1,1,c3));
 //		
 //		int[] c4 = {29,20, 8, 18, 18, 21};
 //		System.out.println(d.max(2,8,c4));
 		
 		File f = new File(args[0]);
 		Scanner sc = new Scanner(f);
 		int l = Integer.parseInt(sc.nextLine());
 		for(int i = 1; i <= l ;i++){
 			String[] line = sc.nextLine().split("" "");
 			int[] c = new int[Integer.parseInt(line[0])];
 			int s = Integer.parseInt(line[1]);
 			int q = Integer.parseInt(line[2]);
 			for(int j = 0; j < c.length; j++)
 				c[j] = Integer.parseInt(line[j+3]);
 			System.out.printf(""Case #%d: %s\n"", i, d.max(s, q, c));
 		}
 	}
 
 }
","package gcj2013.qualifications;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.PrintStream;
 import java.util.Locale;
 import java.util.StringTokenizer;
 
 public class C {
 	private static final String PROBLEM_SET = ""large1-0"";
 	private static final String DATA_FOLDER = C.class.getPackage()
 			.getName().replace('.', '/');
 	private static final String DATA_FILE_PREFIX = DATA_FOLDER + ""/""
 			+ C.class.getSimpleName() + ""-"" + PROBLEM_SET + ""."";
 
 	public C() {
 		Locale.setDefault(Locale.US);
 		BufferedReader reader = null;
 		PrintStream writer = null;
 		try {
 			copyFilesToOutputFolder(""src/""
 					+ getClass().getName().replace('.', '/') + "".java"");
 			StringTokenizer st;
 			reader = new BufferedReader(new FileReader(DATA_FILE_PREFIX + ""in""));
 			if (""test"".equals(PROBLEM_SET))
 				writer = System.out;
 			else
 				writer = new PrintStream(DATA_FILE_PREFIX + ""out"");
 
 			int T = Integer.parseInt(reader.readLine());
 			for (int t = 1; t <= T; t++) {
 				System.out.println(t);
 				st = new StringTokenizer(reader.readLine());
 				long A = Long.parseLong(st.nextToken());
 				long B = Long.parseLong(st.nextToken());
 				long X = (long) Math.ceil(Math.sqrt(A));
 				long Y = (long) Math.floor(Math.sqrt(B));
 				long tot = 0;
 				for(long n = X; n <= Y; n++) {
 					if(isPalindrome(n) && isPalindrome(n * n)) tot++;
 				}
 				writer.printf(""Case #%d: %d\n"", t, tot);
 			}
 		} catch (Exception ex) {
 			ex.printStackTrace();
 		} finally {
 			try {
 				if (reader != null)
 					reader.close();
 				if (writer != null)
 					writer.close();
 			} catch (Exception ex) {
 				ex.printStackTrace();
 			}
 		}
 	}
 	
 	private boolean isPalindrome(long n) {
 		String s = Long.toString(n);
 		for(int i = 0; i < s.length() / 2; i++) {
 			if(s.charAt(i) != s.charAt(s.length() - i - 1)) return false;
 		}
 		return true;
 	}
 
 	private static void copyFilesToOutputFolder(String... paths)
 			throws Exception {
 		byte[] buffer = new byte[4096];
 		int read;
 		FileInputStream is = null;
 		FileOutputStream os = null;
 		File dataFolderFile = new File(DATA_FOLDER);
 		for (String path : paths) {
 			File sourceFile = new File(path);
 			File outputFile = new File(dataFolderFile, sourceFile.getName());
 			try {
 				is = new FileInputStream(sourceFile);
 				os = new FileOutputStream(outputFile);
 				while ((read = is.read(buffer)) != -1) {
 					os.write(buffer, 0, read);
 				}
 			} finally {
 				if (is != null) {
 					is.close();
 					is = null;
 				}
 				if (os != null) {
 					os.close();
 					os = null;
 				}
 			}
 		}
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		new C();
 	}
 
 }
",0
362,1545,"/**
  * 
  */
 package main;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 /**
  * @author ya
  * 
  */
 public class BMain {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try {
 			BufferedReader br = new BufferedReader(new InputStreamReader(
 					new FileInputStream(new File(""B-small-attempt3.in""))));
 			FileWriter out = new FileWriter(new File(""output.out""));
 
 			int l = Integer.parseInt(br.readLine());
 			nextstep: for (int t = 0; t < l; t++) {
 
 				out.write(""Case #"" + (t + 1) + "": "");
 
 				String line = br.readLine();
 				int n = Integer.parseInt(line.split("" "")[0]);
 				int m = Integer.parseInt(line.split("" "")[1]);
 
 				int[][] mat = new int[n][m];
 				for (int i = 0; i < n; i++) {
 					String[] nums = br.readLine().split("" "");
 					for (int j = 0; j < nums.length; j++) {
 						mat[i][j] = Integer.parseInt(nums[j]);
 					}
 				}
 
 				System.out.println(t);
 				while (true) {
 					int min = 100, nextmin = 101;
 					for (int i = 0; i < n; i++) {
 						for (int j = 0; j < m; j++) {
 							if (min == mat[i][j])
 								;
 							else if (min > mat[i][j]) {
 								nextmin = min;
 								min = mat[i][j];
 							} else if (nextmin > mat[i][j]) {
 								nextmin = mat[i][j];
 							}
 						}
 					}
 					if (nextmin == 101) {
 						out.write(""YES\n"");
 						continue nextstep;
 					}
 
 					for (int i = 0; i < n; i++) {
 						for (int j = 0; j < m; j++) {
 							if (min == mat[i][j]) {
 								if (((i == 0 || mat[i - 1][j] == min) && (i == n - 1 || mat[i + 1][j] == min))
 										|| ((j == 0 || mat[i][j - 1] == min) && (j == m - 1 || mat[i][j + 1] == min)))
 									continue;
 								out.write(""NO\n"");
 								continue nextstep;
 							}
 						}
 					}
 
 					for (int i = 0; i < n; i++) {
 						for (int j = 0; j < m; j++) {
 							if (min == mat[i][j]) {
 								mat[i][j] = nextmin;
 							}
 						}
 					}
 				}
 
 			}
 			out.flush();
 			out.close();
 			br.close();
 		} catch (NumberFormatException | IOException e) {
 			e.printStackTrace();
 		}
 	}
 }","/**
  * 
  */
 package google.codejam.fourteen.qua;
 
 import google.codejam.tools.QuestionFile;
 
 import java.io.IOException;
 
 /**
  * @author ya
  * 
  */
 public class B {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		QuestionFile file = new QuestionFile(
 				A.class.getResourceAsStream(""B-small-attempt0.in""), ""B.out"");
 		int queNum = file.getLength();
 		try {
 			for (int t = 0; t < queNum; t++) {
 				String line = file.getLine();
 				String[] nums = line.split("" "");
 				Double C = Double.parseDouble(nums[0]);
 				Double F = Double.parseDouble(nums[1]);
 				Double X = Double.parseDouble(nums[2]);
 
 				Double result = solve(C, F, X);
 				file.writeAns(t, result);
 			}
 			file.end();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 
 	}
 
 	static Double solve(Double C, Double F, Double X) {
 		Double time = 0.0;
 
 		Double speed = 2.0;
 		while (X / speed > C / speed + X / (speed + F)) {
 			time += C / speed;
 			speed += F;
 		}
 		time += X / speed;
 		return time;
 	}
 }
",1
363,6956,"/**
  * 
  */
 package problem;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 
 import general.IO;
 
 /**
  * @author michael
  *
  */
 public class Problem {
 
 	/**
 	 * Metodo main que corre el programa.
 	 * @param args Argumentos con los que es llamado el programa.
 	 * @throws Exception Si hubo excepcion.
 	 */
 	public static void main(String args[]) throws Exception {
 
 		String file = ""C-small-attempt2"";
 
 		Object[] pairIO = IO.openIO(file);
 		BufferedReader red = (BufferedReader) pairIO[0];
 		PrintWriter wr = (PrintWriter) pairIO[1];
 		int problemas = Integer.parseInt(red.readLine());
 		for (int w = 0 ; w < problemas ; w++) {
 
 			String AB [] = red.readLine().split("" "");
 			int A = Integer.parseInt(AB[0]);
 			int B = Integer.parseInt(AB[1]);
 			int c = 0;
 			
 			A = (Math.sqrt(A) - ((int) Math.sqrt(A))) == 0? ((int) Math.sqrt(A)) : ((int) Math.sqrt(A))+1;
 			
 			for (int i = A ; i <= (int) Math.sqrt(B) ; i++) {
 				if (palindrome(i) && palindrome(i*i))
 					c++;
 			}
 			
 			String respuesta = """" + c;
 			// Aqui se imprime la solucion.
 			wr.println(""Case #"" + (w+1) + "": "" + respuesta);
 		}
 	}
 	
 	public static boolean palindrome (int x) {
 		char[] c = Integer.toString(x).toCharArray();
 		int i = 0, j = c.length-1;
 		while(i <= j && c[i] == c[j]) {
 			i++;
 			j--;
 		}
 		return i>j;
 	}
 }
","/**
  * 
  */
 package problem;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 
 import general.IO;
 
 /**
  * @author michael
  *
  */
 public class Problem {
 
 	/**
 	 * Metodo main que corre el programa.
 	 * @param args Argumentos con los que es llamado el programa.
 	 * @throws Exception Si hubo excepcion.
 	 */
 	public static void main(String args[]) throws Exception {
 
 		String file = ""C-small-attempt2"";
 
 		Object[] pairIO = IO.openIO(file);
 		BufferedReader red = (BufferedReader) pairIO[0];
 		PrintWriter wr = (PrintWriter) pairIO[1];
 		int problemas = Integer.parseInt(red.readLine());
 		for (int w = 0 ; w < problemas ; w++) {
 
 			String AB [] = red.readLine().split("" "");
 			int A = Integer.parseInt(AB[0]);
 			int B = Integer.parseInt(AB[1]);
 			int c = 0;
 			
 			A = (Math.sqrt(A) - ((int) Math.sqrt(A))) == 0? ((int) Math.sqrt(A)) : ((int) Math.sqrt(A))+1;
 			
 			for (int i = A ; i <= (int) Math.sqrt(B) ; i++) {
 				if (palindrome(i) && palindrome(i*i))
 					c++;
 			}
 			
 			String respuesta = """" + c;
 			// Aqui se imprime la solucion.
 			wr.println(""Case #"" + (w+1) + "": "" + respuesta);
 		}
 	}
 	
 	public static boolean palindrome (int x) {
 		char[] c = Integer.toString(x).toCharArray();
 		int i = 0, j = c.length-1;
 		while(i <= j && c[i] == c[j]) {
 			i++;
 			j--;
 		}
 		return i>j;
 	}
 }
",1
364,20707,"package RoundC2012;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 import java.util.Stack;
 
 public class A
 {
 	public static void main(String[] args)
 	{
 		try
 		{
 			BufferedReader input = new BufferedReader(new FileReader(""A-large.in""));
 			BufferedWriter output = new BufferedWriter(new FileWriter(""output""));
 			
 			Integer numCases = Integer.parseInt(input.readLine());			
 			
 			for(int i=0; i<numCases; ++i)
 			{
 				output.write(""Case #""+(i+1)+"":"");				
 				int N = Integer.parseInt(input.readLine());
 				int[][] matrix = new int[N][N];
 				
 				for(int j=0; j<N; ++j)
 				{
 					Scanner in= new Scanner(input.readLine());
 					int M = in.nextInt();
 					for(int k=0; k<M; ++k)
 						matrix[j][in.nextInt()-1] = 1;
 				}
 				
 				boolean diamond = false;
 				for(int j=0; j<N && !diamond; ++j)
 				{
 					//BFS
 					boolean[] visited = new boolean[N];
 					Stack<Integer> stack = new Stack<Integer>();
 					stack.push(j);
 					while(!stack.empty())
 					{
 						int current = stack.pop();
 						if(visited[current])
 						{
 							diamond = true;
 							break;
 						}
 						else
 						{
 							visited[current] = true;
 							for(int k=0; k<N; ++k)
 								if(matrix[current][k] == 1)
 									stack.push(k);
 						}
 					}
 					
 				}
 				
 				if(diamond)
 					output.write("" Yes"");
 				else
 					output.write("" No"");
 				
 				if(i != numCases-1)
 					output.write('\n');
 			}
 			
 			input.close();
 			output.close();
 		} catch (NumberFormatException e)
 		{
 			e.printStackTrace();
 		} catch (IOException e)
 		{
 			e.printStackTrace();
 		}
 	}
 }
","import static java.math.BigInteger.ONE;
 import static java.math.BigInteger.ZERO;
 import static java.math.BigInteger.valueOf;
 
 import java.io.File;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Scanner;
 
 public class coaster {
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new File(args[0]));
 		int t = sc.nextInt();
 		for (int x = 1; x <= t; x++) {
 			BigInteger r = valueOf(sc.nextInt());
 			BigInteger k = valueOf(sc.nextInt());
 			int n = sc.nextInt();
 			BigInteger[] ary = new BigInteger[n];
 			for (int y = 0; y < n; y++)
 				ary[y] = BigInteger.valueOf(sc.nextInt());
 			if (x == 11) {
 				System.err.println(""YAY"");
 			}
 			System.out.printf(""Case #%d: %s\n"", x, new coaster().go(r, k, ary));
 		}
 	}
 
 	private BigInteger go(BigInteger r, BigInteger k, BigInteger[] ary) {
 		BigInteger timeElapsed = ZERO;
 		Queue<BigInteger> q = new LinkedList<BigInteger>();
 		BigInteger score = ZERO;
 		for (BigInteger bi : ary)
 			q.add(bi);
 		Map<List<BigInteger>, pkg> mem = new HashMap<List<BigInteger>, pkg>();
 		while (r.compareTo(ZERO) != 0) {
 			if (mem.containsKey(q)) {
 				break;
 			}
 			mem.put(new LinkedList<BigInteger>(q), new pkg(score, timeElapsed));
 			r = r.subtract(ONE);
 			timeElapsed = timeElapsed.add(ONE);
 			BigInteger remainingSpace = k;
 			List<BigInteger> riding = new ArrayList<BigInteger>();
 			while (!q.isEmpty() && q.peek().compareTo(remainingSpace) <= 0) {
 				BigInteger bi = q.remove();
 				remainingSpace = remainingSpace.subtract(bi);
 				riding.add(bi);
 			}
 			for (BigInteger bi : riding) {
 				q.add(bi);
 			}
 			score = score.add(k).subtract(remainingSpace);
 		}
 
 		if (!r.equals(ZERO)) {
 			pkg firstInstance = mem.get(q);
 			BigInteger lengthOfLoop = timeElapsed.subtract(firstInstance.elapsedTime);
 			BigInteger extraLoops = r.divide(lengthOfLoop);
 			r = r.subtract(extraLoops.multiply(lengthOfLoop));
 			BigInteger loopScore = score.subtract(firstInstance.score);
 			score = score.add(loopScore.multiply(extraLoops));
 
 			BigInteger[] ary_new = new BigInteger[q.size()];
 			int idx = 0;
 			for (BigInteger bi : q)
 				ary_new[idx++] = bi;
 
 			return score.add(go(r, k, ary_new));
 		} else
 			return score;
 	}
 }
 
 class pkg {
 	public pkg(BigInteger score, BigInteger elapsedTime) {
 		this.score = score;
 		this.elapsedTime = elapsedTime;
 	}
 
 	public BigInteger score, elapsedTime;
 }
",0
365,8750,"import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class Geometry {
 
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new FileInputStream(new File(""D:\\Workspaces\\CodeJamPython\\CodeJamJava\\src\\A-large.in"")));
 		//BufferedReader rd = new BufferedReader(new FileReader(new File(""input.in"")));
 		
 		
 		
 		int T = in.nextInt();
 		
 		for(int t =0;t<T;t++){
 			
 			if(t == 16){
 				System.out.println("""");
 			}
 			
 			int R = in.nextInt();
 			int C = in.nextInt();
 			char a[][] = new char[R][C];
 			
 			for (int i=0;i<R;i++){
 				String s = in.next();
 				for(int j=0;j<C;j++){
 					a[i][j] = s.charAt(j);					
 				}				
 			}
 			
 			char[][] res = new char[R][C];
 			for (int i=0;i<R;i++){
 				for(int j=0;j<C;j++){
 					res[i][j]=a[i][j];
 					
 					
 				}				
 			}
 			
 			
 			
 			for (int i=0;i<R;i++){
 				for(int j=0;j<C;j++){
 					
 					if(j+1<C && i+1<R ){
 						
 						if(a[i][j]=='#' && a[i][j+1]=='#' && a[i+1][j]=='#' && a[i+1][j+1]=='#'){
 							
 							a[i][j]='/';
 							a[i][j+1]='\\';
 							a[i+1][j]='\\';
 							a[i+1][j+1]='/';
 							
 						}
 						
 						
 						
 					}
 					
 					
 				}				
 			}
 			
 			boolean im = false;
 			
 			for (int i=0;i<R;i++){
 				for(int j=0;j<C;j++){
 					if(a[i][j] == '#'){
 						
 						System.out.println(""Case #""+(t+1)+"":"");
 						System.out.println(""Impossible"");
 						im = true;
 						break;
 					}
 					
 				}	
 				if(im){
 					break;
 				}
 
 			}
 			
 			
 			
 			if(!im){
 				System.out.println(""Case #""+(t+1)+"":"");
 
 				for (int i=0;i<R;i++){
 					for(int j=0;j<C;j++){
 						System.out.print(a[i][j]);
 						
 					}
 					System.out.println();
 				}
 				
 				
 			}
 
 			
 		}
 
 	}
 
 }
","package com.vikram;
 
 public class Directory {
 	
 	public Directory parent;
 	
 	public String name;
 	
 	public int getCount(){
 		int count = 0;
 		
 		Directory parent1 = parent;
 		while(parent1!=null){
 			count++;
 			parent1 = parent1.parent;
 		}
 		return count;
 	}
 	
 	public String getFullName(){
 		String fn = name;
 		Directory parent1 = parent;
 		while(parent1!=null){
 			fn=fn+parent1.name;
 			parent1=parent1.parent;
 		}
 		return fn;
 		
 	}
 
 }
",1
366,7027,"import java.io.*;
 import java.util.*;
 
 public class cookie {
     public static void main(String[] args) throws Exception {
         Scanner in = new Scanner(new File(""cookie.in""));
         
         int a = Integer.parseInt(in.nextLine());
         
         for(int i = 0; i < a; i++) {
             String str = in.nextLine();
             double cost = Double.parseDouble(str.substring(0, str.indexOf("" "")));
             double rate = Double.parseDouble(str.substring(str.indexOf("" "") + 1, str.lastIndexOf("" "")));
             double goal = Double.parseDouble(str.substring(str.lastIndexOf("" "") + 1));
             
             double mintime = goal/2;
             double temptime = 0;
             double cps = 2;
             for(int j = 0; j < 1000001; j++) {//j = number of current farms
                 temptime += cost/cps;
                 cps += rate;
                 mintime = Math.min(mintime, temptime + goal/cps);
             }
             
             System.out.printf(""Case #%s: %.7f%n"", i + 1 + """", mintime);
         }
     }
 }","import java.util.*;
 import java.io.*;
 
 public class round1A1 {
     public static void main(String[] args) throws Exception {
         Scanner in = new Scanner(new File(""round1A1.in""));
         PrintStream out = new PrintStream(new File(""round1A1.out""));
         
         int a = Integer.parseInt(in.nextLine());
         
         for(int i = 0; i < a; i++) {
             String str = in.nextLine();
             int minanswer = Integer.MAX_VALUE / 2;
             int N = Integer.parseInt(str.substring(0, str.indexOf("" "")));
             int L = Integer.parseInt(str.substring(str.indexOf("" "") + 1));
             String[] arr = in.nextLine().split("" "");//outlets
             
             String[] arr2 = in.nextLine().split("" "");//applicances
             Arrays.sort(arr2);
             
             boolean[] doswitch = new boolean[L];
             for(int j = 0; j < arr.length; j++) {//compares all arr with arr2[0], the first outlet thing
                 int count = 0;
                 for(int k = 0; k < arr[j].length(); k++) {
                     doswitch[k] = arr[j].charAt(k) != arr2[0].charAt(k);
                     if(arr[j].charAt(k) != arr2[0].charAt(k)) count++;
                 }
                 String[] arr3 = new String[arr.length];//switched version of arr
                 for(int k = 0 ; k < arr3.length; k++) {
                     String string = """";
                     for(int l = 0; l < arr[k].length(); l++) {
                         if(doswitch[l]) {
                             string += arr[k].charAt(l) == '1' ? '0' : '1';
                         } else {
                             string += arr[k].charAt(l) == '1' ? '1' : '0';
                         }
                     }
                     arr3[k] = string;
                 }
                 Arrays.sort(arr3);
                 
                 if(Arrays.toString(arr3).equals(Arrays.toString(arr2))) {
                     minanswer = Math.min(minanswer, count);
                 }
             }
             if(minanswer != Integer.MAX_VALUE / 2) {
                 System.out.println(""Case #"" + (i + 1) + "": "" + minanswer);
             } else {
                 System.out.println(""Case #"" + (i + 1) + "": NOT POSSIBLE"");
             }
         }
     }
 }",1
367,305,"// gelovic
 // Problem B. Cookie Clicker Alpha
 
 package qualification.problemB;
 
 import java.util.*;
 import java.io.*;
 
 public class problemB {
 
 	final String archivo = ""B-small-attempt0"";
 	final String salida = ""Case #%d: %.7f\n"";
 	public Scanner in;
 	public PrintWriter out;
 	
 	public static void main(String[] args) throws IOException {
 		
 		Locale.setDefault(new Locale (""en"", ""US""));	// saca los datos en formato americano, como la coma flotante
 		problemB solucion = new problemB();
 		solucion.abrir();
 		solucion.run();
 		solucion.cerrar();
 	}
 	
 	public void abrir() throws IOException {
 		in = new Scanner(new File(archivo+"".in""));
 		out = new PrintWriter( new File(archivo+"".out""));
 	}
 	
 	public void cerrar() throws IOException {
 		in.close();
 		out.close();
 	}
 	
 	public void run() {
 		
 		int T = Integer.parseInt(in.nextLine());
 		
 		for (int caso = 1; caso <= T; caso++) {
 			
 			double C = in.nextDouble();
 			double F = in.nextDouble();
 			double X = in.nextDouble();
 			
 			double produce = 2;
 			double tiempo = X/produce;
 			double segundos = 0;
 			
 			for (int fabricas = 1; fabricas*C < X; fabricas++) {
 				segundos+=C/produce;
 				produce+=F;
 
 				double total=segundos+X/produce;
 				tiempo = (tiempo>total) ? total: tiempo;
 			}
 			mostrar (caso, tiempo);
 		}
 	}
 	
 	public void mostrar(int caso, double resultado) {
 		out.printf(salida, caso, resultado);
 	}
 	
 } // fin","// gelovic
 // Problem A. Magic Trick
 
 package qualification.problemA;
 
 import java.util.*;
 import java.io.*;
 
 public class problemA {
 
 	final String archivo = ""A-small-attempt4"";
 	final String salida = ""Case #%d: %s\n"";
 	public Scanner in;
 	public PrintWriter out;
 	
 	public static void main(String[] args) throws IOException {
 		
 		problemA solucion = new problemA();
 		solucion.abrir();
 		solucion.run();
 		solucion.cerrar();
 	}
 	
 	public void abrir() throws IOException {
 		in = new Scanner(new File(archivo+"".in""));
 		out = new PrintWriter( new File(archivo+"".out""));
 	}
 	
 	public void cerrar() throws IOException {
 		in.close();
 		out.close();
 	}
 	
 	public void run() {
 		
 		int T = Integer.parseInt(in.nextLine());
 		
 		for (int caso = 1; caso <= T; caso++) {
 			
 			int a = Integer.parseInt(in.nextLine())-1;
 			String[] A = new String[4];
 			for (int i = 0; i < 4; i++) {
 				A[i] = in.nextLine();
 			}
 			
 			int b = Integer.parseInt(in.nextLine())-1;
 			String[] B = new String[4];
 			for (int i = 0; i < 4; i++) {
 				B[i] = in.nextLine();
 			}
 			
 			String resultado = ""Volunteer cheated!"";
 			int cartas = 0;
 			for (String cartaA : A[a].split("" "")) {
 				for (String cartaB : B[b].split("" "")) {
 					if (cartaA.equals(cartaB)) {
 						resultado = cartaA;
 						if (++cartas > 1) {
 							resultado = ""Bad magician!"";
 							break;
 						}
 					}
 				}
 			}
 			mostrar (caso, resultado);
 		}
 	}
 	
 	public void mostrar(int caso, String resultado) {
 		out.printf(salida, caso, resultado);
 	}
 	
 } // fin",1
368,15312,"import java.util.Scanner;
 
 public class A {
 
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		int T = sc.nextInt();
 		for (int i = 1; i <= T; i++) {
 			int N = sc.nextInt();
 			String[] string = new String[N];
 			for (int j = 0; j < N; j++) {
 				string[j] = sc.next();
 			}
 			char[] carray = new char[101];
 			int[][] count = new int[N][101];
 			int index = 0;
 			carray[index] = string[0].charAt(0);
 			count[0][0]++;
 			for (int k = 1; k < string[0].length(); k++) {
 				if (string[0].charAt(k) == string[0].charAt(k - 1)) {
 					count[0][index]++;
 				} else {
 					carray[++index] = string[0].charAt(k);
 					count[0][index]++;
 				}
 			}
 			boolean flag = true;
 			for (int j = 1; j < N; j++) {
 				int index2 = 0;
 				for (int k = 0; k < string[j].length(); k++) {
 					if (string[j].charAt(k) != carray[index2]) {
 						if (count[j][index2] == 0) {
 							flag = false;
 						} else {
 							index2++;
 							if (string[j].charAt(k) != carray[index2]) {
 								flag = false;
 							} else {
 								count[j][index2]++;
 							}
 						}
 					} else {
 						count[j][index2]++;
 					}
 				}
 				if (count[0][index2 + 1] != 0) {
 					flag = false;
 				}
 			}
 			if (!flag) {
 				System.out.printf(""Case #%d: Fegla Won\n"", i);
 			} else {
 				int res = 0;
 				for (int k = 0; k < 100; k++) {
 					int sum = 0;
 					for (int j = 0; j < N; j++) {
 						sum += count[j][k];
 					}
 					int a = sum / N, b = (int) Math.ceil((double) sum / N);
 					int cura = 0, curb = 0;
 					for (int j = 0; j < N; j++) {
 						cura += Math.abs(count[j][k] - a);
 						curb += Math.abs(count[j][k] - b);
 					}
 					res += Math.min(cura, curb);
 				}
 				System.out.printf(""Case #%d: %d\n"", i, res);
 			}
 		}
 		sc.close();
 	}
 }","import java.util.Scanner;
 import java.util.TreeMap;
 
 
 public class SpeakingInTongues {
  public static void main(String[]args){
 	 Scanner sc = new Scanner(System.in);
 	 TreeMap<Character, Character> m = new TreeMap<Character, Character>();
 	 m.put('a', 'y');
 	 m.put('b', 'h');
 	 m.put('c', 'e');
 	 m.put('d', 's');
 	 m.put('e', 'o');
 	 m.put('f', 'c');
 	 m.put('g', 'v');
 	 m.put('h', 'x');
 	 m.put('i', 'd');
 	 m.put('j', 'u');
 	 m.put('k', 'i');
 	 m.put('l', 'g');
 	 m.put('m', 'l');
 	 m.put('n', 'b');
 	 m.put('o', 'k');
 	 m.put('p', 'r');
 	 m.put('q', 'z');
 	 m.put('r', 't');
 	 m.put('s', 'n');
 	 m.put('t', 'w');
 	 m.put('u', 'j');
 	 m.put('v', 'p');
 	 m.put('w', 'f');
 	 m.put('x', 'm');
 	 m.put('y', 'a');
 	 m.put('z', 'q');
 	 m.put(' ', ' ');
 	 
 	//Read in the T int -- Test Cases
 	int T = Integer.parseInt(sc.nextLine());
 	for (int t = 1; t <= T; t++) {
 		//START OF CODE
 		String sen = sc.nextLine();
 		String out = """";
 		for (int i = 0; i < sen.length(); i++) {
 			out += m.get(sen.charAt(i));
 		}
 		//END OF CODE
 		//OUTPUT
 		System.out.format(""Case #%d: %s\n"", t, out);
 	}
  }
 }
",0
369,11950,"import java.io.*;
 import java.util.*;
 
 
 public class tomek {
 
 	
 	public static void main(String[] args) throws IOException{
 		BufferedReader x = new BufferedReader(new FileReader(""C:/Documents and Settings/ruth/My Documents/alvin/Code Jam/A-large.in""));
 		PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(""C:/Documents and Settings/ruth/My Documents/alvin/test.out.txt"")));
 		int numcases=Integer.parseInt(x.readLine());
 		for (int i=1; i<=numcases; i++){
 			int[][]board=new int[4][4];
 			int counter=0;
 			for (int j=0; j<=3; j++){
 				String currentline=x.readLine();
 				for (int k=0; k<=3; k++){
 					if (currentline.charAt(k)=='X'){
 						board[j][k]=0;
 						counter++;
 					}
 					if (currentline.charAt(k)=='O'){
 						board[j][k]=1;
 						counter++;
 					}
 					if (currentline.charAt(k)=='T'){
 						board[j][k]=2;
 						counter++;
 					}
 					if (currentline.charAt(k)=='.'){
 						board[j][k]=3;
 					}
 				}
 			}
 			boolean finished=false;
 			//checking rows
 			for (int j=0; j<=3; j++){
 				int currentvalue=-1;
 				for (int k=0; k<=3; k++){
 					if (board[j][k]==3)break;
 					if (board[j][k]==1){
 						if (currentvalue==0)break;
 						currentvalue=1;
 					}
 					if (board[j][k]==0){
 						if (currentvalue==1)break;
 						currentvalue=0;
 					}
 					if (k==3){
 						if (currentvalue==0){
 							out.println(""Case #""+i+"": X won"");
 						}
 						if (currentvalue==1){
 							out.println(""Case #""+i+"": O won"");
 						}
 						finished=true;
 						break;
 					}
 				}
 			}
 			if (!finished){
 			for (int j=0; j<=3; j++){
 				int currentvalue=-1;
 				for (int k=0; k<=3; k++){
 					if (board[k][j]==3)break;
 					if (board[k][j]==1){
 						if (currentvalue==0)break;
 						currentvalue=1;
 					}
 					if (board[k][j]==0){
 						if (currentvalue==1)break;
 						currentvalue=0;
 					}
 					if (k==3){
 						if (currentvalue==0){
 							out.println(""Case #""+i+"": X won"");
 						}
 						if (currentvalue==1){
 							out.println(""Case #""+i+"": O won"");
 						}
 						finished=true;
 					}
 				}
 			}
 			}
 			if (!finished){
 			int currentvalue=-1;
 			for (int j=0; j<=3; j++){
 				if (board[j][j]==3)break;
 				if (board[j][j]==1){
 					if (currentvalue==0)break;
 					currentvalue=1;
 				}
 				if (board[j][j]==0){
 					if (currentvalue==1)break;
 					currentvalue=0;
 				}
 				if (j==3){
 					if (currentvalue==0){
 						out.println(""Case #""+i+"": X won"");
 					}
 					if (currentvalue==1){
 						out.println(""Case #""+i+"": O won"");
 					}
 					finished=true;
 				}
 			}
 			}
 			if (!finished){
 				int currentvalue=-1;
 				for (int j=3; j>=0; j--){
 					if (board[3-j][j]==3)break;
 					if (board[3-j][j]==1){
 						if (currentvalue==0)break;
 						currentvalue=1;
 					}
 					if (board[3-j][j]==0){
 						if (currentvalue==1)break;
 						currentvalue=0;
 					}
 					if (j==0){
 						if (currentvalue==0){
 							out.println(""Case #""+i+"": X won"");
 						}
 						if (currentvalue==1){
 							out.println(""Case #""+i+"": O won"");
 						}
 						finished=true;
 					}
 				}
 			}
 			if (!finished){
 				if (counter==16)out.println(""Case #""+i+"": Draw"");
 				else out.println(""Case #""+i+"": Game has not completed"");
 			}
 			x.readLine();
 		}
 		out.close();
 		System.exit(0);
 	}
 
 }
","import java.io.*;
 import java.util.*;
 
 
 public class fair {
 
 	/**
 	 * @param args
 	 */
 	
 	public static void main(String[] args) throws IOException {
 		BufferedReader x = new BufferedReader(new FileReader(""C:/Documents and Settings/ruth/My Documents/alvin/Code Jam/C-small-attempt0.in""));
 		PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(""C:/Documents and Settings/ruth/My Documents/alvin/test.out.txt"")));
 		int numcases=Integer.parseInt(x.readLine());
 		for (int cases=1; cases<=numcases; cases++){
 			StringTokenizer st = new StringTokenizer(x.readLine());
 			int start=Integer.parseInt(st.nextToken());
 			int end=Integer.parseInt(st.nextToken());
 			int[]palindrome=new int[5];
 			palindrome[0]=1;
 			palindrome[1]=4;
 			palindrome[2]=9;
 			palindrome[3]=121;
 			palindrome[4]=484;
 			int counter=0;
 			for (int i=0; i<=4; i++){
 				if (palindrome[i]>=start && palindrome[i]<=end){
 					counter++;
 				}
 			}
 			out.println(""Case #""+cases+"": ""+counter);
 		}
 		out.close();
 		System.exit(0);
 	}
 
 }
",1
370,7812,"import java.io.*;
 public class ttt{
 public static void main(String args[]) throws IOException{
 BufferedReader lector = new BufferedReader(new InputStreamReader(System.in));
 int aa = Integer.parseInt(lector.readLine());
 for(int n = 0;n<aa;n++){
 int x[] = new int[6];
 int o[] = new int[6];
 boolean tt[] = new boolean[6];
 int gana =-1;
 boolean punto = false;
 for(int m = 0;m<4;m++){
 String tmp = lector.readLine().trim();
 if(gana!=-1)continue;
 int xx = 0,oo = 0;
 boolean t = false;
 for(int mm = 0;mm<tmp.length();mm++){
 if(tmp.charAt(mm)=='.')punto = true;
 if(tmp.charAt(mm)=='X'){x[mm]++;xx++;if(mm==m)x[4]++;if(mm==3-m)x[5]++;}
 if(tmp.charAt(mm)=='O'){o[mm]++;oo++;if(mm==m)o[4]++;if(mm==3-m)o[5]++;}
 if(tmp.charAt(mm)=='T'){t=true;tt[mm]=true;if(mm==m)tt[4]=true;if(mm==3-m)tt[5]=true;}
 }
 if(xx==4 || (xx==3 && t))gana = 0;
 if(oo==4 || (oo==3 && t))gana = 1;
 //System.out.println(""fila x ""+xx+"" o ""+oo+"" t ""+t);
 }
 for(int k = 0;k<4;k++){
 //System.out.println(""col x ""+x[k]+"" o ""+o[k]+"" t ""+tt[k]);
 if(o[k]==4 || (o[k]==3 && tt[k]))gana = 1;
 else if(x[k]==4 || (x[k]==3 && tt[k]))gana = 0;
 }
 if(o[4]==4 || (o[4]==3 && tt[4]))gana = 1;
 if(o[5]==4 || (o[5]==3 && tt[5]))gana = 1;
 if(x[4]==4 || (x[4]==3 && tt[4]))gana=0;
 if(x[4]==4 || (x[4]==3 && tt[4]))gana = 0;
 System.out.println(""Case #""+(n+1)+"": ""+((gana==-1)?(punto)?""Game has not completed"":""Draw"":(gana==0)?""X won"":""O won""));
 if(n!=aa-1)
 lector.readLine();
 }
 }
 }
","import java.io.*;
 import java.util.*;
 public class CodeJam1{
 public static int rech[] = new int[26];
 public static void main(String args[]) throws IOException{
 String retal[] = {""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
 ""our language is impossible to understand"",
 ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
 ""there are twenty six factorial possibilities"",
 ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
 ""so it is okay if you want to just give up""};
 for(int n = 0;n<retal.length;n+=2){
 for(int k = 0;k<retal[n].length();k++)
 if(retal[n].charAt(k)!=' ')
 rech[retal[n].charAt(k)-'a']=retal[n+1].charAt(k)-'a';
 }
 rech['z'-'a']='q'-'a';
 rech['q'-'a']='z'-'a';
 BufferedReader lector = new BufferedReader(new FileReader(args[0]));
 String tmp = """";
 int t=1;
 tmp = lector.readLine();
 while((tmp = lector.readLine())!=null){
 System.out.print(""Case #""+(t++)+"": "");
 for(int n = 0;n<tmp.length();n++)
 System.out.print(((tmp.charAt(n)==' ')?' ':(char)(rech[tmp.charAt(n)-'a']+97)));
 System.out.println("""");
 }
 }
 }
",1
371,3273,"import java.util.*;
 
 public class A {
 public static void main(String [] args) {
 	Scanner scanner = new Scanner(System.in);
 	int nCase = Integer.parseInt(scanner.nextLine());
 	
 	char [][] board = new char[4][];
 	char T = 'T';
 	for (int nc = 1; nc <= nCase; nc++) {
 		for (int i = 0; i < 4; i++) {
 			board[i] = scanner.nextLine().toCharArray();
 		}
 		
 		int state = 0;
 		// Check row
 		for (int i = 0; i < 4 && state == 0; i++) {
 			char c = 'X';
 			if ((board[i][0] == c || board[i][0] == T)
 				&& (board[i][1] == c || board[i][1] == T)
 				&& (board[i][2] == c || board[i][2] == T)
 				&& (board[i][3] == c || board[i][3] == T))
 					state = 1;
 			c = 'O';
 			if ((board[i][0] == c || board[i][0] == T)
 				&& (board[i][1] == c || board[i][1] == T)
 				&& (board[i][2] == c || board[i][2] == T)
 				&& (board[i][3] == c || board[i][3] == T))
 					state = 2;
 		}
 		
 		// Check col
 		for (int i = 0; i < 4 && state == 0; i++) {
 			char c = 'X';
 			if ((board[0][i] == c || board[0][i] == T)
 				&& (board[1][i] == c || board[1][i] == T)
 				&& (board[2][i] == c || board[2][i] == T)
 				&& (board[3][i] == c || board[3][i] == T))
 					state = 1;
 			c = 'O';
 			if ((board[0][i] == c || board[0][i] == T)
 				&& (board[1][i] == c || board[1][i] == T)
 				&& (board[2][i] == c || board[2][i] == T)
 				&& (board[3][i] == c || board[3][i] == T))
 					state = 2;
 		}
 		
 		// check diag
 		if (state == 0) {
 			char c = 'X';
 			if ((board[0][0] == c || board[0][0] == T)
 				&& (board[1][1] == c || board[1][1] == T)
 				&& (board[2][2] == c || board[2][2] == T)
 				&& (board[3][3] == c || board[3][3] == T))
 					state = 1;
 			if ((board[0][3] == c || board[0][3] == T)
 				&& (board[1][2] == c || board[1][2] == T)
 				&& (board[2][1] == c || board[2][1] == T)
 				&& (board[3][0] == c || board[3][0] == T))
 					state = 1;
 			c = 'O';
 			if ((board[0][0] == c || board[0][0] == T)
 				&& (board[1][1] == c || board[1][1] == T)
 				&& (board[2][2] == c || board[2][2] == T)
 				&& (board[3][3] == c || board[3][3] == T))
 					state = 2;
 			if ((board[0][3] == c || board[0][3] == T)
 				&& (board[1][2] == c || board[1][2] == T)
 				&& (board[2][1] == c || board[2][1] == T)
 				&& (board[3][0] == c || board[3][0] == T))
 					state = 2;
 		}
 		if (state == 0) {
 			boolean finished = true;
 			for (int i = 0; i < 4; i++)
 			for (int j = 0; j < 4; j++) {
 				if (board[i][j] == '.') {
 					finished = false;
 					break;
 				}
 			}
 			if (finished)
 				state = 3;
 		}
 		
 		String ans = ""Game has not completed"";		
 		switch (state) {
 			case 1:
 				ans = ""X won"";
 				break;
 			case 2:
 				ans = ""O won"";
 				break;
 			case 3:
 				ans = ""Draw"";
 				break;
 		}
 		System.out.println(""Case #"" + nc + "": "" + ans);
 		if (nc < nCase)
 			scanner.nextLine();
 	}
 }
 }","import java.util.*;
 import java.io.*;
 import java.math.*;
 
 public class A {
 
 public static void main(String [] args) throws Exception
 {
 	//Scanner scan = new Scanner(new File(""A-small-attempt0.in""));
 	Scanner scan = new Scanner(new File(""A-large.in""));
 	
 	PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""outA1"")));
 	//PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""outA2"")));
 	
 	// solution
 	
 	int NCASE = scan.nextInt();
 	for (int nCase = 1; nCase <= NCASE; nCase++)
 	{
 		scan.nextLine();
 		int N = scan.nextInt();
 		int K = scan.nextInt();
 		
 		
 		StringBuilder str = new StringBuilder(Integer.toBinaryString(K)).reverse();
 		
 		
 		if (str.length() < N)
 			out.println(""Case #""+nCase+"": OFF"");
 		else {
 			boolean power = true;
 			for (int i = 0; i < N; i++)
 				power &= (str.charAt(i) == '1');
 			if (power)
 				out.println(""Case #""+nCase+"": ON"");
 			else
 				out.println(""Case #""+nCase+"": OFF"");
 		}
 	}
 
 	
 	out.close();
 	
 }
 }",1
372,18409,"import java.io.*;
 import java.util.*;
 
 public class FreeCell {
 	PrintWriter pw;
 	BufferedReader rd;
 	
 	void solve(int iCase) throws Exception{
 		StringTokenizer st = new StringTokenizer(rd.readLine());
 		long N = Long.parseLong(st.nextToken());
 		int PD = Integer.parseInt(st.nextToken());
 		int PG = Integer.parseInt(st.nextToken());
 		
 		boolean possible = false;
 		END:
 		for(int d = 1; d <= 100; d++){
 			for(int g = d; g <= 100; g++){
 				if(d <= N && d * PD % 100 == 0 && g * PG % 100 == 0){
 					int diff = (g * PG - d * PD)/100;
 					if(diff >=0 && diff <= g - d){
 						possible = true;
 						break END;
 					}
 				}
 			}
 		}
 		
 		pw.print(""Case #"");
 		pw.print(iCase);
 		pw.print("": "");
 		pw.println((possible)?""Possible"":""Broken"");
 	}
 	
 	void solve(String inName) throws Exception{
 		rd = new BufferedReader(new FileReader(inName));
 		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 		
 		int nCases = Integer.parseInt(rd.readLine());
 		for(int i = 1; i<=nCases;i++){
 			solve(i);
 		}
 		
 		rd.close();
 		pw.close();
 	}
 	
 	public static void main(String[] args) throws Exception{
 		new FreeCell().solve(args[0]);
 	}
 }
","package googlecodejam;
 
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 import java.io.*;
 import java.util.*;
 /**
  *
  * @author Tom
  */
 public class CookieClickerAlpha {
     private double farmCost;
     private double farmRate;
     private double goal;
     
     public static CookieClickerAlpha[] readFile(Scanner input) {
         CookieClickerAlpha[] puzzles = new CookieClickerAlpha[input.nextInt()];
         
         for(int i = 0; i < puzzles.length; ++i) {
             puzzles[i] = new CookieClickerAlpha(input.nextDouble(), input.nextDouble(), input.nextDouble());
         }
         
         return puzzles;
     }
     
     private CookieClickerAlpha(double farmCost, double farmRate, double goal) {
         this.farmCost = farmCost;
         this.farmRate = farmRate;
         this.goal = goal;
     }
     
     public String solve() {
         double current = goal/2;
         double rate = 2;
         double time = 0;
         boolean done = false;
         int x = 0;
         while(!done) {
             time = time + (farmCost/rate);
             rate += farmRate;
             double next = goal/rate + time;
             
             if(next < current) {
                 current = next;
             } else {
                 done = true;
             }
         }
         
         return String.format(""%.7f"", current);
     }
 }
",0
373,1607,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.util.Set;
 
 
 public class MagicTrick {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scanner = new Scanner(new File(""A-small-attempt0.in""));
 		int t = scanner.nextInt();
 		int caseNumber = 1;
 		while (caseNumber <= t) {
 			int a = scanner.nextInt();
 			for (int i = 1; i <= a; i++) {
 				scanner.nextLine();
 			}
 			Set<Integer> setA = new HashSet<Integer>();
 			for (int i = 0; i < 4; i++) {
 				setA.add(scanner.nextInt());
 			}
 			for (int i = a; i <= 4; i++) {
 				scanner.nextLine();
 			}
 			
 			int b = scanner.nextInt();
 			for (int i = 1; i <= b; i++) {	
 				scanner.nextLine();
 			}
 			Set<Integer> setB = new HashSet<Integer>();
 			for (int i = 0; i < 4; i++) {
 				setB.add(scanner.nextInt());
 			}
 			for (int i = b; i <= 4; i++) {
 				scanner.nextLine();
 			}
 
 			setA.retainAll(setB);
 			Integer[] resultArray = setA.toArray(new Integer[setA.size()]);
 			
 			String result = """";
 			if (resultArray.length == 1) {
 				result = String.valueOf(resultArray[0]);
 			} else if (resultArray.length == 0) {
 				result = ""Volunteer cheated!"";
 			} else if (resultArray.length > 1) {
 				result = ""Bad magician!"";
 			}
 			
 			System.out.println(""Case #"" + caseNumber++ + "": "" + result);
 		}
 	}
 	
 }
","package am.ik.googlecodejam;
 
 import java.io.BufferedReader;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
 public class BotTrust {
     public static void solve(int N, List<String> lines, PrintWriter writer) {
         // writer.println(N);
         for (int i = 0; i < N; i++) {
             // System.out.println(""======== "" + (i + 1) + "" ======="");
             writer.print(""Case #"" + (i + 1) + "": "");
             String line = lines.get(i);
             solveLine(line, writer);
             // System.out.println(""=================="");
         }
     }
 
     public static void solveLine(String line, PrintWriter writer) {
         // System.out.println(line);
         String[] vals = line.split("" "");
         int numberOfBtn = Integer.parseInt(vals[0]);
 
         int time = 0;
         int orange = 1; // positon of orange robot
         int blue = 1; // positon of blue robot
 
         Queue<Integer> orangeQueue = new LinkedList<Integer>();
         Queue<Integer> blueQueue = new LinkedList<Integer>();
 
         for (int i = 0; i < numberOfBtn; i++) {
             String color = vals[2 * i + 1];
             int position = Integer.parseInt(vals[2 * i + 2]);
 
             if (""O"".equals(color)) {
                 orangeQueue.add(position);
             } else if (""B"".equals(color)) {
                 blueQueue.add(position);
             } else {
                 throw new RuntimeException(""mis read"");
             }
         }
 
         for (int i = 0; i < numberOfBtn; i++) {
             String color = vals[2 * i + 1];
             int position = Integer.parseInt(vals[2 * i + 2]);
             if (""O"".equals(color)) {
                 orangeQueue.poll();
                 Integer nextBlue = blueQueue.peek();
                 // move phase
                 int diff = Math.abs(position - orange);
                 if (diff > 0) {
                     time += diff;
                     orange = position;
                 }
                 if (nextBlue != null) {
                     int bDiff = nextBlue - blue;
                     if (Math.abs(bDiff) > diff) {
                         if (bDiff > 0) {
                             blue += diff;
                         } else if (bDiff < 0) {
                             blue -= diff;
                         }
                     } else {
                         blue = nextBlue;
                     }
                 }
             } else if (""B"".equals(color)) {
                 blueQueue.poll();
                 Integer nextOrange = orangeQueue.peek();
                 // move phase
                 int diff = Math.abs(position - blue);
                 if (diff > 0) {
                     time += diff;
                     blue = position;
                 }
                 if (nextOrange != null) {
                     int oDiff = nextOrange - orange;
                     if (Math.abs(oDiff) > diff) {
                         if (oDiff > 0) {
                             orange += diff;
                         } else if (oDiff < 0) {
                             orange -= diff;
                         }
                     } else {
                         orange = nextOrange;
                     }
                 }
             }
             // System.out.printf(""t=%03d, move=[%s:%03d] O=%03d, B=%03d%n"",
             // time,
             // color, position, orange, blue);
 
             if (""O"".equals(color) && !blueQueue.isEmpty()) {
                 int bDiff = blueQueue.peek() - blue;
                 if (bDiff > 0) {
                     blue++;
                 } else if (bDiff < 0) {
                     blue--;
                 }
             } else if (""B"".equals(color) && !orangeQueue.isEmpty()) {
                 int oDiff = orangeQueue.peek() - orange;
                 if (oDiff > 0) {
                     orange++;
                 } else if (oDiff < 0) {
                     orange--;
                 }
             }
 
             // push phase
             time++;
             // System.out.printf(""t=%03d, push=[%s:%03d] O=%03d, B=%03d%n"",
             // time,
             // color, position, orange, blue);
         }
         writer.println(time);
     }
 
     public static void main(String[] args) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(Thread
                 .currentThread().getContextClassLoader()
                 .getResourceAsStream(""A-large.in"")));
 
         String line = reader.readLine();
         int N = Integer.parseInt(line);
         List<String> lines = new ArrayList<String>();
         while ((line = reader.readLine()) != null) {
             lines.add(line);
         }
         OutputStream out = new FileOutputStream(""answer.txt"");
         PrintWriter writer = new PrintWriter(out, true);
         solve(N, lines, writer);
         reader.close();
         writer.close();
     }
 }
",0
374,4177,"package googlestuff;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 /**
  *
  * @author Sean
  */
 public class GoroSort
 {
     public static void main(String[] args) throws FileNotFoundException, IOException
     {
         String filename = ""D-small-attempt1"";
         Scanner in = new Scanner(new File(filename + "".in""));
         FileWriter out = new FileWriter(filename + "".out"");
         int T = in.nextInt();
         for(int t=0; t<T; t++)
         {
             int N = in.nextInt();
             int count = 0;
             for(int n=1; n<=N; n++) if(in.nextInt()==n) count++;
             out.write(""Case #"" + (t+1) + "": "" + (N-count) + ""\n"");
         }
         out.close();
     }
 }
","import java.io.*;
 import java.util.*;
 import static java.lang.System.*;
 
 public class A
 {
 	public static class Pair implements Comparable<Pair>
 	{
 		int i, v;
 		double p;
 		public Pair(int i, int v)
 		{
 			this.i=i;
 			this.v=v;
 			p = 0;
 		}
 		public int compareTo(Pair that)
 		{
 			return that.v-this.v;
 		}
 	}
 	public static double formula(int N, int X, int Ji, int Jmax)
 	{
 		double res = (double)((N-1)*(Jmax-Ji)+X)/(N*X);
 		if (res < 0) res = 0;
 		return res*100;
 	}
 	public static void main(String[] args) throws Exception
 	{
 		//BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		Scanner sc = new Scanner(in);
 		PrintStream ps = new PrintStream(new BufferedOutputStream(out));
 		int cases = sc.nextInt();
 		for (int c = 1; c <= cases; c++)
 		{
 			int n = sc.nextInt();
 			Pair[] arr = new Pair[n];
 			int x = 0;
 			PriorityQueue<Pair> pq = new PriorityQueue<Pair>();
 			for (int i = 0; i < n; i++)
 			{
 				arr[i] = new Pair(i, sc.nextInt());
 				x += arr[i].v;
 				pq.add(arr[i]);
 			}
 			ps.printf(""Case #%d:"", c);
 			int cn = n;
 			int cx = x;
 			while (pq.size() != 0)
 			{
 				Pair p = pq.poll();
 				if (p.v*cn > 2*cx)
 				{
 					//ps.println(""hipster"");
 					p.p = 0;
 				}
 				else
 				{
 					p.p = 2.0/cn - (double)p.v/cx;
 					p.p *= 100;
 				}
 			}
 			for (int i = 0; i < n; i++)
 			{
 				ps.print("" ""+arr[i].p);
 			}
 			ps.println();
 		}
 		ps.flush();
 	}
 }
 
",0
375,10895,"import java.io.*;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
 
 
 
 
 public class TestMain{
 	
 	public static void main(String[] args) throws Exception{
 		
 		TestMain t = new TestMain();
 		t.testRun();
 		
 	}
 	
 	
 	void testRun()throws Exception{
 		inputStream = 
 			//new BufferedReader(new FileReader(""E:\\test\\input.txt""));
            new BufferedReader(new FileReader(""E:\\test\\A-small-attempt0.in""));
         outputStream = 
             new PrintWriter(new FileWriter(""E:\\test\\out.txt""));
         
         String str;
         
         str=inputStream.readLine();
         totalTestCase 	= Integer.parseInt(str);
         totalTestIndex 	= 1;	
         
         int i;
         
         while((str=inputStream.readLine())!=null){
         	String[] tmpStr = str.split("" "");
         	int x = Integer.parseInt(tmpStr[0]);
         	int s = Integer.parseInt(tmpStr[1]);
         	int r = Integer.parseInt(tmpStr[2]);
         	int t = Integer.parseInt(tmpStr[3]);
         	int n = Integer.parseInt(tmpStr[4]);
         	
         	String[] walkwayArray = new String[n];
         	
         	for(i=0;i<n;i++){
         		walkwayArray[i] = inputStream.readLine();
         	}
         	testCase(x,s,r,(float)t,n,walkwayArray);
         	
 		}
         
        
         inputStream.close();
         outputStream.close();
 	}
 	
 	void testCase(int x,int s,int r,float t,int n,String[] caseStrArray)throws Exception{
 		
 		
 		Walkway walkway = new Walkway();
 		walkway.init(caseStrArray);
 		List<Node> road = new LinkedList<Node>();
 		
 		int lastEnd = 0;
 		
 		for(int i=0;i<walkway.num;i++){
 			
 			if(walkway.begin[i]>lastEnd){
 				road.add(new Node(lastEnd,walkway.begin[i],0));
 			}
 			road.add(new Node(walkway.begin[i],walkway.end[i],walkway.speed[i]));
 			lastEnd = walkway.end[i];
 		}
 		
 		if(lastEnd<x){
 			road.add(new Node(lastEnd,x,0));
 		}
 		
 		int curMinValue  = 10000;
 		int nextMinValue = 10000;
 		Iterator it = road.iterator();
 		while(it.hasNext()){
 			Node node = (Node)it.next();
 			if(node.speed<curMinValue){
 				curMinValue = node.speed;
 			}
 		}
 		while(t>0&&curMinValue!=10000){
 			 it = road.iterator();
 			while(it.hasNext()){
 				Node node = (Node)it.next();
 				//System.out.println(""curMinValue:""+curMinValue);
 				if(node.speed==curMinValue){
 					
 					int addSpeed = node.speed+r;
 					float time = ((float)(node.end-node.begin))/((float)addSpeed);
 					if(time<=t){
 						node.time = time;
 						t-=time;
 						node.flag = 1;
 					}
 					else{
 						node.time = (((float)(node.end-node.begin))- t*addSpeed)/(float)(node.speed+s);
 						
 						node.time += t;
 						node.flag = 1;
 						t = 0;
 						break;
 					}
 					
 				}
 				else{
 					if(node.flag==0)
 						if(node.speed<nextMinValue){
 							nextMinValue = node.speed;
 						}
 					
 					
 				}
 				node.print();
 			}
 			//System.out.println(nextMinValue);
 			curMinValue = nextMinValue;
 			nextMinValue = 10000;
 		}
 		 it = road.iterator();
 		float allTime = 0;
 		while(it.hasNext()){
 			Node node = (Node)it.next();
 			if(node.flag==0){
 				node.time = ((float)(node.end - node.begin))/((float)(node.speed+s));
 			}
 			
 			allTime+=node.time;
 			node.print();
 		}
 		//System.out.println(allTime);
 		outputStream.println(""Case #""+totalTestIndex+"": ""+allTime);
 		totalTestIndex++;
 	}
 		
 
 	
 	int totalTestCase;
 	int totalTestIndex;
 	BufferedReader 	inputStream  = null;
 	PrintWriter		outputStream = null;
 	
 }
 
 class Node{
 	Node(int b,int e,int s){
 		begin = b;
 		end   = e;
 		speed = s;
 		flag  = 0;
 		time  = 0;
 	}
 	int begin;
 	int end;
 	int speed;
 	int flag;
 	float time;
 	void print(){
 		System.out.println(begin+""  ( ""+speed+""   )""+ end +""   time:""+time+"" flag:""+flag);
 	}
 }
 
 class Walkway{
 	
 	void init(String[] caseStrArray)throws Exception{
 		
 		num = caseStrArray.length;
 		begin = new int[num];
 		end   = new int[num];
 		speed = new int[num];
 		for(int i=0;i<num;i++){
 			String[] tmpArray = caseStrArray[i].split("" "");
 			begin[i] = Integer.parseInt(tmpArray[0]);
 			end[i] = Integer.parseInt(tmpArray[1]);
 			speed[i] = Integer.parseInt(tmpArray[2]);
 		}
 	}
 	
 	int[] begin;
 	int[] end;
 	int[] speed;
 	int num;
 }
","package gcj;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.StringTokenizer;
 
 public class ProblemA
 {
 	private final String inputFile = ""A-large.in"";
 	private final String outputFile = ""A-large.out"";
 
 	private BufferedReader in = null;
 	private BufferedWriter out = null;
 
 	public static void main(String[] args)
 	{
 		ProblemA prog = new ProblemA();
 
 		prog.openFiles();
 		prog.solution();
 		prog.closeFiles();
 
 		System.out.println(""THE END"");
 	}
 
 	private void openFiles()
 	{
 		// init input file
 		try
 		{
 			in = new BufferedReader(new FileReader(inputFile));
 		}
 		catch (FileNotFoundException ex)
 		{
 			System.out.println(""Input file not found!"");
 		}
 
 		// init output file
 		try
 		{
 			out = new BufferedWriter(new FileWriter(outputFile));
 		}
 		catch (IOException ex)
 		{
 			System.out.println(""Error writing output file!"");
 		}
 	}
 
 	private void closeFiles()
 	{
 		// close input file
 		try
 		{
 			in.close();
 		}
 		catch (IOException e)
 		{
 			System.out.println(""Error closing input!"");
 		}
 
 		// close output file
 		try
 		{
 			out.close();
 		}
 		catch (IOException e)
 		{
 			System.out.println(""Error closing output!"");
 		}
 	}
 
 	private void solution()
 	{
 		try
 		{
 			String s = in.readLine();
 
 			StringTokenizer st = new StringTokenizer(s);
 
 			int T = Integer.parseInt(st.nextToken());
 
 			System.out.println(T);
 
 			// read and write data
 			for (int i = 0; i < T; i++)
 			{
 				char[][] data = new char[4][4];
 
 				// reads data
 				for (int j = 0; j < 4; j++)
 				{
 					s = in.readLine();
 
 					for (int k = 0; k < 4; k++)
 					{
 						data[j][k] = s.charAt(k);
 					}
 
 				}
 
 				// reads empty line
 				in.readLine();
 
 				String answer = solveOne(data);
 
 				System.out.println(""result:"" + answer);
 
 				out.write(""Case #"" + Integer.toString(i + 1) + "": "" + answer);
 				out.newLine();
 			}
 		}
 		catch (IOException e)
 		{
 			System.out.println(""Error reading!"");
 		}
 	}
 
 	private String solveOne(char[][] data)
 	{
 		if (isWinner('X', data))
 		{
 			return ""X won"";
 		}
 		else if (isWinner('O', data))
 		{
 			return ""O won"";
 		}
 		else if (notFilled(data))
 		{
 			return ""Game has not completed"";
 		}
 		else
 		{
 			return ""Draw"";
 		}
 	}
 	
 	private boolean isWinner(char c, char[][] data)
 	{
 		for (int i = 0; i < 4; i++)
 		{
 			boolean goodRow = true;
 			
 			for (int j = 0; j < 4; j++)
 			{
 				if (data[i][j] != c && data[i][j] != 'T')
 				{
 					goodRow = false;
 					break;
 				}
 			}
 			
 			if (goodRow)
 			{
 				return true;
 			}
 		}
 		
 		for (int i = 0; i < 4; i++)
 		{
 			boolean goodColumn = true;
 			
 			for (int j = 0; j < 4; j++)
 			{
 				if (data[j][i] != c && data[j][i] != 'T')
 				{
 					goodColumn = false;
 					break;
 				}
 			}
 			
 			if (goodColumn)
 			{
 				return true;
 			}
 		}
 
 		boolean goodDiagonal = true;
 		
 		for (int i = 0; i < 4; i++)
 		{
 			if (data[i][i] != c && data[i][i] != 'T')
 			{
 				goodDiagonal = false;
 			}
 		}
 		
 		if (goodDiagonal)
 		{
 			return true;
 		}
 		
 		goodDiagonal = true;
 		
 		for (int i = 0; i < 4; i++)
 		{
 			if (data[i][3-i] != c && data[i][3-i] != 'T')
 			{
 				goodDiagonal = false;
 			}
 		}
 		
 		if (goodDiagonal)
 		{
 			return true;
 		}
 		
 		return false;
 	}
 	
 	private boolean notFilled(char[][] data)
 	{
 		for (int i = 0; i < 4; i++)
 		{
 			for (int j = 0; j < 4; j++)
 			{
 				if (data[i][j] == '.')
 				{
 					return true;
 				}
 			}
 		}
 		
 		return false;
 	}
 }
",0
376,2367,"package com.gcj2010;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.HashMap;
 import java.util.Map;
 
 public class FileFixit {
 
 	private static class Node {
 		public Map<String, Node> children = new HashMap<String, Node>();
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws Exception {
 		BufferedReader reader = new BufferedReader(new FileReader(""A-small-attempt0.in""));
 
 		String line = reader.readLine().trim();
 
 		int t = Integer.parseInt(line);
 
 		for (int i = 0; i < t; ++i) {
 
 			String[] ex = reader.readLine().trim().split("" "");
 			int N = Integer.parseInt(ex[0]);
 			int M = Integer.parseInt(ex[1]);
 
 			int result = 0;
 			Node root = new Node();
 
 			for (int n = 0; n < N; ++n) {
 				line = reader.readLine().trim();
 				addToRoot(root, line);
 			}
 
 			for (int m = 0; m < M; ++m) {
 				line = reader.readLine().trim();
 				result += addToRoot(root, line);
 			}
 
 			//dumpNode(root, 0);
 
 			System.out.println(String.format(""Case #%d: %d"", i + 1, result));
 		}
 	}
 
 	public static void dumpNode(Node root, int d) {
 		for (int i = 0; i < d; ++i) {
 			System.out.print("" "");
 		}
 		for (Map.Entry<String, Node> entry : root.children.entrySet()) {
 			System.out.println(entry.getKey());
 			dumpNode(entry.getValue(), d + 4);
 		}
 	}
 	
 	public static int addToRoot(Node root, String full) {
 		int r = 0;
 		int p = full.substring(1).indexOf(""/"");
 		if (p < 0) {
 			String path = full.substring(1);
 			if (!root.children.containsKey(path)) {
 				Node node = new Node();
 				root.children.put(path, node);
 				r++;
 			}
 		} else {
 			String path = full.substring(1).substring(0, p);
 			if (!root.children.containsKey(path)) {
 				Node node = new Node();
 				root.children.put(path, node);
 				r++;
 			}
 			r += addToRoot(root.children.get(path), full.substring(1).substring(p));
 		}
 		
 		return r;
 	}
 }
","package com.gcj2011;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 
 public class Magicka {
     public static void main(String args[]) throws Exception {
 
         BufferedReader reader = new BufferedReader(new FileReader(""in2011/magicka/B-small-attempt0.in""));
 
         String line = reader.readLine().trim();
         int T = Integer.valueOf(line);
 
         for (int i = 0; i < T; ++i) {
             line = reader.readLine().trim();
             Scanner sc = new Scanner(line);
 
             Map<String, String> conv = new HashMap<String, String>();
             Set<String> annu = new HashSet<String>();
 
             int C = sc.nextInt();
             for (int c = 0; c < C; ++c) {
                 String comb = sc.next();
                 conv.put(comb.substring(0, 2), comb.substring(2, 3));
                 conv.put(comb.substring(1, 2) + comb.substring(0, 1), comb.substring(2, 3));
             }
 
             int D = sc.nextInt();
             for (int d = 0; d < D; ++d) {
                 String ann = sc.next();
                 annu.add(ann);
             }
 
             int size = sc.nextInt();
 
             String spell = sc.next();
             LinkedList<String> result = new LinkedList<String>();
 
             for (int j = 0; j < size; ++j) {
                 if (result.size() == 0) {
                     result.add(spell.substring(j, j + 1));
                 } else {
                     String cc = spell.substring(j, j + 1);
                     String c = result.get(result.size() - 1) + cc;
                     String r = conv.get(c);
                     if (r != null) {
                         result.pollLast();
                         result.add(r);
                     } else {
                         result.add(cc);
                         Set<String> t = new HashSet<String>(result);
                         for (String a : annu) {
                             String s1 = a.substring(0, 1);
                             String s2 = a.substring(1, 2);
                             if (t.contains(s1) && t.contains(s2)) {
                                 result.clear();
                             }
                         }
                     }
                 }
             }
 
             System.out.println(""Case #"" + (i + 1) + "": "" + result);
         }
     }
 }
",1
377,12859,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 
 
 public class main {
 
 	/**
 	 * @param args
 	 * @throws Exception 
 	 */
 
 	public static int[] flag;
 	public static ArrayList[] array;
 	public static void main(String[] args) throws Exception {
 		// TODO Auto-generated method stub
 		Input in = new Input(""small.txt"");
 		
 		File file = new File(""out.txt"");
 		FileWriter filewriter = new FileWriter(file);
 		BufferedWriter bw = new BufferedWriter(filewriter);
 		PrintWriter pw = new PrintWriter(bw);
 		
 		int n = in.getInt();
 		
 		for(int i = 0; i < n ; i ++){
 			int result = 0;
 			int num = i + 1 ;
 			int a = in.getInt();
 			int b = in.getInt();	
 			int d = Integer.toString(a).length();
 			array = new ArrayList[b+1];
 			for(int j = a ; j <= b; j++){
 				array[j] = new ArrayList();
 			}
 			for(int j = a ; j <=b ; j++){
 				String s = Integer.toString(j) + Integer.toString(j);
 				result += solve(s,d,a,b,j);				
 			}
 			
 			String ans = ""Case #"" +num +"": ""+result; 
 			pw.println(ans);
 			System.out.println(ans);
 		}
 		pw.close();
 		bw.close();
 		filewriter.close();
 	}
 	
 	public static int solve(String s , int d,int a , int b,int j){
 		int result = 0;
 		int original = j;
 		
 		for(int i = 0 ; i < d ; i++){
 			String sub = s.substring(i+1, i+1+d);
 			int subint = Integer.parseInt(sub);
 			
 			if(subint >= a && subint <=b && subint !=original){
 				if(subint<original){
 					int flag = 0;
 					for(int k  = 0 ; k < array[subint].size(); k++){
 						if(Integer.parseInt(array[subint].get(k).toString())==original){
 							flag++;
 							break;
 						}
 					}
 					if(flag ==0){
 						array[subint].add(original);
 						result++;
 					}
 				}else{
 					int flag = 0;
 					for(int k  = 0 ; k < array[original].size(); k++){
 						if(Integer.parseInt(array[original].get(k).toString())==subint){
 							flag++;
 							break;
 						}
 					}
 					if(flag ==0){
 						array[original].add(subint);
 						result++;
 					}
 				}
 			}
 			
 		}
 		return result;
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.StringTokenizer;
 
 class Input {
 	BufferedReader reader;
 	StringTokenizer st = new StringTokenizer("""");
 
 
 	public Input( BufferedReader reader_ ) { reader = reader_; }
 
 
 	public Input( InputStream in_ ) {
 		reader = new BufferedReader( new InputStreamReader( in_ ) );
 	}
 
 
 	public Input( String fileName ) throws Exception {
 		reader = new BufferedReader( new FileReader( new File( fileName ) ) );
 	}
 
 	public String getToken() throws IOException {
 		while( !st.hasMoreTokens() ) {
 			String line = reader.readLine();
 			if ( line == null )
 				return null;
 			st = new StringTokenizer( line );
 		}
 		return st.nextToken();
 	}
 
 	public int getInt() throws Exception {
 		int ret = Integer.parseInt( getToken() );
 		return ret;
 	}
 }",1
378,6819,"import java.util.Scanner;
 
 public class RecycledSmall {
 	public static void main(String[] args) {
 		Scanner scan = new Scanner(System.in);
 		int cases = scan.nextInt();
 		for (int trial = 1; trial <= cases; trial++) {
 			System.out.print(""Case #"" + trial + "": "");
 			int a = scan.nextInt();
 			int b = scan.nextInt();
 			int rots = 0;
 			for (int v = a; v < b; v++) {
 				rots += countRotations(v, b);
 			}
 			System.out.println(rots);
 		}
 	}
 
 	private static int countRotations(int v, int b) {
 		String vString = Integer.toString(v);
 		String nextString = vString;
 		int count = 0;
 		while (true) {
 			nextString = rotate(nextString);
 			if (nextString.equals(vString))
 				break;
 			int newV = Integer.parseInt(nextString);
 			if (newV > v && newV <= b)
 				count++;
 		}
 		return count;
 	}
 
 	private static String rotate(String nextString) {
 		return nextString.substring(1) + nextString.charAt(0);
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class gcj1a {
 	
 	public static void main(String[] args) throws FileNotFoundException {
 		 Scanner scanner = new Scanner(new File(""/Users/okt777/Documents/A-large.in.txt""));
 		 PrintWriter pw = new PrintWriter(""/Users/okt777/Documents/A-large.ou""); 
 		 int _case = 1;
 		  
 		 scanner.nextLine();
 		 while(scanner.hasNextLine())
 		 {
 			 int a = scanner.nextInt();
 			 int b = scanner.nextInt();
 			 scanner.nextLine();		   
 			 double[] c = new double[a];
 		   
 			 double[] p = new double[a+1];
 			 p[0] = 1;
 			 for (int i=0;i<a;i++) {
 				 c[i] = scanner.nextDouble();
 				 p[1+i] = p[i] * c[i];
 			 }		 
 			 scanner.nextLine();
 			 
 			 double r;
 			 
 
 			 // right way
 			 r = b + 2;
 			 //System.out.printf(""right way:%f\n"",r);
 			 
 			 // back
 			 for(int i=0;i<a+1;i++) {
 				 double tp;
 				 
 				 int ok_num = (b-i) +(a-i) +1;
 				 
 				 tp =  p[i] * ((b-i) +(a-i) +1) + (1-p[i])*(ok_num+b+1);
 				 
 				 r = Math.min(tp, r);
 				 //System.out.printf(""back:%d %f\n"",i, tp);
 
 			 }
 
 			 
 			 System.out.printf(""Case #%d: %f\n"", _case, r);
 		     pw.printf(""Case #%d: %f\n"", _case, r);
 		     _case++;
 		  }
 		  
 		  scanner.close();
 		  pw.close();
 		}
 	}
 
 
 
",0
379,14779,"import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 
 public class A2 {
     public static void main(String[] args) throws IOException {
         Scanner s = new Scanner(System.in);
       s = new Scanner(new File(""A-small-attempt0.in""));
 //      s = new Scanner(new File(""A-large.in""));
         PrintWriter pw = new PrintWriter(new FileWriter(new File(""a.txt"")));
         int c = s.nextInt();
         for(int t=1;t<=c;t++){
             int first = s.nextInt();
             int[] a = new int[16];
             for(int i=0;i<16;i++) a[i] = s.nextInt();
             int second = s.nextInt();
             int[] b = new int[16];
             for(int i=0;i<16;i++) b[i] = s.nextInt();
             String res = cal(first,a,second,b);
 
             System.out.printf(""Case #%d: "", t);
             pw.print(""Case #"" + t + "": "");
             System.out.println(res);
             pw.println(res);
             }
             pw.flush();
         }
     
     
     static String cal(int f, int[] a, int s, int[] b){
         List<Integer> l = new ArrayList<Integer>();
         List<Integer> l2 = new ArrayList<Integer>();
         for(int i=(f-1)*4;i<f*4;i++) l.add(a[i]);
         for(int j=(s-1)*4;j<s*4;j++) l2.add(b[j]);
         int r = 0;
         int v = 999;
         for(int x : l)
             for(int y:l2)
                 if(x == y) {
                     v = x;
                     ++r;
                 }
         if(r == 0) return ""Volunteer cheated!"";
         else if(r > 1) return ""Bad Magician!"";
         return """"+v;
     }
     
 
 }
","import java.io.*;
 import java.util.*;
 
 public class C implements Runnable
 {	
 	private String IFILE = ""C-small-attempt0.in"";
 	private Scanner in;
 	private PrintWriter out;
 	
 	public void Run() throws IOException
 	{
 		in = new Scanner(new File(IFILE));
 		out = new PrintWriter(""output.txt"");
 		
 		int ntest = in.nextInt();
 		for(int test = 1; test <= ntest; test++)
 		{
 			out.print(""Case #"" + test + "": "");
 			int n = in.nextInt();
 			int sum = 0;
 			int min = 1000000;
 			int xor = 0;
 			for(int i = 0; i < n; i++)
 			{
 				int x = in.nextInt();
 				sum += x;
 				min = Math.min(min, x);
 				xor ^= x;
 			}
 			if (xor == 0)
 				out.println(sum - min);
 			else
 				out.println(""NO"");
 		}
 		
 		in.close();
 		out.close();
 	}
 	
 	public void run()
 	{
 		try		
 		{
 			Run();
 		}
 		catch(IOException e)
 		{
 			
 		}
 	}
 
 	public static void main(String[] args) throws IOException
 	{
 		new C().Run();
 		//new Thread(new XXX()).start();
 	}
 
 }
",0
380,20388,"package fairsquare;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class FairSquare {
 	final static String PROBLEM_NAME = ""fairsquare"";
     final static String WORK_DIR = ""/Users/chandangiri/Desktop/CJ/"" + PROBLEM_NAME + ""/"";
     Long A,B;
     Long palin[] = {1L, 4L, 9L, 121L, 484L, 10201L, 12321L, 14641L, 40804L, 44944L, 1002001L, 1234321L, 4008004L, 100020001L, 102030201L, 104060401L, 121242121L, 123454321L, 125686521L, 400080004L, 404090404L, 10000200001L, 10221412201L, 12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L, 4004009004004L, 100000020000001L};
     
     void solve(Scanner sc, PrintWriter pw) {
     	String input = sc.nextLine();
     	String sent[] = input.split(""\\s+"");
     	A = Long.parseLong(sent[0]);
     	B = Long.parseLong(sent[1]);
     	int sz = palin.length;
     	int ct = 0;
     	for(int i=0; i<sz; i++) {
     		if(palin[i]>=A && palin[i]<=B) {
     			ct++;
     		}
     	}
     	pw.println(ct);
     }
     
 	public static void main(String[] args) throws IOException {
 		Scanner sc = new Scanner(new FileReader(WORK_DIR + ""input.txt""));
         PrintWriter pw = new PrintWriter(new FileWriter(WORK_DIR + ""output.txt""));
 		int testCount = sc.nextInt();
 		sc.nextLine();
 		for (int i = 0; i < testCount; i++) {
             pw.print(""Case #"" + (i + 1) + "": "");
             new FairSquare().solve(sc, pw);
         }
 		pw.flush();
         pw.close();
         sc.close();
 	}
 }
 
 
 
 
 
 
 
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.math.BigInteger;
 
 public class ThemePark
 {
 	private static final boolean DEBUG = false;
 
 	public static void main(String[] args) throws Exception
 	{
 		//process(""example.in"");
 		//process(""small.in"");
 		//process(""large.in"");
 		process(""C-small-attempt0.in"");
 		//process(""A-large.in"");
 	}
 
 	public static void process(String filename) throws Exception
 	{
 		if (DEBUG)
 			System.out.printf(""\n<<< %s\n"", filename);
 
 		BufferedReader reader = new BufferedReader(new FileReader(filename));
 		int cases = Integer.parseInt(reader.readLine());
 
 		for (int caseNo = 1; caseNo <= cases; ++caseNo)
 		{
 			if (DEBUG)
 				System.out.println();
 
 			String line1 = reader.readLine();
 			String line2 = reader.readLine();
 			System.out.printf(""Case #%d: %s\n"", caseNo, result(line1, line2));
 		}
 	}
 
 	public static String result(String line1, String line2)
 	{
 		String[] splitted1 = line1.split("" "");
 		String[] splitted2 = line2.split("" "");
 
 		int rounds = Integer.parseInt(splitted1[0]);
 		int limit = Integer.parseInt(splitted1[1]);
 		int groups = Integer.parseInt(splitted1[2]);
 		int[] groupSizes = new int[groups];
 
 		for (int i = 0; i < groups; ++i)
 		{
 			groupSizes[i] = Integer.parseInt(splitted2[i]);
 		}
 
 		// cache
 		Round[] roundData = new Round[groups];
 		Round currentRound = new Round();
 		Round loopRound = null;
 
 		if (DEBUG)
 			System.out.printf(""rounds:%d limit:%d groups:%d\n"", rounds, limit, groups);
 
 		// calculate income from each group until group reset
 		for (int startGroup = 0;;)
 		{
 			// loop found
 			if (roundData[startGroup] != null && roundData[startGroup].next != null)
 			{
 				loopRound = roundData[startGroup];
 				break;
 			}
 
 			if (DEBUG)
 				System.out.printf(""Ride: %d "", groupSizes[startGroup]);
 
 			int endGroup = (startGroup + 1) % groups;
 			int passengerCount = groupSizes[startGroup];
 
 			for (;;)
 			{
 				if (endGroup == startGroup || passengerCount + groupSizes[endGroup] > limit)
 				{
 					endGroup = (endGroup + groups - 1) % groups;
 					break;
 				}
 
 				if (DEBUG)
 					System.out.printf(""%d "", groupSizes[endGroup]);
 
 				passengerCount += groupSizes[endGroup];
 				endGroup = (endGroup + 1) % groups;
 			}
 
 			if (DEBUG)
 			{
 				System.out.println();
 				System.out.printf(""start:%d end:%d income: %d\n"", startGroup, endGroup, passengerCount);
 			}
 
 			// store current round information
 			currentRound.startGroup = startGroup;
 			currentRound.endGroup = endGroup;
 			currentRound.income = passengerCount;
 			roundData[startGroup] = currentRound;
 
 			startGroup = (endGroup + 1) % groups;
 
 			if (roundData[startGroup] == null)
 			{
 				roundData[startGroup] = new Round();
 			}
 
 			currentRound.next = roundData[startGroup];
 			currentRound = currentRound.next;
 		}
 
 		// find loop size and income
 		int loopSize = 0;
 		int loopIncome = 0;
 
 		for (Round round = loopRound;;)
 		{
 			++loopSize;
 			loopIncome += round.income;
 
 			if (round.next == loopRound)
 				break;
 
 			round = round.next;
 		}
 
 		if (DEBUG)
 			System.out.printf(""loop begin:%s size:%d income:%d\n"", loopRound, loopSize, loopIncome);
 
 		// calculate
 		BigInteger income = BigInteger.ZERO;
 		int playedRounds = 0;
 
 		currentRound = roundData[0];
 
 		// calculate income until meeting loop starting point
 		for (;;)
 		{
 			if (currentRound == loopRound)
 				break;
 
 			income = income.add(BigInteger.valueOf(currentRound.income));
 			++playedRounds;
 
 			currentRound = currentRound.next;
 		}
 
 		if (DEBUG)
 			System.out.printf(""leading rounds:%d income:%d\n"", playedRounds, income);
 
 		int remainingRounds = rounds - playedRounds;
 		int remainingLoops = remainingRounds / loopSize;
 		int remainingTrails = remainingRounds % loopSize;
 
 		if (DEBUG)
 			System.out.printf(""remaining rounds:%d (loops:%d trails:%d)\n"", remainingRounds, remainingLoops,
 					remainingTrails);
 
 		BigInteger totalLoopIncome = BigInteger.valueOf(remainingLoops);
 		totalLoopIncome = totalLoopIncome.multiply(BigInteger.valueOf(loopIncome));
 		income = income.add(totalLoopIncome);
 
 		if (DEBUG)
 			System.out.printf(""total loop income:%d\n"", totalLoopIncome);
 
 		currentRound = loopRound;
 
 		for (int i = 0; i < remainingTrails; ++i)
 		{
 			income = income.add(BigInteger.valueOf(currentRound.income));
 			currentRound = currentRound.next;
 		}
 
 		return income.toString();
 	}
 
 	static class Round
 	{
 		public Round next;
 		public int startGroup;
 		public int endGroup;
 		public int income;
 
 		public String toString()
 		{
 			return String.format(""<round[hash:%x next:%x start:%d end:%d income:%d]>"", hashCode(), (next == null ? 0
 					: next.hashCode()), startGroup, endGroup, income);
 		}
 	}
 }
",0
381,1295,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class Main {
 
 	public static void main(String[] args) throws IOException {
 		new Main();
 	}
 
 	public Main() throws IOException {
 		Scanner in = new Scanner(new File(""B-small-attempt4.in""));
 		BufferedWriter out = new BufferedWriter(new FileWriter(""B-small.txt""));
 		int amountOfTasks = in.nextInt();
 		for (int task = 0; task < amountOfTasks; task++) {
 			System.out.println(task);
 			long max = in.nextLong();
 			long regain = in.nextLong();
 			if (regain > max)
 				regain = max;
 			long energy = max;
 			int N = in.nextInt();
 			int[] array = new int[(int) N];
 			for (int i = 0; i < N; i++) {
 				array[i] = in.nextInt();
 			}
 			quickSort(array, 0, N-1);
 			
 			long totaal = 0;
 			if (regain == max) {
 				for (int i = (N-1); i >= 0; i--) {
 					totaal += energy*array[i];
 					energy = regain;
 				}
 			}
 			else {
 				int i = 0;
 				int j = (N-1);
 				boolean finished = false;
 				if (N == 1) {
 					totaal = energy*array[0];
 					finished = true;
 				}
 				if (N == 0) {
 					finished = true;
 				}
 				while(!finished) {
 					if (energy < max && (j-i) != 0) {
 						energy += (regain - 1);
 						if (energy > max) {
 							long teveel = max - energy;
 							if (teveel <= (energy - regain))
 								totaal += teveel*array[i];
 							else {
 								totaal += (energy - regain)*array[i];
 							}
 							energy = max;
 						}	
 						totaal += array[i];
 						i++;
 					} else if ((j-i) == 0) {
 						totaal += energy*array[i];
 						finished = true;
 					} else {
 						totaal += energy*array[j];
 						energy = regain;
 						j--;
 					}
 				}
 			}
 			System.out.println(totaal);
 			out.write(""Case #"" + (task + 1) + "": "" + totaal);
 			out.newLine();
 		}
 		in.close();
 		out.close();
 	}
 
 	private void solve() {
 
 	}
 	
 	public void quickSort(int array[], int start, int end)
 	{
 	        int i = start;                          // index of left-to-right scan
 	        int k = end;                            // index of right-to-left scan
 
 	        if (end - start >= 1)                   // check that there are at least two elements to sort
 	        {
 	                int pivot = array[start];       // set the pivot as the first element in the partition
 
 	                while (k > i)                   // while the scan indices from left and right have not met,
 	                {
 	                        while (array[i] <= pivot && i <= end && k > i)  // from the left, look for the first
 	                                i++;                                    // element greater than the pivot
 	                        while (array[k] > pivot && k >= start && k >= i) // from the right, look for the first
 	                            k--;                                        // element not greater than the pivot
 	                        if (k > i)                                       // if the left seekindex is still smaller than
 	                                swap(array, i, k);                      // the right index, swap the corresponding elements
 	                }
 	                swap(array, start, k);          // after the indices have crossed, swap the last element in
 	                                                // the left partition with the pivot 
 	                quickSort(array, start, k - 1); // quicksort the left partition
 	                quickSort(array, k + 1, end);   // quicksort the right partition
 	        }
 	        else    // if there is only one element in the partition, do not do any sorting
 	        {
 	                return;                     // the array is sorted, so exit
 	        }
 	}
 
 	public void swap(int array[], int index1, int index2) 
 	// pre: array is full and index1, index2 < array.length
 	// post: the values at indices 1 and 2 have been swapped
 	{
 		int temp = array[index1];           // store the first value in a temp
 		array[index1] = array[index2];      // copy the value of the second into the first
 		array[index2] = temp;               // copy the value of the temp into the second
 	}
 
 }
","import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 
 public class B {
 
 	public static void main(String[] args) throws IOException {
 		new B();
 	}
 	
 	public B() throws IOException {
 		Scanner in = new Scanner(new File(""B-small-attempt3.in""));
 		BufferedWriter out = new BufferedWriter(new FileWriter(""B-small.txt""));
 		int amountOfTasks = in.nextInt();
 		for (int task = 0; task < amountOfTasks; task++) {
 			System.out.println(""Case: #"" + (task+1));
 			
 			int x = in.nextInt() + 100;
 			int y = in.nextInt() + 100;
 			
 			ArrayList<Pair> list = new ArrayList<Pair>();
 			
 			String[][] field = new String[201][201];
 			field[100][100] = """";
 			
 			int inc = 1;
 			
 			list.add(new Pair(100,100));
 
 			boolean finished = false;
 			
 			while(!finished) {
 				ArrayList<Pair> newList = new ArrayList<Pair>();
 				for (int i = 0; i<list.size(); i++) {
 					Pair pair = list.get(i);
 					
 					Pair newPair = new Pair(pair.x, pair.y+inc);
 					//System.out.println(newPair.x + "" "" + newPair.y);
 					if (!containsPair(newList, newPair) && newPair.x >= 0 && newPair.x <=200 && newPair.y >= 0 && newPair.y <=200 /*&& field[newPair.x][newPair.y] == null*/) {
 						newList.add(newPair);
 						field[newPair.x][newPair.y] = field[pair.x][pair.y] + ""N"";
 						//System.out.println(newPair.x + "" "" + newPair.y);
 					}
 					
 					newPair = new Pair(pair.x, pair.y-inc);
 					//System.out.println(newPair.x + "" "" + newPair.y);
 					if (!containsPair(newList, newPair) && newPair.x >= 0 && newPair.x <=200 && newPair.y >= 0 && newPair.y <=200 /*&& field[newPair.x][newPair.y] == null*/) {
 						newList.add(newPair);
 						field[newPair.x][newPair.y] = field[pair.x][pair.y] + ""S"";
 						//System.out.println(newPair.x + "" "" + newPair.y);
 					}
 					
 					newPair = new Pair(pair.x+inc, pair.y);
 					//System.out.println(newPair.x + "" "" + newPair.y);
 					if (!containsPair(newList, newPair) && newPair.x >= 0 && newPair.x <=200 && newPair.y >= 0 && newPair.y <=200 /*&& field[newPair.x][newPair.y] == null*/) {
 						newList.add(newPair);
 						field[newPair.x][newPair.y] = field[pair.x][pair.y] + ""E"";
 						//System.out.println(newPair.x + "" "" + newPair.y);
 					}
 					
 					newPair = new Pair(pair.x-inc, pair.y);
 					//System.out.println(newPair.x + "" "" + newPair.y);
 					if (!containsPair(newList, newPair) && newPair.x >= 0 && newPair.x <=200 && newPair.y >= 0 && newPair.y <=200 /*&& field[newPair.x][newPair.y] == null*/) {
 						newList.add(newPair);
 						field[newPair.x][newPair.y] = field[pair.x][pair.y] + ""W"";
 						//System.out.println(newPair.x + "" "" + newPair.y);
 					}
 				}
 				System.out.println(field[x][y]);
 				
 				if (field[x][y] != null)
 					finished = true;
 				
 				list = newList;
 				
 				inc++;
 			}
 
 			System.out.println(field[x][y]);
 			out.write(""Case #"" + (task+1) + "": "" + field[x][y]);
 			out.newLine();
 		}
 		in.close();
 		out.close();
 	}
 	
 	private boolean containsPair(ArrayList<Pair> pairs, Pair pair) {
 		for (int i = 0; i < pairs.size(); i++) {
 			if (pairs.get(i).x == pair.x && pairs.get(i).y == pair.y)
 				return true;
 		}
 		return false;
 	}
 	
 	public class Pair {
 		public int x;
 		public int y;
 		public Pair(int xthis , int ythis) {
 			x = xthis;
 			y = ythis;
 		}
 	}
 }",1
382,388,"import static java.lang.Integer.parseInt;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 public class A {
 	
 	static BufferedReader in;
 	static PrintWriter out;
 	static StringTokenizer tok;
 	
 	static class Directory {
 		final Map<String, Directory> children = new HashMap<String, Directory>();
 		
 		int create(String path) {
 			while (path.length() > 0 && path.charAt(0) == '/') {
 				path = path.substring(1);
 			}
 			if (path.length() == 0) {
 				return 0;
 			}
 			int pos = path.indexOf('/');
 			String name;
 			if (pos < 0) {
 				name = path;
 				path = null;
 			} else {
 				name = path.substring(0, pos);
 				path = path.substring(pos + 1);
 			}
 			int ans = 0;
 			if (!children.containsKey(name)) {
 				children.put(name, new Directory());
 				ans = 1;
 			}
 			if (path != null) {
 				ans += children.get(name).create(path);
 			}
 			return ans;
 		}
 	}
 	
 	static void solveTest() throws Exception {
 		int n = nextInt();
 		int m = nextInt();
 		Directory root = new Directory();
 		for (int i = 0; i < n; i++) {
 			root.create(in.readLine());
 		}
 		int ans = 0;
 		for (int i = 0; i < m; i++) {
 			ans += root.create(in.readLine());
 		}
 		out.println(ans);
 	}
 	
 	static void solve() throws Exception {
 		int tests = nextInt();
 		for (int test = 1; test <= tests; test++) {
 			out.print(""Case #"" + test + "": "");
 			solveTest();
 		}
 	}
 
 	public static void main(String[] args) throws Exception {
 		System.out.print(""Enter filename: "");
 		System.out.flush();
 		String filename = new BufferedReader(new InputStreamReader(System.in)).readLine();
 		in = new BufferedReader(new InputStreamReader(
 			new FileInputStream(new File(filename + "".in""))));
 		out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
 			new FileOutputStream(new File(filename + "".out"")))));
 		solve();
 		in.close();
 		out.close();
 	}
 	
 	static String next() throws IOException {
 		while (tok == null || !tok.hasMoreTokens()) {
 			tok = new StringTokenizer(in.readLine());
 		}
 		return tok.nextToken();
 	}
 	
 	static int nextInt() throws IOException {
 		return parseInt(next());
 	}
 	
 	static BigInteger nextBigInt() throws IOException {
 		return new BigInteger(next());
 	}
 }","
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Scanner;
 
 
 public class clickonce {
 
     static int R = 0;
     static int C = 0; 
     public static void main(String[] args) throws Exception {
         Scanner sc = new Scanner(new FileReader(""/Users/hadoop/C-large.in.txt""));
         PrintWriter pw = new PrintWriter(new FileWriter(""/Users/hadoop/corrlarge.txt""));
         
         int T = Integer.valueOf(sc.nextLine());
         for(int cs = 1; cs <= T; cs++)
         {
             R = sc.nextInt();
             C = sc.nextInt(); 
             int M = sc.nextInt();
             String output = """";
             ArrayList<ArrayList<Character>> result = new ArrayList<ArrayList<Character>>(); 
             for(int i= 0; i < R; i ++)
             {
                 result.add(i, new ArrayList<Character>());
                 for(int j = 0; j < C; j++)
                     result.get(i).add(j, '.');
             }
             if(M == 0)
             {
                 result.get(R-1).set(C-1, 'c');
                 output = buildOutput(result);
             }  
             else
             {
                 fill(result, M, false);
                 revealRec(result, R -1, C -1);
                 if(check(result))
                 {
                     result.get(R-1).set(C-1, 'c');
                     output = buildOutput(result);
                 }
                 else
                 {
                     result = new ArrayList<ArrayList<Character>>(); 
                     for(int i= 0; i < R; i ++)
                     {
                         result.add(i, new ArrayList<Character>());
                         for(int j = 0; j < C; j++)
                             result.get(i).add(j, '.');
                     }
                     fill(result, M, true);
                     revealRec(result, R -1, C -1);
                     if(check(result))
                     {
                         result.get(R-1).set(C-1, 'c');
                         output = buildOutput(result);
                     }
                     else
                     {
                         result = new ArrayList<ArrayList<Character>>(); 
                         for(int i= 0; i < R; i ++)
                         {
                             result.add(i, new ArrayList<Character>());
                             for(int j = 0; j < C; j++)
                                 result.get(i).add(j, '.');
                         }
                         fill2(result, M);
                         revealRec(result, R -1, C -1);
                         if(check(result))
                         {
                             result.get(R-1).set(C-1, 'c');
                             output = buildOutput(result);
                         }
                         else
                         {
                             result = new ArrayList<ArrayList<Character>>(); 
                             for(int i= 0; i < R; i ++)
                             {
                                 result.add(i, new ArrayList<Character>());
                                 for(int j = 0; j < C; j++)
                                     result.get(i).add(j, '.');
                             }
                             fill3(result, M);
                             revealRec(result, R -1, C -1);
                             if(check(result))
                             {
                                 result.get(R-1).set(C-1, 'c');
                                 output = buildOutput(result);
                             }
                             else
                             {
                                 System.out.println(""Case #"" + cs + "": "");
                                 System.out.println(buildCheck(result));
                                 output = ""Impossible"";
                             }
                             
                         }
                         
                     }
                     
                 }
                 
             }
             
             pw.println(""Case #"" + cs + "": "");
             pw.println(output);
             
             System.out.println(""Case #"" + cs + "": "");
             System.out.println(output);
             
             
         }
         
         pw.flush(); 
         sc.close(); 
         pw.close(); 
     }
     
     private static boolean check(ArrayList<ArrayList<Character>> res)
     {
         for(int i = 0; i < R; i++)
             for(int j = 0; j < C; j++)
                 if(res.get(i).get(j) == '.')
                     return false; 
         return true; 
     }
     
     private static void revealRec(ArrayList<ArrayList<Character>> res, int i , int j)
     {
         if(res.get(i).get(j) != '.')
             return;
         int cnt = countAround(res, i , j);
         res.get(i).set(j, 't');
         if(cnt > 0)
             return;
         
         if(i > 0 && j > 0)
             revealRec(res, i-1, j-1);
         
         //check 1
         if(i > 0)
            revealRec(res, i-1, j);
         
         //check 2
         if(i > 0 && j <  C -1)
            revealRec(res, i-1, j+1);
         
         //check 3
         if(j > 0)
             revealRec(res, i, j-1);
         
         //check 4
         if(j < C -1)
             revealRec(res, i, j+1);
         
         //check 5
         if(i < R -1 && j > 0)
            revealRec(res, i+1, j-1);
         
         //check 6
         if(i < R -1 )
            revealRec(res, i+1, j);
         
         //check 7
         if(i < R -1 && j < C -1)
            revealRec(res, i+1, j+1);
         
     }
     
     private static void fill3(ArrayList<ArrayList<Character>> result, int M)
     {
         int fullRows = M / C; 
         fillRows3(fullRows, result);
         int MRem = M % C;
         
         int remRows = R - fullRows; 
         int fullCols = MRem / remRows;
         fillCols3(fullRows, fullCols, result);
         MRem = MRem  % remRows;
         
         if(MRem == 0)
             return;
         
         int downrow = fullRows; 
         
         int acrosscol = fullCols + 1;
         boolean down  = true; 
         boolean firstdown = true;
         while(MRem > 0)
         {
             MRem--;
             if(down)
             {
                 result.get(downrow).set(fullCols, '*');
                 downrow++;
                 if(firstdown)
                     firstdown = false;
                 else if(!(downrow == R - 1 && MRem == 1))
                     down = false; 
             }
             else
             {
                 result.get(fullRows).set(acrosscol, '*');
                 down = true;
                 acrosscol++; 
             }
         }
         
     }
     
     
     private static void fill2(ArrayList<ArrayList<Character>> result, int M)
     {
         int fullCols = M / R; 
         fillCols(fullCols, result);
         int MRem = M % R;
         
         int remCols = C - fullCols; 
         int fullRows = MRem / remCols;
         fillRows(fullCols, fullRows, result);
         MRem = MRem  % remCols;
         
         if(MRem == 0)
             return;
         
         int downrow = fullRows; 
         
         int acrosscol = fullCols + 1;
         boolean down  = true; 
         boolean firstdown = true;
         while(MRem > 0)
         {
             MRem--;
             if(down)
             {
                 result.get(downrow).set(fullCols, '*');
                 downrow++;
                 if(firstdown)
                     firstdown = false;
                 else if(!(downrow == R - 1 && MRem == 1))
                     down = false; 
             }
             else
             {
                 result.get(fullRows).set(acrosscol, '*');
                 down = true;
                 acrosscol++; 
             }
         }
         
     }
     
     private static void fillCols3(int from,int colsUpto,ArrayList<ArrayList<Character>> result )
     {
         for(int i = from; i < R ; i++)
             for(int j = 0; j < colsUpto; j++)
                 result.get(i).set(j, '*');
     }
     
     private static void fillRows3(int fillRowsUpto, ArrayList<ArrayList<Character>> result )
     {
         for(int i = 0; i < fillRowsUpto ; i++)
             for(int j = 0; j < C; j++)
                 result.get(i).set(j, '*');
     }
     
     private static void fillRows(int from,int rowsUpto,ArrayList<ArrayList<Character>> result )
     {
         for(int i = 0; i < rowsUpto ; i++)
             for(int j = from; j < C; j++)
                 result.get(i).set(j, '*');
     }
     
     private static void fillCols(int fillColsUpto, ArrayList<ArrayList<Character>> result )
     {
         for(int i = 0; i < R ; i++)
             for(int j = 0; j < fillColsUpto; j++)
                 result.get(i).set(j, '*');
     }
     
     
     private static void fill(ArrayList<ArrayList<Character>> result, int M, boolean down)
     {
         int currRow = 0; 
         int currCol = 0; 
         while(M > 0)
         {
             if(M >= R - currRow + C - currCol -1)
             {
                 M = M - R + currRow - C + currCol + 1; 
                 fillCol(currCol++, result);
                 fillRow(currRow++, result);
             }
             else if(M >= R - currRow)
             {
                 M = M - R + currRow; 
                 fillCol(currCol++, result);
             }
             else if(M >= C - currCol)
             {
                 M = M - C + currCol;
                 fillRow(currRow++, result);
             }
             else    
             {
                 if(down)
                     fillRest(result, M,currRow, currCol);
                 else
                     fillRest1(result, M, currRow, currCol);
                 return;
             }
         }
     }
     private static void fillRest1(ArrayList<ArrayList<Character>> result, int M, int currRow, int currCol)
     {
         int downrow = currRow; 
         int acrosscol = currCol + 1;
         boolean down = true;
         while(M > 0)
         {
             M--; 
             if(down)
             {
                 result.get(downrow).set(currCol, '*');
                 downrow++;
                 down = false; 
             }
             else
             {
                 result.get(currRow).set(acrosscol, '*');
                 down = true;
                 acrosscol++; 
             }
         }
     }
     
     private static void fillRest(ArrayList<ArrayList<Character>> result, int M, int currRow, int currCol)
     {
         int downrow = currRow; 
         int acrosscol = currCol + 1;
         boolean down = true;
         boolean firstdown = true;
         while(M > 0)
         {
             M--; 
             if(down)
             {
                 result.get(downrow).set(currCol, '*');
                 downrow++;
                 if(firstdown)
                     firstdown = false;
                 else 
                     down = false; 
             }
             else
             {
                 result.get(currRow).set(acrosscol, '*');
                 down = true;
                 acrosscol++; 
             }
         }
     }
     
     private static void fillRow(int rowIndex,ArrayList<ArrayList<Character>> result )
     {
         for(int j = 0; j < C; j++)
             result.get(rowIndex).set(j, '*');
     }
     
     private static void fillCol(int colIndex,ArrayList<ArrayList<Character>> result )
     {
         for(int j = 0; j < R; j++)
             result.get(j).set(colIndex, '*');
     }
     
     private static String buildCheck(ArrayList<ArrayList<Character>> result)
     {
         String output = """";
         for(ArrayList<Character> arr: result)
         {
             for(char c: arr)
                 output = output + c;
             
             output = output + ""\n"";
         }
         return output.substring(0, output.length()-1); 
     }
     
     private static String buildOutput(ArrayList<ArrayList<Character>> result)
     {
         String output = """";
         for(ArrayList<Character> arr: result)
         {
             for(char c: arr)
             {
                 if(c == 'c' || c == '*')
                     output = output + c;
                 else
                     output = output + '.';
             }
             output = output + ""\n"";
         }
         return output.substring(0, output.length()-1); 
     }
     
     private static int countAround(ArrayList<ArrayList<Character>> res, int i, int j)
     {
         
         int mines = 0; 
         //check 1
         if(i > 0 && j > 0)
            if(res.get(i-1).get(j-1) == '*') mines++; 
            
         //check 2
         if(i > 0)
            if(res.get(i-1).get(j) == '*') mines++; 
            
         //check 23
         if(i > 0 && j <  C -1)
            if(res.get(i-1).get(j+1) == '*') mines++; 
            
         //check 4
         if(j > 0)
            if(res.get(i).get(j-1) == '*') mines++; 
            
         //check 5
         if(j < C -1)
            if(res.get(i).get(j+1) == '*') mines++; 
            
         //check 6
         if(i < R -1 && j > 0)
            if(res.get(i+1).get(j-1) == '*') mines++; 
            
         //check 7
         if(i < R -1 )
            if(res.get(i+1).get(j) == '*') mines++; 
            
         //check 8
         if(i < R -1 && j < C -1)
            if(res.get(i+1).get(j+1) == '*') mines++; 
            
         return mines;
         
     }
     
 }
",0
383,8855,"import java.io.BufferedReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 
 public class InputRecord {
 	int caseCount;
 	public List<CaseRecord> cases = new ArrayList<CaseRecord>();
 	
 	InputRecord(BufferedReader f) throws NumberFormatException, IOException {
 		caseCount = Integer.parseInt(f.readLine());
 		for (int i = 0; i < caseCount; i++) {
 			cases.add(new CaseRecord(f));
 		}
 
 	}
 }
","package net.bgok.googleCodeJam.goroSort;
 
 
 
 public class Solver {
 	public String solve(Object caseRecord) {
 		CaseDescription c = (CaseDescription)caseRecord;
 		double solution = 0.0;
 		
 //		findCycles(c.items);
 // After a couple hours of analysis (yes, I did the math), the solution simplifies to this:
 		for (int i = 0; i < c.items.size(); i++ ) {
 			if (c.items.get(i) != (i+1)) {
 				solution += 1.0;
 			}
 		}
 		
 		
 		return String.format(""%.5f"", solution);
 	}
 
 //	private void findCycles(List<Integer> items) {
 //		List<Boolean> used = new ArrayList<Boolean>();
 //		
 //	}
 
 
 }
",1
384,736,"
 package codeJam.google.com;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 
 /**
  * @author Zhenyi
  * 2014 Apr 11, 2014 7:27:05 PM
  */
 public class MagicTrick {
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner(new File(
 				""C:/Users/Zhenyi/Downloads/A-small-attempt0.in""));
 		FileWriter out = new FileWriter(
 				""C:/Users/Zhenyi/Downloads/A-small-attempt0.out"");
 
 		int N = in.nextInt();
 
 		for (int cases = 1; cases <= N; cases++) {
 			int row1 = in.nextInt();
 			int[][] array1 = new int[4][4];
 			for(int i = 0; i < 4; i++){
 				for(int j = 0; j < 4; j++){
 					array1[i][j] = in.nextInt();
 				}
 			}
 			int row2 = in.nextInt();
 			int[][] array2 = new int[4][4];
 			for(int i = 0; i < 4; i++){
 				for(int j = 0; j < 4; j++){
 					array2[i][j] = in.nextInt();
 				}
 			}
 			HashSet<Integer> hs1 = new HashSet<Integer>();
 			HashSet<Integer> hs2 = new HashSet<Integer>();
 			for(int j = 0; j < 4; j++){
 				hs1.add(array1[row1-1][j]);
 			}
 			for(int j = 0; j < 4; j++){
 				hs2.add(array2[row2-1][j]);
 			}
 			int count = 0; 
 			int result = -1;
 			for(int n : hs1){
 				if(hs2.contains(n)){
 					count ++;
 					result = n;
 				}
 			}
 			if(count == 1){
 				out.write(""Case #"" + cases + "": "" + result +""\n"");
 			}else{
 				if(count == 0){
 					out.write(""Case #"" + cases + "": "" + ""Volunteer cheated!\n"");
 				}else{
 					out.write(""Case #"" + cases + "": "" + ""Bad magician!\n"");
 				}
 			}
 		}
 		in.close();
 		out.flush();
 		out.close();
 	}
 }
","
 package codeJam.google.com;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Scanner;
 
 /**
  * @author Zhenyi
  * 2014 Apr 11, 2014 7:27:05 PM
  */
 public class MagicTrick {
 	public static void main(String[] args) throws IOException {
 		Scanner in = new Scanner(new File(
 				""C:/Users/Zhenyi/Downloads/A-small-attempt0.in""));
 		FileWriter out = new FileWriter(
 				""C:/Users/Zhenyi/Downloads/A-small-attempt0.out"");
 
 		int N = in.nextInt();
 
 		for (int cases = 1; cases <= N; cases++) {
 			int row1 = in.nextInt();
 			int[][] array1 = new int[4][4];
 			for(int i = 0; i < 4; i++){
 				for(int j = 0; j < 4; j++){
 					array1[i][j] = in.nextInt();
 				}
 			}
 			int row2 = in.nextInt();
 			int[][] array2 = new int[4][4];
 			for(int i = 0; i < 4; i++){
 				for(int j = 0; j < 4; j++){
 					array2[i][j] = in.nextInt();
 				}
 			}
 			HashSet<Integer> hs1 = new HashSet<Integer>();
 			HashSet<Integer> hs2 = new HashSet<Integer>();
 			for(int j = 0; j < 4; j++){
 				hs1.add(array1[row1-1][j]);
 			}
 			for(int j = 0; j < 4; j++){
 				hs2.add(array2[row2-1][j]);
 			}
 			int count = 0; 
 			int result = -1;
 			for(int n : hs1){
 				if(hs2.contains(n)){
 					count ++;
 					result = n;
 				}
 			}
 			if(count == 1){
 				out.write(""Case #"" + cases + "": "" + result +""\n"");
 			}else{
 				if(count == 0){
 					out.write(""Case #"" + cases + "": "" + ""Volunteer cheated!\n"");
 				}else{
 					out.write(""Case #"" + cases + "": "" + ""Bad magician!\n"");
 				}
 			}
 		}
 		in.close();
 		out.flush();
 		out.close();
 	}
 }
",1
385,15170,"import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class SquareTile {
 
 	static char[] red ={'/','\\'};static char[][] pic;
 	static int r,c;
 
 	public static void main (String [] arg) throws FileNotFoundException{
 
 		Scanner in = new Scanner (new FileReader(""A-small-attempt1.in""));
 		PrintWriter out= new PrintWriter(""squareTile.out"");
 		int kase=in.nextInt();String s;
 		for(int p=1;p<=kase;p++){
 			r=in.nextInt();c=in.nextInt();pic= new char[r][c];
 			for(int i=0;i<r;i++)
 			{ 
 				s=in.next();
 				for(int j=0;j<c;j++)
 					pic[i][j]=s.charAt(j);
 			}out.println(""Case #""+p+"":"");
 			if (Compute()){		
 			
 			for(int i=0;i<r-1;i++){
 				out.println(pic[i]);
 			}out.print(pic[r-1]);			
 			}
 			else out.print(""Impossible"");
 			if(p<=kase-1)out.println();
 		}
 		out.close();
 	}
 
 	static boolean Compute(){
 		boolean possible=true;
 		for(int i=0;i<r && possible; i++)
 			for(int j=0;j<c;j++)				
 				if(pic[i][j]=='#' && !Arround(i, j)){
 					possible=false;
 					break;
 				}
 		
 		return possible;
 		}
 	
 	
 	static boolean Arround(int i,int j){
 		
 		if (i+1<r && j+1<c )
 			{
 			if (pic[i][j]=='#' && pic[i+1][j+1]=='#' && pic[i][j+1]=='#' && pic[i+1][j]=='#')
 			{	
 			 pic[i][j]=pic[i+1][j+1]=red[0];
 			 pic[i][j+1]=pic[i+1][j]=red[1];
 			 return true;
 			 }
 			else return false;
 			}			
 		return false;
 	}
 
 }
","import java.util.Scanner;
 
 public class Main {
 
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		int T = sc.nextInt();
 		for (int i = 1; i <= T; i++) {
 			double C = sc.nextDouble(), F = sc.nextDouble(), X = sc
 					.nextDouble();
 			double min = Integer.MAX_VALUE;
 			for (int j = 0;; j++) {
 				double sum = X / (2 + j * F);
 				for (int k = 0; k < j; k++) {
 					sum += C / (2 + k * F);
 				}
 				if (sum < min) {
 					min = sum;
 				} else {
 					break;
 				}
 			}
 			System.out.printf(""Case #%d: %.7f\n"", i, min);
 		}
 		sc.close();
 	}
 }",0
386,9570,"/**
  * B.java
  * @author Joel C. Soares
  */
 import java.util.Scanner;
 import java.util.LinkedList;
 import java.util.Collections;
  
 class Googlers implements Comparable<Googlers>
 {
 	int n1, n2, n3;
 	int restando;
 	
 	Googlers( int a, int b, int c, int r)
 	{
 		n1 = a; n2 = b; n3 = c; restando = r;
 	} 
 	
 	public int compareTo( Googlers g )
 	{
 		if( n3 > g.n3 )
 			return 1;
 		else if( n3 < g.n3 )
 			return -1;
 		else
 			return 0;
 	} 
 	
 } // fim de classe
 
 public class B
 {
 	// remove grupos que tem notas maiores que p
 	public static int countGooglers( LinkedList<Googlers> lista, int p )
 	{
 		int count = 0;
 		
 		for( int i = 0; i < lista.size(); i++ )
 		{
 			if( lista.get( i ).n3 >= p )
 				count++;
 		}
 		
 		return count;
 	} 
 
 	// faz ajuste para casos surpreendentes
 	public static void ajusteGooglersSurpreendentes( LinkedList<Googlers> lista, int p, int s )
 	{
 		Googlers g;
 		
 		// coloca em ordem
 		Collections.sort( lista );
 		
 		for( int i = lista.size() - 1; i >= 0; i-- )
 		{
 			g = lista.get( i );
 			if( s > 0 && g.n3 < p )
 			{
 				if( g.restando >= 2 )
 				{
 					g.restando -= 2;
 					g.n3 += 2;
 					if( g.restando > 0 )
 					{
 						g.restando--;
 						g.n2++;
 					}
 					s--;
 				}				
 			}
 		} // fim de for
 	} 
 	
 	public static void ajusteGooglers( LinkedList<Googlers> lista, int p, int s )
 	{
 		for( Googlers g : lista )
 		{
 			if( g.n3 + 1 >= p || g.n3 + 2 < p || g.restando == 1 ||
 				s == 0 )
 			{
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n3++;
 				}
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n2++;
 				}
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n1++;
 				}
 			} // fim de if
 		} // fim de for
 	} // fim de mtodo
 	
 	public static boolean existeResto( LinkedList<Googlers> lista )
 	{
 		for( Googlers g : lista )
 			if( g.restando > 0 )
 				return true;
 		
 		return false;
 	}
 	
 	public static void main( String args[] )
 	{
 		Scanner input = new Scanner( System.in );
 		int t, n, s, p, x, v;
 		LinkedList<Googlers> lista = new LinkedList<Googlers>();
 		
 		t = input.nextInt();
 		for( int i = 0; i < t; i++ )
 		{
 			n = input.nextInt();
 			s = input.nextInt();
 			p = input.nextInt();
 			lista.clear();
 			for( int j = 0; j < n; j++ )
 			{
 				x = input.nextInt();
 				v = x / 3;
 				x = x % 3;
 				
 				// ajusta
 				if( x == 0 && v > 0 )
 				{
 					x = 3;
 					v = v - 1;
 				} 
 				
 				lista.add( new Googlers( v, v, v, x ) );					
 			} // fim de for
 			
 			// faz ajuste triviais
 			ajusteGooglers( lista, p, s );
 			
 			// faz ajuste surpreendentes
 			ajusteGooglersSurpreendentes( lista, p, s );
 			
 			System.out.printf( ""Case #%d: %d\n"", i + 1, countGooglers( lista, p ) );
 		} // fim de for externo
 	}
 }","/**
  * B.java
  * @author Joel C. Soares
  */
 import java.util.Scanner;
 import java.util.LinkedList;
 import java.util.Collections;
  
 class Googlers implements Comparable<Googlers>
 {
 	int n1, n2, n3;
 	int restando;
 	
 	Googlers( int a, int b, int c, int r)
 	{
 		n1 = a; n2 = b; n3 = c; restando = r;
 	} 
 	
 	public int compareTo( Googlers g )
 	{
 		if( n3 > g.n3 )
 			return 1;
 		else if( n3 < g.n3 )
 			return -1;
 		else
 			return 0;
 	} 
 	
 } // fim de classe
 
 public class B
 {
 	// remove grupos que tem notas maiores que p
 	public static int countGooglers( LinkedList<Googlers> lista, int p )
 	{
 		int count = 0;
 		
 		for( int i = 0; i < lista.size(); i++ )
 		{
 			if( lista.get( i ).n3 >= p )
 				count++;
 		}
 		
 		return count;
 	} 
 
 	// faz ajuste para casos surpreendentes
 	public static void ajusteGooglersSurpreendentes( LinkedList<Googlers> lista, int p, int s )
 	{
 		Googlers g;
 		
 		// coloca em ordem
 		Collections.sort( lista );
 		
 		for( int i = lista.size() - 1; i >= 0; i-- )
 		{
 			g = lista.get( i );
 			if( s > 0 && g.n3 < p )
 			{
 				if( g.restando >= 2 )
 				{
 					g.restando -= 2;
 					g.n3 += 2;
 					if( g.restando > 0 )
 					{
 						g.restando--;
 						g.n2++;
 					}
 					s--;
 				}				
 			}
 		} // fim de for
 	} 
 	
 	public static void ajusteGooglers( LinkedList<Googlers> lista, int p, int s )
 	{
 		for( Googlers g : lista )
 		{
 			if( g.n3 + 1 >= p || g.n3 + 2 < p || g.restando == 1 ||
 				s == 0 )
 			{
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n3++;
 				}
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n2++;
 				}
 				if( g.restando > 0 )
 				{
 					g.restando--;
 					g.n1++;
 				}
 			} // fim de if
 		} // fim de for
 	} // fim de mtodo
 	
 	public static boolean existeResto( LinkedList<Googlers> lista )
 	{
 		for( Googlers g : lista )
 			if( g.restando > 0 )
 				return true;
 		
 		return false;
 	}
 	
 	public static void main( String args[] )
 	{
 		Scanner input = new Scanner( System.in );
 		int t, n, s, p, x, v;
 		LinkedList<Googlers> lista = new LinkedList<Googlers>();
 		
 		t = input.nextInt();
 		for( int i = 0; i < t; i++ )
 		{
 			n = input.nextInt();
 			s = input.nextInt();
 			p = input.nextInt();
 			lista.clear();
 			for( int j = 0; j < n; j++ )
 			{
 				x = input.nextInt();
 				v = x / 3;
 				x = x % 3;
 				
 				// ajusta
 				if( x == 0 && v > 0 )
 				{
 					x = 3;
 					v = v - 1;
 				} 
 				
 				lista.add( new Googlers( v, v, v, x ) );					
 			} // fim de for
 			
 			// faz ajuste triviais
 			ajusteGooglers( lista, p, s );
 			
 			// faz ajuste surpreendentes
 			ajusteGooglersSurpreendentes( lista, p, s );
 			
 			System.out.printf( ""Case #%d: %d\n"", i + 1, countGooglers( lista, p ) );
 		} // fim de for externo
 	}
 }",1
387,10943,"package me.godcoder.googlecodejam.world2014.qualificationround.magictrick;
 
 import me.godcoder.googlecodejam.api.InputReader;
 import me.godcoder.googlecodejam.world2014.qualificationround.magictrick.model.MagicTrickTestCase;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Ali Valizadeh
  */
 public class MagicTrickInputReaderImpl extends InputReader<MagicTrickTestCase> {
 
     public MagicTrickInputReaderImpl(String filePath) {
         super(filePath);
     }
 
     @Override
     protected List<MagicTrickTestCase> readCases() {
         List<MagicTrickTestCase> cases = new ArrayList<MagicTrickTestCase>();
         try {
             int caseLineNumber = 0;
             int caseNumber = 1;
             MagicTrickTestCase magicTrickTestCase = new MagicTrickTestCase();
             while (reader.ready() || caseNumber == numberOfCases){
                 if(caseLineNumber == 0){
                     magicTrickTestCase.setFirstAnswer(Integer.parseInt(reader.readLine()));
                     caseLineNumber++;
                 } else if(caseLineNumber >= 1 && caseLineNumber <= 4){
                     String[] items = reader.readLine().split("" "");
                     int[] row = new int[4];
                     for (int i = 0; i < items.length; i++) {
                         row[i] = Integer.parseInt(items[i]);
 
                     }
                     magicTrickTestCase.addRowToFirstArrangement(row, caseLineNumber-1);
                     caseLineNumber++;
                 } else if(caseLineNumber == 5) {
                     magicTrickTestCase.setSecondAnswer(Integer.parseInt(reader.readLine()));
                     caseLineNumber++;
                 } else if(caseLineNumber >= 6 && caseLineNumber <= 9) {
                     String[] items = reader.readLine().split("" "");
                     int[] row = new int[4];
                     for (int i = 0; i < items.length; i++) {
                         row[i] = Integer.parseInt(items[i]);
 
                     }
                     magicTrickTestCase.addRowToSecondArrangement(row, caseLineNumber - 6);
                     caseLineNumber++;
                 } else {
                     magicTrickTestCase.setCaseNumber(caseNumber);
                     cases.add(magicTrickTestCase);
                     if (caseNumber++ <= this.numberOfCases) {
                         magicTrickTestCase = new MagicTrickTestCase();
                         caseLineNumber = 0;
                     } else {
                         break;
                     }
                 }
             }
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
 
         return cases;
     }
 }
","package me.godcoder.googlecodejam.api.model;
 
 /**
  * @author Ali Valizadeh
  */
 public abstract class TestCase {
 
     private int caseNumber;
 
     public int getCaseNumber() {
         return caseNumber;
     }
 
     public void setCaseNumber(int caseNumber) {
         this.caseNumber = caseNumber;
     }
 
     protected abstract String process();
 
     @Override
     public String toString() {
         return this.process();
     }
 }
",1
388,16023,"/*
    Minesweeper Master
    @author gary https://plus.google.com/110619450313015458698
 */
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class MinesweeperMaster
 {
    static char[][] fill(int r, int c, int m)
    {
       char[][] board = new char[r][c];
       int mines = m;
       
       board[r-1][c-1] = 'c';
       char mine = '*';
       
       for(int i=0; i<r-2; i++)
       {
          for(int j=0; j<c-2 && m>0; j++)
          {
             board[i][j] = mine;
             m--;
          }
          if(m>=2)
          {
             board[i][c-2] = mine;
             board[i][c-1] = mine;
             m -= 2;
          }
       }
       
       for(int j=0; j<c-2; j++)
       {
          if(m>=2)
          {
             board[r-2][j] = mine;
             board[r-1][j] = mine;
             m -= 2;
          }
       }
       
       if(m==3)
       {
          board[r-2][c-2] = mine;
          board[r-2][c-1] = mine;
          board[r-1][c-2] = mine;
          m -= 3;
       }
       
       if(m==0)
          return board;
       
       r = r^c;
       c = r^c;
       r = r^c;
       board = new char[r][c];
       board[r-1][c-1] = 'c';
       m = mines;
       for(int i=0; i<r-2; i++)
       {
          for(int j=0; j<c-2 && m>0; j++)
          {
             board[i][j] = mine;
             m--;
          }
          if(m>=2)
          {
             board[i][c-2] = mine;
             board[i][c-1] = mine;
             m -= 2;
          }
       }
       
       for(int j=0; j<c-2; j++)
       {
          if(m>=2)
          {
             board[r-2][j] = mine;
             board[r-1][j] = mine;
             m -= 2;
          }
       }
       
       if(m==3)
       {
          board[r-2][c-2] = mine;
          board[r-2][c-1] = mine;
          board[r-1][c-2] = mine;
          m -= 3;
       }
       
       if(m!=0)
          return null;
       
       char[][] board2 = new char[c][r];
       for(int i=0; i<board2.length; i++)
       {
          for(int j=0; j<board2[i].length; j++)
             board2[i][j] = board[j][i];
       }
       
       return board;
    }
    
    static public void main(String[] args)
    {
       Scanner fin;
       PrintWriter fout;
       try
       {
          fin = new Scanner(new File(""MinesweeperMaster.in""));
          fout = new PrintWriter(new File(""MinesweeperMaster.out""));
       }
       catch(FileNotFoundException fnfe)
       {
          fnfe.printStackTrace(System.err);
          return;
       }
       
       int t;
       t = fin.nextInt();
       for(int x=1; x<=t; x++)
       {
          int r = fin.nextInt();
          int c = fin.nextInt();
          int m = fin.nextInt();
          
          fout.println(""Case #""+x+"":"");
          
          int cells = r*c;
          if(r==1 || c==1)
          {
             if(r==1)
             {
                for(int i=0; i<c-1; i++)
                   fout.print( (m-->0)?'*':'.' );
                fout.println('c');
             }
             else
             {
                for(int i=0; i<r-1; i++)
                   fout.println( (m-->0)?'*':'.' );
                fout.println('c');
             }
          }
          else if(m!=cells-1 && m>cells-4)
             fout.println(""Impossible"");
          else
          {
             try
             {
                char[][] board = fill(r, c, m);
                for(int i=0; i<board.length; i++)
                {
                   for(int j=0; j<board[i].length; j++)
                      fout.print( (board[i][j]=='\u0000')? '.' : board[i][j] );
                   fout.println();
                }
             }
             catch(NullPointerException npe)
             {
                fout.println(""Impossible"");
             }
          }
       }
       
       fin.close();
       fout.close();
    }
 }
","/*
    Deceitful War
    @author gary https://plus.google.com/110619450313015458698
 */
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Scanner;
 import java.util.Vector;
 
 public class DeceitfulWar
 {
    static int war(Vector<Double> naomi, Vector<Double> ken)
    {
       if(naomi.size() == 1)
          return (naomi.elementAt(0) > ken.elementAt(0))? 1 : 0 ;
       
       double chosen_naomi = Collections.max(naomi);
       double chosen_ken = Collections.max(ken);
       if(chosen_ken < chosen_naomi)
          chosen_ken = Collections.min(ken);
       else
       {
          int index = ken.size()-1;
          while(index >=0 )
          {
             if(chosen_ken>chosen_naomi && ken.elementAt(index)>chosen_naomi)
                chosen_ken = ken.elementAt(index);
             index--;
          }
       }
       
       naomi.remove(chosen_naomi);
       ken.remove(chosen_ken);
       
       return ((chosen_naomi>chosen_ken)?1:0) + war(naomi,ken);
    }
    
    static int deceitfulWar(Vector<Double> naomi, Vector<Double> ken)
    {
       if(naomi.size() == 1)
          return (naomi.elementAt(0) > ken.elementAt(0))? 1 : 0 ;
       
       double chosen_ken = Collections.max(ken);
       double chosen_naomi = Collections.min(naomi);
       
       double told_naomi = (chosen_naomi<Collections.min(ken))? 
                            chosen_ken-0.0000001 : chosen_ken+0.0000001;
       
       
       if(chosen_ken < told_naomi)
          chosen_ken = Collections.min(ken);
       else
       {
          int index = ken.size()-1;
          while(index >=0 )
          {
             if(chosen_ken>told_naomi && ken.elementAt(index)>told_naomi)
                chosen_ken = ken.elementAt(index);
             index--;
          }
       }
       
       naomi.remove(chosen_naomi);
       ken.remove(chosen_ken);
       
       return ((chosen_naomi>chosen_ken)?1:0) + deceitfulWar(naomi,ken);
    }
    
    static public void main(String[] args)
    {
       Scanner fin;
       PrintWriter fout;
       try
       {
          fin = new Scanner(new File(""DeceitfulWar.in""));
          fout = new PrintWriter(new File(""DeceitfulWar.out""));
       }
       catch(FileNotFoundException fnfe)
       {
          fnfe.printStackTrace(System.err);
          return;
       }
       
       int t;
       t = fin.nextInt();
       for(int x=1; x<=t; x++)
       {
          fout.print(""Case #""+x+"": "");
          int n = fin.nextInt();
          
          double[] naomi = new double[n];
          double[] ken = new double[n];
          
          for(int i=0; i<n; i++)
             naomi[i] = fin.nextDouble();
          for(int i=0; i<n; i++)
             ken[i] = fin.nextDouble();
          Arrays.sort(naomi);
          Arrays.sort(ken);
          
          Vector<Double> naomi_ = new Vector<Double>(n);
          Vector<Double> ken_ = new Vector<Double>(n);
          for(double d:naomi)
             naomi_.add(d);
          for(double d:ken)
             ken_.add(d);
          
          int z = war(naomi_, ken_);
          
          naomi_ = new Vector<Double>(n);
          ken_ = new Vector<Double>(n);
          for(double d:naomi)
             naomi_.add(d);
          for(double d:ken)
             ken_.add(d);
          int y = deceitfulWar(naomi_, ken_);
          fout.println(y+"" ""+z);
       }
       
       fin.close();
       fout.close();
    }
 }
",1
389,19317,"import java.io.BufferedWriter;
 import java.io.File; 
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.OutputStream;
 import java.util.Scanner;
 
 
 public class Problem {
 
 	/**
 	 * @param args
 	 */
 	public static boolean ispal(int N){
 		String str = Integer.toString(N);
 		String ne = new StringBuffer(str).reverse().toString();
 		if(str.equals(ne))
 			return true;
 		else 
 			return false;
 		
 	}
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		try{
 			Scanner scan = new Scanner(new File(""C:/Users/mohit/workspace/gcj13/src/input1.txt""));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(new File(""C:/Users/mohit/workspace/gcj13/src/output.txt"")));
 			int T = scan.nextInt();
 			for(int z=0;z<T;z++)
 			{
 				Long A = scan.nextLong();
 				Long B = scan.nextLong();
 				int x = (int)Math.sqrt(A);
 				int y = (int)Math.sqrt(B);
 				int count =0;
 				if(x*x>=A)
 					if(ispal(x))
 						if(ispal(x*x))
 							count++;
 				int i=x+1;
 				while(i<=y){
 					if(ispal(i))
 						if(ispal(i*i))
 							count++;
 					i++;
 				}
 				bw.write(""Case #"" + (z+1)+"": "" + count+""\n"");
 			}
 			bw.close();
 		}catch(Exception e){System.out.println(""oops"");}
 	}
 
 
 }
","package com.evolve.codejam2013;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 public class FairandSquare {
 
 	private static Long RANGE = 100000000000000l; 
 	
 	private static Long RANGE2 = 10000000l;
 	
 	
 	private static List<Long> PALIN = new ArrayList<Long>(); 
 	
 	private static List<Long> FAS = new ArrayList<Long>(); // fair and square
 	
 	private static final String TEST_FILE = ""C-large-1.in"";
 	private PrintWriter pw = null;
 	private BufferedReader br = null; 		
 	
 	FairandSquare(boolean skip) throws IOException {
 		String outFile = TEST_FILE.replace("".in"", "".out"");
 		//System.out.println(outFile);
 		this.pw = new PrintWriter(new FileWriter(outFile));
 		if (skip)
 			return;
 		
 		File file = new File(TEST_FILE);
 		if (file.exists()) {
 			br = new BufferedReader(new java.io.FileReader(TEST_FILE));
 		} else {
 			br = new BufferedReader(new InputStreamReader(System.in), 1 << 16);
 		}
 	}	
 	
 	void doit() throws NumberFormatException, IOException {
 		int testsNumber = Integer.parseInt(br.readLine());
 		
 		//System.out.println(testsNumber);
 		
 		for (int i = 1; i <= testsNumber; i++) {
 
 			String line = br.readLine();
 			Scanner st = new Scanner(line);
 			long A = st.nextLong();
 			long B = st.nextLong();
 
 			
 //			int counter = 0;
 //			for (long l = A; l <= B; l++) {
 //				if (FAS.contains(l)) {
 //					counter++;
 //				}
 //			}
 			
 			int counter = howMany(A, B);
 			
 			//System.out.println(""Case #"" + i + "": "" + counter);
 			pw.println(""Case #"" + i + "": "" + counter);
 			
 		}
 		pw.flush();
 		pw.close();
 	}	
 	
 	public static void main(String[] args) throws NumberFormatException, IOException {
 		
 		for (long i = 1; i <= RANGE2; i++) {
 			if (isPalindrom(i)) {
 				
 				long l = i*i;
 				if (isPalindrom(l)) {
 					//System.out.println(l + "" is fair and square (i="" + i);
 					FAS.add(l);
 				}
 				
 				//PALIN.add(i);
 			}
 		}
 
 //		for (long i = 1; i <= RANGE; i++) {
 //			if (isFaS(i)) {
 //				System.out.println(i + "" is fair and square"");
 //				//FAS.add(i);
 //			}
 //		}
 		new FairandSquare(false).doit();
 	}
 
 	
 	public int howMany(long A, long B) {
 		int counter = 0;
 		for (long ll : FAS) {
 			if (ll >= A && ll <= B) {
 				counter++;
 			}
 		}
 		return counter;
 	}
 	
 	public static boolean isFaS(final Long n) {
 		if (isPalindrom(n)) {
 			long tst = (long) (Math.sqrt(n) + 0.5);
 			boolean isPerfectSquare = tst * tst == n;
 			if (isPerfectSquare) {
 				
 				//return PALIN.contains(n) && PALIN.contains(tst);
 				return isPalindrom(tst); 
 			} 
 		}
 		return false;
 	}
 	
 	public final static boolean isPerfectSquare(long n) {
 		if (n < 0)
 			return false;
 
 		long tst = (long) (Math.sqrt(n) + 0.5);
 		return tst * tst == n;
 	}
 	
 	public static boolean isPalindrom(Long n) {
 		String str = n.toString();
 		return isPalindrom(str.toCharArray());
 	}
 	
 	public static boolean isPalindrom(char[] word){
 	    int i1 = 0;
 	    int i2 = word.length - 1;
 	    while (i2 > i1) {
 	        if (word[i1] != word[i2]) {
 	            return false;
 	        }
 	        ++i1;
 	        --i2;
 	    }
 	    return true;
 	}	
 	
 }
",0
390,40,"import java.io.*;
 
 public abstract class Common{
     int T;
 
     int currentCase;
     String currentResult;
     String testCase;
     String inputFile;
     String outputFile;
     BufferedReader brFile;
 
 
     public Common() throws Exception{
         this.testCase = ""A-small-attempt0"";
         this.inputFile = this.testCase + "".in"";
         this.outputFile = this.testCase + "".out"";
         this.brFile = new BufferedReader(new FileReader(inputFile));
     }
 
     public String input() throws Exception {
         String sCurrentLine = this.brFile.readLine();
         return sCurrentLine;
     }
 
     public void output (String content) throws Exception {
         File file = new File(this.outputFile);
 
         // if file doesn't exists, then create it
         if (!file.exists()) {
             file.createNewFile();
         }
 
         FileWriter fw = new FileWriter(file.getAbsoluteFile(), true);
         BufferedWriter bw = new BufferedWriter(fw);
         bw.write(content);
         bw.close();
     }
 
     public void start() throws Exception{
         this.T = Integer.parseInt(this.input());
         System.out.println(""No. of Cases: "" + this.T);
 
         for(int i=0; i<this.T; i++){
             System.out.println(""\nCase #"" + (this.currentCase = i+1));
             System.out.println(""Result:"" + (this.currentResult = this.Case()));
             this.output(""Case #"" + this.currentCase + "": "" + this.currentResult +""\n"");
         }
     }
 
     abstract String Case() throws Exception;
 }
","package botthrust;
 
 import template.Template;
 
 public class BotThrust extends Template {
 
 	public static void main(String[] args) throws Exception {
 		init(""src/botthrust/A-large"");
 		int lines = readInt();
 		for (int i = 1; i <= lines; i++) {
 			int steps = -1;
 
 			int posO = 1;
 			int posB = 1;
 			String[] s = readStringArray();
 			int nextO = 0;
 			int nextB = 0;
 			int valueO = -1;
 			int valueB = -1;
 
 			while (nextO != -1 || nextB != -1) {
 				nextO = -1;
 				nextB = -1;
 
 				for (int j = 1; j < s.length; j += 2) {
 					if (s[j].equals(""O"") && nextO == -1) {
 						nextO = j;
 						valueO = Integer.parseInt(s[j + 1]);
 					}
 					if (s[j].equals(""B"") && nextB == -1) {
 						nextB = j;
 						valueB = Integer.parseInt(s[j + 1]);
 					}
 				}
 
 				if (nextO > -1) {
 					if (valueO > posO)
 						posO++;
 					else if (valueO < posO)
 						posO--;
 					else if (nextO < nextB || nextB == -1) {
 						s[nextO] = """";
 					}
 				}
 				if (nextB > -1) {
 					if (valueB > posB)
 						posB++;
 					else if (valueB < posB)
 						posB--;
 					else if (nextB < nextO || nextO == -1) {
 						s[nextB] = """";
 					}
 				}
 				steps++;
 			}
 
 			write(""Case #"" + i + "": "" + steps);
 		}
 
 	}
 }
",0
391,4551,"package jam.jam2011;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 /**
  *
  * @author manwe
  */
 public class Jam1C_A {
     private static final String PATH_IN = ""files/in"";
     private static final String PATH_OUT = ""files/out"";
 
     private static ReaderWrapper reader;
     private static WriterWrapper writer;
 
     public static void main (String args[]) {
         Jam1C_A jam = new Jam1C_A();
 
         long inicio = System.currentTimeMillis();
         jam.start();
         long fim = System.currentTimeMillis();
 
         System.out.println(fim - inicio + ""ms"");
     }
 
     public void start() {
         reader = new ReaderWrapper(PATH_IN);
         writer = new WriterWrapper(PATH_OUT);
 
         if (!reader.available() || !writer.available()) {
             return;
         }
 
         int t, r, c;
         String[] l;
         String l1;
         char[][] table;
         boolean ok;
 
         t = Integer.parseInt(reader.readLine());
         for (int i = 1; i <= t; i++) {
             l = reader.readLine().split("" "");
             r = Integer.parseInt(l[0]);
             c = Integer.parseInt(l[1]);
 
             table = new char[r][c];
             for(int j = 0; j < r; j++) {
                 l1 = reader.readLine();
                 for(int k = 0; k < c; k++) {
                     table[j][k] = l1.charAt(k);
                 }
             }
 
             for(int j = 0; j < r; j++) {
                 for(int k = 0; k < c; k++) {
                     if(table[j][k] == '.' || table[j][k] == '/' || table[j][k] == '\\') continue;
                     if(j+1 >= r || k+1 >= c) continue;
                     if(table[j][k] == '#' && table[j+1][k] == '#' && table[j][k+1] == '#' && table[j+1][k+1] == '#') {
                         table[j][k] = '/';
                         table[j][k+1] = '\\';
                         table[j+1][k] = '\\';
                         table[j+1][k+1] = '/';
 
                     }
                 }
             }
 
             ok = true;
             for(int j = 0; j < r; j++) {
                 for(int k = 0; k < c; k++) {
                     if(table[j][k] == '#') {
                         ok = false;
                         break;
                     }
                 }
             }
 
             print(i, """", writer);
             if(!ok) {
                 print(""Impossible"", writer);
             } else {
                 StringBuilder sb = new StringBuilder();
                 for(int j = 0; j < r; j++) {
                     for(int k = 0; k < c; k++) {
                         sb.append(table[j][k]);
                     }
                     if(j + 1 != r) sb.append('\n');
                 }
                 print(sb.toString(), writer);
             }
         }
 
         writer.close();
     }
 
     private static void print(String result, WriterWrapper writer) {
         System.out.println(result);
         writer.writeLine(result + ""\n"");
     }
 
     private static void print(int nCase, String result, WriterWrapper writer) {
         System.out.println(""Case #"" + nCase + "": "" + result);
         writer.writeLine(""Case #"" + nCase + "": "" + result + ""\n"");
     }
 
     private static class ReaderWrapper {
 
         private boolean ok = false;
         private BufferedReader reader = null;
 
         public ReaderWrapper(String path) {
             try {
                 File file = new File(path);
                 FileReader fileReader = new FileReader(file);
                 reader = new BufferedReader(fileReader);
                 ok = true;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public boolean available() {
             return ok;
         }
 
         public String readLine() {
             if (!ok) {
                 return null;
             }
 
             String str = null;
             try {
                 str = reader.readLine();
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
 
             return str;
         }
     }
 
     private static class WriterWrapper {
 
         private boolean ok = false;
         private BufferedWriter writer = null;
 
         public WriterWrapper(String path) {
             try {
                 File file = new File(path);
                 if (!file.exists()) {
                     file.createNewFile();
                 }
                 FileWriter fileWriter = new FileWriter(file);
                 writer = new BufferedWriter(fileWriter);
                 ok = true;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public boolean available() {
             return ok;
         }
 
         public void close() {
             try {
                 writer.flush();
                 writer.close();
                 ok = false;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public void writeLine(String str) {
             try {
                 writer.write(str, 0, str.length());
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
     }
 }
","package jam.jam2011;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 
 /**
  *
  * @author manwe
  */
 public class Jam1B_A {
     private static final String PATH_IN = ""files/in"";
     private static final String PATH_OUT = ""files/out"";
 
     private static ReaderWrapper reader;
     private static WriterWrapper writer;
 
     public static void main (String args[]) {
         Jam1B_A jam = new Jam1B_A();
 
         long inicio = System.currentTimeMillis();
         jam.start();
         long fim = System.currentTimeMillis();
 
         System.out.println(fim - inicio + ""ms"");
     }
 
     public void start() {
         reader = new ReaderWrapper(PATH_IN);
         writer = new WriterWrapper(PATH_OUT);
 
         if (!reader.available() || !writer.available()) {
             return;
         }
 
         int t, n;
         String l;
         int[][] table;
         double[][] calcs;
         double a, b, c, d = 0;
 
         DecimalFormat df = new DecimalFormat(""0.000000"");
 
         t = Integer.parseInt(reader.readLine());
         for (int i = 1; i <= t; i++) {
             n = Integer.parseInt(reader.readLine());
             table = new int[n][n];
 
             for(int j = 0; j < n; j++) {
                 l = reader.readLine();
                 for(int k = 0; k < n; k++) {
                     table[j][k] = l.charAt(k) == '.' ? -1 : (l.charAt(k) == '0' ? 0 : 1);
                 }
             }
 
             calcs = new double[n][3];
 
             for(int j = 0; j < n; j++) {
                 a = b = 0;
                 for(int k = 0; k < n; k++) {
                     if(j == k) continue;
                     if(table[j][k] != -1) a++;
                     if(table[j][k] == 1) b++;
                 }
                 calcs[j][0] = b / a;
                 //System.out.println(calcs[j][0]);
                 d = a;
             }
 
             for(int j = 0; j < n; j++) {
                 c = 0;
                 d = 0;
                 for(int k = 0; k < n; k++) {
                     if(k == j || table[j][k] == -1) continue;
                     d++;
                     a = b = 0;
                     for(int k2 = 0; k2 < n; k2++) {
                         if(j == k || k2 == j) continue;
                         if(table[k][k2] != -1) a++;
                         if(table[k][k2] == 1) b++;
                     }
                     c += b / a;
                 }
                 calcs[j][1] = c / d;
                 //System.out.println(c + ""/"" + d);
                 //System.out.println(calcs[j][1]);
             }
 
             for(int j = 0; j < n; j++) {
                 a = 0;
                 d = 0;
                 for(int k = 0; k < n; k++) {
                     if(k == j || table[j][k] == -1) continue;
                     d++;
                     a += calcs[k][1];
                 }
                 calcs[j][2] = a / d;
                 //System.out.println(d);
                 //System.out.println(calcs[j][2]);
             }
 
             print(i, """", writer);
 
             for(int j = 0; j < n; j++) {
                 print(df.format(0.25 * calcs[j][0] + 0.5 * calcs[j][1] + 0.25 * calcs[j][2]), writer);
             }
         }
 
         writer.close();
     }
 
     private static void print(String result, WriterWrapper writer) {
         System.out.println(result);
         writer.writeLine(result + ""\n"");
     }
 
     private static void print(int nCase, String result, WriterWrapper writer) {
         System.out.println(""Case #"" + nCase + "": "" + result);
         writer.writeLine(""Case #"" + nCase + "": "" + result + ""\n"");
     }
 
     private static class ReaderWrapper {
 
         private boolean ok = false;
         private BufferedReader reader = null;
 
         public ReaderWrapper(String path) {
             try {
                 File file = new File(path);
                 FileReader fileReader = new FileReader(file);
                 reader = new BufferedReader(fileReader);
                 ok = true;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public boolean available() {
             return ok;
         }
 
         public String readLine() {
             if (!ok) {
                 return null;
             }
 
             String str = null;
             try {
                 str = reader.readLine();
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
 
             return str;
         }
     }
 
     private static class WriterWrapper {
 
         private boolean ok = false;
         private BufferedWriter writer = null;
 
         public WriterWrapper(String path) {
             try {
                 File file = new File(path);
                 if (!file.exists()) {
                     file.createNewFile();
                 }
                 FileWriter fileWriter = new FileWriter(file);
                 writer = new BufferedWriter(fileWriter);
                 ok = true;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public boolean available() {
             return ok;
         }
 
         public void close() {
             try {
                 writer.flush();
                 writer.close();
                 ok = false;
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
 
         public void writeLine(String str) {
             try {
                 writer.write(str, 0, str.length());
             } catch (IOException e) {
                 System.out.println(e.getMessage());
             }
         }
     }
 }
",1
392,1931,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.*;
 
 public class Main extends Thread {
 
     public Main() {
         this.setPriority(Thread.MAX_PRIORITY);
     }
 
     long gcd(long a, long b) {
         if (b != 0) {
             return gcd(b, a % b);
         } else {
             return a;
         }
     }
 
     public void run() {
         try {
 
             in = new BufferedReader(new FileReader(""in1.txt""));
             out = new PrintWriter(""out.txt"");
             int testCount = nextInt();
             boolean[] primes = new boolean[10001];
             for (int i = 2; i <= 10000; ++i) {
                 if (!primes[i]) {
                     for (int j = i * i; j <= 10000; j += i) {
                         primes[j] = true;
                     }
                 }
             }
             List<Integer> pr = new ArrayList<Integer>(0);
             for (int i = 2; i <= 10000; ++i) {
                 if (!primes[i]) {
                     pr.add(i);
                 }
             }
             for (int testNumber = 1; testNumber <= testCount; ++testNumber) {
                 int N = nextInt();
                 long L = nextLong(), H = nextLong();
                 long[] frequencies = new long[N];
                 for (int i = 0; i < N; ++i) {
                     frequencies[i] = nextLong();
                 }
                 boolean ok = false;
                 for (long ans = L ; ans <= H  && !ok; ++ans){
                     ok = true;
 
                     for (long current: frequencies){
                         ok &= current % ans == 0 || ans % current == 0;
                     }
                     if (ok){
                         out.println(""Case #"" + testNumber + "": "" + ans);
                     }
                 }
                 if (!ok){
                     out.println(""Case #"" + testNumber + "": NO"");
                 }
             }
             out.flush();
             out.close();
         } catch (Throwable e) {
             System.err.println(e.getCause());
             System.err.println(Arrays.deepToString(e.getStackTrace()));
             System.exit(1);
         }
     }
 
 
     public static void main(String[] args) {
         new Main().start();
     }
 
     BufferedReader in;
     PrintWriter out;
     StringTokenizer tokens;
 
     int nextInt() throws IOException {
         return Integer.parseInt(nextToken());
     }
 
     long nextLong() throws IOException {
         return Long.parseLong(nextToken());
     }
 
     double nextDouble() throws IOException {
         return Double.parseDouble(nextToken());
     }
 
     String nextToken() throws IOException {
         while (tokens == null || !tokens.hasMoreTokens()) {
             tokens = new StringTokenizer(in.readLine());
         }
         return tokens.nextToken();
     }
 }","import java.io.BufferedOutputStream;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 public class SafetyInNumbers {
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		PrintStream out = new PrintStream(new BufferedOutputStream(System.out));
 		int cases = sc.nextInt();
 		for(int ctr=0; ctr<cases; ctr++){
 			int n = sc.nextInt();
 			int sum = 0;
 			int[] arr = new int[n];
 			for(int i=0; i<n; i++){
 				arr[i] = sc.nextInt();
 				sum += arr[i];
 			}
 			double nrec = 1.0/n;
 			boolean[] shoe = new boolean[n];
 			for(int i=0; i<n; i++){
 				if(arr[i]/(2.0*sum) >= nrec){
 					shoe[i] = true;
 				}
 			}
 			int m = 0;
 			int losersum = 0;
 			for(int i=0; i<n; i++){
 				if(!shoe[i]){
 					losersum += arr[i];
 					m++;
 				}
 			}
 			double pointpool = losersum/(2.0*sum) + 0.5;
 			double mrec = 1.0/m;
 			double minpts = pointpool*mrec;
 			
 			out.printf(""Case #%d:"", ctr+1);
 			for(int i=0; i<n; i++){
 				if(shoe[i]){
 					out.printf("" %.5f"", 0.0);
 				}else{
 					double currpts = arr[i]/((double)sum);
 					out.printf("" %.5f"", 100*(2*minpts - currpts));
 				}
 			}
 			out.println();
 		}
 		out.flush();
 	}
 }
",0
393,8913,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 
 public class C {
 
 	public static void main(String[] args) {
 		try {
 			BufferedReader input = new BufferedReader(new FileReader(""/home/ramzy/Desktop/codejam/C-small.in""));
 			PrintWriter output = new PrintWriter(""/home/ramzy/Desktop/codejam/C-small.out"");
 			String line = input.readLine();
 			int T = Integer.valueOf(line);
 			for(int i = 0; i < T; i++) {
 				line = input.readLine();
 				String[] numbers = line.split("" "");
 				int A = Integer.valueOf(numbers[0]);
 				int B = Integer.valueOf(numbers[1]);
 				int result = 0;
 				ArrayList<String> chosen = new ArrayList<String>();
 				for(int j = A; j <= B; j++) {
 					String str = String.valueOf(j);
 					for(int k = 1; k < str.length(); k++) {
 						int n = Integer.valueOf(str.substring(k) + str.substring(0, k));
 						if(n >= A && n<= B && n != j && !chosen.contains(n + "" "" + j) && !chosen.contains(j + "" "" + n)) {
 							chosen.add(n + "" "" + j);
 							result++;
 						}
 					}
 				}
 				output.println(""Case #"" + (i+1) + "": "" + result);
 				System.out.println(""Case #"" + (i+1) + "": "" + result);
 			}
 			output.close();
 			input.close();
 		} catch(IOException e) {
 			System.err.println(e);
 		}
 	}
 	
 }
","
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 /**
  *
  * @author Eunice
  */
 public class Recycled_Numbers {
 
     static Scanner scanner = new Scanner(System.in);
     static PrintWriter out;
 
     public static void main(String[] args) {
 
         try {
              out = new PrintWriter(new FileWriter(""C:\\Users\\Eunice\\Desktop\\Code Jam\\CodeJam Outputs\\Recycled_Numbers.txt"" ));
         }
         catch (Exception ex) {
             ex.printStackTrace();
         }
 
         int noTestCases = scanner.nextInt();
         for(int i = 0; i < noTestCases; i++) {
             int A = scanner.nextInt();
             int B = scanner.nextInt();
             int noRecycledPairs = 0;
             String valueOfA = String.valueOf(A);
             String valueOfB = String.valueOf(B);
             int noDigits = valueOfA.length();
             int[] possible = new int[(B - (A - 1))];
             for(int j = 0; j < (B - (A - 1)); j++) {
                 possible[j] = A + j;
             }
             int n = 0;
             int m = 0;
             String valueOfn;
             String valueOfm;
             for(int l = 0; l < possible.length; l++) {
                 n = possible[l];
                 valueOfn = String.valueOf(n);
                 for(int k = 0; k < possible.length; k++) {
                     m = possible[k];
                     valueOfm = String.valueOf(m);
                     if(k != l) {
                         if((A <= n) && (n < m) && (m <= B)) {
                             String s = valueOfn;
                             for(int p = 0; p < noDigits; p++) {
                                 
                                 s = s.charAt(s.length() - 1) + s.substring(0, (s.length() - 1));
                                 if(s.equals(valueOfm)) {
                                     noRecycledPairs++;
                                     p = noDigits;
                                 }
                             }
                         }
                     }
                 }
             }
             
             System.out.println(""Case #"" + (i + 1) + "": "" + noRecycledPairs);
 //            out.close();
         }
     }
 }
",0
394,13848,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.Scanner;
 import java.util.StringTokenizer;
 
 
 /**
  *
  * @author Paymon
  */
 public class codejamA11 {
     
     enum states {
         DRAW, XWIN, XLOSE, INCOMP
     }
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws Exception {
         BufferedReader in = new BufferedReader(new FileReader(""input30.in""));
         BufferedWriter out = new BufferedWriter(new FileWriter(""output30.txt""));
         
         String s = in.readLine();
         
         int testcases = Integer.parseInt(s);
         
         for (int i = 0; i < testcases; i++) {  
             
             String line = in.readLine();
             StringTokenizer st = new StringTokenizer(line);
             int e = Integer.parseInt(st.nextToken());
             int inite = e;
             int r = Integer.parseInt(st.nextToken());
             int n = Integer.parseInt(st.nextToken());
             
             String line2 = in.readLine();
             StringTokenizer st2 = new StringTokenizer(line2);
             int[] vals = new int[n];
             int sum = 0;
             int max = 0; 
             for (int j = 0; j < n; j++) {
                 vals[j] = Integer.parseInt(st2.nextToken());
                 sum += vals[j];
                 if (vals[j] > max) {
                     max = vals[j];
                 }
             }
             
             ArrayList<Integer> bigs = new ArrayList<Integer>();
             int currMax = 0;
             for (int j = n-1; j>= 0; j--) {
                 //if (vals[j] == max) {
                     //bigs.add(0, max);
                 //}
                 if (vals[j] >= currMax) {
                     bigs.add(0, vals[j]);
                     currMax = vals[j];
                 }
             }
             //System.out.println(sum);
             
             long gain = 0;
             for (int x = 0; x < n; x++) {
                 int val;
                 if (x == n-1) {
                     val = e;
                 }
                 else if (r == inite) {
                     val = e;
                 }
                 else if (vals[x] == bigs.get(0)) {
                     val = e;
                     bigs.remove(0);
                 }
                 else if (e < inite) {
                     if (e + r >= inite) {
                         val = e + r - inite;
                     }
                     else {
                         val = 0;
                     }
                 }
                 else {
                     val = r;
                 }
                 e -= val;
                 e += r;
                 gain += val * vals[x];
                 if (e > inite) {
                     e = inite;
                 }
             }
             
             System.out.println(""Case #"" + (i+1) + "": "" + gain);
             out.write(""Case #"" + (i+1) + "": "" + gain);
             
             out.newLine();
         }
         out.close();
     }
     
     public static double diff(double r1, double r2) {
         return (r1 - r2) * (r1 + r2);
     }
 }
","
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 /**
  *
  * @author Paymon
  */
 public class codejam1 {
     public static void main(String[] args) throws Exception {
         BufferedReader in = new BufferedReader(new FileReader(""input0001.in""));
         BufferedWriter out = new BufferedWriter(new FileWriter(""output0001.txt""));
 
         String s = in.readLine();
 
         int testcases = Integer.parseInt(s);
 
         for (int i = 0; i < testcases; i++) {  
             
             int row = Integer.parseInt(in.readLine()) - 1;
             int[] nums = new int[4];
             for (int j = 0; j < 4; j++) {
                 if (j == row) {
                     String[] data = in.readLine().split("" "");
                     
                     for (int k = 0; k < data.length; k++) {
                         nums[k] = Integer.parseInt(data[k]);
                     }
                 }
                 else {
                     in.readLine();
                 }
             }
             
             int row2 = Integer.parseInt(in.readLine()) - 1;
             int[] nums2 = new int[4];
             for (int j = 0; j < 4; j++) {
                 if (j == row2) {
                     String[] data = in.readLine().split("" "");
                     for (int k = 0; k < data.length; k++) {
                         nums2[k] = Integer.parseInt(data[k]);
                     }
                 }
                 else {
                     in.readLine();
                 }
             }
             
             int count = 0;
             int index = 0;
             for (int k = 0; k < 4; k++) {
                 for (int j = 0; j < 4; j++) {
                     if (nums[k] == nums2[j]) {
                         count++;
                         index = k;
                     }
                 }
             }
             
 
             if (count == 0) {
                 System.out.println(""Case #"" + (i+1) + "": Volunteer cheated!"");
                 out.write(""Case #"" + (i+1) + "": Volunteer cheated!"");
             }
             else if (count == 1) {
                 System.out.println(""Case #"" + (i+1) + "": "" + nums[index]);
                 out.write(""Case #"" + (i+1) + "": "" + nums[index]);
             }
             else {
                 System.out.println(""Case #"" + (i+1) + "": Bad magician!"");
                 out.write(""Case #"" + (i+1) + "": Bad magician!"");
             }
 
             out.newLine();
         }
         out.close();
     }
     
     public static int containsOne(int[] a, int[] b) {
         int count = 0;
         for (int i = 0; i < 4; i++) {
             for (int j = 0; j < 4; j++) {
                 if (a[i] == b[j]) {
                     count ++;
                 }
             }
         }
         return count;
     }
     
     
     
 }
",1
395,3601,"import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.StringTokenizer;
 
 
 public class BotTrust {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		try{
 		// LEER ARCHIVO
 		File file = new File(""C:/Users/desarrollo4/Desktop/CodeJam/src/A-large.in"");
 		int T = 0,N = 0;
 		List<Object[]> orden;
 		List<Float> objetivosOrange, objetivosBlue;
 		
 		
 		if(file.exists()){
 			BufferedReader input =  new BufferedReader( new FileReader( file ) ); 
 			StringBuilder output = new StringBuilder();
 			T = Integer.valueOf((input.readLine()));
 			
 		    for(int i = 0;i<T;i++){
 		    	objetivosOrange = new LinkedList<Float>();
 		    	objetivosBlue = new LinkedList<Float>(); 
 		    	orden = new ArrayList<Object[]>();
 		    	String original = input.readLine();
 		    	StringTokenizer line = new StringTokenizer(original, "" "");
 		    	
 		    	N = Integer.valueOf(line.nextToken());
 		    	while (line.hasMoreElements()){	
 		    		String ch= line.nextToken();
 		    		Object[] ob = new Object[]{
 		    				ch,Float.parseFloat(line.nextToken().toString())
 		    		};
 		    		orden.add(ob);
 		    		switch (ch.charAt(0)){
 		    		case 'O':
 		    			objetivosOrange.add((Float)ob[1]);
 		    			break;
 		    		case 'B':
 		    			objetivosBlue.add((Float)ob[1]);
 		    			break;
 		    		}
 		    		
 		    	}
 		    	
 		    	int j = 1;
 		    	int time = 0;
 		    	int posicionOrange = 1, posicionBlue = 1;
 		    	while(j <= N){
 		    		boolean objetivo = false;
 		    		char robot = ((String)((Object[])orden.get(0))[0]).charAt(0);	    			
 	    			int boton = ((Float)((Object[])orden.get(0))[1]).intValue();
 		    		while(!objetivo){	    					    			
 		    			switch (robot) {
 						case 'O':
 							if(boton == posicionOrange){
 								objetivo = true;
 								objetivosOrange.remove(0);
 								orden.remove(0);
 								j++;
 								time++;								
 								if(objetivosBlue.size()>0){
 				    				if(objetivosBlue.get(0) > posicionBlue){
 				    					posicionBlue++;				    					
 				    				}
 				    				if(objetivosBlue.get(0) < posicionBlue){
 				    					posicionBlue--;				    					
 				    				}				    		
 				    			}								
 							}else{
 								time++;	
 								if(objetivosOrange.size()>0){
 				    				if(objetivosOrange.get(0) > posicionOrange){
 				    					posicionOrange++;		    					
 				    				}
 				    				if(objetivosOrange.get(0) < posicionOrange){
 				    					posicionOrange--;		    				
 				    				}		    				
 				    			}		    			
 				    			if(objetivosBlue.size()>0){
 				    				if(objetivosBlue.get(0) > posicionBlue){
 				    					posicionBlue++;		    					
 				    				}
 				    				if(objetivosBlue.get(0) < posicionBlue){
 				    					posicionBlue--;		    					
 				    				}		    				
 				    			}
 							}
 							break;
 						case 'B':
 							if(boton == posicionBlue){
 								objetivo = true;
 								time++;	
 								
 								objetivosBlue.remove(0);
 								orden.remove(0);
 								j++;
 								if(objetivosOrange.size()>0){
 									
 				    				if(objetivosOrange.get(0) > posicionOrange){
 				    					posicionOrange++;				    				
 				    				}
 				    				if(objetivosOrange.get(0) < posicionOrange){
 				    					posicionOrange--;			    					
 				    				}				    				
 				    			}																
 							}else{
 								time++;
 								if(objetivosOrange.size()>0){
 				    			
 				    				if(objetivosOrange.get(0) > posicionOrange){
 				    					posicionOrange++;		    					
 				    				}
 				    				if(objetivosOrange.get(0) < posicionOrange){
 				    					posicionOrange--;		    				
 				    				}		    				
 				    			}		    			
 				    			if(objetivosBlue.size()>0){
 				    				if(objetivosBlue.get(0) > posicionBlue){
 				    					posicionBlue++;		    					
 				    				}
 				    				if(objetivosBlue.get(0) < posicionBlue){
 				    					posicionBlue--;		    					
 				    				}		    				
 				    			}
 							}
 							break;	
 						default:
 							break;
 						}		    					    		
 		    		}
 		    	}
 		    	
 		    	output.append(""Case #"");
 		    	output.append((i+1));
 		    	output.append("": "");
 		    	output.append(time);
 		    	output.append(""\n"");
 		    	
 		    }
 		    System.out.println(output.toString());
 		    
 		    
 		}else{
 			System.out.println(""no existe"");
 		}
 		}catch (Exception e) {
 			// TODO: handle exception
 			e.printStackTrace();
 		}
 	}
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package codejam2103;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  *
  * @author john
  */
 public class A {
 
     Map<String, String> mapLenguaje;
 
     public static void main(String arg[]) {
         try {
             Map<String, String> map = getMap();
             File file = new File(""/home/john/Descargas/A-large.in"");
             int T = 0;
 
             if (file.exists()) {
                 BufferedReader input = new BufferedReader(new FileReader(file));
 
                 StringBuilder output = new StringBuilder();
                 
                 String s = input.readLine();
                 
                
                 T = Integer.parseInt(s);
 
                 for (int i = 1; T >= i; i++) {
 
                     char[][] table = new char[4][4];
 
                     boolean isComplete = false;
 
                     boolean winX = false;
                     boolean winO = false;
                     
 
                     table[0] = input.readLine().toCharArray();
                     table[1] = input.readLine().toCharArray();
                     table[2] = input.readLine().toCharArray();
                     table[3] = input.readLine().toCharArray();
 
                     if (String.copyValueOf(table[0]).contains(""."")
                             || String.copyValueOf(table[1]).contains(""."")
                             || String.copyValueOf(table[2]).contains(""."")
                             || String.copyValueOf(table[3]).contains(""."")) {
                         isComplete = true;
                     }
 
 
                     for (int j = 0; j < 4; j++) {
 
                         // Win X
 
                         if (((table[j][0] == 'X' || table[j][0] == 'T')
                                 && (table[j][1] == 'X' || table[j][1] == 'T')
                                 && (table[j][2] == 'X' || table[j][2] == 'T')
                                 && (table[j][3] == 'X' || table[j][3] == 'T'))
                                 || ((table[0][j] == 'X' || table[0][j] == 'T')
                                 && (table[1][j] == 'X' || table[1][j] == 'T')
                                 && (table[2][j] == 'X' || table[2][j] == 'T')
                                 && (table[3][j] == 'X' || table[3][j] == 'T'))) {
                             winX = true;
 
                         }
 
                         // Win O
 
                         if (((table[j][0] == 'O' || table[j][0] == 'T')
                                 && (table[j][1] == 'O' || table[j][1] == 'T')
                                 && (table[j][2] == 'O' || table[j][2] == 'T')
                                 && (table[j][3] == 'O' || table[j][3] == 'T'))
                                 || ((table[0][j] == 'O' || table[0][j] == 'T')
                                 && (table[1][j] == 'O' || table[1][j] == 'T')
                                 && (table[2][j] == 'O' || table[2][j] == 'T')
                                 && (table[3][j] == 'O' || table[3][j] == 'T'))) {
                             winO = true;
 
                         }
                     }
 
                     if (((table[0][0] == 'O' || table[0][0] == 'T')
                             && (table[1][1] == 'O' || table[1][1] == 'T')
                             && (table[2][2] == 'O' || table[2][2] == 'T')
                             && (table[3][3] == 'O' || table[3][3] == 'T'))
                             || ((table[0][3] == 'O' || table[0][3] == 'T')
                             && (table[1][2] == 'O' || table[1][2] == 'T')
                             && (table[2][1] == 'O' || table[2][1] == 'T')
                             && (table[3][0] == 'O' || table[3][0] == 'T'))) {
                         winO = true;
 
                     }
 
                     if (((table[0][0] == 'X' || table[0][0] == 'T')
                             && (table[1][1] == 'X' || table[1][1] == 'T')
                             && (table[2][2] == 'X' || table[2][2] == 'T')
                             && (table[3][3] == 'X' || table[3][3] == 'T'))
                             || ((table[0][3] == 'X' || table[0][3] == 'T')
                             && (table[1][2] == 'X' || table[1][2] == 'T')
                             && (table[2][1] == 'X' || table[2][1] == 'T')
                             && (table[3][0] == 'X' || table[3][0] == 'T'))) {
                         winX = true;
 
                     }
 
                     output.append(""Case #"");
                     output.append(i);
                     output.append("": "");
 
                     if (winX) {
                         output.append(""X won"");
                     } else {
                         if (winO) {
                             output.append(""O won"");
                         } else {
                             if (isComplete) {
                                 output.append(""Game has not completed"");
                             } else {
                                 output.append(""Draw"");
                             }
                         }
                     }
                     
                     output.append(""\n"");
                     input.readLine();
                 }
 
                 System.out.println(output);
             }
         } catch (Exception e) {
             e.printStackTrace();
         }
 
     }
 
     public static Map<String, String> getMap() {
         Map<String, String> map = new HashMap<String, String>();
         map.put(""y"", ""a"");
         map.put(""h"", ""b"");
         map.put(""e"", ""c"");
         map.put(""s"", ""d"");
         map.put(""o"", ""e"");
         map.put(""c"", ""f"");
         map.put(""v"", ""g"");
         map.put(""x"", ""h"");
         map.put(""d"", ""i"");
         map.put(""u"", ""j"");
         map.put(""i"", ""k"");
         map.put(""g"", ""l"");
         map.put(""l"", ""m"");
         map.put(""b"", ""n"");
         map.put(""k"", ""o"");
         map.put(""r"", ""p"");
         map.put(""z"", ""q"");
         map.put(""t"", ""r"");
         map.put(""n"", ""s"");
         map.put(""w"", ""t"");
         map.put(""j"", ""u"");
         map.put(""p"", ""v"");
         map.put(""f"", ""w"");
         map.put(""m"", ""x"");
         map.put(""a"", ""y"");
         map.put(""q"", ""z"");
         return map;
     }
 }
",1
396,7677,"package gcj2012.qr;
 
 import java.io.*;
 import java.util.StringTokenizer;
 
 /**
  *
  * @author Scott DellaTorre
  */
 public class B {
 
     public static void main(String[] args) throws IOException {
 
         BufferedReader in = new BufferedReader(new FileReader(""src/gcj2012/qr/in""));
         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""src/gcj2012/qr/B.out"")));
 
         int T = Integer.parseInt(in.readLine());
         for (int i = 0; i < T; i++) {
             StringTokenizer st = new StringTokenizer(in.readLine());
             int N = Integer.parseInt(st.nextToken()); // Number of Googlers
             int S = Integer.parseInt(st.nextToken()); // Number of suprising cases
             int p = Integer.parseInt(st.nextToken());
             int[] t = new int[N]; // Total points of the Googlers
             for (int j = 0; j < N; j++) {
                 t[j] = Integer.parseInt(st.nextToken());
             }
 
             // What is the maximum number of Googlers that could have had a best
             // result of at least p?
 
             int lowSurprising = p < 2 ? p : p * 3 - 4;
             int lowNormal = p < 1 ? p : p * 3 - 2;
 
             int count = 0;
             for (int j = 0; j < N; j++) {
                 if (t[j] >= lowNormal) {
                     count++;
                 } else if (S > 0 && t[j] >= lowSurprising) {
                     S--;
                     count++;
                 }
             }
 
             out.println(""Case #"" + (i + 1) + "": "" + count);
         }
 
         out.close();
     }
 }
","package gcj2010.qualificationround.fairwarning;
 
 import codejam.Utils;
 import java.math.BigInteger;
 import java.util.Arrays;
 
 /**
  *
  * @author Scott
  */
 public class FairWarning {
 
    private static BigInteger gcd(BigInteger[] integers) {
       BigInteger gcd = integers[0];
       for (int i = 1; i < integers.length; i++) {
          gcd = gcd.gcd(integers[i]);
          if (gcd.equals(BigInteger.ONE)) {
             return BigInteger.ONE;
          }
       }
       return gcd;
    }
 
    private static BigInteger getMaximumNumber(BigInteger[] events) {
       BigInteger[] diffs = new BigInteger[events.length - 1];
       for (int i = 0; i < diffs.length; i++) {
          diffs[i] = events[i + 1].subtract(events[i]);
       }
       return gcd(diffs);
    }
 
    public static void main(String[] args) {
       int cases = Utils.readInt();
       for (int i = 0; i < cases; i++) {
          BigInteger[] events = new BigInteger[Utils.readInt()];
          for (int j = 0; j < events.length; j++) {
             events[j] = new BigInteger(Utils.readString());
          }
          Arrays.sort(events);
          BigInteger maximumNumber = getMaximumNumber(events);
          BigInteger slarboseconds = BigInteger.ZERO;
          if (!events[0].mod(maximumNumber).equals(BigInteger.ZERO)) {
             slarboseconds = maximumNumber.subtract(events[0].mod(maximumNumber));
          }
          Utils.write(slarboseconds);
       }
    }
 }
",1
397,506,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Scanner;
 public final class C extends AbstractCodeJamSolver {
 	
 	int n;
 	int[] a = new int[15];
 	
 	void input() {
 		n = in.nextInt();
 		for(int i=0;i<n;i++)
 			a[i] = in.nextInt();
 	}
 
 	@Override
 	public void solve() {
 		int casen = in.nextInt();
 		for(int casei=1;casei<=casen;casei++) {
 			input();
 			int max = 0;
 			for(int i=0;i<(1<<n); i++) {
 				int rsean = 0;
 				int sean = 0;
 				int patrick = 0;
 				int rpatrick = 0;
 				for(int j=0;j<n;j++) {
 					if(BitUtil.isSet(i, j)) {
 						rsean += a[j];
 						sean ^= a[j];
 					} else {
 						rpatrick += a[j];
 						patrick ^= a[j];
 					}
 				}
 				if(rsean > 0 && rpatrick > 0 && sean == patrick) {
 					max = Math.max(max, rsean);
 				}
 			}
 			out.print(""Case #"" + casei + "": "");
 			if(max == 0)
 				out.println(""NO"");
 			else
 				out.println(max);
 		}
 	}
 	
 	public static void main(String[] args) throws FileNotFoundException {
 		new C().launch(""C-small-attempt0.in"");
 	}
 
 }
 class BitUtil {
 
 	static public boolean isSet(int v, int pos) {
 		return (v & 1<<pos) != 0;
 	}
 
 	static public int set(int v, int p) {
 		return v | (1<<p);
 	}
 
 	static public int toggle(int v, int p) {
 		if(isSet(v, p))
 			return v - (1<<p);
 		else
 			return v + (1<<p);
 	}
 
 }
 abstract class AbstractCodeJamSolver {
 	
 	protected Scanner in;
 	protected PrintStream out = System.out;
 
 	abstract public void solve(); 
 	
 	protected void print(Object o) {
 		out.print(o);
 	}
 	
 	protected void println() {
 		out.println();
 	}
 	
 	protected void println(Object o) {
 		out.println(o);
 	}
 	
 	protected void printf(String f, Object... o) {
 		out.format(f, o);
 	}
 
 
 	final public void launch(String inputFileName) throws FileNotFoundException {
 		in = new Scanner(new File(inputFileName));
 		solve();
 	}
 }
 
","import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.util.Arrays;
 import java.util.Scanner;
 
 import org.psjava.util.FromTo;
 import org.psjava.util.ZeroTo;
 
 public class D implements Runnable {
 
 	@Override
 	public void run() {
 		Scanner in = new Scanner(System.in);
 		int casen = in.nextInt();
 		for (int casei : FromTo.get(1, casen + 1)) {
 			int n = in.nextInt();
 			double[] a = inputWeights(in, n);
 			double[] b = inputWeights(in, n);
 			Arrays.sort(a);
 			Arrays.sort(b);
 			int deceitfulWarScore = calcWarScore(n, a, b);
 			int warScore = n - calcWarScore(n, b, a);
 			System.out.print(""Case #"" + casei + "": "");
 			System.out.println(deceitfulWarScore + "" "" + warScore);
 		}
 	}
 
 	private double[] inputWeights(Scanner in, int n) {
 		double[] a = new double[n];
 		for (int i : ZeroTo.get(n))
 			a[i] = in.nextDouble();
 		return a;
 	}
 
 	private int calcWarScore(int n, double[] good, double[] bad) {
 		int goodp = 0;
 		int score = 0;
 		for (int i : ZeroTo.get(n)) {
 			while (goodp < n && good[goodp] < bad[i])
 				goodp++;
 			if (goodp < n) {
 				score++;
 				goodp++;
 			}
 		}
 		return score;
 	}
 
 	public static void main(String[] args) throws Exception {
 		System.setIn(new BufferedInputStream(new FileInputStream(""C:\\Users\\imyoyo\\Desktop\\D-small-attempt0.in"")));
 		// System.setIn(new BufferedInputStream(new FileInputStream(""D.txt"")));
 		new D().run();
 	}
 
 }
",1
398,10818,"package code.jam._2010;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class R1B_A
 {
     public static void main(String[] args) throws IOException
     {
         final String IN = ""A-small-attempt0.in"";
         //        final String IN = ""C-large.in"";
         final String OUT = IN.substring(0, IN.indexOf(""."")) + "".out"";
 
         BufferedReader in = new BufferedReader(new FileReader(IN));
 
         int numOfTests = (int) readLong(in);
 
         PrintStream out = new PrintStream(OUT);
         for (int i = 1; i <= numOfTests; i++)
         {
             out.println(String.format(""Case #%d: %s"", i, solve(in)));
         }
         out.close();
 
         System.out.println(""Completed!"");
     }
 
     private static int solve(BufferedReader in) throws IOException
     {
         int N = (int) readLong(in);
         int M = (int) readLong(in);
 
         Set<String> existed = new HashSet<String>();
         for (int i = 0; i < N; i++)
         {
             String path = in.readLine();
             StringTokenizer token = new StringTokenizer(path, ""/"");
             String parent = """";
             while(token.hasMoreTokens())
             {
                 parent += ""/"" + token.nextToken();
                 existed.add(parent);
             }
         }
 
         int toCreate = 0;
         for(int i = 0; i < M; i++)
         {
             String path = in.readLine();
             StringTokenizer token = new StringTokenizer(path, ""/"");
             String parent = """";
 
             while(token.hasMoreTokens())
             {
                 parent += ""/"" + token.nextToken();
                 if(!existed.contains(parent))
                 {
                     existed.add(parent);
                     toCreate += 1;
                 }
             }
         }
 
         return toCreate;
     }
 
     private static long readLong(BufferedReader in) throws IOException
     {
         long number = 0;
         while (true)
         {
             int c = in.read();
             if (c == -1 || Character.isWhitespace(c))
             {
                 return number;
             }
             else
             {
                 number = number * 10 + (c - '0');
             }
         }
     }
 }
","package code.jam._2010;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 public class R1B_A
 {
     public static void main(String[] args) throws IOException
     {
         final String IN = ""A-large.in"";
         //        final String IN = ""C-large.in"";
         final String OUT = IN.substring(0, IN.indexOf(""."")) + "".out"";
 
         BufferedReader in = new BufferedReader(new FileReader(IN));
 
         int numOfTests = (int) readLong(in);
 
         PrintStream out = new PrintStream(OUT);
         for (int i = 1; i <= numOfTests; i++)
         {
             out.println(String.format(""Case #%d: %s"", i, solve(in)));
         }
         out.close();
 
         System.out.println(""Completed!"");
     }
 
     private static int solve(BufferedReader in) throws IOException
     {
         int N = (int) readLong(in);
         int M = (int) readLong(in);
 
         Set<String> existed = new HashSet<String>();
         for (int i = 0; i < N; i++)
         {
             String path = in.readLine();
             StringTokenizer token = new StringTokenizer(path, ""/"");
             String parent = """";
             while(token.hasMoreTokens())
             {
                 parent += ""/"" + token.nextToken();
                 existed.add(parent);
             }
         }
 
         int toCreate = 0;
         for(int i = 0; i < M; i++)
         {
             String path = in.readLine();
             StringTokenizer token = new StringTokenizer(path, ""/"");
             String parent = """";
 
             while(token.hasMoreTokens())
             {
                 parent += ""/"" + token.nextToken();
                 if(!existed.contains(parent))
                 {
                     existed.add(parent);
                     toCreate += 1;
                 }
             }
         }
 
         return toCreate;
     }
 
     private static long readLong(BufferedReader in) throws IOException
     {
         long number = 0;
         while (true)
         {
             int c = in.read();
             if (c == -1 || Character.isWhitespace(c))
             {
                 return number;
             }
             else
             {
                 number = number * 10 + (c - '0');
             }
         }
     }
 }
",1
399,10968,"import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 /**
  * Grupo Fortaleza
  * Facebook
  * .CJ1BA
  * Created by: agutierrez
  * May 3, 2014 - 12:10:56 PM
  * 
  */
 
 /**
  * @author agutierrez
  *
  */
 public class CJ1BA
 {
   
   static class Count {
     public Count() {
       super();
     }
     char tchar;
     int  quantity;
     /* (non-Javadoc)
      * @see java.lang.Object#toString()
      */
     @Override
     public String toString()
     {
       return ""[char="" + tchar + "", quantity="" + quantity + ""]"";
     }
     
   }
   
   //  'a'-> 2, 'b' -> 2, 'c' -> 1, 'd'-> 2, 'a'->1
   
   public static List<List<Count>> parse(String strings[])
   {
 //    boolean equal = true;
 //    for (int i = 0; i < strings.length; i++)
 //    {
 //      if (i > 0)
 //      {
 //        if (!strings[i].equals(strings[i - 1]))
 //        {
 //          equal = false;
 //          break;
 //        }
 //      }
 //    }
 //    if (equal)
 //    {
 //      //return 0;
 //      return;
 //    }
     List<List<Count>> list = new ArrayList<>();
     for (String s1 : strings)
     {
       List<Count> l = new ArrayList<>();
       for (int i = 0; i < s1.length(); i++)
       {
         final char c1 = s1.charAt(i);
         if (i == 0)
         {
           Count c = new Count();
           c.tchar = c1;
           c.quantity = 1;
           l.add(c);
         }
         else
         {
           if (s1.charAt(i - 1) == c1)
           {
             l.get(l.size()-1).quantity = l.get(l.size()-1).quantity+1;
           }
           else
           {
             Count c = new Count();
             c.tchar = c1;
             c.quantity = 1;
             l.add(c);
           }
         }
       }
       list.add(l);
     }
     return list;
   }
 
   public static Integer makeEqual(List<List<Count>> list)
   {
     Map<Integer, List<Count>> split = new HashMap<>();
     int size = -1;
     for (int j=0; j < list.size(); j++)
     {
       List<Count> l = list.get(j);
       if (j == 0) {
         size = l.size();
       } else {
         if (l.size() != size) {
           return null;
         }
       }
       
       for (int i = 0; i < l.size(); i++)
       {
         if (!split.containsKey(i))
         {
           if (j == 0)
           {
             List<Count> m = new ArrayList<Count>();
             m.add(l.get(i));
             split.put(i, m);
           }
           else
           {
             return null;
           }
         }
         else
         {
           split.get(i).add(l.get(i));
         }
       }
     }
     int operaciones = 0;
     for (Integer i : split.keySet())
     {
       List<Count> l = split.get(i);
       List<Integer> n = new ArrayList<>();
       char ca = l.get(0).tchar;
       for (Count c : l)
       {
         if (c.tchar != ca)
         {
           return null;
         }
         n.add(c.quantity);
       }
       int moda = obtenerModa(n);
       for (Count c : l)
       {
         if (c.quantity != moda)
         {
           if (c.quantity > moda)
           {
             operaciones += (c.quantity - moda);
           }
           else
           {
             operaciones += (moda - c.quantity);
           }
         }
       }      
     }
     return operaciones;
   }  
   
   /**
    * @param n
    * @return
    */
 //  private static int obtenerModa(List<Integer> n)
 //  {
 //    HashMap<Integer, Integer> m = new HashMap<>();
 //    for (Integer i : n)
 //    {
 //      if (m.containsKey(i))
 //      {
 //        m.put(i, m.get(i) + 1);
 //      }
 //      else
 //      {
 //        m.put(i, 1);
 //      }
 //    }
 //    int maxCount = 0;
 //    int maxInteger = 0;
 //    for (Integer i : m.keySet())
 //    {
 //      if (m.get(i) > maxCount)
 //      {
 //        maxInteger = i;
 //        maxCount = m.get(i);
 //      }
 //    }
 //    return maxInteger;
 //  }
 
   private static int obtenerModa(List<Integer> n)
   {
     int sumMinima = Integer.MAX_VALUE;
     int valorMin = -1;
     for (Integer i: n) {
       int sum = 0;
       for (Integer j: n) {
          sum+=Math.abs(i-j);
       }
       if (sum < sumMinima) {
         sumMinima = sum;
         valorMin = i;
       }
     }
     return valorMin;
   }
   
 //  public static void main(String[] args) {
 //      System.out.println(makeEqual(parse(new String[]{""aaabbb"", ""ab"", ""aabb""})));
 //      System.out.println(makeEqual(parse(new String[]{""aabc"", ""abbc"", ""abcc""})));
 ////    System.out.println(obtenerModa(Arrays.asList(1)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2,3)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(2,1,2,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(2,1,2,1,2)));
 ////    System.out.println(obtenerModa(Arrays.asList(3,3,3,3,2)));
 //  }
 
   public static void main(String args[]) throws Exception
   {
     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     String line = br.readLine();
     int T = Integer.parseInt(line);
     for (int t = 0; t < T; t++)
     {
       line = br.readLine();
       int S = Integer.parseInt(line);
       String[] strings = new String[S];
       for (int i=0;i < S; i++) {
         strings[i] = br.readLine();        
       }
       Integer res = (makeEqual(parse(strings)));
       if (res == null) {
       System.out.println(""Case #"" + (t + 1) + "": Fegla Won"");
       } else {
       System.out.println(""Case #"" + (t + 1) + "": ""+res);
       }
     }
   }
   
 }
","import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 /**
  * Grupo Fortaleza
  * Facebook
  * .CJ1BA
  * Created by: agutierrez
  * May 3, 2014 - 12:10:56 PM
  * 
  */
 
 /**
  * @author agutierrez
  *
  */
 public class CJ1BA
 {
   
   static class Count {
     public Count() {
       super();
     }
     char tchar;
     int  quantity;
     /* (non-Javadoc)
      * @see java.lang.Object#toString()
      */
     @Override
     public String toString()
     {
       return ""[char="" + tchar + "", quantity="" + quantity + ""]"";
     }
     
   }
   
   //  'a'-> 2, 'b' -> 2, 'c' -> 1, 'd'-> 2, 'a'->1
   
   public static List<List<Count>> parse(String strings[])
   {
 //    boolean equal = true;
 //    for (int i = 0; i < strings.length; i++)
 //    {
 //      if (i > 0)
 //      {
 //        if (!strings[i].equals(strings[i - 1]))
 //        {
 //          equal = false;
 //          break;
 //        }
 //      }
 //    }
 //    if (equal)
 //    {
 //      //return 0;
 //      return;
 //    }
     List<List<Count>> list = new ArrayList<>();
     for (String s1 : strings)
     {
       List<Count> l = new ArrayList<>();
       for (int i = 0; i < s1.length(); i++)
       {
         final char c1 = s1.charAt(i);
         if (i == 0)
         {
           Count c = new Count();
           c.tchar = c1;
           c.quantity = 1;
           l.add(c);
         }
         else
         {
           if (s1.charAt(i - 1) == c1)
           {
             l.get(l.size()-1).quantity = l.get(l.size()-1).quantity+1;
           }
           else
           {
             Count c = new Count();
             c.tchar = c1;
             c.quantity = 1;
             l.add(c);
           }
         }
       }
       list.add(l);
     }
     return list;
   }
 
   public static Integer makeEqual(List<List<Count>> list)
   {
     Map<Integer, List<Count>> split = new HashMap<>();
     int size = -1;
     for (int j=0; j < list.size(); j++)
     {
       List<Count> l = list.get(j);
       if (j == 0) {
         size = l.size();
       } else {
         if (l.size() != size) {
           return null;
         }
       }
       
       for (int i = 0; i < l.size(); i++)
       {
         if (!split.containsKey(i))
         {
           if (j == 0)
           {
             List<Count> m = new ArrayList<Count>();
             m.add(l.get(i));
             split.put(i, m);
           }
           else
           {
             return null;
           }
         }
         else
         {
           split.get(i).add(l.get(i));
         }
       }
     }
     int operaciones = 0;
     for (Integer i : split.keySet())
     {
       List<Count> l = split.get(i);
       List<Integer> n = new ArrayList<>();
       char ca = l.get(0).tchar;
       for (Count c : l)
       {
         if (c.tchar != ca)
         {
           return null;
         }
         n.add(c.quantity);
       }
       int moda = obtenerModa(n);
       for (Count c : l)
       {
         if (c.quantity != moda)
         {
           if (c.quantity > moda)
           {
             operaciones += (c.quantity - moda);
           }
           else
           {
             operaciones += (moda - c.quantity);
           }
         }
       }      
     }
     return operaciones;
   }  
   
   /**
    * @param n
    * @return
    */
 //  private static int obtenerModa(List<Integer> n)
 //  {
 //    HashMap<Integer, Integer> m = new HashMap<>();
 //    for (Integer i : n)
 //    {
 //      if (m.containsKey(i))
 //      {
 //        m.put(i, m.get(i) + 1);
 //      }
 //      else
 //      {
 //        m.put(i, 1);
 //      }
 //    }
 //    int maxCount = 0;
 //    int maxInteger = 0;
 //    for (Integer i : m.keySet())
 //    {
 //      if (m.get(i) > maxCount)
 //      {
 //        maxInteger = i;
 //        maxCount = m.get(i);
 //      }
 //    }
 //    return maxInteger;
 //  }
 
   private static int obtenerModa(List<Integer> n)
   {
     int sumMinima = Integer.MAX_VALUE;
     int valorMin = -1;
     for (Integer i: n) {
       int sum = 0;
       for (Integer j: n) {
          sum+=Math.abs(i-j);
       }
       if (sum < sumMinima) {
         sumMinima = sum;
         valorMin = i;
       }
     }
     return valorMin;
   }
   
 //  public static void main(String[] args) {
 //      System.out.println(makeEqual(parse(new String[]{""aaabbb"", ""ab"", ""aabb""})));
 //      System.out.println(makeEqual(parse(new String[]{""aabc"", ""abbc"", ""abcc""})));
 ////    System.out.println(obtenerModa(Arrays.asList(1)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2,3)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(1,2,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(2,1,2,1)));
 ////    System.out.println(obtenerModa(Arrays.asList(2,1,2,1,2)));
 ////    System.out.println(obtenerModa(Arrays.asList(3,3,3,3,2)));
 //  }
 
   public static void main(String args[]) throws Exception
   {
     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     String line = br.readLine();
     int T = Integer.parseInt(line);
     for (int t = 0; t < T; t++)
     {
       line = br.readLine();
       int S = Integer.parseInt(line);
       String[] strings = new String[S];
       for (int i=0;i < S; i++) {
         strings[i] = br.readLine();        
       }
       Integer res = (makeEqual(parse(strings)));
       if (res == null) {
       System.out.println(""Case #"" + (t + 1) + "": Fegla Won"");
       } else {
       System.out.println(""Case #"" + (t + 1) + "": ""+res);
       }
     }
   }
   
 }
",1
400,7300,"
 /**
  * Write a description of class TrustBot here.
  * 
  * @author (your name) 
  * @version (a version number or a date)
  */
 public class TrustBot
 {
    public static void main(String[] args)
    {
        int lineNo=-2;
        
        int pta=0;                        int ptb=0;
        int pbpa=1;                       int pbpb=1;
        int mta=0;                        int mtb=0;
        int tea=0;                        int teb=0;
        int pt=0;
        int caseNo=0;
        
        Literate lit=new Literate(""trust.txt"",""trustout.txt"");
        String str="""";
        while((str=lit.readLine())!=null)
        {
            lineNo++;
            
            if(lineNo==-1) {}
            
            if(lineNo>-1)
            {
                caseNo++;
                
                 pta=0;                         ptb=0;
                 pbpa=1;                        pbpb=1;
                 mta=0;                         mtb=0;
                 tea=0;                         teb=0;
                 pt=0;
                String[] splited=lit.split(str);
                
                int len=Integer.parseInt(splited[0]);
                
                char[] colorar=new char[len];
                int[] buPos=new int[len];
                
                for(int j=1;j<splited.length;j++)
                {
                    if((j%2)==1) { 
                        colorar[(j-1)/2]=splited[j].charAt(0);
                     }
                     
                    else {
                        buPos[(j/2)-1]=Integer.parseInt(splited[j]);
                     }
                 }
                
                for(int i=0;i<colorar.length;i++)
                {
                    //System.out.println(colorar[i]+""  ""+buPos[i]);
                 }
                
                for(int i=0;i<colorar.length;i++)
                {
                    if(colorar[i]=='O'|colorar[i]=='o')
                    {
                        //System.out.println(""inside color""+colorar[i]);
                        mta=Math.abs(buPos[i]-pbpa);
                        tea=pt-pta;
                        
                        if(mta>tea) { pt+=mta-tea;} else { }
                        
                        //pushing
                        //System.out.println(""mta ""+mta+"" tea ""+tea+"" pt ""+pt);
                        pt++;
                        //assigning new value
                        pbpa=buPos[i];
                        pta=pt;
                        
                     }
                     else
                     {
                         //System.out.println(""inside color""+colorar[i]);
                         mtb=Math.abs(buPos[i]-pbpb);
                         
                         teb=pt-ptb;
                         
                         if(teb<mtb) { pt+=mtb-teb;} else { }
                         //button pushing
                         //System.out.println(""mtb ""+mtb+"" teb ""+teb+"" pt ""+pt);
                         pt++;
                        pbpb=buPos[i];
                        ptb=pt;
                     }
                 }
                 String ans=lit.giveAns(caseNo)+pt;
                 System.out.println(ans);
                 
                 
             }
         }
     }
                 
            
        
        
 }
","
 import java.util.Arrays;
 import java.util.regex.Pattern;
 import java.util.regex.Matcher;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 public class Prob2A
 {
    public static void main(String[] args)
    {
        Literate lit=new Literate(""aInput.txt"",""notmatter.txt"");
        
        int lineNo=-2;
        int caseNo=0;
        
        String str="""";
        
        
        
        while((str=lit.readLine())!=null)
        {
            lineNo++;
            
            if(lineNo==-1) 
            {
                continue;
             }
             int lines=0;
             int len=0;
             if(lineNo%2==0)
             {
                // u.println(""reached 0 ""+ str);
                 int [] data=lit.splitInt(str);
                 lines=data[0];
                 len=data[1];
                 
                 lineNo++;
             }
             char[][] tile=new char[lines][len];
             
             
             if(lineNo%2==1)
             {
                 // u.println(""reached 1"");
                 caseNo++;
                 int nhash=0;
                 for(int i=0;i<lines;i++)
                 {
                     str=lit.readLine();
                     nhash=nhash+u.countChar('#',str);
                     
                     for(int j=0;j<len;j++)
                     {
                         tile[i][j]=str.charAt(j);
                     }
                     
                 }
                 
                 
                 //u.println(nhash);
                 
                 if(nhash%4!=0)
                 {
                     System.out.println(lit.giveAns(caseNo));
                     System.out.println(""Impossible"");
                 }
                 else
                 {
                     for(int i=0;i<lines-1;i++)
                     {
                         for(int j=0;j<len-1;j++)
                         {
                             if((tile[i][j]=='#')&(tile[i][j+1]=='#'))
                             {
                                 if((tile[i+1][j]=='#')&(tile[i+1][j+1]=='#'))
                                 {
                                     tile[i][j]='/';
                                     String temp=""\\"";
                                     
                                     char c=temp.charAt(0);
                                     
                                     //u.println(temp+ "" temp "");
                                     
                                     tile[i][j+1]=c;
                                     
                                     tile[i+1][j]=c;
                                     tile[i+1][j+1]='/';
                                 }
                             }
                         }
                     }
                     boolean imp=false;
                     for(int i=0;i<lines;i++)
                   {
                    // str=lit.readLine();
                     //nhash=nhash+u.countChar('#',str);
                     
                     for(int j=0;j<len;j++)
                     {
                         if(tile[i][j]=='#')
                         {
                             imp=true;
                         }
                         
                     }
                     
                   }
                   if(imp)
                   {
                       System.out.println(lit.giveAns(caseNo));
                     System.out.println(""Impossible"");
                     }
                     else
                     {
                       
                     System.out.println(lit.giveAns(caseNo));                    
                     u.printel(tile);
                   }
                 }
                 
                 
                                 
                         
                 
                     
                 
             }
             
             //if(lineNo%==0)
             {
                 
             }
             
         }
     }
 }",1
401,10918,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.LinkedList;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 
 class CharacterPair implements Comparable<CharacterPair> {
 	final char ch1;
 	final char ch2;
 	
 	public CharacterPair(char ch1, char ch2) {
 		if (ch1 > ch2) {
 			this.ch1 = ch1;
 			this.ch2 = ch2;
 		} else {
 			this.ch1 = ch2;
 			this.ch2 = ch1;
 		}
 	}
 
 	@Override
 	public int compareTo(CharacterPair arg0) {
 		int ret = this.ch1 - arg0.ch1;
 		if (ret == 0) {
 			ret = this.ch2 - arg0.ch2;
 		}
 		return ret;
 	}
 }
 
 public class Magicka {
 	
 	private static String parseCaseStr(String inputStr,
 			TreeMap<CharacterPair, Character> combinePairs, 
 			TreeMap<Character, Character> oppositePairs) {
 		
 		final String[] input = inputStr.split("" "");
 		int currentIndex = 0;
 		final int combineCount = Integer.parseInt(input[currentIndex++]);
 		
 		for (int i = 0; i < combineCount; ++ i) {
 			String combineStr = input[currentIndex++];
 			combinePairs.put(new CharacterPair(combineStr.charAt(0), combineStr.charAt(1)), combineStr.charAt(2));
 		}
 		
 		final int oppositeCount = Integer.parseInt(input[currentIndex++]);
 		
 		for (int i = 0; i < oppositeCount; ++ i) {
 			String oppositeStr = input[currentIndex++];
 			oppositePairs.put(oppositeStr.charAt(0), oppositeStr.charAt(1));
 			oppositePairs.put(oppositeStr.charAt(1), oppositeStr.charAt(0));
 		}
 		
 		return input[currentIndex + 1];
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		try {
 			String inFileName = args[0];
 			BufferedReader in = new BufferedReader(new FileReader(inFileName));
 			BufferedWriter out = new BufferedWriter(new FileWriter(inFileName + "".out""));
 			int testCases = Integer.parseInt(in.readLine());
 			
 			for (int caseNo = 1; caseNo <= testCases; ++caseNo) {
 			
 				TreeMap<CharacterPair, Character> combinePairs = new TreeMap<CharacterPair, Character>();
 				TreeMap<Character, Character> oppositePairs = new TreeMap<Character, Character>();
 				final String caseStr = in.readLine();
 				final String inputStr = parseCaseStr(caseStr, combinePairs, oppositePairs);				
 				final LinkedList<Character> outSequence = new LinkedList<Character>();
 				TreeSet<Character> oppositeChars = new TreeSet<Character>();
 				
 				for (int i = 0; i < inputStr.length(); ++i) {
 					char ch = inputStr.charAt(i);
 					
 					if (outSequence.size() > 0) {
 						char lastChar = outSequence.getLast();
 						Character combinedChar = combinePairs.get(new CharacterPair(ch, lastChar));
 						if (combinedChar != null) {
 							outSequence.removeLast();
 							outSequence.add(combinedChar);
 							
 							Character oppositeChar = oppositePairs.get(lastChar);
 							
 							if (oppositeChar != null && !outSequence.contains(lastChar)) {
 								oppositeChars.remove(oppositeChar);
 							}
 							
 							continue;
 						}
 					}
 						
 					if (oppositeChars.contains(ch)) {
 						outSequence.clear();
 						oppositeChars.clear();
 						continue;
 					}
 						
 					outSequence.add(ch);
 					Character oppositeChar = oppositePairs.get(ch);
 						
 					if (oppositeChar != null) {
 						oppositeChars.add(oppositeChar);
 					}
 				}
 				
 				StringBuilder s = new StringBuilder();
 				
 				for (Character ch : outSequence) {
 					if (s.length() > 0) {
 						s.append("", "");
 					}
 					s.append(ch);
 				}
 				
 				String caseResultStr = ""Case #"" + caseNo + "": ["" + s.toString() + ""]\n"";
 				System.out.print(caseResultStr);
 				out.write(caseResultStr);
 				out.flush();
 			}
 		}
 		catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.LinkedList;
 import java.util.Locale;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 class Interval {
 	final long length;
 	final long velocity;
 	
 	Interval(long length, long velocity) {
 		this.length = length;
 		this.velocity = velocity;
 	}
 }
 
 public class CodeJam {
 	
 
 	public static void main(String[] args) throws IOException {
 		
 		String inFileName = args[0];
 		BufferedReader in = new BufferedReader(new FileReader(inFileName));
 		BufferedWriter out = new BufferedWriter(new FileWriter(inFileName + "".out""));
 		int testCases = Integer.parseInt(in.readLine());
 
 		for (int caseNo = 1; caseNo <= testCases; ++caseNo) {
 			String caseStr[] = in.readLine().split("" "");
 			final long X = Long.parseLong(caseStr[0]);
 			final long walkSpeed = Long.parseLong(caseStr[1]);
 			final long runSpeed = Long.parseLong(caseStr[2]);
 			double runTime = Long.parseLong(caseStr[3]);
 			final int N = Integer.parseInt(caseStr[4]);
 			
 			LinkedList<Interval> intervals = new LinkedList<Interval>();
 			long prevEnd = 0;
 			
 			for (int i = 0; i < N; ++i) {
 				String walkWay[] = in.readLine().split("" "");
 				long b = Long.parseLong(walkWay[0]);
 				long e = Long.parseLong(walkWay[1]);
 				long w = Long.parseLong(walkWay[2]);
 				
 				if (prevEnd < b) {
 					intervals.add(new Interval(b - prevEnd, 0));
 				}
 				intervals.add(new Interval(e - b, w));
 				prevEnd = e;
 			}
 			
 			if (prevEnd < X) {
 				intervals.add(new Interval(X - prevEnd, 0));
 			}
 			
 			Collections.sort(intervals, new Comparator<Interval>() {
 
 				@Override
 				public int compare(Interval arg0, Interval arg1) {
 					return Long.signum(arg0.velocity - arg1.velocity);
 				}
 			});
 			
 			double time = 0;
 			
 			for (Interval i : intervals) {
 				double length = i.length;
 				double velocity = i.velocity;
 				
 				if (runTime > 0) {
 					double rt = Math.min(length / (velocity + runSpeed), runTime);
 					time += rt;
 					runTime -= rt;
 					length -= rt * (velocity + runSpeed);
 				}
 				
 				time += length / (velocity + walkSpeed);
 			}
 			
 			StringBuilder result = new StringBuilder();
 			result.append(String.format(Locale.US, ""%.9f"", time));
 			
 			final String resultStr = ""Case #"" + caseNo + "": "" + result.toString() + ""\n"";
 			out.write(resultStr);
 			System.out.print(resultStr);
 			out.flush();
 		}
 	}
 }
",1
402,8818,"package Qualification;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 /**
  * Task B
  * 
  * @author Krisztian Balog
  */
 public class TaskB {
 
 	private static double solve(double C, double F, double X) {
 		// no farms
 		double best = X / 2.0;		
 		// have one or more farms
 		double lastFarmTime = C / 2.0; // time to build the 1st farm
 		for (int farms = 1; farms <= Math.floor(X / C); farms++) {
 			double totalTime = lastFarmTime + X / (farms * F + 2.0);
 			if (totalTime < best)
 				best = totalTime;
 			//System.out.println(farms + "" farms at "" + lastFarmTime + "" \ttotal: "" + totalTime);
 			lastFarmTime += C / (farms * F + 2.0);
 		}
 
 		return best;
 	}
 
 	public static void main(String[] args) {
 		String inputFile = ""src/Qualification/B-small-attempt0.in"";
 		String outputFile = ""src/Qualification/B-small-attempt0.out"";
 
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(inputFile));
 			BufferedWriter out = new BufferedWriter(new FileWriter(outputFile));
 			int T = new Integer(br.readLine());
 			for (int i = 0; i < T; i++) {
 				String[] tmp = br.readLine().split("" "");
 				double C = new Double(tmp[0]);
 				double F = new Double(tmp[1]);
 				double X = new Double(tmp[2]);
 
 				// evaluate case #i
 				double solution = solve(C, F, X);
 				out.write(""Case #"" + (i + 1) + "": "" + solution + ""\n"");
 				System.out.println(""Case #"" + (i + 1) + "": "" + solution);
 			}
 			br.close();
 			out.close();
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
","package Qualification;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Arrays;
 
 /**
  * Task D
  * 
  * @author Krisztian Balog
  */
 public class TaskD {
 
 	private static double[] massesStrToDouble(String[] wstr) {
 		double[] w = new double[wstr.length];
 		for (int i = 0; i < wstr.length; i++)
 			w[i] = new Double(wstr[i]).doubleValue();
 		return w;
 	}
 	
 	private static int playUnfair(double[] mNaomi, double[] mKen) {
 		int N = mNaomi.length;
 		boolean[] used = new boolean[N];
 		for (int i = 0; i < N; i++) 
 			used[i] = false;
 		
 		int score = N;
 		for (int i = N-1; i >= 0; i--) {
 			boolean canBeat = false;
 			for (int j = N-1; j >= 0; j--) {
 				if (!used[j] && mNaomi[j] > mKen[i]) {
 					canBeat = true;
 					used[j] = true;
 					break;
 				}
 			}
 			if (!canBeat)
 				score--;
 		}
 		return score;
 	}
 	
 	private static int playFair(double[] mNaomi, double[] mKen) {
 		int N = mNaomi.length;
 		Ken ken = new Ken(mKen);
 		
 		int score = 0;
 		for (int i = N-1; i >= 0; i--) {
 			double massNaomi = mNaomi[i];
 			double massKen = ken.next(massNaomi);
 			
 			if (massNaomi > massKen) {
 				score++;
 			}
 		}
 		return score;
 	}	
 	
 	public static void main(String[] args) {
 		String inputFile = ""src/Qualification/D-large.in"";
 		String outputFile = ""src/Qualification/D-large.out"";
 
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(inputFile));
 			BufferedWriter out = new BufferedWriter(new FileWriter(outputFile));
 			int T = new Integer(br.readLine());
 			for (int i = 0; i < T; i++) {
 				int N = new Integer(br.readLine());			
 				double[] mNaomi = massesStrToDouble(br.readLine().split("" ""));				
 				double[] mKen = massesStrToDouble(br.readLine().split("" ""));
 
 				Arrays.sort(mNaomi);
 				Arrays.sort(mKen);
 				
 				int scoreFair = playFair(mNaomi, mKen);
 				int scoreUnfair = playUnfair(mNaomi, mKen);
 				
 				// evaluate case #i
 				out.write(""Case #"" + (i + 1) + "": "" + scoreUnfair + "" "" + scoreFair + ""\n"");
 				System.out.println(""Case #"" + (i + 1) + "": "" + scoreUnfair + "" "" + scoreFair);
 			}
 			br.close();
 			out.close();
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 
 }
",1
403,8224,"
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class main {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
         Scanner scanner;
         try {
             String[] arr= new String[5];
             scanner = new Scanner(new File(""1.in""));
             int t=Integer.parseInt(scanner.nextLine());
             int i=0;
             int j=0;
             while(j<t){
                 arr[i++]=scanner.nextLine();
                 if(i==4)
                 {
                     if(scanner.hasNextLine())
                         scanner.nextLine();
                     j++;i=0;
                     System.out.print(""Case #""+j+"": "");
                     f(arr);
                 }
             }
         } 
         catch (FileNotFoundException ex) {
             
         }
         
     }
     public static void f(String[] arr){
         int[][] p=new int[4][4];
         int i,j,sum;
         for(i=0;i<4;i++)
         {
             String q=arr[i];
             for(j=0;j<4;j++)
             {
                 if(q.charAt(j)=='.')
                     p[i][j]=0;
                 else if(q.charAt(j)=='O')
                     p[i][j]=1;
                 else if(q.charAt(j)=='X')
                     p[i][j]=20;
                 else if(q.charAt(j)=='T')
                     p[i][j]=10;
             }
         }
         for(i=0;i<4;i++)
         {
             sum=0;
             for(j=0;j<4;j++)
                 sum+=p[i][j];
             if(sum==4||sum==13)
             {   
                 System.out.println(""O won"");
                 return;
             }
             else if(sum==80||sum==70)  
             {   
                 System.out.println(""X won"");
                 return;
             }
             sum=0;
             for(j=0;j<4;j++)
                 sum+=p[j][i];
             if(sum==4||sum==13)
             {   
                 System.out.println(""O won"");
                 return;
             }
             else if(sum==80||sum==70)  
             {   
                 System.out.println(""X won"");
                 return;
             }
         }
         sum=0;
         for(i=0;i<4;i++)
             sum+=p[i][i];
         if(sum==4||sum==13)
         {   
             System.out.println(""O won"");
             return;
         }
         else if(sum==80||sum==70)  
         {   
             System.out.println(""X won"");
             return;
         }
         sum=0;
         for(i=0;i<4;i++)
             sum+=p[i][3-i];
         if(sum==4||sum==13)
         {   
             System.out.println(""O won"");
             return;
         }
         else if(sum==80||sum==70)  
         {   
             System.out.println(""X won"");
             return;
         }
         int check=0;
         for(i=0;i<4;i++)
             for(j=0;j<4;j++)
                 if(p[i][j]==0)
                     check=1;
         if(check==1)
             System.out.println(""Game has not completed"");
         else
             System.out.println(""Draw"");
     }
 }
","
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class PC {
 
     private static int[] div = {10, 100, 1000, 10000, 100000, 1000000};
 
     public static void main(String[] args) throws FileNotFoundException {
         if (args.length != 1) {
             System.exit(1);
         }
         File inFile = new File(args[0]);
         Scanner sc = new Scanner(inFile);
         int T = sc.nextInt();
         try (PrintWriter out = new PrintWriter(""out.txt"")) {
             for (int i = 1; i <= T; i++) {
                 int A = sc.nextInt(), B = sc.nextInt(), count = 0, maxPow = 0;
                 for (int j = 0; j < 6; j++) {
                     if (A / div[j] == 0) {
                         maxPow = j - 1;
                         break;
                     }
                 }
                 int[] prevFound = new int[2000000];
                 for (int j = A; j <= B; j++) {
                     int pow = 0;
                     while (true) {
                         int numFront = j / div[pow];
                         if (numFront == 0) {
                             break;
                         }
                         int numBack = j % div[pow];
                         int newNum = numBack * div[maxPow - pow] + numFront;
                         if (j < newNum && A <= newNum && newNum <= B && prevFound[newNum - 1] < j) {
                             prevFound[newNum - 1] = j;
                             count++;
                         }
                         pow++;
                     }
                 }
                 out.println(""Case #"" + i + "": "" + count);
             }
         }
         System.out.println(""Completed!"");
     }
 }",0
404,9471,"package codejam.codejam2014.round1B;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  * 
  * New Lottery Game
  * 
  */
 
 public class ProblemB {
     
     private static final String ID = ""gcj2014round1B\\B-small-attempt0"";
     
     private static Scanner input;
     private static PrintWriter output;
     
     private static void run() {
         long time = System.currentTimeMillis();
         solve();
         output.flush();
         output.close();
         input.close();
         time = System.currentTimeMillis() - time;
         System.out.printf(""[%s] finished in %d ms\n"", ID, time);
     }
     
     public static void main(String[] args) {
         try {
             input = new Scanner(new File(""codejam\\"" + ID + "".in""));
             output = new PrintWriter(new FileWriter(""codejam\\"" + ID + "".out""));
             run();
         } catch (Exception ex) {
             ex.printStackTrace(System.out);
         }
     }
     
     private static void solve() {
         final int T = input.nextInt();
         for (int t = 1; t <= T; t++) {
             final long A = input.nextLong();
             final long B = input.nextLong();
             final long K = input.nextLong();
             
             System.out.printf(""Case #%d\n"", t);
             int answer = solve(A, B, K);
             System.out.println(answer);
             output.printf(""Case #%d: %d\n"", t, answer);
             System.out.println();
         }
     }
     
     private static final long ALL_SET = 0xffffffffffffffffL;
     private static int solve(long A, long B, long K) {
         int answer = 0;
 //        System.out.printf(""  A:%d B:%d K:%d\n"", A, B, K);
 //        for (long k = 0; k < K; k++) {
 //            System.out.printf(""  k:%s\n"", Long.toBinaryString(k));
 //            for (long a = 0; a < A; a++) {
 //                if ((a & k) != k) {
 //                    continue;
 //                }
 //                
 //                for (long b = 0; b < B; b++) {
 //                    if ((b & k) != k) {
 //                        continue;
 //                    }
 //                    
 //                    if ((a & b) == k)
 //                }
 //                
 //                System.out.printf(""    a:%s\n"", Long.toBinaryString(a));
 //                
 //                long zMask = ~(a & ~k);
 //                long vary = ~k & ~a;
 //                
 //                System.out.printf(""      zMask:%s\n"", Long.toBinaryString(zMask));
 //                System.out.printf(""      vary:%s\n"", Long.toBinaryString(vary));
 //                
 //                
 //            }
 //        }
         
         for (long a = 0; a < A; a++) {
             for (long b = 0; b < B; b++) {
                 if ((a & b) < K) answer++;
             }
         }
         
         return answer;
     }
     
 }
","package codejam.codejam2014.qualification;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 /**
  * 
  * Deceitful War
  * 
  * for War:
  *  - Naomi optimal gameplay is just to play blocks in descending order
  * 
  * for Deceitful War:
  *  - Naomi has two options for optimal gameplay:
  *    - if her heaviest block is heavier than Ken's heaviest block, play it (and say what it is)
  *    - otherwise, play the lowest block - and say that it is 0.000001 kg lighter than Ken's heaviest (so he must play it)
  * 
  * no matter what:
  *  - Ken has two options for responding:
  *    - if he can beat Naomi, play the lowest block that beats it
  *    - if he can't beat Naomi, play the lowest block he has
  * 
  */
 
 public class ProblemD {
     
     private static final String ID = ""gcj2014quals\\D-small-attempt0"";
     
     private static Scanner input;
     private static PrintWriter output;
     
     private static void run() {
         long time = System.currentTimeMillis();
         solve();
         output.flush();
         output.close();
         input.close();
         time = System.currentTimeMillis() - time;
         System.out.printf(""[%s] finished in %d ms\n"", ID, time);
     }
     
     public static void main(String[] args) {
         try {
             input = new Scanner(new File(""codejam\\"" + ID + "".in""));
             output = new PrintWriter(new FileWriter(""codejam\\"" + ID + "".out""));
             run();
         } catch (Exception ex) {
             ex.printStackTrace(System.out);
         }
     }
     
     private static void solve() {
         int T = input.nextInt();
         
         for (int count = 1; count <= T; count++) {
 //            System.out.println();
 //            System.out.println("">>>>>>>>>>>Beginning case "" + count);
             int N = input.nextInt();
             
             double[] blocks = new double[N];
             
             for (int i = 0; i < N; i++)
                 blocks[i] = input.nextDouble();
             Arrays.sort(blocks);
             LinkedList<Double> naomiBlocks = new LinkedList();
             for (double block : blocks)
                 naomiBlocks.add(block);
             
             for (int i = 0; i < N; i++)
                 blocks[i] = input.nextDouble();
             LinkedList<Double> kenBlocks = new LinkedList();
             Arrays.sort(blocks);
             for (double block : blocks)
                 kenBlocks.add(block);
             
             output.print(""Case #"");
             output.print(count);
             output.print("": "");
             output.print(naomiWinsDeceitfulWar(new LinkedList(naomiBlocks), new LinkedList(kenBlocks)));
             output.print(' ');
             output.println(naomiWinsWar(new LinkedList(naomiBlocks), new LinkedList(kenBlocks)));
         }
     }
     
     private static double playKen(LinkedList<Double> kenBlocks, double toldNaomi) {
         double minHigher = 1.0, min = 1.0;
         for (double block : kenBlocks) {
             if (block > toldNaomi && block < minHigher)
                 minHigher = block;
             if (block < min)
                 min = block;
         }
         
         if (minHigher == 1.0)
             return min;
         else
             return minHigher;
     }
     
     private static int naomiWinsWar(LinkedList<Double> naomiBlocks, LinkedList<Double> kenBlocks) {
         int wins = 0;
         while (!naomiBlocks.isEmpty()) {
             double chosenNaomi = naomiBlocks.getLast();
             naomiBlocks.removeLast();
             
             double chosenKen = playKen(kenBlocks, chosenNaomi);
             if (chosenNaomi > chosenKen)
                 wins++;
             
             kenBlocks.remove(chosenKen);
         }
         return wins;
     }
     
     private static int naomiWinsDeceitfulWar(LinkedList<Double> naomiBlocks, LinkedList<Double> kenBlocks) {
         int wins = 0;
         while (!naomiBlocks.isEmpty()) {
             double naomiLightest = naomiBlocks.getFirst(), kenLightest = kenBlocks.getFirst();
             double toldNaomi = kenBlocks.getLast() + (naomiLightest > kenLightest ? 0.0000001 : -0.0000001);
             
 //            if (naomiLightest > kenLightest) {
 //                toldNaomi = kenBlocks.getLast() + 0.0000001;
 //            } else {
 //                toldNaomi = kenBlocks.getLast() - 0.0000001;
 //            }
             
             naomiBlocks.removeFirst();
             
             double chosenKen = playKen(kenBlocks, toldNaomi);
             if (naomiLightest > chosenKen)
                 wins++;
             
             kenBlocks.remove(chosenKen);
             
 //            System.out.println(""-----"");
 //            System.out.println(""Chosen_Naomi: "" + chosenNaomi);
 //            System.out.println(""  Told_Naomi: "" + toldNaomi);
 //            System.out.println(""  Chosen_Ken: "" + chosenKen);
         }
         return wins;
     }
     
 }
",1
405,10425,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Main {
 
   static int N;
   static int M;
   static int endArr[][];
 
   public static void main(String[] args) throws IOException {
     String strr[];
     BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""B-large.in"")));
     PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));
     int cases = Integer.parseInt(br.readLine());
     for (int i = 1; i <= cases; i++) {
       strr = br.readLine().split("" "");
       N = Integer.parseInt(strr[0]);
       M = Integer.parseInt(strr[1]);
       endArr = new int[N][M];
       for (int j = 0; j < N; j++) {
         strr = br.readLine().split("" "");
         for (int k = 0; k < strr.length; k++) {
           endArr[j][k] = Integer.parseInt(strr[k]);
         }
       }
       if (N == 1 || M == 1) {
         out.println(""Case #"" + i + "": "" + ""YES"");
         continue;
       }
       boolean res = isPossible(initArray(), new ArrayList<Integer>(), new ArrayList<Integer>());
       if (res) {
         out.println(""Case #"" + i + "": "" + ""YES"");
       } else {
         out.println(""Case #"" + i + "": "" + ""NO"");
       }
     }
     out.flush();
   }
 
   public static int[][] initArray() {
     int arr[][] = new int[N][M];
     for (int i = 0; i < N; i++) {
       for (int j = 0; j < M; j++) {
         arr[i][j] = 100;
       }
     }
     return arr;
   }
 
   public static int[][] copyArray(int[][] matrix) {
     if (matrix == null) {
       return null;
     }
     int[][] myInt = new int[N][M];
     for (int i = 0; i < N; i++) {
       System.arraycopy(matrix[i], 0, myInt[i], 0, M);
     }
     return myInt;
   }
 
   public static boolean isPossible(int currentArr[][], List<Integer> visitedRows, List<Integer> visitedCols) {
     int height = 100;
     int x = 0;
     int y = 0;
     boolean match = true;
     for (int i = 0; i < N; i++) {
       for (int j = 0; j < M; j++) {
         if (currentArr[i][j] != endArr[i][j]) {
           match = false;
           height = endArr[i][j];
           x = i;
           y = j;
           break;
         }
       }
       if (!match)
         break;
     }
     if (match)
       return true;
 
     int[][] myArr;
     boolean isRowAssignmentPossible = true;
     boolean ret1 = true;
     if (!visitedRows.contains(x)) {
       myArr = copyArray(currentArr);
       for (int i = 0; i < M; i++) {
         if (endArr[x][i] > height) {
           isRowAssignmentPossible = false; // Not possible to Assign
           ret1 = false;
           break;
         } else {
           if (myArr[x][i] > height)
             myArr[x][i] = height;
         }
       }
       if (isRowAssignmentPossible) {
         visitedRows.add(x);
         ret1 = isPossible(myArr, visitedRows, visitedCols);
         visitedRows.remove(new Integer(x));
         if (ret1)
           return ret1;
       }
     } else {
       isRowAssignmentPossible = false;
       ret1 = false;
     }
 
     boolean isColumnAssignmentPossible = true;
     boolean ret2 = true;
     if (!visitedCols.contains(y)) {
       myArr = copyArray(currentArr);
       for (int i = 0; i < N; i++) {
         if (endArr[i][y] > height) {
           isColumnAssignmentPossible = false;// Not possible to assign
           ret2 = false;
           break;
         } else {
           if (myArr[i][y] > height)
             myArr[i][y] = height;
         }
       }
       if (isColumnAssignmentPossible) {
         visitedCols.add(y);
         ret2 = isPossible(myArr, visitedRows, visitedCols);
         visitedCols.remove(new Integer(y));
         if (ret2)
           return ret2;
       }
     } else {
       isColumnAssignmentPossible = false;
       ret2 = false;
     }
 
     if (ret1 == false && ret2 == false)
       return false;
     if (isRowAssignmentPossible == false && isColumnAssignmentPossible == false)
       return false;
     return true; // unreachable
   }
 }
","import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
 
 public class Main 
 {
 	public static void main(String[] args) throws IOException 
 	{
 		String[] strr;
 		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(""C-large.in""))));
 		PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(""C-large.out""))));
 		int cases = Integer.parseInt(br.readLine());
 		for(int i=1; i<=cases; i++)
 		{
 			br.readLine();
 			strr = br.readLine().split("" "");
 			int xor = 0;
 			int sum = 0;
 			int min = Integer.MAX_VALUE;
 			int temp;
 			for (int j = 0; j < strr.length; j++) {
 				temp = Integer.parseInt(strr[j]);
 				xor ^= temp;
 				sum += temp;
 				min = Math.min(temp, min);
 			}
 			if(xor == 0)
 			{
 				out.println(""Case #"" + i +"": "" + (sum-min));
 			}
 			else
 			{
 				out.println(""Case #"" + i + "": "" + ""NO"");
 			}
 		}
 		out.flush();
 		out.close();		
 	} 
 }",1
406,16535,"import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  * @author Aliaksei Andreyeu
  *         <p/>
  *         Date created: 14.04.13 3:36
  */
 public class FairAndSquareSimple
 {
 
     public int solve(int A, int B)
     {
         int counter = 0;
         for (int i = (int)Math.ceil(Math.sqrt(A)); i <= Math.sqrt(B); i++)
         {
             if (isPalindrome(i) && isPalindrome(i * i))
             {
                 counter++;
             }
         }
         return counter;
     }
 
     private boolean isPalindrome(int num)
     {
         String numStr = num + """";
         int length = numStr.length();
 
         for (int i = 0; i < length / 2; i++)
         {
             if (numStr.charAt(i) != numStr.charAt(length - 1 - i))
             {
                 return false;
             }
         }
 
         return true;
     }
 
     public static void main(String[] args)
     {
         Scanner inputScan = null;
         PrintWriter out = null;
 
         FairAndSquareSimple solver = new FairAndSquareSimple();
 
         try
         {
             inputScan = new Scanner(new FileInputStream(args[0]));
             out = new PrintWriter(new FileOutputStream(args[1]));
 
             int casesNum = inputScan.nextInt();
             inputScan.nextLine();
 
             for (int i = 1; i <= casesNum; i++)
             {
                 String[] intervalStr = inputScan.nextLine().split("" "");
                 int A = Integer.parseInt(intervalStr[0]);
                 int B = Integer.parseInt(intervalStr[1]);
 
                 out.println(""Case #"" + i + "": "" + solver.solve(A, B));
             }
 
         }
         catch (Throwable ex)
         {
             System.out.println(ex.getMessage());
             ex.printStackTrace();
         }
         finally
         {
             if (out != null)
             {
                 out.flush();
                 out.close();
             }
             if (inputScan != null)
             {
                 inputScan.close();
             }
         }
 
     }
 
 }
","
 package cj3;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 public class CJ3 {
 
     public static void main(String[] args) throws FileNotFoundException, IOException {
        
         File file = new File(""input.txt"");
         PrintWriter pw = new PrintWriter(""output.txt"");
           
         FileReader fr = new FileReader(file);
         BufferedReader r = new BufferedReader(fr);
          
         int T;          
  
         T = Integer.parseInt(r.readLine());        
          for(int t =0;t<T;t++){
              
              int N = Integer.parseInt(r.readLine());
              
              ArrayList<Double> ww1 = new ArrayList<>();
              ArrayList<Double> ww2 = new ArrayList<>();
              double [] w1 = new double[N];
              double [] w2 = new double[N];
              double [] w1Copy = new double[N];
              double [] w2Copy = new double[N];
              
               String lineW1 = r.readLine();
               String lineW2 = r.readLine();
               
               StringTokenizer sto1 =  new StringTokenizer(lineW1 ,"" ""); 
               StringTokenizer sto2 =  new StringTokenizer(lineW2 ,"" ""); 
                             
               for(int i =0;i<N;i++){
                   w1[i] = Double.parseDouble(sto1.nextElement().toString());
                   w2[i] = Double.parseDouble(sto2.nextElement().toString());
                   w1Copy[i] = w1[i];
                   w2Copy[i] = w2[i];              
               }     
               
              
               Arrays.sort(w1Copy);
               Arrays.sort(w2Copy);
              
   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////            
             //optimality not sure
               int count =0;
               int i=N-1;
               int j =N-1;
               while(j>=0 && i>=0){
                  if(w1Copy[i]>w2Copy[j]){
                      //System.out.println(w1Copy[i]+"" ## ""+w2Copy[N-j-1]);
                       count++; 
                       i--;
                  }else{
                      w1Copy[i] =0;
                      w2Copy[j] =0;
                      j--;                     
                  }
               }   
                    
               
               
                
               
               
               
          /*     int points=0;
               for(int j=0; j<N;j++ ){
                  boolean won = true;
                  for(int k=0;k<N;k++){
                      if(w2Copy[k]>w1Copy[j]){
                        // System.out.println(w2Copy[k]+"" ## ""+w1Copy[j]);   
                          w2Copy[k] =-1;
                          won = false;
                          k=N;
                      }
                      
                  } 
                   if(won){
                      points++;
                  } 
                 
               }*/
               
           //    System.out.println(points);
               
               Arrays.sort(w1);
               Arrays.sort(w2);
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
               int points2=N;              
               int k=0;
               while(k<N && w1[k]<w2[0]){
                   k++;
                   points2--;
                   w2[N-k] =-1;
               }
            /*  int M = k;
              int l = N-1;
               while(w2[N-1-M]>w1[l] ){
                   points2--;
                   M++;                  
               }   */         
            //   System.out.println(""##"" +points2);               
                       
                pw.println(""Case #""+(t+1)+"": "" +points2 +"" ""+ count );
                pw.flush();
          }            
     }
 
 
 }
",0
407,2735,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.io.InputStreamReader;
 import java.io.IOException;
 
 public class Main2{
 
 	public static void main(String args[]){
 		try{
 			FileReader fr=new FileReader(""input.txt"");
 			BufferedReader br=new BufferedReader(fr);
 			PrintWriter pr=new PrintWriter(""out.txt"");
 			String str=br.readLine();
 			int T=Integer.parseInt(str);
 			for(int t=1;t<=T;t++){
 				str=br.readLine();
 				int bl=str.indexOf(' ');
 				int a=Integer.parseInt(str.substring(0,bl));
 				str=str.substring(bl+1);
 				bl=str.indexOf(' ');
 				int b=Integer.parseInt(str.substring(0,bl));
 				int k=Integer.parseInt(str.substring(bl+1));
 				int ct=0;
 				for(int i=0;i<a;i++){
 					for(int j=0;j<b;j++){
 						int x=i&j;
 						if(x<k) ct++;
 					}
 				}
 				str=""Case #""+t+"": ""+ct;
 				pr.println(str);
 				System.out.println(str);
 			}
 			pr.flush();
 		}catch(IOException ioe){
 			ioe.printStackTrace();
 		}
 	}
 }","package codejam2011.q;
 
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 public class GoroSort
 {
 	static public void solveOne(int caseNo, Scanner in, PrintStream out)
 	{
 		// get integer
 		int n = in.nextInt();
 		int count = 0;
 		for( int i=1 ; i<=n ; i++ ){
 			int v = in.nextInt();
 			if( v!=i ) count++;
 		}
 		in.nextLine();
 
 		String answer = ""Case #"" + caseNo + "": "" + count;
 		System.out.println(answer);
 		if( out!=null ){
 			out.println(answer);
 		}
 	}
 	
 	static public void solveAll(String infilename, String outfilename)
 	{
 		try {
 			FileInputStream stream = new FileInputStream(infilename);
 			Scanner in = new Scanner(stream);
 			PrintStream out = null;
 			if( outfilename!=null ){
 				out = new PrintStream(outfilename);
 				System.out.println(""--- "" + outfilename);
 			}
 
 			int nbcases = in.nextInt();
 			in.nextLine();
 			for( int n=1 ; n<=nbcases ; n++ ){
 				solveOne(n, in, out);
 			} // for n
 			
 		} catch( IOException ex ){
 			ex.printStackTrace();
 		}
 		
 	}
 	
 	public static void solve(String dir, String problem){
 		solveAll(dir + problem + "".in"", dir + problem + "".out"");
 	}
 	
 	public static void main(String[] args)
 	{
 		String pkg = GoroSort.class.getPackage().getName().replaceAll(""\\."", ""/"");
 		String data = args.length>0 ? args[0] : ""D-sample"";
 //		String data = args.length>0 ? args[0] : ""D-small-attempt0"";
 //		String data = args.length>0 ? args[0] : ""D-large"";
 		solve(""src/"" + pkg + ""/"", data);
 	}
 }
",0
408,8089,"package game2013.qualification;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class Tic_Tac_Toe_Tome {
 	public static final String[] oWinString = { ""OOOO"", ""TOOO"", ""OTOO"", ""OOTO"",
 			""OOOT"" };
 	public static final String[] xWinString = { ""XXXX"", ""TXXX"", ""XTXX"", ""XXTX"",
 			""XXXT"" };
 
 	private static String getResult(String line) {
 		for (int i = 0; i < 5; i++) {
 			if (oWinString[i].equals(line)) {
 				return ""O won"";
 			}
 			if (xWinString[i].equals(line)) {
 				return ""X won"";
 			}
 		}
 		if (line.contains(""."")) {
 			return ""NotFinish"";
 		}
 		return ""Draw"";
 	}
 
 	public static void main(String[] args) throws IOException {
 		BufferedReader f = new BufferedReader(new FileReader(
 				""A-small-practice.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(
 				""A-small-practice.out"")));
 		StringTokenizer st = new StringTokenizer(f.readLine());
 		int tests = Integer.parseInt(st.nextToken());
 		for (int t = 1; t <= tests; t++) {
 			out.printf(""Case #%d: "", t);
 			String[] lines = new String[4];
 			String[] column = new String[4];
 			String[] diag = new String[2];
 			for (int i = 0; i < 4; i++) {
 				st = new StringTokenizer(f.readLine());
 				lines[i] = st.nextToken();
 				for (int j = 0; j < 4; j++) {
 					if (column[j] == null) {
 						column[j] = String.valueOf(lines[i].charAt(j));
 					} else
 						column[j] += lines[i].charAt(j);
 					if (i == j) {
 						if (diag[0] == null) {
 							diag[0] = String.valueOf(lines[i].charAt(j));
 						} else
 							diag[0] += lines[i].charAt(j);
 					}
 					if(i + j == 3){
 						if (diag[1] == null) {
 							diag[1] = String.valueOf(lines[i].charAt(j));
 						} else
 							diag[1] += lines[i].charAt(j);						
 					}
 				}
 			}
 			String results = new String();
 			for (int i = 0; i < 4; i++) {
 				results += getResult(lines[i]);
 				results += getResult(column[i]);
 				if (i < 2) {
 					results += getResult(diag[i]);
 				}
 			}
 			if (results.contains(""O won"")) {
 				out.println(""O won"");
 			} else if (results.contains(""X won"")) {
 				out.println(""X won"");
 			} else if (results.contains(""Draw"")) {
 				out.println(""Draw"");
 			} else {
 				out.println(""Game has not completed"");
 			}
 			f.readLine();
 		}
 		out.close();
 	}
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 
 public class Problem1 {
 	
 	public static int fun1(int v, int w, int [][] array){
 		int n1 = -1;
 		int i = 0;
 		for (; i < 10; i++){
 			if(array[v - 1][i] == w){
 				i++;
 				break;
 			}
 		} 
 		
 		for (; i < 10; i++){
 			if(array[v - 1][i] != -1){
 				n1 = array[v - 1][i] ;
 				break;
 			}
 		} 
 		return n1;
 	}
 	
 	public static boolean fun2(int v, int [][] array, int [] status){
 		int n1 = -1;
 		for (int i = 0; i < 10; i++){
 			if(array[v - 1][i] != -1){
 				n1 = array[v - 1][i] ;
 				break;
 			}
 		}
 		
 		while(n1 != -1) {
 			if(status[n1 - 1] == 0){
 				if(fun2(n1, array, status)) 
 					return true;
 				else status[n1 - 1] = 1;
 			} else{
 				return true;
 			}
 			
 			n1 = fun1(v, n1, array);
 		}
 		
 		return false;
 	}
 	
 	public static void main (String [] args) throws IOException {
 		BufferedReader f = new BufferedReader(new FileReader(""A-small-practice.in""));
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""A-small-practice.out"")));
 	    StringTokenizer st = new StringTokenizer(f.readLine());
 	    
 	    int tests = Integer.parseInt(st.nextToken());
 	    
 	    for (int t = 1; t <= tests; t++){
 	    	out.printf(""Case #%d: "", t);
 	    	
 		    st = new StringTokenizer(f.readLine());
 	    	int number = Integer.parseInt(st.nextToken());
 	    	int [][] array = new int [number][10];
 	    	int [] status = new int [number];
 	    	
 	    	for (int i = 0; i < number; i++){
 	    		for (int j = 0; j < 10; j++){
 	    			array[i][j] = -1;
 	    		}
 	    	}
 	    	
 	    	for (int i = 0; i < number; i++){
 			    st = new StringTokenizer(f.readLine());
 			    int m = Integer.parseInt(st.nextToken());
 			    
 			    for (int j = 0; j < m; j++){
 			    	array[i][j] = Integer.parseInt(st.nextToken());
 			    }
 	    	}
 	    	int i = 1;
 	    	for(; i <= number; i++){
 	    		for(int j = 0; j < number; j++){
 	    			status[j] = 0;
 	    		}
 	    		
 	    		if(fun2(i, array, status)){
 	    			out.println(""Yes"");
 	    			break;
 	    		}
 	    	}
 	    	
 	    	if(i == number+1){
 	    		out.println(""No"");
 	    	}
 	    	
 	    }
 	    out.close();
 	  }
 }
",1
409,11848,"import java.io.BufferedReader;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 
 
 public class Main {
 
 	public static void main(String[] args) {
 		try{
             FileInputStream fstream = new FileInputStream(""c:\\AAACodigo\\tmp\\A-small-attempt0.in"");
             DataInputStream entrada = new DataInputStream(fstream);
             BufferedReader buffer = new BufferedReader(new InputStreamReader(entrada));
             String strLinea;
             
             strLinea = buffer.readLine();
             int casos = Integer.parseInt(strLinea);
             
             for (int cont=1;cont<=casos;cont++){
             	String row1="""",row2="""",res="""";
             	//System.err.println(cont);
             	strLinea = buffer.readLine();
                 int opcion1 = Integer.parseInt(strLinea);
                 //System.err.println(""\t""+opcion1);
                 for (int i=0;i<4;i++){
                 	strLinea = buffer.readLine();
                 	if (i+1==opcion1){
                 		row1 = strLinea;
                 	}
                 }
                 strLinea = buffer.readLine();
                 int opcion2 = Integer.parseInt(strLinea);
                 //System.err.println(""\t""+opcion2);
                 for (int i=0;i<4;i++){
                 	strLinea = buffer.readLine();
                 	if (i+1==opcion2){
                 		row2 = strLinea;
                 	}
                 }
                 
                 //System.err.println(""\t""+row1);
                 //System.err.println(""\t""+row2);
                 String[] fila1 = row1.split("" "");
                 String[] fila2 = row2.split("" "");
                 int contador = 0;
                 for (int i=0;i<fila1.length;i++){
                 	for (int k=0;k<fila2.length;k++){
                     	if (fila1[i].equals(fila2[k])){
                     		contador++;
                     		res = fila1[i];
                     	}
                     }
                 }
                 //System.err.println(""\tcontador: ""+contador);
                 
                 System.out.print(""Case #""+cont+"": "");
                 if (contador==1){
                 	System.out.println(res);
                 }
                 else{
                 	if (contador==0){
                 		System.out.println(""Volunteer cheated!"");
                     }
                     else{
                     	System.out.println(""Bad magician!"");
                     }
                 }
             }
             entrada.close();
         }catch (Exception e){ //Catch de excepciones
             System.err.println(""Ocurrio un error: "" + e.getMessage());
         }
 
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.StringTokenizer;
 
 public class Main {
 
 	public static void main(String[] args) throws Exception {
 
 		FileReader in = new FileReader(""F:\\download\\B-large.in"");
 		BufferedReader br = new BufferedReader(in);
 		FileWriter out = new FileWriter(""F:\\download\\CodeJam\\out.txt"");
 		BufferedWriter bw = new BufferedWriter(out);
 
 		int t = Integer.parseInt(br.readLine());
 		for (int c = 0; c < t; c++){
 			String line = br.readLine();
 			StringTokenizer St1 = new StringTokenizer(line, "" "");
 			double cc = Double.valueOf(St1.nextToken()).doubleValue();
 			double ff = Double.valueOf(St1.nextToken()).doubleValue();
 			double xx = Double.valueOf(St1.nextToken()).doubleValue();
 
 			double cps = 2.0;
 			double answer = 0.0;
 			
 			int count = 0;
 			
 			while(true){
 				count++;
 				if (xx/cps > cc/cps + xx/(cps+ff)){
 					answer += cc/cps;
 					cps += ff;
 				}
 				else{
 					answer += xx/cps;
 					break;
 				}
 			}
 			
 			bw.write(String.format(""Case #%d: %.7f\n"", c+1, answer));
 		}
 		
 		br.close();
 		in.close();
 		bw.close();
 		out.close();
 
 	}
 
 }",0
410,14285,"import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class Snapper implements Solver
 {
 
   @Override
   public void solve(Scanner scanner, PrintStream output) throws Exception
   {
     int n = scanner.nextInt();
     int k = scanner.nextInt();
     if(k % (1<<n) == (1 << n) - 1)
     {
       output.print(""ON"");
     }
     else
     {
       output.print(""OFF"");
     }
   }
 
   public static void main(String[] args) throws Exception
   {
     CodeJamHelper.solve(""A-large"", new Snapper());
   }
 
 }
","
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.TreeSet;
 
 /**
  * Google Code Jam 2013 - Qualification Round - Problem C
  *
  * @author Pablos
  */
 public class QRC {
 
     //
     private Scanner s;
     private FileWriter fw;
     private PrintWriter out;
     //
     int T; // number of cases
     Set<BigInteger> FaS; // Fair and Square collection.
 
     public static void main(String[] args) {
         new QRC(args[0]);
     }
 
     public QRC(String input) {
         try {
             fw = new FileWriter(input + "".out"");
             out = new PrintWriter(fw);
             //Initialize the Fair and Square number below to 1000 (just 6 numbers)
             s = new Scanner(new File(""top_FaS_14.txt""));
             FaS = new TreeSet<BigInteger>();
             while (s.hasNextLine()) {
                 FaS.add(new BigInteger(s.nextLine()));
             }
             s.close();
             
             s = new Scanner(new File(input));
             //Start the problem...
             start();
             out.close();
 
         } catch (IOException ex) {
             System.err.println(""error at creating out file"");
             System.exit(1);
         }
     }
 
     private void start() {
         //Read number of cases
         T = Integer.parseInt(s.nextLine());
         //loop around this cases
         for (int actualCase = 1; actualCase <= T; actualCase++) {
             String[] limit = s.nextLine().split("" "");
             BigInteger A = new BigInteger(limit[0]);
             BigInteger B = new BigInteger(limit[1]);
             //s.nextLine(); //skip return line
             int sum = 0;
             for (BigInteger n : FaS) {
                 if (n.compareTo(A) >= 0 && n.compareTo(B) <= 0) {
                     sum++;
                 } 
                 if (n.compareTo(B) > 0){
                     break;
                 }
             }
             out.println(""Case #"" + actualCase + "": "" + sum);
         }
     }
 }
",0
411,845,"package qRound_2014;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 
 public class CookieClickerAlpha
 {
 	private static boolean test=false;
 
 	private static PrintWriter pw;
 	private static BufferedReader br;
 
 	public static void main(String[] args) throws Exception
 	{
 		String carpeta = ""./data/qRound_2014/CookieClickerAlpha/"";
 		String archivo = ""B-small-attempt0"";//""A-small-practice"";
 
 		if(!test)pw = new PrintWriter(new File(carpeta+archivo+"".out""));
 
 		br = new BufferedReader(new FileReader(new File(carpeta+archivo+"".in"")));
 		solucionarProblema();
 
 		br.close();
 		if(!test)pw.close();
 	}
 
 	private static void solucionarProblema() throws IOException
 	{
 		DecimalFormat df=new DecimalFormat(""#.0000000"");
 		
 		int casos = Integer.parseInt(br.readLine());
 		for(int c=1; c<=casos; c++)
 		{
 			//Separar informacion pertinente
 			String[] aux=br.readLine().split("" +"");
 			double C=Double.parseDouble(aux[0]);
 			double F=Double.parseDouble(aux[1]);
 			double X=Double.parseDouble(aux[2]);
 			
 			double tiempoMinimo=X/2.0;
 			ArrayList<Double> acumuladas=new ArrayList<Double>();
 			for(int n=0; true; n++)
 			{
 				double p=2+n*F;
 				
 				if(n==0) acumuladas.add(0.0);
 				else acumuladas.add((acumuladas.get(n-1)+(C/(2+(n-1)*F))));
 				
 				double e=acumuladas.get(n)+(X/p);
 				
 				if(e<=tiempoMinimo) tiempoMinimo=e;
 				else break;
 			}
 
 			String solucion = ""Case #""+c+"": ""+df.format(tiempoMinimo).replace(',', '.');
 			imprimirSolucion(solucion);
 		}
 	}
 
 	private static void imprimirSolucion(String solucion)
 	{
 		if(test)System.out.println(solucion);
 		else pw.println(solucion);
 	}
 }","import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import com.sun.xml.internal.ws.util.StringUtils;
 
 public class CandySplitting {
 
 	static int getCorrectValue(List<Integer> pile, List<Integer> sean, int len) {
 		int sumPileList = 0;
 		len = 20;
 		for (int i : pile) {
 			sumPileList += i;
 		}
 		BitSet bitSetPile = new BitSet(len);
 		for (int i : pile) {
 			bitSetPile.xor(getBitSet(i, len));
 		}
 		int sumPileList_Sean = getValue(bitSetPile, len);
 		BitSet bitSetSean = new BitSet(len);
 		for (int i : sean) {
 			bitSetSean.xor(getBitSet(i, len));
 		}
 
 		int sumSeanList = getValue(bitSetSean, len);
 		if (sumPileList_Sean == sumSeanList)
 			return sumPileList;
 		else
 			return -1;
 	}
 
 	static BitSet getBitSet(int number, int len) {
 		BitSet finalBitSet = new BitSet(len);
 		int bi = len - 1;
 		while (number != 0) {
 			if (number % 2 == 1)
 				finalBitSet.set(bi);
 			bi--;
 			number = number / 2;
 		}
 		return finalBitSet;
 	}
 
 	static int getValue(BitSet b, int len) {
 		int r = 0;
 		int inindexd = len - 1;
 		int multiplyFactor = 1;
 		for (int i = inindexd; i >= 0; i--) {
 			if (b.get(i))
 				r += multiplyFactor;
 			multiplyFactor = multiplyFactor * 2;
 		}
 		return r;
 	}
 
 	public static void main(String[] args) throws NumberFormatException,
 			IOException {
 		BufferedReader reader = null;
 		try {
 			reader = new BufferedReader(new FileReader(new File(
 					""C:/Users/girish/Desktop/input.txt"")));
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			System.out.println(""File not found exception !!!!!!!"");
 			e.printStackTrace();
 		}
 		int testCount = Integer.parseInt(reader.readLine());
 
 		for (int testCaseNumber = 1; testCaseNumber <= testCount; testCaseNumber++) {
 			Map<String,String> combineList = new HashMap<String,String>();
 			Map<String,String> oppList = new HashMap<String,String>();
 			String[] input = reader.readLine().split("" "");
 			int ct = Integer.parseInt(input[0]);
 			for(int i=1;i<=ct;i++){
 				String com = input[i];
 				String key1 = """";
 				key1 = key1 + com.charAt(0)+com.charAt(1);
 				String v = """";
 				v = v+ com.charAt(2);
 				String key2 = """";
 				key2 = key2 + com.charAt(1)+com.charAt(0);
 				//String keyR = 
 				combineList.put(key1, v);
 				combineList.put(key2, v);
 				
 			}
 			int ot = Integer.parseInt(input[ct+1]);
 			for(int i=ct+2;i<=ct+1+ot;i++){
 				String com = input[i];
 				String key1 = """";
 				key1 = key1 + com.charAt(0)+com.charAt(1);
 				String v = """";
 				//v = v+ com.charAt(2);
 				String key2 = """";
 				key2 = key2 + com.charAt(1)+com.charAt(0);
 				//String keyR = 
 				oppList.put(key1, v);
 				oppList.put(key2, v);
 				
 			}
 			
 			String outS = input[input.length-1];
 			String inTrace = """";
 			inTrace += outS.charAt(0);
 			List<String> outPut = new ArrayList<String>();
 			for(int k = 0; k< outS.length();k++){
 			if(outPut.size() ==0){
 				String x = """";
 				x += outS.charAt(k);
 				outPut.add(x);
 				continue;
 				
 			}
 			String tmp = """";
 			tmp+=outS.charAt(k);
 			outPut.add(tmp);
 			int last = outPut.size();
 			String key = outPut.get(last-1)+outPut.get(last-2);
 			if(combineList.containsKey(key)){
 			   outPut.remove(last-1);
 			   outPut.remove(last-2);
 			   outPut.add(combineList.get(key));
 			}
 			else{
 				for(int z = outPut.size()-2;z >=0;z--){
 					String ky = """";
 					ky += outPut.get(z);
 					ky+= outPut.get(outPut.size()-1);
 					if(oppList.containsKey(ky)){
 						outPut.clear();
 					}
 				}
 			}
 		
 			}
 			System.out.print(""Case #""+testCaseNumber+"": ["");
 			
 			for(int s = 0;s < outPut.size();s++){
 			    if(s==0){
 			    	System.out.print(outPut.get(s));
 			        continue;
 			    }
 			    
 				System.out.print("", ""+outPut.get(s));
 			}
 			//System.out.println(outPut.size());
 			System.out.println(""]"");
 		}
 
 	}
 }
",0
412,11738,"import java.io.*;
 import java.util.*;
 
 public class Freecell {
 
     public static void main(String[]argsr)throws IOException
     {
         System.setOut(new PrintStream(new File(""Freecell.out"")));
         new DoFreecell();
     }
 
 }
 
 class DoFreecell
 {
     public DoFreecell() throws IOException
     {
         Scanner sc = new Scanner(new File(""Freecell.in""));
         int runs = Integer.parseInt(sc.nextLine().trim());
         int count = 0;
         while(count++<runs)
         {
             boolean broken = true;
             System.out.print(""Case #""+count+"": "");
             int n = sc.nextInt();
             int PD = sc.nextInt();
             double pd = PD/100.;
             int pg = sc.nextInt();
             int wins = -1;
             //System.out.println(n+"" ""+PD+"" ""+pg);
             if(PD == 0 && pg < 100)broken = false;
             else if(PD == 0 && pg == 100)broken = true;
             else if(pg == 0 && PD > 0)broken = true;
             else if(pg == 0 && PD == 0)broken = false;
             else if(pg == 100 && PD != 100)broken = true;
             else if(PD == 100 && pg == 100)broken = false;
             else
             for(int i=1;i<=n;i++)
             {
                 if(Math.abs((int)(pd*i) - pd*i) < .001)
                 {
                     //System.out.println(pd*i);
                     wins = (int)(pd*i);
                     //System.out.println(wins+"" ""+i);
                     if(pg - wins >= 0 && pg - wins < 100 - i)
                     {
                         broken = false;
                     }
                     if(pg - wins < 0)
                         broken = false;
                 }
             }
             if(broken)System.out.println(""Broken"");
             else System.out.println(""Possible"");
         }
     }
 }
","import java.io.*;
 import java.util.*;
 
 public class Googlerese {
 
     public static void main(String[]argsr)throws IOException
     {
         System.setOut(new PrintStream(new File(""Googlerese.out"")));
         new DoGooglerese();
     }
 
 }
 
 class DoGooglerese
 {
     public DoGooglerese() throws IOException
     {
         Scanner sc = new Scanner(new File(""Googlerese.in""));
         int runs = Integer.parseInt(sc.nextLine().trim());
         int count = 0;
         HashMap<Character,Character>map = new HashMap<Character,Character>();
         map.put('y','a');
         map.put('n','b');
         map.put('f','c');
         map.put('i','d');
         map.put('c','e');
         map.put('w','f');
         map.put('l','g');
         map.put('b','h');
         map.put('k','i');
         map.put('u','j');
         map.put('o','k');
         map.put('m','l');
         map.put('x','m');
         map.put('s','n');
         map.put('e','o');
         map.put('v','p');
         map.put('z','q');
         map.put('p','r');
         map.put('d','s');
         map.put('r','t');
         map.put('j','u');
         map.put('g','v');
         map.put('t','w');
         map.put('h','x');
         map.put('a','y');
         map.put('q','z');
         while(count++<runs)
         {
             System.out.print(""Case #""+count+"": "");
             StringBuffer line = new StringBuffer(sc.nextLine());
             for(int i=0;i<line.length();i++)
                 if(map.containsKey(line.charAt(i)))
                     line.setCharAt(i, map.get(line.charAt(i)));
             System.out.println(line);
         }
     }
 }
",1
413,1032,"package gcj.qr;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public abstract class JamInputReader<T> {
     private final ExecutorService service;
 
     public JamInputReader(int threads) {
         service = Executors.newFixedThreadPool(threads);
     }
 
     public JamInputReader() {
         this(10);
     }
     
     public List<String> processFile(String fileName) {
         try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
             String buffer = br.readLine();
             int testCases = Integer.parseInt(buffer);
             List<String> result = new ArrayList<>(testCases);
             for (int i = 0 ; i < testCases ; i++) {
                 result.add(null);
                 service.submit(processTestCase(br, i, result));
             }
             service.shutdown();
             while (!service.isTerminated()) {
                 try {
                     Thread.sleep(100);
                 } catch(InterruptedException e) {
                     e.printStackTrace();
                 }
             }
             return result;
         } catch (IOException e) {
             e.printStackTrace();
         }
         return null;
     }
     
     protected abstract Worker<T> processTestCase(BufferedReader br, int number, List<String> result) throws IOException;
 }
","import java.io.*;
 import java.util.*;
 
 public class B {
 	public static void main(String[] args) throws IOException {
 		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(""src/B-small.in""))));
 
 		String output = """";
 		int t = sc.nextInt();
 		sc.nextLine();
 		for (int i = 1; i <= t; i++) {
 			int n = sc.nextInt();
 			ArrayList<Integer> a = new ArrayList<Integer>();
 			ArrayList<Integer> as = new ArrayList<Integer>();
 			for (int j = 0; j < n; j++) {
 				a.add(sc.nextInt());
 				as.add(a.get(j));
 			}
 			Collections.sort(as);
 			int swaps = 0;
 			while (as.size() > 0) {
 				int la = as.remove(0);
 				int lai = a.indexOf(la);
 				int swapsAdd = lai;
 				if (a.size()-swapsAdd-1 < swapsAdd)
 					swapsAdd = a.size()-swapsAdd-1;
 				swaps += swapsAdd;
 				a.remove(lai);
 			}
 			output += ""Case #"" + i + "": "" + swaps + ""\n"";
 		}
 		
 		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""src/B-small.out""), ""utf-8""));
 		bw.write(output);
 		bw.close();
 	}
 }",0
414,128,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.math.BigInteger;
 import java.util.Scanner;
 
 
 public class B {
 
 	/**
 	 * @param args
 	 * @throws FileNotFoundException 
 	 */
 	public static void main(String[] args) throws FileNotFoundException {
 		 Scanner in;
 		 PrintStream out;
 			//in = new Scanner(System.in);
 			in = new Scanner(new File(""C:/personal/balaji/C-small-attempt0.in""));
 			out = new PrintStream(new File(""C:/personal/balaji/out.txt""));
 		int total = in.nextInt();
 		int square, count =0, start, end;
 		BigInteger sq ;
 		int num1, num2;
 		String temp;
 		for(int j=0;j<total;j++)
 		{
 			
 			num1 = in.nextInt();
 			num2 = in.nextInt();
 			start = (int) Math.sqrt(num1);
 			end = (int) Math.sqrt(num2);
 			count=0;
 			for(int i=start;i<=end;i++)
 			{
 				square = i*i;
 				//sq = new BigInteger(i*i+"""");
 				if(square < num1 )
 					continue;
 				if(square > num2 )
 					break;
 				if(isPallindrom(i+"""") && isPallindrom((square)+""""))
 				{
 					//System.out.println(i + "",  ""+square);;
 					count++;
 				}
 			}
 			
 			System.out.println(""Case #"" + (j+1) + "": ""+count);
 			out.println(""Case #"" + (j+1) + "": ""+count);
 		}
 		
 System.out.println(""end"");
 	}
 
 	public static boolean isPallindrom(String num)
 	{
 		String reverse = new StringBuffer(num).reverse().toString();
 		if(reverse.equalsIgnoreCase(num))
 			return true;
 		return false;
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class ProblemA
 {
     public static void main(String args[]) throws IOException {
         MyReader in = new MyReader(new File(""A-small-attempt0.in""));
         FileWriter out = new FileWriter(new File(""A-small-attempt0.out""));
         //System.out.println();
         int t = in.nextInt();
         if(t < 1 || t > 100)
             return;
         for(int c = 1; c <= t; c++) {
             int a[][] = new int[4][4];
             int b[][] = new int[4][4];
             int r1, r2;
             r1 = in.nextInt();
             for(int i = 0; i < 4; i++) {
                 for(int j = 0; j < 4; j++) {
                     a[i][j] = in.nextInt();
                 }
             }
             r2 = in.nextInt();
             for(int i = 0; i < 4; i++) {
                 for(int j = 0; j < 4; j++) {
                     b[i][j] = in.nextInt();
                 }
             }
             int count = 0;
             int y = 0;
             for(int i = 0; i < 4; i++) {
                 for(int j = 0; j < 4; j++) {
                     if(a[r1 - 1][i] == b[r2 - 1][j]) {
                         if(count == 0) {
                             count++;
                             y = a[r1 - 1][i];
                         }
                         else
                             count++;
                     }
                 }
             }
             if(count == 0) {
                 //System.out.println(""Case #"" + c + "": Volunteer cheated!"");
                 out.write(""Case #"" + c + "": Volunteer cheated!\n"");
             }
             else if(count == 1) {
                 //System.out.println(""Case #"" + c + "": "" + y);
                 out.write(""Case #"" + c + "": "" + y + ""\n"");
             }
             else {
                 //System.out.println(""Case #"" + c + "": Bad magician!"");
                 out.write(""Case #"" + c + "": Bad magician!\n"");
             }
         }
         in.close();
         out.flush();
         out.close();
     }
     
     static class MyReader {
         BufferedReader br;
         StringTokenizer st;
         
         public MyReader(File file) {
             try {
                 br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
             } catch(FileNotFoundException e) {
                 e.printStackTrace();
             }
         }
     
         String next() {
             while (st == null || !st.hasMoreElements()) {
                 try {
                     st = new StringTokenizer(br.readLine());
                 } catch(IOException e) {
                     e.printStackTrace();
                 }
             }
             return st.nextToken();
         }
     
         int nextInt() {
             return Integer.parseInt(next());
         }
         
         void close() {
             try {
                 br.close();
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
     }
 }",0
415,9027,"import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.InputMismatchException;
 import java.io.BufferedReader;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.util.StringTokenizer;
 import java.io.InputStream;
 
 /**
  * Built using CHelper plug-in
  * Actual solution is at the top
  * @author RiaD
  */
 public class Main {
 	public static void main(String[] args) {
 		InputStream inputStream = System.in;
 		OutputStream outputStream = System.out;
 		Reader in = new Reader(inputStream);
 		OutputWriter out = new OutputWriter(outputStream);
 		ManageYourEnergy solver = new ManageYourEnergy();
 		int testCount = Integer.parseInt(in.next());
 		for (int i = 1; i <= testCount; i++)
 			solver.solve(i, in, out);
 		out.close();
 	}
 }
 
 class ManageYourEnergy {
     public void solve(int testNumber, Reader in, OutputWriter out) {
         int e = in.nextInt();
         int r = in.nextInt();
         int n = in.nextInt();
 
         int[] v = in.nextIntArray(n);
 
         int[][] dp = new int[n + 1][e + 1];
         for(int i = 0; i < n; ++i){
             for(int prev = 0; prev <= e; ++prev) {
                 for(int used = 0; used <= prev; ++used) {
                     dp[i + 1][Math.min(e, prev - used + r)] = Math.max(dp[i + 1][Math.min(e, prev - used + r)], dp[i][prev] + used * v[i]);
                 }
             }
         }
         int mx = 0;
         for(int i = 0; i <= e; ++i){
             mx = Math.max(dp[n][i], mx);
         }
         out.println(""Case #"" + testNumber + "": "" + mx);
     }
 }
 
 class Reader {
     private BufferedReader reader;
     private StringTokenizer tokenizer;
 
     public Reader(BufferedReader reader) {
         this.reader = reader;
     }
 
     public Reader(InputStream stream) {
         this(new BufferedReader(new InputStreamReader(stream)));
     }
 
     public String nextString() {
         while (tokenizer == null || !tokenizer.hasMoreTokens()) {
             tokenizer = new StringTokenizer(readLine());
         }
         return tokenizer.nextToken();
     }
 
     public int nextInt() {
         return Integer.parseInt(nextString());
     }
 
     public String next() {
         return nextString();
     }
 
     public int[] nextIntArray(int size) {
         int[] array = new int[size];
         for (int i = 0; i < size; ++i) {
             array[i] = nextInt();
         }
         return array;
     }
 
     private String readLine() {
         try {
             return reader.readLine();
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 }
 
 class OutputWriter extends PrintWriter {
 
 	public OutputWriter(OutputStream out) {
 		super(out);
 	}
 
 	public OutputWriter(java.io.Writer writer){
 		super(writer);
 	}
 
 	}
 
","package main;
 
 import name.admitriev.spsl.io.OutputWriter;
 import name.admitriev.spsl.io.Reader;
 
 import java.util.ArrayList;
 import java.util.Collections;
 
 public class FullBinaryTree {
     private int deleted;
 
     public void solve(int testNumber, Reader in, OutputWriter out) {
         int n = in.nextInt();
         ArrayList<Integer>[] graph = new ArrayList[n];
         for(int i = 0; i < n; ++i) {
             graph[i] = new ArrayList<Integer>();
         }
         for(int i = 0; i < n - 1; ++i) {
             int x = in.nextInt() - 1;
             int y = in.nextInt() - 1;
             graph[x].add(y);
             graph[y].add(x);
         }
 
         int answer = n - 1;
 
         for(int i = 0; i < n; ++i) {
             deleted = 0;
             rec(graph, i, -1);
 
             answer = Math.min(answer, deleted);
         }
         out.println(""Case #"" + testNumber + "": "" + answer);
     }
 
     private int rec(ArrayList<Integer>[] graph, int v, int p) {
 
         ArrayList<Integer> sizes = new ArrayList<Integer>();
         for (int to : graph[v]) {
             if(to != p)
                 sizes.add(rec(graph, to, v));
         }
         if(sizes.isEmpty())
             return 1;
         if(sizes.size() == 1) {
             deleted += sizes.get(0);
             return 1;
         }
         Collections.sort(sizes, Collections.reverseOrder());
         for(int i = 2; i < sizes.size(); ++i) {
             deleted += sizes.get(i);
         }
         return 1 + sizes.get(0) + sizes.get(1);
     }
 }
",1
416,17514,"import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 public class aEasy {
 	
 	private static final long MAX = (int)Math.pow(2, 40);
 
 	public static void main(String[] args) throws IOException {
 
 		String fileIn = ""C:/Users/Valentin/workspace/GoogleCodeJamR1B/src/A-large (1).in"";
 		String fileOut = ""C:/Users/Valentin/workspace/GoogleCodeJamR1B/src/test.out"";
 		System.setIn(new FileInputStream(fileIn));
 		BufferedReader stdin = new BufferedReader(new InputStreamReader(
 				System.in));
 		System.setOut(new PrintStream(fileOut));
 
 		String line;
 		int testCase = 1;
 
 		boolean firstLine = true;
 		while ((line = stdin.readLine()) != null && line.length() != 0) {
 			String[] input = line.split("" "");
 			if (firstLine) {
 				firstLine = false;
 				continue;
 			}
 			String[] temp = input[0].split(""/"");
 			calculate(Long.valueOf(temp[0]).longValue(), Long.valueOf(temp[1]).longValue(), testCase);
 			testCase++;
 		}
 
 	}
 
 	private static void calculate(long p, long q, int testCase) {
 		if (!check(p, q)) {
 			System.out.println(""Case #"" + testCase + "": impossible"");
 			return;
 		}
 		for (int i = 1; i < 41; i++) {
 			if (p * Math.pow(2, i) >= q) {
 				System.out.println(""Case #"" + testCase + "": "" + i);
 				return;
 			}
 		}
 	}
 
 	private static boolean check(long p, long q) {
 		for (int i = 0; i < 41; i++) {
 			if (p * Math.pow(2, i) % q == 0) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 
 }
","
 package Cookie;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 
 
 public class CookieCutter{
     public CookieCutter(){    
     }
     public void CookieCutter(String filename) throws NumberFormatException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException{
    	 BufferedReader greyparse = new BufferedReader(new FileReader(filename));
    	 greyparse.readLine();
    	 PrintWriter writer = new PrintWriter(""output.txt"", ""UTF-8"");
    	 int thiscase = 1;
    	 String thisString;
    	 Double cps;
    	 Double cpf;
    	 Double fp;
    	 Double goal;
    	 Double timetaken;
    	 Double timenofarm;
    	 Double timefarm;
    	 while(greyparse.ready()){
    		 thisString = ""Case #"" + thiscase + "": "";
    		 String[] curr = greyparse.readLine().split("" "");
    		 fp = Double.valueOf(curr[0]);
    		 cpf = Double.valueOf(curr[1]);
    		 goal = Double.valueOf(curr[2]);
    		 timetaken = 0.0;
    		 cps = 2.0;
    		 
    		 timenofarm = goal/cps + timetaken;
    		 timefarm = goal/(cps + cpf) + fp/cps + timetaken;
    		 while(timefarm < timenofarm){
    			 timetaken += fp/cps;
    			 cps += cpf;
    			 timenofarm = goal/cps + timetaken;
    			 timefarm = goal/(cps + cpf) + fp/cps + timetaken;
    		 }
    		 thisString += timenofarm;
    		 thiscase++;
    		 writer.println(thisString);
    	 }
    	 writer.close();
     }
     /**
     public static void main(String[] args) throws NumberFormatException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException{
    	 CookieCutter c = new CookieCutter();
    	 c.CookieCutter(""src/CookieCutter/B-large.in"");
     }
     */
     
 }",0
417,5394,"package codejam;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.TreeSet;
 
 public class C {
 
 	/*public static boolean isPalindrome(String s) {
 		int len = s.length();
 		for (int i = 0; i < len / 2; i++)
 			if (s.charAt(i) != s.charAt(len - i - 1))
 				return false;
 		return true;
 	}
 
 	 public static ArrayList<Long> precalcStage1() {
 		ArrayList<Long> result = new ArrayList<Long>();
 
 		for (long i = 1; i <= 3000000000l; i++) {
 			if (i % 1000000 == 0)
 				System.out.println(i / 1000000l + "" out of "" + 3000l);
 			if (isPalindrome(Long.toString(i))
 					&& isPalindrome(Long.toString(i * i)))
 				result.add(i);
 		}
 
 		return result;
 	}*/
 
 	public static List<String> fourOnes(int k) {
 		ArrayList<String> result = new ArrayList<String>();
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.setLength(k);
 
 		for (int i2 = 0; i2 < k; i2++)
 			for (int i3 = 0; i3 < k; i3++)
 				for (int i4 = 0; i4 < k; i4++) {
 					for (int i = 0; i < k; i++)
 						buffer.setCharAt(i, '0');
 
 					buffer.setCharAt(0, '1');
 
 					buffer.setCharAt(i2, '1');
 					buffer.setCharAt(i3, '1');
 					buffer.setCharAt(i4, '1');
 
 					result.add(buffer.toString());
 				}
 
 		return result;
 	}
 
 	public static List<String> twoOnes(int k) {
 		ArrayList<String> result = new ArrayList<String>();
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.setLength(k);
 
 		for (int i2 = 0; i2 < k; i2++) {
 			for (int i = 0; i < k; i++)
 
 				buffer.setCharAt(i, '0');
 			buffer.setCharAt(0, '1');
 
 			buffer.setCharAt(i2, '1');
 
 			result.add(buffer.toString());
 		}
 
 		return result;
 	}
 
 	public static String reverse(String s) {
 		StringBuffer result = new StringBuffer();
 
 		for (int i = 0; i < s.length(); i++)
 			result.append(s.charAt(s.length() - i - 1));
 
 		return result.toString();
 	}
 
 	public static TreeSet<BigInteger> findAllBases() {
 		TreeSet<BigInteger> result = new TreeSet<BigInteger>();
 		
 		result.add(new BigInteger(""1""));
 		result.add(new BigInteger(""2""));
 		result.add(new BigInteger(""3""));
 
 		for (int k = 1; k < 26; k++) {
 			List<String> four = fourOnes(k);
 			for (String s : four) {
 				result.add(new BigInteger(s + ""1"" + reverse(s)));
 				result.add(new BigInteger(s + ""0"" + reverse(s)));
 				result.add(new BigInteger(s + reverse(s)));
 			}
 
 			List<String> two = twoOnes(k);
 			for (String s : two)
 				result.add(new BigInteger(s + ""2"" + reverse(s)));
 
 			StringBuffer buf = new StringBuffer();
 			buf.setLength(k);
 			for (int i = 0; i < k; i++)
 				buf.setCharAt(i, '0');
 			buf.setCharAt(0, '2');
 
 			String ss = buf.toString();
 
 			result.add(new BigInteger(ss + ""0"" + reverse(ss)));
 			result.add(new BigInteger(ss + ""1"" + reverse(ss)));
 			result.add(new BigInteger(ss + reverse(ss)));
 		}
 
 		return result;
 	}
 	
 	public static TreeSet<BigInteger> findAll() {
 		TreeSet<BigInteger> result = new TreeSet<BigInteger>();
 		
 		TreeSet<BigInteger> bases = findAllBases();
 		
 		for (BigInteger i: bases )
 			result.add(i.multiply(i));
 		
 		return result;
 	}
 
 	public static void main(String[] args) {
 		File in = new File (""E:\\Dev\\CodeJam2013\\Qual\\io\\C-large-2.in"");
 		File out = new File(""E:\\Dev\\CodeJam2013\\Qual\\io\\C-large-2.out"");
 		
 		TreeSet<BigInteger> solution = findAll();
 
 		try {
 			BufferedReader reader = new BufferedReader(new FileReader(in));
 			PrintWriter writer = new PrintWriter(out);
 
 			int n = Integer.parseInt(reader.readLine());
 
 			for (int i = 1; i <= n; i++) {
 				String[] line = reader.readLine().split("" "");
 				
 				BigInteger from = new BigInteger(line[0]);
 				BigInteger to = new BigInteger(line[1]).add(BigInteger.ONE);
 				
 				writer.println (""Case #"" + i + "": "" + solution.subSet(from, to).size());
 			}
 
 			writer.close();
 
 		} catch (Throwable e) {
 			throw new RuntimeException(e);
 		}
 
 	}
 
 }
","package codejam;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.TreeSet;
 
 public class C {
 
 	/*public static boolean isPalindrome(String s) {
 		int len = s.length();
 		for (int i = 0; i < len / 2; i++)
 			if (s.charAt(i) != s.charAt(len - i - 1))
 				return false;
 		return true;
 	}
 
 	 public static ArrayList<Long> precalcStage1() {
 		ArrayList<Long> result = new ArrayList<Long>();
 
 		for (long i = 1; i <= 3000000000l; i++) {
 			if (i % 1000000 == 0)
 				System.out.println(i / 1000000l + "" out of "" + 3000l);
 			if (isPalindrome(Long.toString(i))
 					&& isPalindrome(Long.toString(i * i)))
 				result.add(i);
 		}
 
 		return result;
 	}*/
 
 	public static List<String> fourOnes(int k) {
 		ArrayList<String> result = new ArrayList<String>();
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.setLength(k);
 
 		for (int i2 = 0; i2 < k; i2++)
 			for (int i3 = 0; i3 < k; i3++)
 				for (int i4 = 0; i4 < k; i4++) {
 					for (int i = 0; i < k; i++)
 						buffer.setCharAt(i, '0');
 
 					buffer.setCharAt(0, '1');
 
 					buffer.setCharAt(i2, '1');
 					buffer.setCharAt(i3, '1');
 					buffer.setCharAt(i4, '1');
 
 					result.add(buffer.toString());
 				}
 
 		return result;
 	}
 
 	public static List<String> twoOnes(int k) {
 		ArrayList<String> result = new ArrayList<String>();
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.setLength(k);
 
 		for (int i2 = 0; i2 < k; i2++) {
 			for (int i = 0; i < k; i++)
 
 				buffer.setCharAt(i, '0');
 			buffer.setCharAt(0, '1');
 
 			buffer.setCharAt(i2, '1');
 
 			result.add(buffer.toString());
 		}
 
 		return result;
 	}
 
 	public static String reverse(String s) {
 		StringBuffer result = new StringBuffer();
 
 		for (int i = 0; i < s.length(); i++)
 			result.append(s.charAt(s.length() - i - 1));
 
 		return result.toString();
 	}
 
 	public static TreeSet<BigInteger> findAllBases() {
 		TreeSet<BigInteger> result = new TreeSet<BigInteger>();
 		
 		result.add(new BigInteger(""1""));
 		result.add(new BigInteger(""2""));
 		result.add(new BigInteger(""3""));
 
 		for (int k = 1; k < 26; k++) {
 			List<String> four = fourOnes(k);
 			for (String s : four) {
 				result.add(new BigInteger(s + ""1"" + reverse(s)));
 				result.add(new BigInteger(s + ""0"" + reverse(s)));
 				result.add(new BigInteger(s + reverse(s)));
 			}
 
 			List<String> two = twoOnes(k);
 			for (String s : two)
 				result.add(new BigInteger(s + ""2"" + reverse(s)));
 
 			StringBuffer buf = new StringBuffer();
 			buf.setLength(k);
 			for (int i = 0; i < k; i++)
 				buf.setCharAt(i, '0');
 			buf.setCharAt(0, '2');
 
 			String ss = buf.toString();
 
 			result.add(new BigInteger(ss + ""0"" + reverse(ss)));
 			result.add(new BigInteger(ss + ""1"" + reverse(ss)));
 			result.add(new BigInteger(ss + reverse(ss)));
 		}
 
 		return result;
 	}
 	
 	public static TreeSet<BigInteger> findAll() {
 		TreeSet<BigInteger> result = new TreeSet<BigInteger>();
 		
 		TreeSet<BigInteger> bases = findAllBases();
 		
 		for (BigInteger i: bases )
 			result.add(i.multiply(i));
 		
 		return result;
 	}
 
 	public static void main(String[] args) {
 		File in = new File (""E:\\Dev\\CodeJam2013\\Qual\\io\\C-large-2.in"");
 		File out = new File(""E:\\Dev\\CodeJam2013\\Qual\\io\\C-large-2.out"");
 		
 		TreeSet<BigInteger> solution = findAll();
 
 		try {
 			BufferedReader reader = new BufferedReader(new FileReader(in));
 			PrintWriter writer = new PrintWriter(out);
 
 			int n = Integer.parseInt(reader.readLine());
 
 			for (int i = 1; i <= n; i++) {
 				String[] line = reader.readLine().split("" "");
 				
 				BigInteger from = new BigInteger(line[0]);
 				BigInteger to = new BigInteger(line[1]).add(BigInteger.ONE);
 				
 				writer.println (""Case #"" + i + "": "" + solution.subSet(from, to).size());
 			}
 
 			writer.close();
 
 		} catch (Throwable e) {
 			throw new RuntimeException(e);
 		}
 
 	}
 
 }
",1
418,1081,"package za.co.knonchalant.google.qualify.square;
 
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Scanner;
 
 /**
  * <p>Title: Runner</p>
  * 
  * <p>Description: </p>
  * 
  * @author Evan Knowles
  * @version 1.0
  */
 public class Runner
 {
   private static final String RESULT = ""Case #%d: %s"";
   private static HashMap<Integer, Boolean> checked = new HashMap<>();
 
   public static void main(String[] args) throws IOException
   {
     String dir = ""C:\\Users\\User\\Desktop"";
     String fileName = ""C-small-attempt0"";
 
     List<String> lines = readLines(dir, fileName);
     int testCases = Integer.parseInt(lines.get(0));
     lines.remove(0);
     List<String> results = new ArrayList<String>(testCases);
     for (int i = 0; i < testCases; i++)
     {
       results.add(String.format(RESULT, i + 1, doIt(lines.get(i))));
     }
     writeFile(results, dir, fileName);
   }
 
   protected static List<String> readLines(String dir, String name) throws IOException
   {
     Path path = Paths.get(dir, name + "".in"");
     return Files.readAllLines(path, StandardCharsets.UTF_8);
   }
 
   protected static void writeFile(List<String> aLines, String dir, String aFileName) throws IOException
   {
     Path path = Paths.get(dir, aFileName + "".out"");
     Files.write(path, aLines, StandardCharsets.UTF_8);
   }
 
   public static int doIt(String line)
   {
     Scanner scan = new Scanner(line);
     int start = scan.nextInt();
     int end = scan.nextInt();
     scan.close();
     int total = 0;
     for (int i = start; i <= end; i++)
     {
       if (checkPalindrome(i))
       {
         double root = Math.sqrt(i);
         int rootInt = (int) root;
         if ((root == rootInt) && checkPalindrome(rootInt))
         {
           total++;
         }
       }
     }
 
     return total;
   }
 
   public static boolean checkPalindrome(int number)
   {
     if (checked.containsKey(number))
     {
       return checked.get(number);
     }
 
     String numberString = String.valueOf(number);
     String otherString = new StringBuilder(numberString).reverse().toString();
     boolean result = numberString.equals(otherString);
     checked.put(number, result);
     return result;
   }
 }
","import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.InputMismatchException;
 import java.util.LinkedList;
 
 
 public class D {
 	static int best, N, S, ways;
 	static String[] array;
 	static int[] place;
 	static long mod = 100000007;
 	public static void main(String[] args) throws Exception{
 		MScanner sc = new MScanner();
 		PrintWriter out = new PrintWriter(new File(""D.out""));
 		int T = sc.nextInt();
 		for(int t=1;t<=T;t++){
 			N = sc.nextInt();
 			S = sc.nextInt();
 			array = sc.next(N);
 	//		System.out.println(Arrays.toString(array));
 			place = new int[N];
 			place[0]=0;
 			best = -1;
 			ways = 0; 
 			magic(0,0);
 			int ans = ways;
 		//	System.out.println(best+"" ""+ways);
 			ans*=S;
 			ans%=mod;
 			out.printf(""Case #%d: %d %d%n"", t,best,ans);
 			System.out.println(t+"" ""+ans);
 		}		
 		out.close();
 		
 	}
 	private static void magic(int pos, int j) {
 		int ans = 0;
 		if(pos==N-1){
 			HashSet<String>[] T = new HashSet[S];
 		//	System.out.println(Arrays.toString(place));
 			boolean[] nums = new boolean[S];
 			for(int a=0;a<S;a++)
 				T[a]=new HashSet<String>();
 			
 			for(int a=0;a<N;a++){
 				nums[place[a]]=true;
 
 				for(int b=0;b<=array[a].length();b++){
 					T[place[a]].add(array[a].substring(0,b));
 				}
 			}
 			for(int a=0;a<S;a++){
 				if(!nums[a])return;
 				ans+=T[a].size();
 			}
 			if(best==ans){
 				ways++;
 				ways%=mod;
 			}
 			else if(best<ans){
 				best = ans;
 				ways=1;
 			}
 			return;
 		}
 		for(int a=0;a<S;a++){
 			place[pos+1]=a;
 			magic(pos+1,a);
 		}
 		return;
 	}
 	static class TRIE{
 		TRIE[] next;
 		TRIE(){
 			next = new TRIE[26];
 		}
 		public int size() {
 			int ans = 0;
 			for(int a=0;a<26;a++)
 				if(next[a]!=null){
 					ans+=next[a].size();
 					ans++;
 				}
 			return ans;
 		}
 		void add(String s, int index){
 			if(index==s.length())return;
 			int pos = s.charAt(index)-'A';
 			if(next[pos]==null)
 				next[pos]=new TRIE();
 			next[pos].add(s, index+1);
 		}
 	}
 	static void permuteS(int[] array) {
 		permute(new int[array.length], 0, new boolean[array.length], array);
 	}
 	static void permute(int perm[], int pos, boolean[] used, int[] array) {
 		if (pos == perm.length) {
 			int done = 0;
 			boolean up = true;
 			for(int a=1;a<perm.length;a++){
 				if(perm[a-1]>perm[a])up=false;
 				if(!up&&perm[a-1]<perm[a])return;
 			}
 			LinkedList<Integer> LL = new LinkedList<Integer>();
 			int N = array.length;
 			for(int a=0;a<N;a++)LL.add(perm[a]);
 			for(int b=0;b<array.length;b++){
 					int post =0;
 					for(Integer x : LL){
 						if(x==array[b]){
 							done+=Math.abs(post);
 							break;
 						}
 						post++;
 					}
 					LL.remove((Integer)array[b]);
 			}
 
 			best = Math.min(done,best);
 			return;
 		}
 		for (int pick = 0; pick < perm.length; pick++) {
 			if (!used[pick]) {
 				perm[pos] = array[pick];
 				used[pick] = true;
 				permute(perm, pos + 1, used, array);
 				used[pick] = false;
 			}
 		}
 	}
 
 
 
 
 
 	static class MScanner{
 		private InputStream stream;
 		private byte[] buf = new byte[1024];
 		private int curChar;
 		private int numChars;
 		
 		public MScanner() throws FileNotFoundException{
 		//	stream = System.in;
 			stream = new FileInputStream(new File(""D.in""));
 
 		}
 		int read(){
 			if(numChars==-1)
 				throw new InputMismatchException();
 			if(curChar>=numChars){
 				curChar = 0;
 				try{
 					numChars = stream.read(buf);
 				} catch (IOException e){
 					throw new InputMismatchException();
 				}
 				if(numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 		
 		boolean isSpaceChar(int c){
 			return c==' '||c=='\n'||c=='\r'||c=='\t'||c==-1;
 		}
 		boolean isEndline(int c){
 			return c=='\n'||c=='\r'||c==-1;
 		}
 		int nextInt(){
 			return Integer.parseInt(next());
 		}
 		int[] nextInt(int N){
 			int[] ret = new int[N];
 			for(int a=0;a<N;a++)
 				ret[a] = nextInt();
 			return ret;
 		}
 		int[][] nextInt(int N, int M){
 			int[][] ret = new int[N][M];
 			for(int a=0;a<N;a++)
 				ret[a] = nextInt(M);
 			return ret;
 		}
 		long nextLong(){
 			return Long.parseLong(next());
 		}
 		long[] nextLong(int N){
 			long[] ret = new long[N];
 			for(int a=0;a<N;a++)
 				ret[a] = nextLong();
 			return ret;
 		}
 		double nextDouble(){
 			return Double.parseDouble(next());
 		}
 		double[] nextDouble(int N){
 			double[] ret = new double[N];
 			for(int a=0;a<N;a++)
 				ret[a] = nextDouble();
 			return ret;
 		}
 		String next(){
 			int c = read();
 			while(isSpaceChar(c))
 				c=read();
 			StringBuilder res = new StringBuilder();
 			do{
 				res.appendCodePoint(c);
 				c=read();
 			} while(!isSpaceChar(c));
 			return res.toString();
 		}
 		String[] next(int N){
 			String[] ret = new String[N];
 			for(int a=0;a<N;a++)
 				ret[a] = next();
 			return ret;
 		}
 		String nextLine(){
 			int c = read();
 			while(isEndline(c))
 				c=read();
 			StringBuilder res = new StringBuilder();
 			do{
 				res.appendCodePoint(c);
 				c = read();
 			}while(!isEndline(c));
 			return res.toString();
 		}
 		String[] nextLine(int N){
 			String[] ret = new String[N];
 			for(int a=0;a<N;a++)
 				ret[a] = nextLine();
 			return ret;
 		}
 		
 	}
 
 }
",0
419,18926,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StreamTokenizer;
 
 public class Asmall {
 
 	public static void main(String[] args) throws IOException {
 		VidaElf ve = new VidaElf();
 		ve.solve();
 	}
 
 }
 
 class VidaElf {
 	
 	VidaElf() throws IOException {
 		in = new FScanner(""input.txt"");
 		T = in.nextInt();
 		in.in.whitespaceChars('/', '/');
 		in.in.ordinaryChars('0', '9');
 		in.in.wordChars('0', '9');
 	}
 	
 	long gcd(long a, long b){
 		long res;
 		while ((a != 0) && (b != 0)) {
 			if (a > b){
 				a = a % b;
 			}
 			else {
 				b = b % a;
 			}
 		}
 		
 		if (a != 0){
 			res = a;
 		}
 		else {
 			res = b;
 		}
 		
 		return res;
 	}
 	
 	boolean checkDenom(long d){
 		boolean res = true;
 		while ((d > 1) && (d % 2 == 0)){
 			d = d/2;
 		}
 		res = !(d > 1);
 		return res;
 	}
 	
 	void analyzeTestcase(int tc) throws IOException  {
 		String nnom = in.next();
 		long nom = Long.parseLong(nnom);
 		String dnom = in.next();
 		long denom = Long.parseLong(dnom);
 		
 		long g = gcd(nom, denom);
 		nom = nom/g;
 		denom = denom/g;
 		
 		if (!checkDenom(denom)){
 			ans = ""impossible"";
 			return;
 		}
 		
 		int depth = 0;
 		while (nom < denom){
 			denom = denom/2;
 			depth++;
 		}
 		
 		ans = """" + depth;
 		
 	}
 	
 	void solve() throws IOException  {
 		FPrinter out = new FPrinter(""output.txt"");
 		
 		for (int tc = 1; tc <= T; tc++){
 			analyzeTestcase(tc);
 			out.printlnCase(tc, ans);
 		}
 		
 		out.fclose();
 	}
 	
 	String ans;
 	FScanner in;
 	int T;
 }
 
 class FScanner {
 	
 	FScanner(String inputfile) throws IOException {
 		in = new StreamTokenizer(new BufferedReader(new FileReader(inputfile)));
 	}
 	
 	int nextInt() throws IOException {
 		in.nextToken();
 		return (int)in.nval;
 	}
 	
 	double nextDouble() throws IOException {
 		in.nextToken();
 		return in.nval;
 	}
 	
 	String next() throws IOException {
 		in.nextToken();
 		return in.sval;
 	}
 	
 	StreamTokenizer in;
 }
 
 class FPrinter {
 	
 	FPrinter(String outputfile) throws IOException {
 		out = new PrintWriter(outputfile);
 	}
 	
 	void printCase(int tc) throws IOException {
 		out.print(""Case #"");
 		out.print(tc);
 		out.print("": "");
 	}
 	
 	void printlnCase(int tc, String ans) throws IOException {
 		printCase(tc);
 		out.println(ans);
 	}
 	
 	void fclose() {
 		out.flush();
 		out.close();
 	}
 	
 	PrintWriter out;
 }
","import java.math.BigInteger;
 import java.util.Scanner;
 
 
 public class BLarge {
 
 	public static void main(String[] args) {
 		
 		Scanner sc = new Scanner(System.in);
 				
 		int cases = sc.nextInt();
 		
 		for(int k = 0; k < cases; k++) {
 			int n = sc.nextInt();
 			
 			BigInteger times[] = new BigInteger[n];
 			
 			BigInteger min = new BigInteger(""10000000000000000000000000000000000000000000000000000"");
 			BigInteger max = BigInteger.ZERO;
 			for(int i = 0; i < n; i++) {
 				times[i] = sc.nextBigInteger();
 				if(times[i].compareTo(min) < 0)
 					min = times[i];
 				if(times[i].compareTo(max) > 0)
 					max = times[i];
 			}
 			
 			BigInteger great = max.subtract(min);
 			for(int i = 0; i < n; i++) {
 				great = great.gcd(times[i].subtract(min));
 			}
 			
 			BigInteger res = great.subtract((times[0].mod(great)));
 			res = res.mod(great);
 			
 			System.out.println(""Case #""+ (k+1)+"": ""+ res );
 			
 		}
 	}
 }
",0
420,9751,"import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class QRA {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int T = sc.nextInt();
         for (int i = 0; i < T; i++) {
             int c=sc.nextInt()-1;
             int[][] in = new int[4][4];
             ArrayList<Integer> a1 = new ArrayList<Integer>();
             ArrayList<Integer> a2 = new ArrayList<Integer>();
             for (int j = 0; j < 4; j++) {
                 for (int k = 0; k < 4; k++) {
                     int n=sc.nextInt();
                     if(j==c){
                         a1.add(n);
                     }
                 }
             }
             c=sc.nextInt()-1;
             for (int j = 0; j < 4; j++) {
                 for (int k = 0; k < 4; k++) {
                     int n=sc.nextInt();
                     if(j==c){
                         a2.add(n);
                     }
                 }
             }
             a1.retainAll(a2);
             switch (a1.size()){
                 case 0:
                     System.out.println(""Case #""+(i+1)+"": Volunteer cheated!"");
                     break;
                 case 1:
                     System.out.println(""Case #""+(i+1)+"": ""+a1.get(0));
                     break;
                 default:
                     System.out.println(""Case #""+(i+1)+"": Bad magician!"");
             }
         }
     }
 }
","import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 
 /**
  * @author : Ahmad Medhat Othman
  * @codeJame userName : AMedOs
  * @topCoder Handel : AMedOs
  * @email :contact@ahmadmedhat.com
  **/
 public class A {
 
 	static int T;
 
 	public static void main(String[] args) throws Exception  {
 		// Input file
 		String in = ""A-small-attempt0.in"";
 		FileInputStream fin = new FileInputStream(in);
 		Scanner scn = new Scanner(fin);
 		
 		// Output file
 		String out = ""A.out"";
 		FileOutputStream fout = new FileOutputStream (out);
 		PrintStream ps = new PrintStream(fout);
 		 
 		T = scn.nextInt();
 		
 		int nn = 0;
 		for (nn = 1 ; nn <= T ; nn++) {
 			List <Move> movs = new ArrayList<Move>();
 			
 			int N = scn.nextInt();
 			
 			List<Integer> BB = new ArrayList<Integer>();
 			List<Integer> OO = new ArrayList<Integer>();
 			int oSize = 0, bSize = 0, oIndex = 0, bIndex = 0;;
 			
 			for (int i = 0 ; i < N ; i ++) {
 				Move move = new Move();
 				move.c = scn.next();
 				move.step = scn.nextInt();
 				
 				movs.add(move);
 				
 				if (move.c.equals(""B"")){
 					BB.add(move.step);
 					bSize++;
 				} else {
 					OO.add(move.step);
 					oSize++;
 				}
 			}
 			
 			int o = 1, b = 1, i = 0;
 			for(Move oneMove : movs) {
 				String str = oneMove.c;
 				Integer step = oneMove.step;
 				
 				boolean first = true;
 				while (true) {
 					if (str.equals(""O"")) {
 						if (step == o) {
 							if (first) {
 								first = false;
 							} else {
 								// push the button
 								oIndex++;
 								break;
 							}
 						} else if (step > o) {
 							// move to the next step
 							o++;
 						} else {
 							// move back
 							o--;
 						}
 						// move the other robot
 						if (BB.size() > bIndex && BB.get(bIndex) > b) {
 							b++;
 						} else if (BB.size() > bIndex && BB.get(bIndex) < b) {
 							b--;
 						}
 					} else if (str.equals(""B"")) {
 						if (step == b) {
 							if (first) {
 								first = false;
 							} else {
 								// push the button
 								bIndex++;
 								break;
 							}
 						} else if (step > b) {
 							b++;
 						} else {
 							// move back
 							b--;
 						}
 						// move the other robot
 						if (OO.size() > oIndex && OO.get(oIndex) > o) {
 							o++;
 						} else if (OO.size() > oIndex && OO.get(oIndex) < o) {
 							o--;
 						}
 					}
 					i++;
 				}
 			}
 			
 			ps.println(""Case #"" + nn + "": "" + i);
 		}
 		
 		fout.close();
 		fin.close();
 		System.out.println(""Done:......."");
 		System.exit(0);
 	}
 }
 
 class Move {
 	Integer step;
 	String c;
 }",0
421,1705,"import java.util.*;
 
 class B
 {
 	public B()
 	{
 		Scanner input = new Scanner(System.in);
 		int tcase = input.nextInt();
 		for(int q = 0; q < tcase; q++)
 		{
 			Hashtable<String,Character> table = new Hashtable<String,Character>();
 			TreeSet<String> find = new TreeSet<String>();
 			System.out.print(""Case #"" + (q+1) + "": "");
 			int C = input.nextInt();
 			for(int i = 0; i < C; i++)
 			{
 				String temp = input.next();
 				table.put(temp.substring(0,2),temp.charAt(2));
 				table.put(""""+temp.charAt(1)+temp.charAt(0),temp.charAt(2));
 			}
 			int D = input.nextInt();
 			for(int i = 0; i < D; i++)
 			{
 				String temp = input.next();
 				find.add(temp);
 				find.add(""""+temp.charAt(1)+temp.charAt(0));
 			}
 			int N = input.nextInt();
 			String temp = input.next();
 			LinkedList<Character> list = new LinkedList<Character>();
 			list.add(temp.charAt(0));
 			for(int i = 1; i < N; i++)
 			{
 				list.add(temp.charAt(i));
 				if(list.size() >= 2 && table.get(""""+list.get(list.size()-2)+list.get(list.size()-1)) != null)
 				{
 					String combine = """"+list.get(list.size()-2)+list.get(list.size()-1);
 					list.removeLast();
 					list.removeLast();
 					list.add(table.get(combine));
 				}
 				else
 				{
 					ArrayList<Character> ar = new ArrayList<Character>(list);
 					for(int j = 0; j < ar.size(); j++)
 					{
 						for(int k = 0; k < ar.size(); k++)
 						{
 							if(find.contains(""""+ar.get(j)+ar.get(k)))
 							{
 								list = new LinkedList<Character>();
 							}
 						}
 					}
 				}
 			}
 			System.out.println(list);
 		}
 	}
 
 	public static void main(String[] args)
 	{
 		new B();
 	}
 }","import java.util.*;
 import java.math.*;
  
 class Main
 {
     BigInteger[] num,dif;
     
     BigInteger GCD(BigInteger a,BigInteger b)
     {
         return b.compareTo(new BigInteger(""0"")) == 0 ? a : GCD(new BigInteger(b.toString()),new BigInteger((a.mod(b)).toString()));
     }
     
     void solve()
     {
         Scanner input = new Scanner(System.in);
         int tcase = input.nextInt();
         for(int t = 1; t <= tcase; t++)
         {
             System.out.print(""Case #""+t+"": "");      
             int N = input.nextInt();
 			num = new BigInteger[N];
         	dif = new BigInteger[N];
             for(int i = 0; i < N; i++)
             {
                 num[i] = new BigInteger(input.next());
             }
 			Arrays.sort(num);
             for(int i = 0; i < N-1; i++)
             {
                 dif[i] = new BigInteger(num[i+1].subtract(num[i]).toString());
             }
             BigInteger a = new BigInteger(dif[0].toString());
             for(int i = 0; i < N-1; i++)
             {
                 a = GCD(a,dif[i]);
             }
             BigInteger sisa = new BigInteger(num[0].mod(a).toString());
             System.out.println(a.subtract(sisa).mod(a));
         }
     }
  
     public static void main(String[] args)
     {
         new Main().solve();
     }
 }",1
422,13251,"
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.*;
 
 public class Repeater {
 
 		public static void main(String args[]) throws Exception {
 
 			BufferedReader br = new BufferedReader(new FileReader(""A-large.in""));
 
 			try {
 				int intCases=Integer.parseInt(br.readLine());
 	            
 				for(int intCase=1; intCase<=intCases; intCase++) {
 					int intStrings = Integer.parseInt(br.readLine());
 					String[] strStrings = new String[intStrings];
 					for(int intCount=0; intCount<intStrings; intCount++) {
 						strStrings[intCount] = br.readLine();
 					}
 					System.out.print(""Case #"" + intCase + "": "");
 					int result = process(strStrings, intStrings);
 					if(result==-1) System.out.println(""Fegla Won"");
 					else System.out.println(result);
 					
 				}
 			} catch(Exception e) {
 				throw e;
 			} finally {
 				br.close();
 			}
 		}
 		
 		private static int process(String[] s, int i) {
 			// determine how many splits
 			int splits=0, moves=0;
 			int[] idx = new int[i];
 			int[] numChars = new int[i];
 			char[] whichChar = new char[100];
 			//System.out.println();
 			//for(int curString=0; curString<i; curString++) System.out.println(s[curString]);
 
 			for(int c=0; c<s[0].length()-1; c++) {				
 				if(s[0].charAt(c)!=s[0].charAt(c+1)) whichChar[splits++]=s[0].charAt(c);
 			}
 			whichChar[splits] = s[0].charAt(s[0].length()-1);
 			
 			// find average count of each character across all strings
 			for(int curSplit=0; curSplit<=splits; curSplit++) {
 				int totChars=0, aveChars=0;
 				
 				for(int curString=0; curString<i; curString++) {
 					numChars[curString]=0;
 					//System.out.println(whichChar[curSplit]);
 					for(;idx[curString]<s[curString].length(); idx[curString]++) { 
 						if(s[curString].charAt(idx[curString])!=whichChar[curSplit]) break;
 						numChars[curString]++;
 					}
 					if(curSplit==splits && idx[curString]<s[curString].length()) return -1;
 					if(numChars[curString]==0) return -1; // impossible
 					totChars+=numChars[curString];
 				}
 				aveChars=Math.round((float)totChars/(float)i);
 				// calc number of moves for current character
 				int curMoves=0;
 				for(int curString=0; curString<i; curString++) {
 					curMoves+=Math.abs(numChars[curString]-aveChars);
 				}
 				
 				moves+=curMoves;
 				//if(curMoves>0) System.out.print(""'"" + whichChar[curSplit] + ""' "" + curMoves + "" | "");
 				}
 				//System.out.println();
 				//System.out.println(""splits "" + splits);
 				return moves;
 			
 			}
 	}
 		","import java.io.*;
 
 
 public class Magician {
 
 	public static void main(String args[]) throws Exception {
 		
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(""A-small-attempt0.in""));
 			int cases=Integer.parseInt(br.readLine());
             
 			for(int count = 0; count<cases; count++) {
 				String[] strFirstRow = getNextRow(br).split("" "");
 				String[] strSecondRow = getNextRow(br).split("" "");
 
 				// compare each elem in first row with each elem in second row
 				int intResult=compareRows(strFirstRow, strSecondRow);
 				System.out.print(""Case #"" + (count+1) + "": "");
 				if(intResult==-1) System.out.println(""Volunteer cheated!"");
 				else if(intResult==-2) System.out.println(""Bad magician!"");
 				else System.out.println(strFirstRow[intResult]);
 			}
 			br.close();
 		} catch(Exception e) {
 			System.out.println(e.toString());
 		}
 	}
 	
 	private static int compareRows(String[] strFirstRow, String[] strSecondRow) {
 		int winningfRowPos=-1;
 		for(int fRowPos=0; fRowPos<4; fRowPos++)
 			for(int sRowPos=0; sRowPos<4; sRowPos++) {
 				if(strFirstRow[fRowPos].equals(strSecondRow[sRowPos])) {
 					if(winningfRowPos==-1)
 					    winningfRowPos=fRowPos;
 					else {
 						winningfRowPos=-2; break; // More than one solution - BAD MAGICIAN
 					}
 				}
 			}
 		return winningfRowPos;
 	}
 	private static String getNextRow(BufferedReader br) throws Exception {
 		String strRow=null;
 		
 		int pickedRow=Integer.parseInt(br.readLine());
 		String strPickedRow=null;
 		for(int curRow=0; curRow<4; curRow++) {
 			strRow=br.readLine();
 			if(curRow+1==pickedRow) strPickedRow=strRow;
 		}
 		return strPickedRow;
 	}
 }
",1
423,2820,"package codejam2013.qualificationround;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author rymbuvv
  * @since Apr 13, 2013
  */
 public class QRA {
 
 	private Scanner sc;
 	private PrintWriter pw;
 	private int CASES;
 
 	public static void main(String[] args) {
 		QRA qra = new QRA(""/home/rymbuvv/Downloads/a.in"", ""/home/rymbuvv/a.out"");
 		qra.execute();
 	}
 
 	public QRA(String fileIn, String fileOut) {
 		try {
 			sc = new Scanner(new File(fileIn));
 			pw = new PrintWriter(new FileWriter(fileOut));
 			CASES = Integer.parseInt(sc.nextLine());
 		} catch (Exception e) {
 			System.out.println(""In Constructor "" + e);
 		}
 	}
 
 	public void execute() {
 		for (int ncase = 1; ncase <= CASES; ncase++) {
 			char[][] winLines = new char[10][4];
 			pw.print(""Case #"" + ncase + "": "");
 
 			for (int i = 0; i < 4; i++)
 				winLines[i] = sc.nextLine().toCharArray();
 
 			for (int i = 4; i < 8; i++) {
 				char[] tmp = new char[4];
 				for (int j = 0; j < 4; j++)
 					tmp[j] = winLines[j][i - 4];
 				winLines[i] = tmp;
 			}
 			
 			char[] tmp = new char[4];
 			for (int j = 0; j < 4; j++)
 				tmp[j] = winLines[j][j];
 			winLines[8] = tmp;
 
 			tmp = new char[4];
 			for (int j = 3, i = 0; j >= 0; j--, i++)
 				tmp[j] = winLines[j][i];
 			winLines[9] = tmp;
 			
 			int countX = 0;
 			int countO = 0;
 			int countPoint = 0;
 			boolean endGame = false;
 			for (int i = 0; i < 10; i++) {
 				countX = 0;
 				countO = 0;
 				for (int j =0; j<4; j++){
 					if (winLines[i][j] == 'X' || winLines[i][j] == 'T')
 						countX++;
 					if (winLines[i][j] == 'O' || winLines[i][j] == 'T')
 						countO++;
 					if (winLines[i][j] == '.') countPoint++;
 				}
 				if (countX == 4){
 					pw.println(""X won"");
 					endGame = true;
 					break;
 				} else if (countO == 4){
 					pw.println(""O won"");
 					endGame = true;
 					break;
 				}
 			}
 			if (!endGame && countPoint > 0)
 					pw.println(""Game has not completed"");
 			else if (!endGame && countPoint == 0) pw.println(""Draw"");
 			sc.nextLine();
 		}
 
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 }","package com.g0412.c;
 
 import java.io.*;
 import java.util.StringTokenizer;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 public class Test {
 
 	// private static final String TASK = ""sample"";
 	// private static final String TASK = ""C-small-attempt1"";
 	// private static final String TASK = ""A-small-attempt2"";
 	private static final String TASK = ""C-large"";
 
 	private int r, c, m;
 
 	public Test(InputReader reader) throws IOException {
 		
 		r = reader.nextInt();
 		c = reader.nextInt();
 		m = reader.nextInt();
 	}
 
 	private String solve() throws Exception {
 		String ans = ""\n"";
 
 		// init
 		int oldM = m;
 		int[][] mass = new int[c][r];
 		for (int i = 0; i < c; i++) {
 			for (int j = 0; j < r; j++) {
 				mass[i][j] = -1;
 			}
 		}
 		
 		// place bomb
 		int cMax = c - 1;
 		int rMax = r - 1;
 		
 		int massC = -1;
 		int massR = -1;
 		boolean rFlag = true;
 		while (0 < m) {
 			if (cMax < rMax) {
 				for (int i = c - 1; 0 <= i; i--) {
 					if (mass[i][rMax] == -1) {
 						mass[i][rMax] = 11;
 						m --;
 						if (m == 0) {
 							if (i == 1) {
 								massC = i;
 								massR = rMax;
 								rFlag = true;
 							}
 							break;
 						}
 					}
 				}
 				rMax --;
 			} else {
 				for (int i = r - 1; 0 <= i; i--) {
 					if (mass[cMax][i] == -1) {
 						mass[cMax][i] = 11;
 						m --;
 						if (m == 0) {
 							if (i == 1) {
 								massC = cMax;
 								massR = i;
 								rFlag = false;
 							}
 							break;
 						}
 					}
 				}
 				cMax --;
 			}
 		}
 		
 		if (massC != -1) {
 			// System.out.println(""hoge "" + massC + "","" + massR);
 			if (rFlag) {
 				mass[massC][massR] = -1;
 				if (3 < r && mass[cMax][1] == -1 && mass[cMax][2] == -1 && mass[cMax][3] == 11) {
 					mass[cMax][2] = 11;
 				} else {
 					mass[cMax][0] = 11;
 				}
 			} else {
 				mass[massC][massR] = -1;
 				if (3 < c && mass[1][rMax] == -1 && mass[2][rMax] == -1 && mass[3][rMax] == 11) {
 					mass[2][rMax] = 11;
 				} else {
 					mass[0][rMax] = 11;
 				}
 			}
 		}
 		int count = 0;
 		for (int i = 0; i < c; i++) {
 			for (int j = 0; j < r; j++) {
 				if (mass[i][j] == 11) {
 					count ++;
 				}
 			}
 		}
 		if (oldM != count) {
 			return ""\nImpossible"";
 		}
 		
 		reveal(mass, 0, 0);
 		/*
 		if (mass[0][0] != 0) {
 			return ""\nImpossible"";
 		}
 		*/
 		
 		// reveal
 		for (int i = 0; i < c; i++) {
 			for (int j = 0; j < r; j++) {
 				if (mass[i][j] == 0) {
 					reveal (mass, i-1, j-1);
 					reveal (mass, i-1, j);
 					reveal (mass, i-1, j+1);
 					reveal (mass, i, j-1);
 					reveal (mass, i, j+1);
 					reveal (mass, i+1, j-1);
 					reveal (mass, i+1, j);
 					reveal (mass, i+1, j+1);
 				}
 			}
 		}
 
 		// print
 		for (int j = 0; j < r; j++) {
 			for (int i = 0; i < c; i++) {
 				if (i + j == 0) {
 					ans += ""c"";
 				} else if (mass[i][j] == -1) {
 					ans += ""?"";
 					return ""\nImpossible"";
 				} else if (mass[i][j] == 11) {
 					ans += ""*""; // bomb
 				} else {
 					// ans += mass[i][j];
 					ans += ""."";
 				}
 			}
 			if (j != r-1) ans += ""\n"";
 		}
 		// System.out.println(""======="");
 		return """" + ans;
 	}
 	
 	public void reveal(int mass[][], int a, int b) {
 		if (a < 0 || c <= a || b < 0 || r <= b) {
 			return;
 		}
 		
 		int n = 0;
 		if (0 <= b-1) {
 			if (0 <= a-1 && mass[a-1][b-1] == 11) {
 				n ++;
 			}
 			if (mass[a][b-1] == 11) {
 				n ++;
 			}
 			if (a+1 < c && mass[a+1][b-1] == 11) {
 				n ++;
 			}
 		}
 		
 		if (0 <= a-1 && mass[a-1][b] == 11) {
 			n ++;
 		}
 		if (a+1 < c && mass[a+1][b] == 11) {
 			n ++;
 		}
 		
 		if (b+1 < r) {
 			if (0 <= a-1 && mass[a-1][b+1] == 11) {
 				n ++;
 			}
 			if (mass[a][b+1] == 11) {
 				n ++;
 			}
 			if (a+1 < c && mass[a+1][b+1] == 11) {
 				n ++;
 			}
 		}
 		mass[a][b] = n;
 	}
 
 	public static void main(String[] args) throws Exception {
 		String directory = new File(""src\\""
 			+ Test.class.getPackage().getName().replace(""."", ""/"")).getAbsolutePath() +
 			""\\"";
 		String inName = directory + TASK + "".in"";
 		String outName = directory + TASK + "".out"";
 
 		try (InputReader reader = new InputReader(inName);
 				OutputWriter writer = new OutputWriter(outName)) {
 			ExecutorService executorService = Executors.newFixedThreadPool(1); // TODO
 
 			int testCaseN = reader.nextInt();
 			final String[] result = new String[testCaseN];
 			for (int i = 0; i < testCaseN; i++) {
 				final Test test = new Test(reader);
 				final int ii = i;
 				executorService.submit(new Runnable() {
 					@Override
 					public void run() {
 						try {
 							result[ii] = test.solve();
 						} catch (Exception e) {
 							e.printStackTrace();
 							System.out.println(""failure :: "" + ii);
 							throw new RuntimeException(""failure :: "" + ii, e);
 						}
 					}
 				});
 			}
 			executorService.shutdown();
 			executorService.awaitTermination(10, TimeUnit.MINUTES);
 
 			for (int i = 0; i < testCaseN; i++) {
 				writer.println(""Case #"" + (i + 1) + "": "" + result[i]);
 				if (result[i] == null) {
 					System.out.println(""failure : "" + i);
 					throw new RuntimeException(""failure : "" + i);
 				}
 			}
 		} catch (FileNotFoundException e) {
 			System.out.println(""FileNotFound : "" + e.getMessage());
 		}
 	}
 	
 	/** Utility **/
 	public static class InputReader implements AutoCloseable {
 		private final BufferedReader reader;
 		private StringTokenizer tokenizer = new StringTokenizer("""");
 		public InputReader(String filename) throws FileNotFoundException {
 			this.reader = new BufferedReader(new FileReader(filename));
 		}
 		public String nextToken() throws IOException {
 			while (!tokenizer.hasMoreTokens()) {
 				tokenizer = new StringTokenizer(reader.readLine());
 			}
 			return tokenizer.nextToken();
 		}
 		public int nextInt() throws IOException {
 			return Integer.parseInt(nextToken());
 		}
 		public long nextLong() throws IOException {
 			return Long.parseLong(nextToken());
 		}
 		public double nextDouble() throws IOException {
 			return Double.parseDouble(nextToken());
 		}
 		public String nextString() throws IOException {
 			return nextToken();
 		}
 		@Override
 		public void close() throws Exception {
 			reader.close();
 		}
 	}
 	
 	public static class OutputWriter implements AutoCloseable {
 		private final PrintWriter writer;
 		public OutputWriter(String file) throws FileNotFoundException {
 			writer = new PrintWriter(file);
 		}
 		public void println(String str) {
 			System.out.println(str);
 			writer.println(str);
 		}
 		@Override
 		public void close() throws Exception {
 			writer.close();
 		}
 	}
 	
 }
",0
424,4179,"import java.io.*;
 
 public class ProblemB {
 
 
     public static void main(String[] args) throws IOException {
         ProblemB trans = new ProblemB();
         trans.doMe();
     }
 
 //    private static final String ID = ""attempt0"";
 //    private static final String SIZE = ""small"";
 //    private static final String CODE = ""A"";
 
     private static final String NAME = ""p2l"";
 
     public void doMe() throws IOException {
         File file = new File(NAME + "".in"");
         BufferedWriter out = new BufferedWriter(new FileWriter(NAME + "".out""));
         try {
             //use buffering, reading one line at a time
             //FileReader always assumes default encoding is OK!
             BufferedReader input = new BufferedReader(new FileReader(file));
             try {
                 String line = input.readLine();
                 int count = Integer.parseInt(line);
 
                 for (int i = 0; i < count; i++) {
                     String ui = input.readLine();
                     String uis[]  = ui.split("" "");
                     int N = Integer.parseInt(uis[0]);
                     int M = Integer.parseInt(uis[1]);
 
                     String[] rows = new String[N];
                     for (int j = 0; j < N; j++) {
                         rows[j] = input.readLine();
                     }
                     String str = this.proccessLines(N, M, rows);
                     out.write(""Case #"" + (i + 1) + "": "" + str);
                     if (i < count - 1)
                         out.write(System.getProperty(""line.separator""));
                     System.out.println(str);
                 }
             } finally {
                 input.close();
                 out.flush();
                 out.close();
             }
         } catch (IOException ex) {
             ex.printStackTrace();
         }
     }
 
     String proccessLines(int N, int M, String[] lines) {
         int[][] to =  new int[N][M];
         int[][] from =  new int[N][M];
         for (int i = 0; i < N; i++) {
             String hj[] = lines[i].split("" "");
             for (int j = 0; j < M; j++) {
                 to[i][j] = Integer.parseInt(hj[j]);
                 from[i][j]=100;
             }
         }
         while(true) {
             int[] xy = lowerNotMatched(from,to);
             if (xy[0]<0) return ""YES"";
             else {
                 boolean horizontal = true;
                 boolean vertical = true;
                 boolean cutted = false;
                 for (int i = 0; i < M; i++) {
                     if (to[xy[0]][i] > xy[2]) {
                         horizontal = false;
                         break;
                     }
                 }
                 for (int i = 0; i < N; i++) {
                     if (to[i][xy[1]] > xy[2]) {
                         vertical = false;
                         break;
                     }
                 }
                 if (horizontal) {
                     for (int i = 0; i < M; i++) {
                         if (from[xy[0]][i] > xy[2]) {
                             from[xy[0]][i] = xy[2];
                             cutted = true;
                         }
                     }
                 }
                 if (vertical) {
                     for (int i = 0; i < N; i++) {
                         if (from[i][xy[1]] > xy[2]) {
                             from[i][xy[1]] = xy[2];
                             cutted = true;
                         }
                     }
                 }
                 if (!cutted) return ""NO"";
             }
         }
     }
 
     int[] lowerNotMatched(int[][]from, int[][]to) {
         int max = -100;
         int x = -1;
         int y = -1;
         for (int i = 0; i < from.length; i++) {
             for (int j = 0; j < from[i].length; j++) {
                 if (from[i][j] != to[i][j]) {
                     if (to[i][j] > max) {
                         max = to[i][j];
                         x = i;
                         y = j;
                     }
                 }
             }
         }
         //System.out.println(x+"",""+y+"",""+max);
         return new int[]{x,y, max};
     }
 
 }
","import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 
 public class A {
     FastScanner in;
     PrintWriter out;
 
     Random rnd = new Random(123);
 
     long sum(long r, long cnt) {
         BigInteger rr = BigInteger.valueOf(r);
         BigInteger cc = BigInteger.valueOf(cnt);
         BigInteger pi = BigInteger.ONE;
         BigInteger two = BigInteger.valueOf(2);
         BigInteger tmp1 = BigInteger.valueOf(cnt + 1).multiply(pi);
         BigInteger tmp2 = two.multiply(rr).add(BigInteger.ONE);
         BigInteger tmp3 = two.multiply(cc).add(tmp2);
         BigInteger res = tmp1.multiply(tmp3);
         BigInteger max = BigInteger.valueOf(Long.MAX_VALUE);
         if (res.compareTo(max) >= 0)
             return Long.MAX_VALUE;
         return res.longValue();
     }
     
     void solve() throws IOException {
         long R = in.nextLong();
         long t = in.nextLong();
         long l = 0, r = (long) 1e18 + 1000;
         while (r - l > 1) {
             long m = (l + r) / 2;
             long ss = sum(R, m);
             if (ss <= t) {
                 l = m;
             } else {
                 r = m;
             }
         }
         out.println(l + 1);
     }
 
     void run() throws IOException {
         try {
             in = new FastScanner(new File(""A.in""));
             out = new PrintWriter(new File(""A.out""));
 
             int testNumber = in.nextInt();
             for (int test = 1; test <= testNumber; test++) {
                 out.print(""Case #"" + (test) + "": "");
                 solve();
                 System.out.println(test);
             }
 
             out.close();
         } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
     }
 
     void runIO() {
 
         in = new FastScanner(System.in);
         out = new PrintWriter(System.out);
 
         try {
             solve();
         } catch (IOException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
 
         out.close();
     }
 
     class FastScanner {
         BufferedReader br;
         StringTokenizer st;
 
         public FastScanner(File f) {
             try {
                 br = new BufferedReader(new FileReader(f));
             } catch (FileNotFoundException e) {
                 e.printStackTrace();
             }
         }
 
         public FastScanner(InputStream f) {
             br = new BufferedReader(new InputStreamReader(f));
         }
 
         String next() {
             while (st == null || !st.hasMoreTokens()) {
                 String s = null;
                 try {
                     s = br.readLine();
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
                 if (s == null)
                     return null;
                 st = new StringTokenizer(s);
             }
             return st.nextToken();
         }
 
         boolean hasMoreTokens() {
             while (st == null || !st.hasMoreTokens()) {
                 String s = null;
                 try {
                     s = br.readLine();
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
                 if (s == null)
                     return false;
                 st = new StringTokenizer(s);
             }
             return true;
         }
 
         int nextInt() {
             return Integer.parseInt(next());
         }
 
         long nextLong() {
             return Long.parseLong(next());
         }
     }
 
     public static void main(String[] args) throws IOException {
         new A().run();
     }
 }",0
425,14509,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class C {
    public static void main(String[] args) throws IOException {
       BufferedReader in = new BufferedReader(new FileReader(""C-small.in""));
       FileWriter fw = new FileWriter(""C-small.out"");
       int T = new Integer(in.readLine());
       for (int currentCase = 1; currentCase <= T; currentCase++) {
          String[] currentLine = in.readLine().split("" "");
          int R = Integer.parseInt(currentLine[0]);
          int C = Integer.parseInt(currentLine[1]);
          int M = Integer.parseInt(currentLine[2]);
 
          int criteria = 2;
          if (R != 1 && C != 1) {
             criteria = 4;
          }
 
          int toFill = R * C - M;
 
          if (toFill < criteria) {
             fw.write(""Case #"" + currentCase + "": \nImpossible\n"");
          } else {
             fw.write(""Case #"" + currentCase + "": \n"");
             char[][] mineMatrix = new char[R][C];
 
             int fillSize = (int) Math.sqrt(R * C - M + 1);
             int row = fillSize;
             int column = fillSize;
             if (C < fillSize) {
                column = C;
             } else if (R < fillSize) {
                row = R;
             }
 
             int filled = 0;
             for (int i = 0; i < row; i++) {
                for (int j = 0; j < column; j++) {
                   mineMatrix[i][j] = '.';
                   filled++;
                   if (toFill - filled == 0) {
                      break;
                   }
                }
                if (toFill - filled == 0) {
                   break;
                }
             }
 
             int difference = toFill - filled;
 
             if (difference > 0) {
                if (row == R) {
                   row = 0;
                } else if (column == C) {
                   column = 0;
                } else if (R > C) {
                   column = 0;
                } else {
                   row = 0;
                }
 
                for (int i = row; i < R; i++) {
                   for (int j = column; j < C; j++) {
                      mineMatrix[i][j] = '.';
                      difference--;
                      if (difference == 0) {
                         break;
                      }
                   }
                   if (difference == 0) {
                      break;
                   }
                }
             }
             if (difference != 0) {
                for (int i = R - 1; i >= 0; i--) {
                   for (int j = C - 1; j >= 0; j--) {
                      if (mineMatrix[i][j] != '.') {
                         mineMatrix[i][j] = '.';
                         difference--;
                      }
                      if (difference == 0) {
                         break;
                      }
                   }
                   if (difference == 0) {
                      break;
                   }
                }
             }
             mineMatrix[0][0] = 'c';
 
             for (int i = 0; i < R; i++) {
                for (int j = 0; j < C; j++) {
                   if (mineMatrix[i][j] != '.' && mineMatrix[i][j] != 'c') {
                      fw.write(""*"");
                   } else {
                      fw.write(mineMatrix[i][j]);
                   }
                }
                fw.write(""\n"");
             }
          }
       }
       fw.flush();
       fw.close();
    }
 
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class C {
    public static void main(String[] args) throws IOException {
       BufferedReader in = new BufferedReader(new FileReader(""C-small.in""));
       FileWriter fw = new FileWriter(""C-small.out"");
       int T = new Integer(in.readLine());
       for (int currentCase = 1; currentCase <= T; currentCase++) {
          String[] currentLine = in.readLine().split("" "");
          int R = Integer.parseInt(currentLine[0]);
          int C = Integer.parseInt(currentLine[1]);
          int M = Integer.parseInt(currentLine[2]);
 
          int criteria = 2;
          if (R != 1 && C != 1) {
             criteria = 4;
          }
 
          int toFill = R * C - M;
 
          if (toFill < criteria) {
             fw.write(""Case #"" + currentCase + "": \nImpossible\n"");
          } else {
             fw.write(""Case #"" + currentCase + "": \n"");
             char[][] mineMatrix = new char[R][C];
 
             int fillSize = (int) Math.sqrt(R * C - M + 1);
             int row = fillSize;
             int column = fillSize;
             if (C < fillSize) {
                column = C;
             } else if (R < fillSize) {
                row = R;
             }
 
             int filled = 0;
             for (int i = 0; i < row; i++) {
                for (int j = 0; j < column; j++) {
                   mineMatrix[i][j] = '.';
                   filled++;
                   if (toFill - filled == 0) {
                      break;
                   }
                }
                if (toFill - filled == 0) {
                   break;
                }
             }
 
             int difference = toFill - filled;
 
             if (difference > 0) {
                if (row == R) {
                   row = 0;
                } else if (column == C) {
                   column = 0;
                } else if (R > C) {
                   column = 0;
                } else {
                   row = 0;
                }
 
                for (int i = row; i < R; i++) {
                   for (int j = column; j < C; j++) {
                      mineMatrix[i][j] = '.';
                      difference--;
                      if (difference == 0) {
                         break;
                      }
                   }
                   if (difference == 0) {
                      break;
                   }
                }
             }
             if (difference != 0) {
                for (int i = R - 1; i >= 0; i--) {
                   for (int j = C - 1; j >= 0; j--) {
                      if (mineMatrix[i][j] != '.') {
                         mineMatrix[i][j] = '.';
                         difference--;
                      }
                      if (difference == 0) {
                         break;
                      }
                   }
                   if (difference == 0) {
                      break;
                   }
                }
             }
             mineMatrix[0][0] = 'c';
 
             for (int i = 0; i < R; i++) {
                for (int j = 0; j < C; j++) {
                   if (mineMatrix[i][j] != '.' && mineMatrix[i][j] != 'c') {
                      fw.write(""*"");
                   } else {
                      fw.write(mineMatrix[i][j]);
                   }
                }
                fw.write(""\n"");
             }
          }
       }
       fw.flush();
       fw.close();
    }
 
 }
",1
426,12838,"package com.kovacshuni.sampleproblem.domain;
 
 public class Case {
 
     private char[][] matrix;
 
     public Case(char[][] matrix) {
         this.matrix = matrix;
     }
 
     public char[][] getMatrix() {
         return matrix;
     }
 }
","package com.hunorkovacs.fairandsquare;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Reader {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(Reader.class);
     private static final String INPUT_FILE = ""C-small-attempt0.in"";
 
     public List<Case> read() throws IOException {
         BufferedReader fileReader = new BufferedReader(new FileReader(INPUT_FILE));
 
         String line = fileReader.readLine();
         LOGGER.debug(""Read from file, line: {}"", line);
         int nCases = new Integer(line);
         List<Case> cases = new ArrayList<Case>();
         for (int caseIndex = 0; caseIndex < nCases; caseIndex++) {
 
             line = fileReader.readLine();
             LOGGER.debug(""Read from file, line: {}"", line);
             int low = new Integer(line.split("" "")[0]);
             int high = new Integer(line.split("" "")[1]);
 
             cases.add(new Case(low, high));
         }
         fileReader.close();
         return cases;
     }
 }
",1
427,9413,"import java.io.*;
 import java.util.*;
 
 public class MagicTrick {
 	
 	public static void main(String[] args) throws IOException {		
 		BufferedReader br = new BufferedReader(new FileReader(new File(""/Users/atai/Play/Codejam/input.txt"")));
 		PrintWriter prn = new PrintWriter(new FileWriter(""output.txt""));
 		
 		int numTests = Integer.parseInt(br.readLine().trim());
 		for (int i = 0; i < numTests; i++) {
 			int first= Integer.parseInt(br.readLine().trim());
 			int [] row = new int[4];
 			for (int j=  0; j < 4; j++) {
 				if ((j+1) == first) {
 					String[] temp = br.readLine().trim().split("" "");
 					for (int z = 0 ;z < 4; z++) {
 						row[z] = Integer.parseInt(temp[z]);
 						System.out.print(row[z]);
 						System.out.print("" "");
 					}
 				} else {
 					br.readLine();
 				}
 			}
 			System.out.println();
 			
 			int second = Integer.parseInt(br.readLine().trim());
 			int [] row2 = new int[4];
 			for (int j=  0; j < 4; j++) {
 				if ((j+1) == second) {
 					String[] temp = br.readLine().trim().split("" "");
 					for (int z = 0 ;z < 4; z++) {
 						row2[z] = Integer.parseInt(temp[z]);
 						System.out.print(row2[z]);
 						System.out.print("" "");
 					}
 				} else {
 					br.readLine();
 				}
 			}
 			System.out.println();
 			
 			int overlap = 0;
 			int same = -1;
 			// Now find the intersection between row and row2
 			for (int j = 0; j< row.length; j++) {
 				if (contains(row2, row[j])) {
 					overlap++;
 					same = row[j];
 				}
 			}
 			
 			if (overlap > 1)
 				prn.printf(""Case #%d: Bad Magician!\n"", i+1);
 			else if (overlap == 1)
 				prn.printf(""Case #%d: %d\n"", i+1, same);
 			else prn.printf(""Case #%d: Volunteer cheated!\n"", i+1);
 		}
 		
 		prn.close();
 	}
 		
 	public static boolean contains(int [] ary, int a) {
 		for (int i = 0; i < ary.length; i++) {
 			if (ary[i] == a)
 				return true;
 		}
 		return false;
 	}
 }","import java.io.*;
 import java.util.*;
 
 public class MagicTrick {
 	
 	public static void main(String[] args) throws IOException {		
 		BufferedReader br = new BufferedReader(new FileReader(new File(""/Users/atai/Play/Codejam/input.txt"")));
 		PrintWriter prn = new PrintWriter(new FileWriter(""output.txt""));
 		
 		int numTests = Integer.parseInt(br.readLine().trim());
 		for (int i = 0; i < numTests; i++) {
 			int first= Integer.parseInt(br.readLine().trim());
 			int [] row = new int[4];
 			for (int j=  0; j < 4; j++) {
 				if ((j+1) == first) {
 					String[] temp = br.readLine().trim().split("" "");
 					for (int z = 0 ;z < 4; z++) {
 						row[z] = Integer.parseInt(temp[z]);
 						System.out.print(row[z]);
 						System.out.print("" "");
 					}
 				} else {
 					br.readLine();
 				}
 			}
 			System.out.println();
 			
 			int second = Integer.parseInt(br.readLine().trim());
 			int [] row2 = new int[4];
 			for (int j=  0; j < 4; j++) {
 				if ((j+1) == second) {
 					String[] temp = br.readLine().trim().split("" "");
 					for (int z = 0 ;z < 4; z++) {
 						row2[z] = Integer.parseInt(temp[z]);
 						System.out.print(row2[z]);
 						System.out.print("" "");
 					}
 				} else {
 					br.readLine();
 				}
 			}
 			System.out.println();
 			
 			int overlap = 0;
 			int same = -1;
 			// Now find the intersection between row and row2
 			for (int j = 0; j< row.length; j++) {
 				if (contains(row2, row[j])) {
 					overlap++;
 					same = row[j];
 				}
 			}
 			
 			if (overlap > 1)
 				prn.printf(""Case #%d: Bad Magician!\n"", i+1);
 			else if (overlap == 1)
 				prn.printf(""Case #%d: %d\n"", i+1, same);
 			else prn.printf(""Case #%d: Volunteer cheated!\n"", i+1);
 		}
 		
 		prn.close();
 	}
 		
 	public static boolean contains(int [] ary, int a) {
 		for (int i = 0; i < ary.length; i++) {
 			if (ary[i] == a)
 				return true;
 		}
 		return false;
 	}
 }",1
428,19088,"import java.io.BufferedReader;
 import java.io.PrintStream;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 
 public class TicTacToeTomek {
 	private static final String FILE_NAME = ""A-large.in"";
 	private static final Charset CS = Charset.forName(""UTF-8"");
 
 	private final Path INPUT = Paths.get(""in"", FILE_NAME);
 	private final Path OUTPUT = Paths.get(""out"",
 			FILE_NAME.replaceAll("".in"", "".out""));
 
 	public static void main(String[] args) {
 		try {
 			new TicTacToeTomek().run();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private void run() throws Exception {
 		Files.deleteIfExists(OUTPUT);
 
 		BufferedReader in = Files.newBufferedReader(INPUT, CS);
 		PrintStream out = new PrintStream(Files.newOutputStream(OUTPUT,
 				StandardOpenOption.CREATE_NEW));
 
 		final int games = Integer.valueOf(in.readLine());
 		// System.out.println(games);
 
 		final char[][] game = new char[4][4];
 
 		for (int g = 0; g < games; g++) {
 
 			for (int i = 0; i < 4; i++) {
 				for (int j = 0; j < 4; j++) {
 					game[i][j] = (char) in.read();
 				}
 				// System.out.println(game[i]);
 				in.read(); // line break
 			}
 
 			out.println(String.format(""Case #%d: %s"", g + 1, testGame(game)));
 
 			// empty line
 			in.readLine();
 			// System.out.println();
 		}
 		// System.out.println();
 
 		in.close();
 		out.close();
 	}
 
 	private Status testGame(char[][] game) {
 		Status status = Status.DRAW;
 
 		status = testArray(game); // test horizontal
 		if (status == Status.X_WON || status == Status.O_WON)
 			return status;
 
 		status = testArray(horizontalToVertical(game)); // test vertical
 		if (status == Status.X_WON || status == Status.O_WON)
 			return status;
 
 		status = testArray(horizontalToDiagonal(game)); // test diagonal
 
 		return status;
 	}
 
 	private char[][] horizontalToDiagonal(char[][] hArray) {
 		if (hArray.length != hArray[0].length)
 			throw new IllegalArgumentException(""Array not a square!"");
 
 		int length = hArray.length;
 
 		char[][] dArray = new char[2][length];
 		for (int i = 0; i < length; i++) {
 			dArray[0][i] = hArray[i][i];
 			dArray[1][i] = hArray[i][length - i - 1];
 		}
 
 		return dArray;
 	}
 
 	private char[][] horizontalToVertical(char[][] hArray) {
 		char[][] vArray = new char[hArray[0].length][hArray.length];
 
 		for (int i = 0; i < hArray.length; i++)
 			for (int j = 0; j < hArray[i].length; j++)
 				vArray[j][i] = hArray[i][j];
 
 		return vArray;
 	}
 
 	private Status testArray(char[][] array) {
 		Status status = Status.DRAW;
 
 		for (int i = 0; i < array.length; i++) {
 			status = testLine(array[i]);
 
 			if (status == Status.X_WON || status == Status.O_WON)
 				return status;
 		}
 
 		return status;
 	}
 
 	private Status testLine(char[] line) {
 		Status status = Status.DRAW;
 
 		for (int i = 0; i < line.length; i++) {
 			switch (line[i]) {
 			case '.':
 				return Status.NOT_OVER;
 			case 'X':
 				if (status == Status.DRAW)
 					status = Status.X_WON;
 				else if (status == Status.O_WON)
 					return Status.DRAW;
 				break;
 			case 'O':
 				if (status == Status.DRAW)
 					status = Status.O_WON;
 				else if (status == Status.X_WON)
 					return Status.DRAW;
 				break;
 			case 'T': // ignore
 				break;
 			default:
 				throw new IllegalArgumentException(String.format(
 						""Bad input: %s"", line));
 			}
 		}
 
 		return status;
 	}
 
 	private enum Status {
 		X_WON(""X won""), O_WON(""O won""), DRAW(""Draw""), NOT_OVER(
 				""Game has not completed"");
 
 		private final String s;
 
 		private Status(String s) {
 			this.s = s;
 		}
 
 		@Override
 		public String toString() {
 			return s;
 		}
 	}
 }
","package codejam2013.round1c;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 public class A {
 
 	private static boolean[] vowels = new boolean[26];
 	static {
 		char[] v = new char[] { 'a', 'e', 'i', 'o', 'u' };
 		for (int i = 0; i < v.length; ++i) {
 			vowels[v[i] - 'a'] = true;
 		}
 	}
 
 	public static long nValue(String word, int consonants) {
 		long sum = 0;
 		int currentCons = 0;
 		int prevStart = -1;
 		for (int i = 0, n = word.length(); i < n; ++i) {
 			if (vowels[word.charAt(i) - 'a']) {
 				currentCons = 0;
 				continue;
 			}
 
 			currentCons++;
 			if (currentCons == consonants) {
 				int start = i - currentCons + 1;
 				long before = start - (prevStart + 1);
 				long after = n - (start + consonants);
 
 				long substrings = 0;
 				substrings += after;
 				substrings += before;
 				substrings += before * after;
 				substrings++;
 
 				sum += substrings;
 				prevStart = start;
 				currentCons--;
 			}
 		}
 
 		return sum;
 	}
 
 	public static void solve(String fileName, String outputFileName)
 			throws IOException {
 		BufferedReader reader = new BufferedReader(new InputStreamReader(
 				new FileInputStream(fileName)));
 		PrintWriter writer = new PrintWriter(outputFileName);
 
 		int testCases = Integer.parseInt(reader.readLine());
 		for (int t = 0; t < testCases; ++t) {
 			String[] splits = reader.readLine().split("" "");
 			String word = splits[0];
 			int n = Integer.parseInt(splits[1]);
 			writer.format(""Case #%d: %s\n"", t + 1, nValue(word, n));
 		}
 
 		writer.close();
 		reader.close();
 	}
 
 	/**
 	 * @param args
 	 * @throws IOException
 	 */
 	public static void main(String[] args) throws IOException {
 		solve(""A-large.in"", ""a.out"");
 		// System.out.println(nValue(""tsetse"", 2));
 	}
 
 }
",0
429,10882,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayDeque;
 import java.util.Formatter;
 import java.util.Queue;
 import java.util.Scanner;
 
 
 public class A {
 
 	static boolean multipleRoutes(final boolean[][] M, int start) {
 		final int N = M.length - 1;
 		boolean[] found = new boolean[N+1];
 		Queue<Integer> q = new ArrayDeque<Integer>(N);
 		q.add(start);
 		while (!q.isEmpty()) {
 			int here = q.poll();
 			if (found[here]) return true;
 			found[here] = true;
 			for (int next=1; next<=N; next++) {
 				if (M[here][next]) {
 					q.add(next);
 				}
 			}
 		}
 		return false;
 	}
 	
 	static String solve(final boolean[][] M) {
 		final int N = M.length - 1;
 		for (int i=1; i<=N; i++) {
 			if (multipleRoutes(M,i))
 				return ""Yes"";
 		}
 		return ""No"";
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		//String filename = ""A-test.in"";
 		String filename = ""A-small-attempt0.in"";
 		//String filename = ""A-large.in"";
 		assert filename.endsWith("".in"");
 		Scanner in = new Scanner(new File(filename));
 		Formatter out = new Formatter(new File(filename.replace("".in"", "".out"")));
 
 		assert in.hasNext();
 		int T = in.nextInt();
 		in.nextLine();
 		for (int t = 0; t < T; t++) {
 			int N = in.nextInt();
 			boolean M[][] = new boolean[N+1][N+1];
 			for (int i = 0; i < N; i++) {
 				int num = in.nextInt(); 
 				for (int j = 0; j < num; j++) {
 					int next = in.nextInt(); 
 					M[i+1][next] = true;
 				}
 			}
 			
 			String ans = solve(M);
 
 			String result;
 			if (t < T - 1)
 				result = String.format(""Case #%d: %s%n"", t + 1, ans);
 			else
 				result = String.format(""Case #%d: %s"", t + 1, ans);
 			out.format(result);
 			System.out.format(result);
 		}
 
 		out.flush();
 		out.close();
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Formatter;
 import java.util.HashSet;
 import java.util.Scanner;
 
 public class RecycledNumbers {
 
 	private static String solve(int A, int B) {
 		int count = 0;
 		final HashSet<Integer> seen = new HashSet<Integer>(10);
 		for (int n = A; n < B; n++) {
 			// Find number of decimal digits.
 			int nTemp = n, digits = 0, unit = 1;
 			while (nTemp > 0) {
 				digits++;
 				nTemp /= 10;
 				unit *= 10;
 			}
 			unit /= 10;
 
 			int m = n;
 			seen.clear();
 			for (int i = 1; i < digits; i++) {
 				if (m % 10 == 0) {
 					// Don't process because there will be a leading zero.
 					m /= 10;
 				} else {
 					m = (unit * (m % 10)) + (m / 10);
 					if (m > n && m <= B && !seen.contains(m)) {
 						seen.add(m);
 						count++;
 					}
 				}
 			}
 		}
 
 		return """" + count;
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		//String filename = ""C-test.in"";
 		//String filename = ""C-small-attempt0.in"";
 		String filename = ""C-large.in"";
 		assert filename.endsWith("".in"");
 		Scanner in = new Scanner(new File(filename));
 		Formatter out = new Formatter(new File(filename.replace("".in"", "".out"")));
 
 		assert in.hasNext();
 		int T = in.nextInt();
 		in.nextLine();
 		for (int t = 0; t < T; t++) {
 			int A = in.nextInt();
 			int B = in.nextInt();
 
 			String ans = solve(A, B);
 
 			String result;
 			if (t < T - 1)
 				result = String.format(""Case #%d: %s%n"", t + 1, ans);
 			else
 				result = String.format(""Case #%d: %s"", t + 1, ans);
 			out.format(result);
 			System.out.format(result);
 		}
 
 		out.flush();
 		out.close();
 	}
 
 }
",1
430,14628,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.Scanner;
 
 public class Main {
 	public static void main(String[] args) {
 		FileReader isr;
 
 		try {
 
 			Scanner in = new Scanner(new File(
 					""C:\\Users\\dilip1\\Desktop\\B-large.in""));
 			// BufferedReader br = new BufferedReader(isr);
 
 			FileWriter fw = new FileWriter(new File(
 					""C:\\Users\\dilip1\\Desktop\\output.out""));
 			BufferedWriter bw = new BufferedWriter(fw);
 
 			int no_cases = in.nextInt();
 			// //System.out.println(""cases:""+no_cases);
 			for (int j = 1; j <= no_cases; j++) {
 
 				double c = in.nextDouble();
 				double f = in.nextDouble();
 				double x = in.nextDouble();
 				double f1 = 0.0;
 				double t = 0;
 				double t1 = (x / (2.0 + f1 * f));
 				double t2 = (c / (2.0 + f1 * f) + (x / (2.0 + (f1 + 1) * f)));
 				f1 += 1;
 				if (t1 > t2) {
 					t = c / 2.0;
 
 					t1 = (x / (2.0 + f1 * f));
 					t2 = (c / (2.0 + f1 * f) + (x / (2.0 + (f1 + 1) * f)));
 
 					f1 += 1;
 					while (t1 > t2) {
 						t = t + (c / (2.0 + (f1 - 1) * f));
 						t1 = (x / (2.0 + f1 * f));
 						t2 = (c / (2.0 + f1 * f) + (x / (2.0 + (f1 + 1.0) * f)));
 						f1 += 1;
 						// System.out.println(t+"" ""+t1+"" ""+t2);
 					}
 					t += (x / (2.0 + (f1 - 1) * f));
 				} else
 					t = t1;
 				//System.out.println(""time: "" + t);
 				DecimalFormat df = new DecimalFormat(""#.0000000"");
 				
 				fw.write(""Case #"" + j + "": "" + df.format(t));
 				if (j < no_cases)
 					fw.write(""\n"");
 			}
 			fw.close();
 
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 }
","import java.io.File;
 import java.math.BigInteger;
 import java.util.Scanner;
 
 public class Fair {
 
 	public static void main(String[] args) throws Exception {
 
 		Scanner sc = new Scanner(new File(""e.in""));
 		int count = sc.nextInt();
 		// System.out.println(count);
 
 		outer: for (int i = 0; i < count; i++) {
 			int index = 0;
 			BigInteger a = new BigInteger(sc.nextInt() + """");
 			BigInteger b = new BigInteger(sc.nextInt() + """");
 
 			BigInteger sqrt = BigInteger.ONE;
 			BigInteger sqr = BigInteger.ONE;
 
 			StringBuilder temp = null, xtemp = null;
 			for (;;) {
 				if (sqr.compareTo(a) >= 0) {
 					break;
 				} else {
 					sqrt = sqrt.add(BigInteger.ONE);
 
 					sqr = sqrt.multiply(sqrt);
 
 				}
 			}
 
 			String sqrtString = null, sqrString = null;
 
 			for (;;) {
 				if (sqr.compareTo(b) > 0) {
 					break;
 				}
 
 				sqrtString = sqrt.toString();
 
 				temp = new StringBuilder(sqrtString);
 				temp.reverse();
 				if (temp.toString().equals(sqrtString)) {
 					sqrString = sqr.toString();
 					xtemp = new StringBuilder(sqrString);
 					xtemp.reverse();
 					if (xtemp.toString().equals(sqrString)) {
 						// System.out.println(""********"" + sqr);
 						index++;
 					}
 				}
 
 				sqrt = sqrt.add(BigInteger.ONE);
 
 				sqr = sqrt.multiply(sqrt);
 
 			}
 
 			// System.out.println(index);
 			System.out.println(""Case #"" + (i + 1) + "": "" + index);
 
 		}
 
 	}
 
 }
",0
431,50,"import java.util.*;
 import java.io.*;
 public class B
 {
 	public static void main(String[] args) throws Exception
 	{
 //		Scanner in = new Scanner(System.in);
 		Scanner in = new Scanner(new File(""b-large.in""));
 		PrintWriter out = new PrintWriter(new FileWriter(new File(""blarge.out"")));
 		
 		int t = in.nextInt();
 		for(int x = 0; x < t; x++)
 		{
 			int n = in.nextInt();
 			
 			int[] sequence = new int[n];
 			for(int y = 0; y < n; y++)
 			{
 				sequence[y] = in.nextInt();
 			}
 			
 			int[] sorted = Arrays.copyOf(sequence, sequence.length);
 			Arrays.sort(sorted);
 			
 			int[] pos = new int[n];
 			for(int z = 0; z < pos.length; z++)
 			{
 				for(int a = 0; a < sequence.length; a++)
 				{
 					if(sequence[a] == sorted[z])
 					{
 						break;
 					}
 					else if(sequence[a] > sorted[z])
 					{
 						pos[z]++;
 					}
 				}
 			}
 			
 			int result = 0;
 			for(int b = 0; b < pos.length; b++)
 			{
 				result += Math.min(pos[b], (n - b - pos[b] - 1));
 			}
 			
 			out.println(""Case #"" + (x + 1) + "": "" + result);
 		}
 		
 		out.close();
 	}
 }
","import java.util.*;
 import java.io.*;
 public class B
 {
 	public static int[] hit;
 	public static int[] gold;
 	public static int[] diane;
 	public static int[] tower;
 	public static int[][] memo;
 	
 	public static void main(String[] args) throws Exception
 	{
 //		Scanner in = new Scanner(System.in);
 		Scanner in = new Scanner(new File(""b-small-attempt2.in""));
 		PrintWriter out = new PrintWriter(new FileWriter(new File(""bsmallattempt2.out"")));
 		
 		int t = in.nextInt();
 		for(int x = 0; x < t; x++)
 		{
 			int p = in.nextInt();
 			int q = in.nextInt();
 			int n = in.nextInt();
 			
 			hit = new int[n];
 			gold = new int[n];
 			diane = new int[n];
 			tower = new int[n];
 			for(int y = 0; y < n; y++)
 			{
 				hit[y] = in.nextInt();
 				gold[y] = in.nextInt();
 				diane[y] = ((hit[y] - 1) % q) / p + 1;
 				tower[y] = (hit[y] - 1) / q + 1;
 			}
 			
 			memo = new int[n][10 * n + 100];
 			for(int z = 0; z < memo.length; z++)
 			{
 				Arrays.fill(memo[z], -1);
 			}
 			
 			int result = fight(0, 1);
 			
 			out.println(""Case #"" + (x + 1) + "": "" + result);
 		}
 		
 		out.close();
 	}
 	
 	public static int fight(int index, int ahead)
 	{
 		if(index == hit.length)
 		{
 			return 0;
 		}
 		else if(memo[index][ahead] != -1)
 		{
 			return memo[index][ahead];
 		}
 		else
 		{
 			int best = fight(index + 1, ahead + tower[index]);
 			
 			if(diane[index] < tower[index] + ahead)
 			{
 				best = Math.max(best, gold[index] + fight(index + 1, ahead + tower[index] - diane[index] - 1));
 			}
 			
 			return memo[index][ahead] = best;
 		}
 	}
 }
",1
432,3281,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.StringTokenizer;
 
 public class A {
     BufferedReader in;
     StringTokenizer st;
     PrintWriter out;
 
     static class Cake {
         private final int[] ux;
         private final int[] uy;
         private final int[] lx;
         private final int[] ly;
         private final double[] pu;
         private final double[] pl;
 
         public Cake(int[] lx, int[] ly, int[] ux, int[] uy) {
             this.lx = lx;
             this.ly = ly;
             this.ux = ux;
             this.uy = uy;
 
             pl = new double[lx.length];
             pu = new double[ux.length];
             for (int i = 1; i < pl.length; ++i) {
                 pl[i] = pl[i - 1] + (ly[i - 1] + ly[i]) / 2.0 * (lx[i] - lx[i - 1]);
             }
             for (int i = 1; i < pu.length; ++i) {
                 pu[i] = pu[i - 1] + (uy[i] + uy[i - 1]) / 2.0 * (ux[i] - ux[i - 1]);
             }
         }
 
         public double area(double slice) {
             double ans = 0;
             //lower
             {
                 int l = 0, r = lx.length - 1;
                 while (r - l > 1) {
                     int m = (l + r) >>> 1;
                     if (lx[m] <= slice) {
                         l = m;
                     } else {
                         r = m;
                     }
                 }
                 double y = (ly[r] - ly[l]) * (slice - lx[l]) / (lx[r] - lx[l]) + ly[l];
                 ans -= pl[l];
                 ans -= (ly[l] + y) / 2.0 * (slice - lx[l]);
             }
             //lower
             {
                 int l = 0, r = ux.length - 1;
                 while (r - l > 1) {
                     int m = (l + r) >>> 1;
                     if (ux[m] <= slice) {
                         l = m;
                     } else {
                         r = m;
                     }
                 }
                 double y = (uy[r] - uy[l]) * (slice - ux[l]) / (ux[r] - ux[l]) + uy[l];
                 ans += pu[l];
                 ans += (uy[l] + y) / 2.0 * (slice - ux[l]);
             }
             return ans;
         }
     }
 
     public void solveOne(String prefix) throws IOException {
         int w = nextInt();
         int l = nextInt();
         int u = nextInt();
         int g = nextInt();
         int[] lx = new int[l];
         int[] ly = new int[l];
         int[] ux = new int[u];
         int[] uy = new int[u];
         for (int i = 0; i < l; ++i) {
             lx[i] = nextInt();
             ly[i] = nextInt();
         }
         for (int i = 0; i < u; ++i) {
             ux[i] = nextInt();
             uy[i] = nextInt();
         }
         Cake cake = new Cake(lx, ly, ux, uy);
         double sum = cake.area(w);
         out.println(prefix);
         for (int i = 1; i < g; ++i) {
             double rate = sum / g * i;
             double left = 0, right = w;
             for (int it = 0; it < 30; ++it) {
                 double mid = (left + right) / 2;
                 if (cake.area(mid) > rate) {
                     right = mid;
                 } else {
                     left = mid;
                 }
             }
             out.println((left + right) / 2);
         }
     }
 
     public void run() throws IOException {
         in = new BufferedReader(new FileReader(A.class.getSimpleName() + "".in""));
         out = new PrintWriter(A.class.getSimpleName() + "".out"");
 
         int nTests = nextInt();
 
         for (int i = 1; i <= nTests; ++i) {
             solveOne(String.format(""Case #%d: "", i));
         }
 
         out.close();
         in.close();
     }
 
     String next() throws IOException {
         while (st == null || !st.hasMoreTokens()) {
             String line = in.readLine();
             if (line == null) {
                 return null;
             }
             st = new StringTokenizer(line);
         }
         return st.nextToken();
     }
 
     int nextInt() throws IOException {
         return Integer.parseInt(next());
     }
 
     long nextLong() throws IOException {
         return Long.parseLong(next());
     }
 
     double nextDouble() throws IOException {
         return Double.parseDouble(next());
     }
 
     public static void main(String[] args) throws IOException {
         new A().run();
     }
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class B {
     private int maxNonSurprise(int v) {
         switch (v % 3) {
             case 0: return v / 3;
             case 1:
             case 2: return v / 3 + 1;
             default: throw new AssertionError();
         }
     }
 
     private int maxSurprise(int v) {
         if (v <= 2) {
             return v;
         }
         switch (v % 3) {
             case 0:
             case 1: return v / 3 + 1;
             case 2: return v / 3 + 2;
             default: throw new AssertionError();
         }
     }
 
     public void run(Scanner in, PrintWriter out, int nCase) {
         int n = in.nextInt();
         int s = in.nextInt();
         int p = in.nextInt();
         int alreadyP = 0;
         int potentialP = 0;
         for (int i = 0; i < n; ++i) {
             int v = in.nextInt();
             if (maxNonSurprise(v) >= p) {
                 ++alreadyP;
             } else {
                 if (maxSurprise(v) >= p) {
                     ++potentialP;
                 }
             }
         }
         int ans = alreadyP + Math.min(s, potentialP);
         out.printf(""Case #%d: %d%n"", nCase, ans);
     }
 
     public static void main(String[] args) throws FileNotFoundException {
         String filename = B.class.getSimpleName().toLowerCase();
 
         Scanner in = new Scanner(new File(filename + "".in""));
         PrintWriter out = new PrintWriter(filename + "".out"");
 
         int nCases = in.nextInt();
 
         for (int i = 1; i <= nCases; ++i) {
             new B().run(in, out, i);
         }
 
         out.close();
         in.close();
     }
 }
",1
433,8840,"import java.util.*;
 import java.io.*;
 
 class MakeSmooth
 {
 	public static void main(String[] args) throws IOException
 	{
 		BufferedReader fin = new BufferedReader(new FileReader(""B-small.in""));
 		PrintWriter fout = new PrintWriter(new FileWriter(""B-small.out""));
 		int T;
 		T = Integer.parseInt(fin.readLine());
 		for (int t = 1; t <= T; t++) {
 			String[] sp = fin.readLine().split("" "");
 			int D = Integer.parseInt(sp[0]);
 			int I = Integer.parseInt(sp[1]);
 			int M = Integer.parseInt(sp[2]);
 			int N = Integer.parseInt(sp[3]);
 			int[] A = new int[N];
 			sp = fin.readLine().split("" "");
 			for (int i = 0; i < N; ++i)
 				A[i] = Integer.parseInt(sp[i]);
 			try {
 				int ans = new MakeSmooth().solve(D, I, M, N, A);
 				fout.print(""Case #""+t+"": "");
 				System.out.print(""Case #""+t+"": "");
 				fout.println(ans);
 				System.out.println(ans);
 			} catch (Exception e) {
 				System.err.println(e);
 			}
 		}
 		fout.flush();
 		fout.close();
 	}
 	public int solve(int D,int I, int M, int N, int[] A)
 	{
 		ArrayList<Integer> a = new ArrayList<Integer>();
 		for (int i = 0; i < N; ++i)
 			a.add(A[i]);
 		int ret = 0;
 		int cnt = 1000;
 		while (--cnt>0) {
 			int k = smooth(a, M);
 			if (k == -1)
 				break;
 			int v = a.get(k);
 			int left = k-1;
 			if (left > -1) {
 				int vl = a.get(left);
 				if (v-vl > M) {
 					int nv = vl+M;
 					int cst = v-nv;
 					if (cst <= I && cst <= D) {
 						a.set(k, nv);
 						ret += cst;
 					} else if (I <= cst && I <= D) {
 						a.add(k, v-M);
 						ret += I;
 					} else if (D <= cst && D <= I) {
 						a.remove(k);
 						ret += D;
 					}
 				} else {
 					int nv = vl-M;
 					int cst = nv-v;
 					if (cst <= I && cst <= D) {
 						a.set(k, nv);
 						ret += cst;
 					} else if (I <= cst && I <= D) {
 						a.add(k, vl-M);
 						ret += I;
 					} else if (D <= cst && D <= I) {
 						a.remove(k);
 						ret += D;
 					}
 				}
 			}
 			/*
 			for (int i = 0; i < a.size(); ++i)
 				System.out.print(a.get(i)+"" "");
 			System.out.println();
 			*/
 		}
 		return ret;
 	}
 	private int smooth(ArrayList<Integer> a, int M)
 	{
 		for (int i = 1; i < a.size(); ++i) {
 			if (Math.abs(a.get(i)-a.get(i-1)) > M)
 				return i;
 		}
 		return -1;
 	}
 }
","import java.util.*;
 import java.io.*;
 
 class MakeSmooth
 {
 	public static void main(String[] args) throws IOException
 	{
 		BufferedReader fin = new BufferedReader(new FileReader(""A-small.in""));
 		PrintWriter fout = new PrintWriter(new FileWriter(""A-small.out""));
 		int T;
 		T = Integer.parseInt(fin.readLine());
 		for (int t = 1; t <= T; t++) {
 			String[] sp = fin.readLine().split("" "");
 			int N = Integer.parseInt(sp[0]);
 			int K = Integer.parseInt(sp[1]);
 			String[] board = new String[N];
 			for (int i = 0; i < N; ++i)
 				board[i] = fin.readLine();
 			try {
 				String ans = new MakeSmooth().solve(N, K, board);
 				fout.print(""Case #""+t+"": "");
 				System.out.print(""Case #""+t+"": "");
 				fout.println(ans);
 				System.out.println(ans);
 			} catch (Exception e) {
 				System.err.println(e);
 			}
 		}
 		fout.flush();
 		fout.close();
 	}
 	public String solve(int N, int K, String[] board)
 	{
 		char[][] b = new char[N][N];
 		for (int i = N-1; i > -1; --i) {
 			for (int j = 0; j < N; ++j) {
 				b[j][N-1-i] = board[i].charAt(j);
 			}
 		}
 		for (int i = 0; i < N; ++i) {
 			for (int j = N-1; j > -1; --j) {
 				if (b[j][i] != '.')
 					continue;
 				for (int k = j-1; k > -1; --k) {
 					if (b[k][i] == '.')
 						continue;
 					b[j][i] = b[k][i];
 					b[k][i] = '.';
 					break;
 				}
 			}
 		}
 		boolean red = false, blue = false;
 		for (int i = 0; i < N; ++i) {
 			for (int j = 0; j < N; ++j) {
 				if (b[i][j] == 'R') {
 					int cnt = 1;
 					for (int k = j+1; k < N; ++k) {
 						if (b[i][k] == 'R') {
 							cnt++;
 						} else {
 							break;
 						}
 					}
 					if (cnt >= K) {
 						red = true;
 						break;
 					}
 				}
 			}
 			if (red)
 				break;
 		}
 		for (int i = 0; i < N; ++i) {
 			for (int j = 0; j < N; ++j) {
 				if (b[i][j] == 'B') {
 					int cnt = 1;
 					for (int k = j+1; k < N; ++k) {
 						if (b[i][k] == 'B') {
 							cnt++;
 						} else {
 							break;
 						}
 					}
 					if (cnt >= K) {
 						blue = true;
 						break;
 					}
 				}
 			}
 			if (blue)
 				break;
 		}
 		if (!red) {
 			for (int i = 0; i < N; ++i) {
 				for (int j = 0; j < N; ++j) {
 					if (b[j][i] == 'R') {
 						int cnt = 1;
 						for (int k = j+1; k < N; ++k) {
 							if (b[k][i] == 'R') {
 								cnt++;
 							} else {
 								break;
 							}
 						}
 						if (cnt >= K) {
 							red = true;
 							break;
 						}
 					}
 				}
 				if (red)
 					break;
 			}
 		}
 		if (!blue) {
 			for (int i = 0; i < N; ++i) {
 				for (int j = 0; j < N; ++j) {
 					if (b[j][i] == 'B') {
 						int cnt = 1;
 						for (int k = j+1; k < N; ++k) {
 							if (b[k][i] == 'B') {
 								cnt++;
 							} else {
 								break;
 							}
 						}
 						if (cnt >= K) {
 							blue = true;
 							break;
 						}
 					}
 				}
 				if (blue)
 					break;
 			}
 		}
 		if (!red) {
 			for (int i = 0; i < N; ++i) {
 				int k = -1;
 				for (int j = 0; j < N; ++j) {
 					if (b[i][j] == 'R') {
 						k = j;
 						break;
 					}
 				}
 				if (k == -1)
 					continue;
 				int cnt = 1;
 				for (int x = i-1, y = k+1; x > -1 && y < N && b[x][y] == 'R'; x--, y++)
 					cnt++;
 				for (int x = i+1, y = k-1; x < N && y > -1 && b[x][y] == 'R'; x++, y--)
 					cnt++;
 				if (cnt >= K) {
 					red = true;
 					break;
 				}
 				cnt = 1;
 				for (int x = i-1, y = k-1; x > -1 && y > -1 && b[x][y] == 'R'; x--, y--)
 					cnt++;
 				for (int x = i+1, y = k+1; x < N && y < N && b[x][y] == 'R'; x++, y++)
 					cnt++;
 				if (cnt >= K) {
 					red = true;
 					break;
 				}
 				if (red)
 					break;
 			}
 		}
 		if (!blue) {
 			for (int i = 0; i < N; ++i) {
 				int k = -1;
 				for (int j = 0; j < N; ++j) {
 					if (b[i][j] == 'B') {
 						k = j;
 						break;
 					}
 				}
 				if (k == -1)
 					continue;
 				int cnt = 1;
 				for (int x = i-1, y = k+1; x > -1 && y < N && b[x][y] == 'B'; x--, y++)
 					cnt++;
 				for (int x = i+1, y = k-1; x < N && y > -1 && b[x][y] == 'B'; x++, y--)
 					cnt++;
 				if (cnt >= K) {
 					blue = true;
 					break;
 				}
 				cnt = 1;
 				for (int x = i-1, y = k-1; x > -1 && y > -1 && b[x][y] == 'B'; x--, y--)
 					cnt++;
 				for (int x = i+1, y = k+1; x < N && y < N && b[x][y] == 'B'; x++, y++)
 					cnt++;
 				if (cnt >= K) {
 					blue = true;
 					break;
 				}
 				if (blue)
 					break;
 			}
 		}
 
 		if (red && blue)
 			return ""Both"";
 		else if (blue)
 			return ""Blue"";
 		else if (red)
 			return ""Red"";
 		else
 			return ""Neither"";
 	}
 }
",1
434,1339,"package com.google.codejam;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Bullseye {
 
     public static void main(String[] args) throws FileNotFoundException {
         Scanner scanner = new Scanner(new File(args[0]));
         PrintWriter writer = new PrintWriter(new FileOutputStream(""bullseye.out""));
         try {
             int caseCnt = scanner.nextInt();
             for (int i = 0; i < caseCnt; i++) {
                 long r = scanner.nextLong();
                 long t = scanner.nextLong();
                 long circleCnt = solve(r, t);
                 writer.println(String.format(""Case #%d: %d"", i + 1, circleCnt));
             }
         } finally {
             writer.close();
         }
     }
 
     static long solve(long startRadius, long paint) {
         long radius = startRadius;
         boolean isBlack = false;
         long circleCnt = 0;
         while (true) {
             if (isBlack) {
                 long neededPaint = (radius) * (radius) - (radius - 1) * (radius - 1);
                 if (neededPaint <= paint) {
                     paint -= neededPaint;
                     ++circleCnt;
                 } else {
                     break;
                 }
             }
             isBlack = !isBlack;
             ++radius;
         }
         return circleCnt;
     }
 
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 package prototypes;
 import java.util.*;
 import java.io.*;
 
 /**
  *
  * @author Malte
  */
 public class Main {
 
     public static void main(String[] args) throws IOException{
 
         BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(System.getProperty(""user.home"") + ""\\data.in"")));
         BufferedWriter out = new BufferedWriter(new FileWriter(System.getProperty(""user.home"") + ""\\results.txt""));
 
         int caseAmount = Integer.parseInt(in.readLine());
         Case[] cases = new Case[caseAmount];
 
         for (int i = 0; i < cases.length; i++) {
 
 
             int amount = Integer.parseInt(in.readLine());
             int[] array = new int[amount];
 
             String line = in.readLine();
 
             System.out.println(i + "" "" + line + ""."");
             String values[] = proto.splitString(line);
 
             for (int j = 0; j < array.length; j++) {
 
                 array[j] = Integer.parseInt(values[j]);
             }
 
             double result = 0;
 
 
             for (int j = 0; j < array.length; j++) {
 
                 if (array[j] != j+1) {
 
                     result += 1;
                 }
             }
 
             cases[i] = new Case(i+1, array, result);
 
         }
 
         for (int i = 0; i < cases.length; i++) {
 
             System.out.println(""Case #"" + (i+1) + "": "" + cases[i].result);
             out.write(""Case #"" + (i+1) + "": "" + cases[i].result + ""\r\n"");
         }
 
         in.close();
 
         out.flush();
         out.close();
     }
 
 
 }
",0
435,19608,"import java.util.Arrays;
 import java.util.Collections;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Scanner;
 import java.io.BufferedReader;
 
 public class D{
   private static int most,count;
 
   public static void main(String[] args){
     Scanner scanner=new Scanner(System.in);
     final int cases=scanner.nextInt();
 
     for(int t=0;t<cases;t++){
       most=0;
       count=0;
       solve(scanner);
       System.out.println(""Case #""+(t+1)+"": ""+most+"" ""+count);
     }
   }
 
   private static int compute(ArrayList<String> trie){
     HashSet<String> set=new HashSet<String>();
     for(int i=0;i<trie.size();i++){
       String s=trie.get(i);
       //System.out.print("" ""+s);
       for(int j=0;j<=s.length();j++)
         set.add(s.substring(0,j));
     }
     //System.out.println("": ""+set.size());
     return set.size();
   }
 
   private static void compute(ArrayList<String>[] tries){
     int total=0;
     for(int i=0;i<tries.length;i++)
       total+=compute(tries[i]);
     if(total>most){
       most=total;
       count=1;
     }else if(total==most){
       count++;
     }
   }
 
   private static void dfs(ArrayList<String> data,ArrayList<String>[] tries,int index){
     if(index==data.size()){
       compute(tries);
       return;
     }
     for(int i=0;i<tries.length;i++){
       tries[i].add(data.get(index));
       dfs(data,tries,index+1);
       tries[i].remove(tries[i].size()-1);
     }
   }
 
   private static void solve(Scanner scanner){
     int strings=scanner.nextInt();
     int servers=scanner.nextInt();
     ArrayList<String> data=new ArrayList<String>();
     ArrayList<String>[] tries=new ArrayList[servers];
 
     for(int i=0;i<tries.length;i++)
       tries[i]=new ArrayList<String>();
     for(int i=0;i<strings;i++){
       String datum=scanner.next();
       data.add(datum);
     }
     dfs(data,tries,0);
   }
 }
","package problemScenario.y2011.round1A;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class  FreeCellStatistics {
 	public static void main(String[] args) {
 		done();
 //		System.out.println(greatestCommonDivisor(80,100));
 	}
 
 	private static void done() {
 		// TODO Auto-generated method stub
 
 		String inputFile = ""/net/10.0.1.145/Users/325761/Downloads/A-small-attempt2.in.txt"";//""src/large.in"";//""/net/10.0.1.145/Users/325761/Desktop/A-small-attempt0.in"";// 
 		String outputFile = ""/net/10.0.1.145/Users/325761/Desktop/Code Jam/FreeCellStatistics.out"";
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(inputFile));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile));
 			int NCase = Integer.valueOf(br.readLine().trim());
 //			System.out.println(NCase);
 			for (int icase = 0; icase < NCase; icase++) {
 				String[] str = br.readLine().trim().split("" "");
 				int N=0, Pd=0,Pg=0;
 				N=Integer.parseInt(str[0]);
 				Pd=Integer.parseInt(str[1]);
 				Pg=Integer.parseInt(str[2]);
 				
 				if(Pg == 100 && Pd != 100){
 					System.out.println(""Case #""+ (icase+1) +"": Broken"");
 					bw.write(""Case #""+ (icase+1) +"": Broken"");
 					bw.newLine();
 					continue;
 				}
 				
 				if(Pd == 0  ){
 					System.out.println(""Case #""+ (icase+1) +"": Possible"");
 					bw.write(""Case #""+ (icase+1) +"": Possible"");
 					bw.newLine();
 					continue;
 				} else if(Pg == 0){
 					System.out.println(""Case #""+ (icase+1) +"": Broken"");
 					bw.write(""Case #""+ (icase+1) +"": Broken"");
 					bw.newLine();
 					continue;
 				}
 				
 				
 				
 				int gcd = (int)greatestCommonDivisor(Pd, 100);
 				int gcd1 = (int)greatestCommonDivisor(Pg, 100);
 				
 				if((100/gcd)>N){
 					System.out.println(""Case #""+ (icase+1) +"": Broken"");
 					bw.write(""Case #""+ (icase+1) +"": Broken"");
 					bw.newLine();
 					continue;
 				}
 				
 				System.out.println(""Case #""+ (icase+1) +"": Possible"");
 				bw.write(""Case #""+ (icase+1) +"": Possible"");
 				bw.newLine();
 
 
 
 			}
 			br.close();
 			bw.close();
 		} catch (IOException ex) {
 			System.out.println(ex);
 		}
 
 	}
 	
 	static long greatestCommonDivisor (long m, long n){
 		long x;
 		long y;
 		while(m%n != 0){
 			x = n;
 			y = m%n;
 			m = x;
 			n = y;
 		}
 		return n;
 	}	
 }
",0
436,4500,"import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class ManageYourEnergy {
 
 	private int regain;
 	private int[] activities;
 	private int energy;
 
 	// LONG!
 	private long getMaxGain(int energy, int regain, int[] activities) {
 		this.energy = energy;
 		this.regain = regain;
 		this.activities = activities;
 		return rec(energy, 0, 0);
 	}
 
 	public int rec(int en, int actNum, int currentProfit) {
 		if (actNum == activities.length) {
 			return currentProfit;
 		}
 		int res = 0;
 		for (int i = 0; i <= en; i++) {
 			if (en - i >= 0) {
 				res = Math.max(res, rec(Math.min(en - i + regain, energy), actNum + 1, currentProfit + i * activities[actNum]));
 			}
 		}
 		return res;
 	}
 
 	public static final String INPUT_FILE_PATH = ""C://DiskD//CodeJamInput.txt"";
 	public static final String OUTPUT_FILE_PATH = ""C://DiskD//CodeJamOutput.txt"";
 
 	public static void main(String[] args) {
 		Scanner input = null;
 		PrintWriter writer = null;
 		try {
 			System.out.println(""start"");
 
 			input = new Scanner(new File(INPUT_FILE_PATH));
 			int testCount = input.nextInt();
 			String[] output = new String[testCount];
 
 			for (int i = 0; i < testCount; i++) {
 				int energy = input.nextInt();
 				int regain = input.nextInt();
 				int[] activities = new int[input.nextInt()];
 				for (int j = 0; j < activities.length; j++) {
 					activities[j] = input.nextInt();
 				}
 
 				System.out.println(i);
 				output[i] = ""Case #"" + (i + 1) + "": "" + new ManageYourEnergy().getMaxGain(energy, regain, activities);
 			}
 
 			writer = new PrintWriter(new FileWriter(OUTPUT_FILE_PATH));
 			for (String line : output) {
 				writer.println(line);
 			}
 			writer.flush();
 
 			System.out.println(""end"");
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		} finally {
 			if (input != null) input.close();
 			if (writer != null) writer.close();
 		}
 	}
 
 }
","import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class CodeJam {
 
 	public static final String INPUT_FILE_PATH = ""C://DiskD//CodeJamInput.txt"";
 	// public static final String INPUT_FILE_PATH = ""D://C-large.in"";
 	public static final String OUTPUT_FILE_PATH = ""C://DiskD//CodeJamOutput.txt"";
 
 	public static void main(String[] args) {
 		Scanner input = null;
 		PrintWriter writer = null;
 		try {
 			input = new Scanner(new File(INPUT_FILE_PATH));
 			int testCount = input.nextInt();
 			String[] output = new String[testCount];
 			
 			for (int i = 0; i < testCount; i++) {
 				String[] ar = new String[4];
 				for (int j = 0; j < ar.length; j++) {
 					ar[j] = input.next();
 				}
 				
 				output[i] = ""Case #"" + (i + 1) + "": "" + new TicTacToeTomek().getDescription(ar);
 			}
 			
 			writer = new PrintWriter(new FileWriter(OUTPUT_FILE_PATH));
 			for (String line : output) {
 				writer.println(line);
 			}
 			writer.flush();
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		} finally {
 			if (input != null) input.close();
 			if (writer != null) writer.close();
 		}
 	}
 }
",1
437,625,"package RoundB_2012;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.Scanner;
 
 public class ProbC2 {
 
 	static Scanner in;
 	static int N;
 	static int[] a;
 
 	public static String solve() {
 		N = in.nextInt();
 		a = new int[N];
 		for (int i = 0; i < N; i++)
 			a[i] = in.nextInt();
 
 		Hashtable<Integer, Integer> hash = new Hashtable<Integer, Integer>();
 
 		for (int i = 1; i < (1 << N) - 1; i++) {
 			int sum = 0;
 			for (int k = 0; k < N; k++) {
 				if (((1 << k) & i) != 0) {
 					sum += a[k];
 				}
 			}
 			Integer map = hash.get(sum);
 			if (map != null) {
 				ArrayList<Integer> s1 = new ArrayList<Integer>();
 				ArrayList<Integer> s2 = new ArrayList<Integer>();
 				for (int k = 0; k < N; k++) {
 					boolean x = (((1 << k) & i) != 0);
 					boolean y = (((1 << k) & map) != 0);
 					if (!(x && y)) {
 						if (x)
 							s1.add(a[k]);
 						if (y)
 							s2.add(a[k]);
 					}
 				}
 
 				StringBuffer s = new StringBuffer(""\n"");
 				s.append(s1.get(0));
 				for (int k = 1; k < s1.size(); k++)
 					s.append("" "" + s1.get(k));
 				s.append(""\n"" + s2.get(0));
 				for (int k = 1; k < s2.size(); k++)
 					s.append("" "" + s2.get(k));
 				return s.toString();
 
 			} else
 				hash.put(sum, i);
 
 		}
 		return ""\nImpossible"";
 	}
 
 	public static void main(String[] args) throws IOException {
 		in = new Scanner(new File(""in.in""));
 
 		FileWriter out = new FileWriter(""out.out"");
 
 		int t = in.nextInt();
 
 		for (int i = 1; i <= t; i++) {
 			out.write(""Case #"" + i + "":"" + solve() + ""\n"");
 		}
 		in.close();
 		out.close();
 	}
 
 }
","package Qualification_2012;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 public class SpeakingSol {
 
 	static BufferedReader in;
 	static int[] a;
 
 	private static String solve() throws IOException {
 		String ln = in.readLine();
 		StringBuffer s = new StringBuffer("""");
 		for (int i = 0; i < ln.length(); i++)
 			if (ln.charAt(i) == ' ')
 				s.append(' ');
 			else
 				s.append((char) ('a' + a[ln.charAt(i) - 'a']));
 		return s.toString();
 	}
 
 	public static void main(String[] args) throws IOException {
 		in = new BufferedReader(new FileReader(""in.in""));
 		FileWriter out = new FileWriter(""out.out"");
 		a = new int[] { 24, 7, 4, 18, 14, 2, 21, 23, 3, 20, 8, 6, 11, 1, 10,
 				17, 25, 19, 13, 22, 9, 15, 5, 12, 0, 16 };
 		int t = Integer.parseInt(in.readLine());
 
 		for (int i = 1; i <= t; i++) {
 			out.write(""Case #"" + i + "": "" + solve() + ""\n"");
 		}
 		in.close();
 		out.close();
 	}
 
 }
",1
438,6931,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 public class CodeJamBotTrust {
 
 	public static void main(String[] args) throws IOException {
 		BufferedReader reader = new BufferedReader(new FileReader(""/Users/Christopher/Downloads/A-large.in.txt""));
 		int numOfCases = Integer.parseInt(reader.readLine());
 
 		for (int caseNum = 1; caseNum <= numOfCases; caseNum++) {
 			String[] strButtons = reader.readLine().split("" "");
 			int numOfButtons = Integer.parseInt(strButtons[0]);
 			List<Integer> orangeButtons = new ArrayList<Integer>();
 			List<Integer> blueButtons = new ArrayList<Integer>();
 			String[] buttonColors = new String[numOfButtons];
 
 			for (int i = 0; i < numOfButtons; i++) {
 				String color = strButtons[i * 2 + 1];
 				int position = Integer.parseInt(strButtons[i * 2 + 2]);
 				buttonColors[i] = color;
 				if (""O"".equals(color)) {
 					orangeButtons.add(position);
 				} else { // B
 					blueButtons.add(position);
 				}
 			}
 
 			int orangePosition = 1;
 			int bluePosition = 1;
 			int curOrangeButtonIndex = 0;
 			int curBlueButtonIndex = 0;
 			int timeElapsed = 0;
 			int orangeGoal = goal(orangeButtons, curOrangeButtonIndex);
 			int blueGoal = goal(blueButtons, curBlueButtonIndex);
 
 			while (orangeGoal > -1 | blueGoal > -1) {
 				boolean nextButtonIsOrange = ""O"".equals(buttonColors[curOrangeButtonIndex + curBlueButtonIndex]);
 
 				if (orangeGoal == orangePosition) {
 					if (nextButtonIsOrange) {
 						// press the button
 						curOrangeButtonIndex++;
 						orangeGoal = goal(orangeButtons, curOrangeButtonIndex);
 					} // else wait
 				} else {
 					orangePosition = moveTowardsButton(orangePosition, orangeGoal);
 				}
 
 				if (blueGoal == bluePosition) {
 					if (!nextButtonIsOrange) {
 						// press the button
 						curBlueButtonIndex++;
 						blueGoal = goal(blueButtons, curBlueButtonIndex);
 					} // else wait
 				} else {
 					bluePosition = moveTowardsButton(bluePosition, blueGoal);
 				}
 
 				timeElapsed++;
 			}
 
 			System.out.format(""Case #%d: %d\n"", caseNum, timeElapsed);
 		}
 	}
 
 	public static int goal(List<Integer> buttons, int index) {
 		if (index < buttons.size()) {
 			return buttons.get(index);
 		} else {
 			return -1;
 		}
 	}
 
 	// returns new pos
 	public static int moveTowardsButton(int curPos, int buttonPos) {
 		if (curPos == buttonPos) {
 			return curPos;
 		} else if (curPos < buttonPos) {
 			return curPos + 1;
 		} else {
 			return curPos - 1;
 		}
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 
 public class CodeJamCandySplitting {
 
 	public static void main(String[] args) throws IOException {
 		BufferedReader reader = new BufferedReader(new FileReader(""/Users/Christopher/Downloads/C-large.in.txt""));
 		int numOfCases = Integer.parseInt(reader.readLine());
 
 		for (int caseNum = 1; caseNum <= numOfCases; caseNum++) {
 			int numOfCandies = Integer.parseInt(reader.readLine());
 			String[] strCandyValues = reader.readLine().split("" "");
 			int[] candyValues = new int[numOfCandies];
 			for (int i = 0; i < numOfCandies; i++) {
 				candyValues[i] = Integer.parseInt(strCandyValues[i]);
 			}
 
 			solveCase(caseNum, candyValues);
 		}
 	}
 
 	private static void solveCase(int caseNum, int[] candyValues) {
 		// Determine if it can be split equally according to Patrick.
 		if (0 != patrickSum(candyValues)) {
 			System.out.format(""Case #%d: NO\n"", caseNum);
 		} else {
 			// No matter how you split the pile the piles will be the same to Patrick.
 			// So just give the smallest piece to Patrick and he'll be happy.
 			// :)
 			int smallestPiece = candyValues[0];
 			for (int i = 0; i < candyValues.length; i++) {
 				int j = candyValues[i];
 				if (j < smallestPiece) {
 					smallestPiece = j;
 				}
 			}
 
 			System.out.format(""Case #%d: %d\n"", caseNum, seanSum(candyValues) - smallestPiece);
 		}
 	}
 
 	private static int seanSum(int[] values) {
 		int sum = 0;
 
 		for (int i = 0; i < values.length; i++) {
 			sum += values[i];
 		}
 
 		return sum;
 	}
 
 	private static int patrickSum(int[] values) {
 		int sum = 0;
 
 		for (int i = 0; i < values.length; i++) {
 			sum ^= values[i];
 		}
 
 		return sum;
 	}
 
 }
",1
439,1662,"import java.io.*;
 import java.util.*;
 
 public class KingdomRush {
 	public static void main(String[] args) {
 		try {
 			BufferedReader ifStream = new BufferedReader(new FileReader(""in""));
 			PrintWriter ofStream = new PrintWriter(new FileWriter(""out""));
 			int numCase = Integer.parseInt(ifStream.readLine());
 
 			for (int i=1; i<=numCase; i++) {
 				ofStream.println(""Case #""+i+"": ""+computeAns(ifStream));
 			}
 
 			ifStream.close();
 			ofStream.close();
 		}
 		catch (IOException e) {
 			System.out.println(""IOException."");
 		}
 	}
 
 	private static String computeAns(BufferedReader ifStream) {
 		try {
 			int numLevel = Integer.parseInt(ifStream.readLine());
 			Level[] level = new Level[numLevel];
 			int numClear = 0;
 			int numStar = 0;
 			boolean earnFlag = false;
 			int clearCount = 0;
 			Level nextClear = null;
 
 			for (int i=0; i<numLevel; i++) {
 				StringTokenizer st = new StringTokenizer(ifStream.readLine(), "" "",
 														 false);
 				level[i] = new Level(Integer.parseInt(st.nextToken()),
 									 Integer.parseInt(st.nextToken()));
 			}
 
 			while (!(numClear == numLevel)) {
 				nextClear = null;
 				for (int i=0; i<numLevel; i++) {
 					if ((level[i].completed2 == false) && (numStar >= level[i].star2)) {
 						if (nextClear == null) {
 							nextClear = level[i];
 						}
 						else if (level[i].star2 < nextClear.star2) {
 							nextClear = level[i];
 						}
 					}
 				}
 				if (nextClear != null) {
 					numClear++;
 					clearCount++;
 					nextClear.completed2 = true;
 					if (nextClear.completed1 == true) {
 						numStar = numStar + 1;
 					}
 					else {
 						numStar = numStar + 2;
 					}
 					continue;
 				}
 
 
 				earnFlag = false;
 				for (int i=0; i<numLevel; i++) {
 					if ((level[i].completed1 == false) && (level[i].star1 == 0)) {
 						clearCount++;
 						numStar++;
 						earnFlag = true;
 						break;
 					}
 					if ((level[i].completed1 == true) && (level[i].star2 == 0)) {
 						clearCount++;
 						numStar++;
 						earnFlag = true;
 						break;
 					}
 				}
 				if (earnFlag) {
 					continue;
 				}
 
 				return ""Too Bad"";
 			}
 
 			return clearCount + """";
 		}
 		catch (IOException e) {
 			System.out.println(""IOException."");
 		}
 		return null;
 	}
 }
 
 class Level {
 	boolean completed1;
 	boolean completed2;
 	int star1;
 	int star2;
 
 	Level (int star1, int star2) {
 		boolean completed1 = false;
 		boolean completed2 = false;
 		this.star1 = star1;
 		this.star2 = star2;
 	}
 }
","import java.io.*;
 import java.util.*;
 
 public class PasswordProblem {
 	public static void main(String[] args) {
 		try {
 			BufferedReader ifStream = new BufferedReader(new FileReader(""in""));
 			PrintWriter ofStream = new PrintWriter(new FileWriter(""out""));
 			int numCases = Integer.parseInt(ifStream.readLine());
 
 			for (int i=1; i<=numCases; i++) {
 				String line1 = ifStream.readLine();
 				String line2 = ifStream.readLine();
 				ofStream.println(""Case #""+i+"": ""+computeAns(line1, line2));
 			}
 
 			ifStream.close();
 			ofStream.close();
 		}
 		catch (IOException e) {
 			System.out.println(""IOException."");
 		}
 	}
 
 	private static double computeAns(String line1, String line2) {
 		StringTokenizer st1 = new StringTokenizer(line1, "" "", false);
 		StringTokenizer st2 = new StringTokenizer(line2, "" "", false);
 		int numTyped = Integer.parseInt(st1.nextToken());
 		int numKey = Integer.parseInt(st1.nextToken());
 		double[] prob = new double[numTyped];
 		double minExp = numKey + 2;
 		double curExp = 0.0;
 
 		for (int i=0; i<numTyped; i++) {
 			prob[i] = Double.parseDouble(st2.nextToken());
 		}
 
 		for (int numBack=0; numBack<=numTyped; numBack++) {
 			curExp = computeExp(numTyped, numBack, numKey, prob);
 			if (curExp < minExp) {
 				minExp = curExp;
 			}
 		}
 
 		return minExp;
 	}
 
 	private static double computeExp(int numTyped, int numBack, int numKey,
 									double[] prob) {
 		double suProb = 1.0;
 		double faProb = 1;
 		int suStr = numBack + (numKey - (numTyped-numBack)) + 1;
 		int faStr = numBack + (numKey - (numTyped-numBack)) + 1 + numKey + 1;
 
 		for (int i=0; i<numTyped-numBack; i++) {
 			suProb *= prob[i];
 		}
 		faProb = 1.0 - suProb;
 
 		return suStr*suProb + faStr*faProb;
 	}
 }
",1
440,150,"package r1b.a;
 
 import java.io.*;
 import java.util.*;
 
 public class What {
   static PrintStream out;
   public static final void main(String[]args)throws Exception{
     Scanner s = new Scanner(new File(args[0]));
     out = new PrintStream(new FileOutputStream(args[0]+"".out""));
     int T = s.nextInt();
     for (int t=0; t<T; t++) {
       int A = s.nextInt();
       int N = s.nextInt();
       int[] motes = new int[N];
       for (int i=0;i<N;i++)
         motes[i] = s.nextInt();
       Arrays.sort(motes);
       println(""Case #"" + (t+1)+"": "" + foo(A,motes));
     }
     s.close();
     out.close();
   }
 
 
   private static int foo(int a, int[] motes) {
     if (motes.length == 0) return 0;
     if (a > motes[0]) {
       return 0 + foo(a + motes[0], Arrays.copyOfRange(motes, 1, motes.length));
     }
     int y = 1 + foo(a, Arrays.copyOfRange(motes, 0, motes.length - 1));
     if (a == 1) return y;
     int x = 1 + foo(a + (a-1), motes);
     return Math.min(x,  y);
   }
 
 
 
 
 
 
 
 
   public static void println(String s) throws Exception {
     System.out.println(s);
     out.println(s);
   }
 
 }
","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.HashMap;
 import java.util.Map;
 
 
 public class Foo {
 	public static void main(String[] args) throws Exception {
 		BufferedReader in = new BufferedReader(new FileReader(args[0]));
 		int T = Integer.parseInt(in.readLine());
 		for (int t = 1; t <= T; t++) {
 			System.out.print(""Case #""+t+"": "");
 			String[] arr = in.readLine().split("" "");
 			int N = Integer.parseInt(arr[0]);
 			int M = Integer.parseInt(arr[1]);
 			Foo f = new Foo();
 			for (int n=0;n<N;n++) {
 				f.exists(in.readLine());
 			}
 			for (int m=0;m<M;m++) {
 				f.mkdir(in.readLine());
 			}
 			System.out.println(f.get());
 		}
 	}
 private int get() {
 	return count;
 	}
 int count = 0;
 	private void mkdir(String readLine) {
 		Map tmp = m;
 		for (String s :  readLine.substring(1).split(""/"")) {
 		//	System.out.println(s);
 			Map tmp2 = (Map) tmp.get(s);
 			if (tmp2 == null) {
 				count++;
 				tmp.put(s, tmp2 = new HashMap());
 			}
 			tmp = tmp2;
 		}
 	//	System.out.println(""?""+readLine+"" ""+m+"" ""+count);
 	}
 
 	Map m = new HashMap();
 
 	private void exists(String readLine) {
 		Map tmp = m;
 		for (String s :  readLine.substring(1).split(""/"")) {
 			Map tmp2 = (Map) tmp.get(s);
 			if (tmp2 == null) {
 				tmp.put(s, tmp2 = new HashMap());
 			}
 			tmp = tmp2;
 		}
 	//	System.out.println(""!""+readLine+"" ""+m);
 	}
 
 
 }
",1
441,18646,"package round1b;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.LinkedList;
 import java.util.List;
 
 public class A {
 
 	private static int caseNr;
 
 	private static BufferedWriter out;
 
 	private static BufferedReader in;
 
 	public static void main(String[] args) throws IOException {
 		File inputFile = new File(""in/A-small.in"");
 		in = new BufferedReader(new FileReader(inputFile));
 
 		File outputFile = new File(""out/A-small.out"");
 		out = new BufferedWriter(new FileWriter(outputFile));
 
 		int t = Integer.parseInt(in.readLine());
 		for (caseNr = 1; caseNr <= t; caseNr++) {
 			System.out.println(caseNr);
 			solveTest();
 		}
 
 		in.close();
 		out.close();
 		System.out.println(""done"");
 	}
 
 	private static void solveTest() throws IOException {
 		String[] line = in.readLine().split("" "");
 
 		int n = Integer.parseInt(line[0]);
 		int m = Integer.parseInt(line[1]);
 
 		List<Dir> children = new LinkedList<Dir>();
 		for (int i = 0; i < n; i++) {
 			String[] dirs = in.readLine().split(""/"");
 			List<Dir> cchildren = children;
 			for (int j=1; j<dirs.length; j++) {
 				Dir parent = null;
 				for (Dir cdir : cchildren) {
 					if (cdir.name.equals(dirs[j])) {
 						parent = cdir;
 						break;
 					}
 				}
 				if (parent == null) {
 					parent = new Dir(dirs[j]);
 					cchildren.add(parent);
 				}
 				cchildren = parent.children;
 			}
 		}
 		
 		int result = 0;
 		
 		for (int i = 0; i < m; i++) {
 			String[] dirs = in.readLine().split(""/"");
 			List<Dir> cchildren = children;
 			for (int j=1; j<dirs.length; j++) {
 				Dir parent = null;
 				for (Dir cdir : cchildren) {
 					if (cdir.name.equals(dirs[j])) {
 						parent = cdir;
 						break;
 					}
 				}
 				if (parent == null) {
 					parent = new Dir(dirs[j]);
 					cchildren.add(parent);
 					result++;
 				}
 				cchildren = parent.children;
 			}
 		}
 
 		out.write(""Case #"" + caseNr + "": "" + result + ""\n"");
 	}
 	
 	private static class Dir {
 		String name;
 		List<Dir> children = new LinkedList<Dir>();
 		
 		public Dir(String name) {
 			this.name = name;
 		}
 	}
 
 }
","package googlecodejam;
 
 /**
  *
  * @author ffreakk
  */
 
 import java.util.Scanner;
 import java.lang.Math;
 public class Main {
 
     public static void main(String[] args) {
         Scanner in = new Scanner(System.in);
         int T = in.nextInt(); in.nextLine();
 
         char convert[][] = new char[27][2];
 
         // manual conversion
         convert[0][0] = 'a';        convert[0][1] = 'y';
         convert[1][0] = 'b';        convert[1][1] = 'n';
         convert[2][0] = 'c';        convert[2][1] = 'f';
         convert[3][0] = 'd';        convert[3][1] = 'i';
         convert[4][0] = 'e';        convert[4][1] = 'c';
         convert[5][0] = 'f';        convert[5][1] = 'w';
         convert[6][0] = 'g';        convert[6][1] = 'l';
         convert[7][0] = 'h';        convert[7][1] = 'b';
         convert[8][0] = 'i';        convert[8][1] = 'k';
         convert[9][0] = 'j';        convert[9][1] = 'u';
         convert[10][0] = 'k';       convert[10][1] = 'o';
         convert[11][0] = 'l';       convert[11][1] = 'm';
         convert[12][0] = 'm';       convert[12][1] = 'x';
         convert[13][0] = 'n';       convert[13][1] = 's';
         convert[14][0] = 'o';       convert[14][1] = 'e';
         convert[15][0] = 'p';       convert[15][1] = 'v';
         convert[16][0] = 'q';       convert[16][1] = 'z';
         convert[17][0] = 'r';       convert[17][1] = 'p';
         convert[18][0] = 's';       convert[18][1] = 'd';
         convert[19][0] = 't';       convert[19][1] = 'r';
         convert[20][0] = 'u';       convert[20][1] = 'j';
         convert[21][0] = 'v';       convert[21][1] = 'g';
         convert[22][0] = 'w';       convert[22][1] = 't';
         convert[23][0] = 'x';       convert[23][1] = 'h';
         convert[24][0] = 'y';       convert[24][1] = 'a';
         convert[25][0] = 'z';       convert[25][1] = 'q';
         convert[26][0] = ' ';       convert[26][1] = ' ';
 
         for (int t=1; t<=T; t++){
             System.out.print(""Case #""+t+"": "");
             String inputString = in.nextLine();
             char input[] = new char[1];
             input = inputString.toCharArray();
             for (int i = 0; i<input.length; i++) {
                 for (int ii=0; ii<27; ii++) {
                     if (convert[ii][1] == input[i])
                         System.out.print(convert[ii][0]);
                 }
             }
             System.out.println();
         }
 
     }
 
 }
",0
442,12218,"import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
 public class PetitBonbonA {
 	private final String _PROBLEM_NO = ""201102A"";
 	private final String _FILE_DIRECTORY = ""K:/Dropbox/workspace/codejam/"" + _PROBLEM_NO + ""/"";
 	private final String _FILE_PATH = _FILE_DIRECTORY + ""A-small-attempt1"";
 	
 	public static void main(String[] args) throws IOException {
 		Locale.setDefault(Locale.US);
 		new PetitBonbonA().execute();
 	}
 
 	public void execute() {
 		BufferedReader br = null;
 		PrintWriter pw = null;
 
 		try {
 			br = new BufferedReader(new FileReader(_FILE_PATH + "".in""));
 			pw = new PrintWriter(_FILE_PATH + "".out"");
 			
 			//main
 	
 			int caseno = Integer.parseInt(br.readLine());
 			
 			
 			for (int count = 1; count <= caseno; count++) {
 				pw.print(""Case #"" + count + "": "");
 				System.out.print(""Case #"" + count + "": "");
 				
 				String inputs[] = br.readLine().split("" "");
 				
 				long n = Long.parseLong(inputs[0]);
 				int d = Integer.parseInt(inputs[1]);
 				int g = Integer.parseInt(inputs[2]);
 				
 				boolean result = false;
 				
 				if(g == 0 && d != 0) {
 					
 				}
 				else if(g == 100 && d != 100) {
 					
 				}
 				else {
 					for(long i=1;i<=n;i++) {
 						if(i*d % 100 == 0) {
 							long lost = i - (i*d/100);
 							if(lost > 0 && g < 100) {
 								result = true;
 								break;
 							}
 							else if(lost == 0) {
 								result = true;
 								break;
 							}
 							else if(lost > 0 && g == 100) {
 								break;
 							}
 							
 						}
 					}
 				}
 				
 				
 				
 				if(result) {
 					pw.print(""Possible"");
 					System.out.print(""Possible"");
 								
 				}
 				else {
 					pw.print(""Broken"");
 					System.out.print(""Broken"");
 				}
 				
 				
 				pw.print(""\n"");
 				System.out.print(""\n"");
 			}
 			
 			//end
 	
 	
 			br.close();
 			pw.close();
 		
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 		finally {
 			try {
 				if(pw != null) pw.close();
 			} catch(Exception e) {}
 			try {
 				if(br != null) br.close();
 			} catch(Exception e) {}
 		}
 	}
 
 }
","import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
 public class MonPetitBonbonB {
 	private final String _FILE_DIRECTORY = ""D:\\workspace\\codejam\\"";
 	private final String _FILE_PATH = _FILE_DIRECTORY + ""B-small-attempt1"";
 	
 	public static void main(String[] args) throws IOException {
 		Locale.setDefault(Locale.US);
 		new MonPetitBonbonB().execute();
 	}
 
 	public void execute() {
 		BufferedReader br = null;
 		PrintWriter pw = null;
 
 		try {
 			br = new BufferedReader(new FileReader(_FILE_PATH + "".in""));
 			pw = new PrintWriter(_FILE_PATH + "".out"");
 	
 			int caseno = Integer.parseInt(br.readLine());
 		
 			for (int count = 1; count <= caseno; count++) {
 				pw.print(""Case #"" + count + "": "");
 				System.out.print(""Case #"" + count + "": "");
 				
 				String inputsTmp[] = br.readLine().split("" "");
 				long inputs[] = new long[inputsTmp.length-1];
 				for(int i=0;i<inputs.length;i++) {
 					inputs[i] = Long.parseLong(inputsTmp[i+1]);
 				}
 				long inputsDiff[] = new long[inputs.length];
 				for(int i=0;i<inputs.length;i++) {
 					if(i == inputs.length - 1)
 						inputsDiff[i] = Math.abs(inputs[i] - inputs[0]);
 					else
 						inputsDiff[i] = Math.abs(inputs[i] - inputs[i+1]); 
 				}
 				
 				int noZero = 0;
 				for(int i=0;i<inputsDiff.length;i++) {
 					if(inputsDiff[i] != 0)
 						noZero++;
 				}
 				long inputsDiffNoZero[] = new long[noZero];
 				noZero=0;
 				for(int i=0;i<inputsDiff.length;i++) {
 					if(inputsDiff[i] != 0)
 						inputsDiffNoZero[noZero++] = inputsDiff[i];
 				}
 					
 				long gcd = 0;
 				if(inputsDiffNoZero.length == 1)
 					gcd = inputsDiffNoZero[0];
 				else {
 					gcd = gcd(inputsDiffNoZero[0],inputsDiffNoZero[1]);
 					if(inputsDiffNoZero.length > 2) {
 						for(int i=2;i<inputsDiffNoZero.length;i++) {
 							gcd = gcd(gcd,inputsDiffNoZero[i]);
 						}
 					}
 					
 				}
 				long dday = 0;
 				while(true) {
 					if(inputs[0] > gcd)
 						inputs[0] = inputs[0] - gcd;
 					else
 						break;
 				}
 				dday = gcd - inputs[0];
 				pw.print(dday + ""\n"");
 				System.out.print(dday + ""\n"");
 			}
 			br.close();
 			pw.close();
 		
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 		finally {
 			try {
 				if(pw != null) pw.close();
 			} catch(Exception e) {}
 			try {
 				if(br != null) br.close();
 			} catch(Exception e) {}
 		}
 	}
 	public long gcd(long x, long y) {
 		long tmp;
         while (x % y != 0) {
             tmp = y;
             y = x % y;
             x = tmp;
         }
         return y;
     }
 
 }
",1
443,18928,"package qualification;
 
 import java.math.BigDecimal;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 import util.TestUtil;
 
 public class FairWarning2 {
 
 	private int caseNum = 0;
 	private NumberFormat nf = NumberFormat.getInstance();
 	private String inputFileName = ""C:/Download/B-large.in"";
 	private String outputFileName = ""./small.out"";
 
 	public FairWarning2() {
 	}
 
 	private void process() {
 
 		nf.setMaximumFractionDigits(0);
 		nf.setGroupingUsed(false);
 		nf.setMaximumIntegerDigits(50);
 		
 		List<String> inputList;
 		List<String> outputList;
 		inputList = readList(inputFileName);
 		outputList = calcResult(inputList);
 		writeOutputList(outputFileName, outputList);
 	}
 
 	private List<String> readList(String fileName) {
 
 		List<String> inputList = TestUtil.readLines(inputFileName);
 		caseNum = Integer.parseInt(inputList.get(0));
 		inputList.remove(0);
 		return inputList;
 	}
 
 	private List<String> calcResult(List<String> inputList) {
 		List<String> result = new ArrayList<String>();
 		String[] tmps;
 		int eventNum = 0;
 
 		BigDecimal[] eventTime;
 		for (int i = 0; i < caseNum; i++) {
 			tmps = inputList.get(i).split("" "");
 			eventNum = Integer.parseInt(tmps[0]);
 			eventTime = new BigDecimal[eventNum];
 			for (int j = 0; j < eventNum; j++) {
 				eventTime[j] = new BigDecimal(tmps[j + 1]);
 //				System.out.println(nf.format(eventTime[j]));
 			}
 			Arrays.sort(eventTime);
 
 			result.add(""Case #"" + (i + 1) + "": "" + formatNumber(calcApocalypse(eventNum, eventTime)));
 			System.out.println(result.get(i));
 		}
 		return result;
 	}
 
 	private String formatNumber(BigDecimal apocalypse) {
 		return apocalypse.toString();
 	}
 
 	private BigDecimal calcApocalypse(int eventNum, BigDecimal[] eventTime) {
 
 		BigDecimal commonGCD = new BigDecimal(""0"");
 		BigDecimal[] diffTimes = new BigDecimal[eventNum - 1];
 
 		for (int i = 0; i < eventNum - 1; i++) {
 			diffTimes[i] = eventTime[i + 1].subtract(eventTime[i]);
 		}
 
 		commonGCD = diffTimes[0];
 		for (int i = 0; i < diffTimes.length; i++) {
 			commonGCD = GCD(commonGCD, diffTimes[i]);
 		}
 
 		BigDecimal lastEventTime = eventTime[0].divideAndRemainder(commonGCD)[1];
 
 		if (lastEventTime.equals(new BigDecimal(""0""))) {
 			return new BigDecimal(""0"");
 		} else {
 			return commonGCD.subtract(lastEventTime);
 		}
 
 	}
 
 	private void writeOutputList(String fileName, List<String> outputList) {
 		TestUtil.writeToFile(fileName, outputList);
 	}
 
 	public BigDecimal GCD(BigDecimal a, BigDecimal b) {
 		if (b.equals(new BigDecimal(""0"")))
 			return a;
 		return GCD(b, a.divideAndRemainder(b)[1]);
 	}
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		System.out.println(""========= START ========="");
 		FairWarning2 proc = new FairWarning2();
 		proc.process();
 		System.out.println(""=========  END  ========="");
 	}
 
 }
","import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 
 public class TicTacToeTomek {
 
 	public void solve() throws Exception {
 		Scanner sc = new Scanner(new FileReader(""A-small-attempt0.in""));
 		PrintWriter pw = new PrintWriter(new FileWriter(""A-small-attempt0.txt""));
 		
 		int caseCnt = sc.nextInt();
 		
 		for (int caseNum = 0; caseNum < caseCnt; caseNum++) {
 			pw.print(""Case #"" + (caseNum + 1) + "": "");
 					
 //			System.out.println(caseNum);
 //			if(caseNum > 0) {
 //				sc.next();
 //			}
 			
 			String[][] board = new String[4][4];
 			for(int i=0; i<4; i++) {
 				String line = sc.next();
 				for(int j=0; j<4; j++) {
 					board[i][j] = line.substring(j, j+1);
 				}
 			}
 			
 //			print(board);
 			
 			pw.println(check(board));
 		}
 		
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 	
 	public static void main(String[] args) throws Exception {
 		
 		new TicTacToeTomek().solve();
 	}
 	
 	public void print(String[][] board) {
 		for(int i=0; i<4; i++) {
 			for(int j=0; j<4; j++) {
 				System.out.print(board[i][j]);
 			}
 			System.out.println();
 		}
 	}
 	
 	public String check(String[][] board) {
 		String status = ""Draw"";
 		boolean dot = false;
 		
 		for(int i=0; i<4; i++) {
 			
 			int xRows = 0;
 			int oRows = 0;	
 			int xCols = 0;
 			int oCols = 0;		
 			
 			for(int j=0; j<4; j++) {
 				//rows
 				if(board[i][j].equals(""X"")) {
 					xRows++;
 				} else if(board[i][j].equals(""O"")) {
 					oRows++;
 				} else if(board[i][j].equals(""T"")) {
 					xRows++; oRows++;
 				} else {
 					dot = true;
 				}
 				
 				//columns
 				if(board[j][i].equals(""X"")) {
 					xCols++;
 				} else if(board[j][i].equals(""O"")) {
 					oCols++;
 				} else if(board[j][i].equals(""T"")) {
 					xCols++; oCols++;
 				} else {
 					dot = true;
 				}			
 								
 				if(xRows == 4 || xCols == 4) {
 					return ""X won"";
 				} else if(oRows == 4 || oCols == 4) {
 					return ""O won"";
 				}
 			}			
 		}
 		
 		//diags
 		int xDiag = 0;
 		int oDiag = 0;	
 		int xDiag2 = 0;
 		int oDiag2 = 0;	
 		for(int i=0; i<4; i++) {
 //			System.out.print(i);
 			if(board[i][i].equals(""X"")) {
 				xDiag++;
 			} else if(board[i][i].equals(""O"")) {
 				oDiag++;
 			} else if(board[i][i].equals(""T"")) {
 				xDiag++; oDiag++;
 			} else {
 				dot = true;
 			}
 			
 			if(board[i][3-i].equals(""X"")) {
 				xDiag2++;
 			} else if(board[i][3-i].equals(""O"")) {
 				oDiag2++;
 			} else if(board[i][3-i].equals(""T"")) {
 				xDiag2++; oDiag2++;
 			} else {
 				dot = true;
 			}
 			
 			if(xDiag == 4 || xDiag2 == 4) {
 				return ""X won"";
 			} else if(oDiag == 4 || oDiag2 == 4) {
 				return ""O won"";
 			}
 		}
 		
 		if(dot) {
 			status = ""Game has not completed"";
 		}
 		
 		return status;
 	}
 
 }
",0
444,2886,"package candy;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Main {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new FileInputStream(""C-small.in""));
 		PrintWriter out = new PrintWriter(new FileOutputStream(""C-small.out""));
 		int T = in.nextInt();
 		for (int t = 1; t <= T; t++) {
 			Solver solver = new Solver(in);
 			out.println(""Case #"" + t + "": "" + solver.getResult());
 		}
 		out.close();
 		System.out.println(""finished"");
 	}
 }
","import java.math.BigInteger;
 
 
 
 
 public class intCases {
 	private int startPoint;
 	private int endPoint;
 	public intCases(int startPoint, int endPoint) {
 		// TODO Auto-generated constructor stub
 		this.startPoint = startPoint;
 		this.endPoint = endPoint;
 	}
 	public boolean judgePalindrome(int num){
 		String str = Integer.toString(num);
 		if(str.length()%2==1)
 			for(int i = 0;i < (str.length()-1)/2; i++){
 				if(str.charAt(i)!=str.charAt(str.length() - 1 - i))
 					return false;
 			}
 		else 
 			for(int i = 0;i < str.length()/2; i++){
 				if(str.charAt(i)!=str.charAt(str.length() - 1 - i))
 					return false;
 			}
 		return true;	
 	}
 	
 
 	public boolean judgeSquare(int num){
 		int i = 1;
 		while(true){
 			if(i*i==num&&judgePalindrome(i))
 				return true;
 		i++;
 		if(i>num)
 			break;
 		}
 		return false;
 	}
 	
 	public int calculateFairAndSquareNumber(){
 		int i = startPoint;
 		int number=0;
 		while(i <= endPoint){
 			if(judgeSquare(i)&&judgePalindrome(i)){
 				number++;
 			}
 				
 			i++;
 		}
 			
 		return number;
 	}
 
 	
 	
 	
 	
 	
 	
 	
 }
",0
445,1785,"import java.util.*;
 
 public class B {
 	public static void main(String[] args) {
 		Scanner in = new Scanner(System.in);
 		int cases = in.nextInt();
 		for(int c=1;c<=cases;++c) {
 			int combinations = in.nextInt();
 			char[][] combos = new char[128][128]; //A-Z by A-Z. the element at [x][y] is what [x] and [y] combine to make
 			for(int i=0;i<128;++i) {
 				Arrays.fill(combos[i], ' ');
 			}
 			for(int i=0;i<combinations;++i) {
 				String combo = in.next();
 				char first = combo.charAt(0);
 				char second = combo.charAt(1);
 				char end = combo.charAt(2);
 				combos[first][second] = combos[second][first] = end;
 			}
 			int negations = in.nextInt();
 			boolean[][] opposed = new boolean[128][128];
 			for(int i=0;i<negations;++i) {
 				String negation = in.next();
 				char first = negation.charAt(0);
 				char second = negation.charAt(1);
 				opposed[first][second] = opposed[second][first] = true;
 			}
 			int elementCount = in.nextInt();
 			String elements = in.next();
 			List<Character> listOfElements = new LinkedList<Character>();
 			A: for(int i=0;i<elementCount;++i) {
 				char curChar = elements.charAt(i);
 				if (listOfElements.isEmpty()) {
 					listOfElements.add(curChar);
 				}
 				else {
 					char prev = listOfElements.get(listOfElements.size()-1);
 					if (combos[prev][curChar] != ' ') {
 						listOfElements.remove(listOfElements.size()-1);
 						listOfElements.add(combos[prev][curChar]);
 					}
 					else {
 						for(char cc : listOfElements) {
 							if (opposed[curChar][cc]) {
 								listOfElements = new LinkedList<Character>();
 								continue A;
 							}
 						}
 						listOfElements.add(curChar);
 					}
 				}
 			}
 			
 			
 			
 			System.out.printf(""Case #%d: %s\n"", c, listOfElements.toString());
 		}
 	}
 }","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Arrays;
 import java.util.Scanner;
 import java.util.TreeSet;
 
 public class DW {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		PrintStream out = new PrintStream(""output.txt"");
 //		PrintStream out = System.out;
 
 		Scanner scanner = new Scanner(new File(""D-small-attempt0.in""));
 
 		int cases = scanner.nextInt();
 		for (int casen = 1; casen <= cases; casen++) {
 			out.print(""Case #"" + casen + "": "");
 
 			int n = scanner.nextInt();
 			TreeSet<Double> A = new TreeSet<Double>();
 			TreeSet<Double> B = new TreeSet<Double>();
 			TreeSet<Double> A2 = new TreeSet<Double>();
 			TreeSet<Double> B2 = new TreeSet<Double>();
 			
 			for (int i=0;i<n;i++) {
 				double tmp = scanner.nextDouble();
 				A.add(tmp);
 				A2.add(tmp);
 			}
 			for (int i=0;i<n;i++) {
 				double tmp = scanner.nextDouble();
 				B.add(tmp);
 				B2.add(tmp);
 			}
 			
 			int score2 = 0; 
 			for (int i=0;i<n;i++) {
 				if (A2.last() > B2.last()) {
 					score2++;
 					A2.remove(A2.last());
 					B2.remove(B2.first());
 				} else {
 					A2.remove(A2.last());
 					B2.remove(B2.last());
 				}
 			}
 			
 			int score = 0;
 			for (int i=0;i<n;i++) {
 				if (A.last() < B.last()) {
 					A.remove(A.first());
 					B.remove(B.last());
 				} else {
 					score++;					
 					A.remove(A.last());
 					B.remove(B.last());
 				}
 			}
 				
 			out.print(score+"" ""+score2);
 			
 			out.println();
 		}
 		scanner.close();
 	}
 
 }",0
446,11082,"import java.io.BufferedReader;
 import java.io.IOException;
 
 public class TestOneSolver {
 
 	public StringBuilder process(BufferedReader in, StringBuilder builder)
 			throws IOException {
 		in.readLine();
 		String line = in.readLine();
 		int count = 1;
 		while (line != null) {
 			line = line.replace('y', bigger('a'));
 			line = line.replace('n', bigger('b'));
 			line = line.replace('f', bigger('c'));
 			line = line.replace('i', bigger('d'));
 			line = line.replace('c', bigger('e'));
 			line = line.replace('w', bigger('f'));
 			line = line.replace('l', bigger('g'));
 			line = line.replace('b', bigger('h'));
 			line = line.replace('k', bigger('i'));
 			line = line.replace('u', bigger('j'));
 			line = line.replace('o', bigger('k'));
 			line = line.replace('m', bigger('l'));
 			line = line.replace('x', bigger('m'));
 			line = line.replace('s', bigger('n'));
 			line = line.replace('e', bigger('o'));
 			line = line.replace('v', bigger('p'));
 			line = line.replace('z', bigger('q'));
 			line = line.replace('p', bigger('r'));
 			line = line.replace('d', bigger('s'));
 			line = line.replace('r', bigger('t'));
 			line = line.replace('j', bigger('u'));
 			line = line.replace('g', bigger('v'));
 			line = line.replace('t', bigger('w'));
 			line = line.replace('h', bigger('x'));
 			line = line.replace('a', bigger('y'));
 			line = line.replace('q', bigger('z'));
 
 			for (int i = 0; i < 26; i++) {
 				line = line.replace(bigger((char)('a'+i)), (char)('a'+i));
 			}
 			appendLine(line, builder,count);
 			count++;
 			line = in.readLine();
 		}
 		return builder;
 	}
 
 	private char bigger(char c) {
 		c = (char) ((byte) c + 50);
 		return c;
 	}
 
 	private static void appendLine(String line, StringBuilder builder, int count) {
 		builder.append(""Case #""+count+"": ""+line + ""\r\n"");
 	}
 }
","import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.Scanner;
 
 class Board {
 	public static final char O = 'O';
 	public static final char X = 'X';
 	public static final char T = 'T';
 	public static final char DOT = '.';
 	
 	public static final int size = 4;
 	private char[][] data;
 	
 	public Board(String representation) {
 		
 		if (representation.length() != size * size) {
 			throw new IllegalArgumentException();			
 		}
 		
 		data = new char[size][];
 		for (int i = 0; i < data.length; ++i) {
 			data[i] = new char[size];
 		}
 		
 		for (int i = 0; i < representation.length(); ++i) {
 			data[i / size][i % size] = representation.charAt(i);
 		}
 	}
 
 	public boolean isWonO() {
 		for (int row = 0; row < size; ++row) {
 			
 			int nT = 0, nO = 0, nX = 0;
 			
 			for (int column = 0; column < size; ++column) {
 
 				char c = data[row][column];
 				if (c == O) {
 					++nO;
 				}
 				else if (c == X) {
 					++nX;
 				}
 				else if (c == T) {
 					++nT;
 				}
 			}
 			
 			if (nO + nT == size) {
 				return true;
 			}			
 		}
 		
 		for (int column = 0; column < size; ++column) {
 			
 			int nT = 0, nO = 0, nX = 0;
 			
 			for (int row = 0; row < size; ++row) {
 
 				char c = data[row][column];
 				if (c == O) {
 					++nO;
 				}
 				else if (c == X) {
 					++nX;
 				}
 				else if (c == T) {
 					++nT;
 				}
 			}
 			
 			if (nO + nT == size) {
 				return true;
 			}			
 		}
 		
 		int nT = 0, nO = 0, nX = 0;		
 		for (int rowcolumn = 0; rowcolumn < size; ++rowcolumn) {						
 
 			char c = data[rowcolumn][rowcolumn];
 			if (c == O) {
 				++nO;
 			}
 			else if (c == X) {
 				++nX;
 			}
 			else if (c == T) {
 				++nT;
 			}	
 		}		
 		if (nO + nT == size) {
 			return true;
 		}		
 		
 		nT = 0; nO = 0; nX = 0;		
 		for (int row = 0; row < size; ++row) {						
 
 			char c = data[row][size - 1 - row];
 			if (c == O) {
 				++nO;
 			}
 			else if (c == X) {
 				++nX;
 			}
 			else if (c == T) {
 				++nT;
 			}	
 		}		
 		if (nO + nT == size) {
 			return true;
 		}		
 		
 		return false;
 	}
 	
 	public boolean isWonX() {
 		for (int row = 0; row < size; ++row) {
 			
 			int nT = 0, nO = 0, nX = 0;
 			
 			for (int column = 0; column < size; ++column) {
 
 				char c = data[row][column];
 				if (c == O) {
 					++nO;
 				}
 				else if (c == X) {
 					++nX;
 				}
 				else if (c == T) {
 					++nT;
 				}
 			}
 			
 			if (nX + nT == size) {
 				return true;
 			}			
 		}
 		
 		for (int column = 0; column < size; ++column) {
 			
 			int nT = 0, nO = 0, nX = 0;
 			
 			for (int row = 0; row < size; ++row) {
 
 				char c = data[row][column];
 				if (c == O) {
 					++nO;
 				}
 				else if (c == X) {
 					++nX;
 				}
 				else if (c == T) {
 					++nT;
 				}
 			}
 			
 			if (nX + nT == size) {
 				return true;
 			}			
 		}
 		
 		int nT = 0, nO = 0, nX = 0;		
 		for (int rowcolumn = 0; rowcolumn < size; ++rowcolumn) {						
 
 			char c = data[rowcolumn][rowcolumn];
 			if (c == O) {
 				++nO;
 			}
 			else if (c == X) {
 				++nX;
 			}
 			else if (c == T) {
 				++nT;
 			}	
 		}		
 		if (nX + nT == size) {
 			return true;
 		}		
 		
 		nT = 0; nO = 0; nX = 0;		
 		for (int row = 0; row < size; ++row) {						
 
 			char c = data[row][size - 1 - row];
 			if (c == O) {
 				++nO;
 			}
 			else if (c == X) {
 				++nX;
 			}
 			else if (c == T) {
 				++nT;
 			}	
 		}		
 		if (nX + nT == size) {
 			return true;
 		}		
 		
 		return false;
 	}
 	
 	public boolean areEmptyCells() {
 		for (int i = 0; i < size; ++i) {
 			for (int j = 0; j < size; ++j) {
 				if (data[i][j] == DOT) {
 					return true;
 				}
 			}
 		}
 		return false;		
 	}
 	
 	public void print() {
 		for (int i = 0; i < size; ++i) {
 			for (int j = 0; j < size; ++j) {
 				System.out.print(data[i][j]);
 			}
 		}
 		System.out.println();
 	}	
 }
 	
 class Problem1 {
 	
 	private long T;
 	
 	public void solve(String in) throws IOException {
 		Scanner scanner = new Scanner(new File(in));
 		Writer outFile = new FileWriter(""OUT""+in);
 		
 		T = Integer.parseInt(scanner.nextLine());
 		
 		for (int i = 1; i <= T; ++i) {
 			StringBuilder str = new StringBuilder();
 			for (int j = 0; j < Board.size; ++j) {
 				str.append(scanner.nextLine());
 			}
 			//empty
 			Board board = new Board(str.toString());
 			String result;
 			if (board.isWonO()) {
 				result = ""O won"";
 			}
 			else if (board.isWonX()) {
 				result = ""X won"";
 			}
 			else if (!board.areEmptyCells()) {
 				result = ""Draw"";
 			}
 			else {
 				result = ""Game has not completed"";				
 			}
 			outFile.write(""Case #""+i+"": "" + result +'\n');
 			
 			scanner.nextLine();
 		}
 		
 		outFile.flush();
 		outFile.close();		
 	}
 	
 }
 public class Launcher {
 
 	public static void main(String[] args) {
 		Problem1 problem1 = new Problem1();
 		try {
 			problem1.solve(""A-large.in.txt"");
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
 }
",0
447,1429,"/**
  * @(#)Magicka.java
  *
  * Magicka application
  *
  * @author 
  * @version 1.00 2011/5/7
  */
 import java.io.*;
 import java.util.*;  
 public class Magicka {
 	public static HashMap oppHash = new HashMap();
 	public static HashMap currentHash = new HashMap();
 	public static String[][] subwords;
 	public static Boolean checkOpposites(String out,String aLetter){
 		if(oppHash.containsKey(aLetter)){
 			String value =(String)oppHash.get(aLetter);
 			for(int i=0;i<out.length();i++){
 				String let = """"+out.charAt(i);
 				if(let.compareTo(value)==0){
 					return true;
 				}
 			}
 			
 		}
 		currentHash.put(aLetter,aLetter);
 		//System.out.println(currentHash);
 		return false;
 	}
 	public static String substitute(String output){
 		Boolean change = true;
 		while(change){
 			String start = output;
 			int count = 0;
 			for(int i =0; i<subwords.length;i++){
 				//System.out.println(""sub: ""+subwords[i][0]+"" ""+output);
 				String last=output;
 				output = output.replaceAll(""(""+subwords[i][0]+""){1}"",subwords[i][1]);
 				if(last.compareTo(output) !=0){					
 					count++;
 				}
 				
 			}
 			
 			if(start.compareTo(output)== 0){
 				change = false;
 				
 			}
 		}
 		//System.out.println(""subf: ""+output);
 		return output;
 		
 	}
 	public static void storeSub(String aWord,int index){
 		String word1 =  """"+aWord.charAt(0)+""""+aWord.charAt(1);
 		String word2 =  """"+aWord.charAt(1)+""""+aWord.charAt(0);
 		String aSub = """"+aWord.charAt(2);
 		subwords[index][0] = word1;
 		subwords[index][1] = aSub;
 		subwords[index+1][0] = word2;
 		subwords[index+1][1] = aSub;		
 	}
 	public static void storeOpp(String aWord){
 		String word1 =  """"+aWord.charAt(0);
 		String word2 =  """"+aWord.charAt(1);
 		oppHash.put(word1,word2);
 		oppHash.put(word2,word1);
 		
 	}
     public static void run(){
     	try{
     		BufferedReader in  = new BufferedReader(new FileReader(""B-large.in""));
     		int N = Integer.parseInt(in.readLine());
     		for(int i =0; i<N; i++){
     			currentHash = new HashMap();
     			oppHash = new HashMap();
     			//System.out.println();
     			//System.out.println();
     			String words = in.readLine();
     			String wordsArr[] = words.split("" "");
     			int count = 0;
     			int C = Integer.parseInt(wordsArr[count]);
     			subwords = new String[2*C][2];
     			count++;
     			for(int j = 0; j< C; j++){
     				storeSub(wordsArr[count],2*j);
     				count++;
     			}
     			
     			int D = Integer.parseInt(wordsArr[count]);    			
     			count++;
     			for(int j = 0; j< D; j++){
     				storeOpp(wordsArr[count]);
     				count++;
     			}
     			int SN = Integer.parseInt(wordsArr[count]);
     			count++;
     			String S = wordsArr[count];
     			
     			if(SN != S.length()){ System.out.println(""Scream"");}
     			String output="""";
     			for(int j=0;j <SN; j++){
     				String aLetter = """"+S.charAt(j);
     				output += aLetter;
     				output= substitute(output);
     				aLetter = """"+output.charAt(output.length()-1);
     				if(checkOpposites(output,aLetter)){
     					output = """";
     					currentHash = new HashMap();	
     				}
     				//System.out.println(output+"". ""+i);
     			}
     			String finaloutput = ""["";
     			for(int j = 0; j < output.length(); j++){
     				finaloutput +=output.charAt(j);
     				if(j != output.length()-1){
     					finaloutput += "", "";
     				}
     			}
     			finaloutput += ""]"";
     			try{
     				PrintWriter out = new PrintWriter(new FileWriter(""B-large.out"",true));
     				
     				out.println(""Case #""+(i+1)+"": ""+finaloutput);
     				out.close();
     			}catch(IOException ex2){
     				System.out.println(ex2);
     				System.exit(1);
     			}
     		}
     	}catch(IOException ex){
     		System.out.println(ex);
     		System.exit(1);
     	}
     	
     }
     public static void main(String[] args) {
     	
     	try{
     		PrintWriter out = new PrintWriter(new FileWriter(""B-large.out""));
     	}catch(IOException ex){
     		System.out.println(ex);
     	}
     	run();
     }
 }
","package round1c;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;
 
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.Map;
 import java.util.Set;
 
 class Graph {
 	private Map<String, LinkedHashSet<String>> map = new HashMap();
 
 	public void addEdge(String node1, String node2) {
 		LinkedHashSet<String> adjacent = map.get(node1);
 		if (adjacent == null) {
 			adjacent = new LinkedHashSet();
 			map.put(node1, adjacent);
 		}
 		adjacent.add(node2);
 	}
 
 	public void addTwoWayVertex(String node1, String node2) {
 		addEdge(node1, node2);
 		addEdge(node2, node1);
 	}
 
 	public boolean isConnected(String node1, String node2) {
 		Set adjacent = map.get(node1);
 		if (adjacent == null) {
 			return false;
 		}
 		return adjacent.contains(node2);
 	}
 
 	public LinkedList<String> adjacentNodes(String last) {
 		LinkedHashSet<String> adjacent = map.get(last);
 		if (adjacent == null) {
 			return new LinkedList();
 		}
 		return new LinkedList<String>(adjacent);
 	}
 }
 
 public class ProblemA2 {
 	private static void breadthFirst(Graph graph, LinkedList<String> visited,
 			String end, LinkedList<String> paths) {
 		LinkedList<String> nodes = graph.adjacentNodes(visited.getLast());
 		// examine adjacent nodes
 		for (String node : nodes) {
 			if (visited.contains(node)) {
 				continue;
 			}
 			if (node.equals(end)) {
 				visited.add(node);
 				printPath(visited, paths);
 				visited.removeLast();
 				break;
 			}
 		}
 		// in breadth-first, recursion needs to come after visiting adjacent
 		// nodes
 		for (String node : nodes) {
 			if (visited.contains(node) || node.equals(end)) {
 				continue;
 			}
 			visited.addLast(node);
 			breadthFirst(graph, visited, end, paths);
 			visited.removeLast();
 		}
 	}
 
 	private static void printPath(LinkedList<String> visited, LinkedList<String> paths) {
         String path = """";
 		for (String node : visited) {
 			path = path + node + "" "";
           //  System.out.print(node);
            // System.out.print("" "");
         }
         //System.out.println();
         paths.add(path);
     }
 
 	public static void main(String[] args) throws Exception {
 
 		Scanner sc = new Scanner(System.in);
 		int cases = sc.nextInt();
 		for (int i = 0; i < cases; i++) {
 			int N = sc.nextInt();
 
 			Graph graph = new Graph();
 
 			for (int j = 1; j <= N; j++) {
 				int classes = sc.nextInt();
 
 				for (int k = 0; k < classes; k++) {
 					int c = sc.nextInt();
 					graph.addEdge("""" + j, """" + c);
 					
 				}
 			}
 			
 			/*graph.addEdge(""A"", ""B"");
 	        graph.addEdge(""A"", ""C"");
 	        graph.addEdge(""B"", ""A"");
 	        graph.addEdge(""B"", ""D"");
 	        graph.addEdge(""B"", ""E""); // this is the only one-way connection
 	        graph.addEdge(""B"", ""F"");
 	        graph.addEdge(""C"", ""A"");
 	        graph.addEdge(""C"", ""E"");
 	        graph.addEdge(""C"", ""F"");
 	        graph.addEdge(""D"", ""B"");
 	        graph.addEdge(""E"", ""C"");
 	        graph.addEdge(""E"", ""F"");
 	        graph.addEdge(""F"", ""B"");
 	        graph.addEdge(""F"", ""C"");
 	        graph.addEdge(""F"", ""E"");
 	        LinkedList<String> visited = new LinkedList();
 	        LinkedList<String> paths = new LinkedList<String>();
 	        visited.add(""B"");
 	        breadthFirst(graph, visited, ""E"", paths);*/
 
 			boolean found = false;
 
 			outer: for (int j = 1; j <= N; j++) {
 				for (int k = j + 1; k <= N; k++) {
 					LinkedList<String> visited = new LinkedList<String>();
 					LinkedList<String> paths = new LinkedList<String>();
 					visited.add("""" + j);
 					breadthFirst(graph, visited, """" + k, paths);
 					if (paths.size() > 1) {
 						found = true;
 						break outer;
 					}
 				}
 
 			}
 
 			System.out.println(""Case #"" + (i + 1) + "": ""
 					+ (found ? ""Yes"" : ""No""));
 		}
 	}
 
 }
",0
448,3072,"/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package gcj2013.qualification_round;
 
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 /**
  *
  * @author langlv
  */
 public class Lawnmower {
 
     public static void main(String[] args) throws Exception {
 //        Scanner sc = new Scanner(System.in);
 //        PrintWriter pw = new PrintWriter(System.out);
 
         Scanner sc = new Scanner(new FileReader(""D:\\Workspace\\projects\\gcj\\IO\\2013\\Round.Qualification\\B-small-attempt2.in""));
         PrintWriter pw = new PrintWriter(new FileWriter(""D:\\Workspace\\projects\\gcj\\IO\\2013\\Round.Qualification\\B-small-attempt2.out""));
 //
 //        Scanner sc = new Scanner(new FileReader(""D:\\Workspace\\projects\\gcj\\IO\\2013\\Round.Qualification\\1.in""));
 //        PrintWriter pw = new PrintWriter(new FileWriter(""D:\\Workspace\\projects\\gcj\\IO\\2013\\Round.Qualification\\1.out""));
 
         try {
             int ntest = Integer.parseInt(sc.nextLine());
 
             for (int test = 1; test <= ntest; ++test) {
                 int n = sc.nextInt();
                 int m = sc.nextInt();
                 int[][] lawn = new int[n][m];
                 boolean[][] mark = new boolean[n][m];
                 for (int i = 0; i < n; i++) {
                     for (int j = 0; j < m; j++) {
                         lawn[i][j] = sc.nextInt();
                         mark[i][j] = false;
                     }
                 }
 
                 boolean pos = true;
 
                 if (n == 1 || m == 1) {
                     pos = true;
                 } else {
                     for (int i = 0; i < n; i++) {
                         boolean lineok = true;
                         if (lawn[i][0] == 1) {
                             for (int j = 0; j < m; j++) {
                                 if (lawn[i][j] == 2) {
                                     lineok = false;
                                     break;
                                 }
                             }
                             if (lineok) {
                                 for (int j = 0; j < m; j++) {
                                     mark[i][j] = true;
                                 }
                             }
 
                         }
                     }
                     for (int i = 0; i < m; i++) {
                         boolean colok = true;
                         if (lawn[0][i] == 1) {
                             for (int j = 0; j < n; j++) {
                                 if (lawn[j][i] == 2) {
                                     colok = false;
                                     break;
                                 }
                             }
                             if (colok) {
                                 for (int j = 0; j < n; j++) {
                                     mark[j][i] = true;
                                 }
                             }
                         }
                     }
                     boolean isbreak = false;
                     for (int i = 0; i < n; i++) {
                         for (int j = 0; j < m; j++) {
                             if (lawn[i][j] == 1 && !mark[i][j]) {
                                 pos = false;
                                 isbreak = true;
                                 break;
                             }
                         }
                         if (isbreak) {
                             break;
                         }
                     }
                 }
 
                 pw.print(""Case #"" + test + "": "");
                 pw.print(pos ? ""YES"" : ""NO"");
                 pw.println();
             }
         } catch (Exception e) {
             System.err.println(e.getMessage());
             e.printStackTrace();
         } finally {
             pw.close();
             sc.close();
         }
     }
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 package gcj2011.qualificationRound;
 
 import gcjproblem.AbstractProblem;
 import gcjproblem.GCJLogger;
 
 /**
  *
  * @author langlv
  */
 public class Magicka extends AbstractProblem<MagickaCase> {
 
     public Magicka() {
         super(MagickaCase.class);
     }
 
     public static void main(String args[]) {
         try {
             Magicka instance = new Magicka();
             instance.smallInputFile = ""C:\\Users\\langlv\\Desktop\\gcj\\2011\\B-small-attempt0.in"";
             instance.smallOutputFile = ""C:\\Users\\langlv\\Desktop\\gcj\\2011\\B-small-attempt0.out"";
 //             instance.largeInputFile = ""C:\\Users\\langlv\\Desktop\\gcj\\2011\\A-large.in"";
 //             instance.largeOutputFile = ""C:\\Users\\langlv\\Desktop\\gcj\\2011\\A-large.out"";
 
             GCJLogger.log(""Start process BotTrust..."");
             instance.process();
             GCJLogger.log(""End process BotTrust..."");
         } catch (Exception ex) {
             GCJLogger.log(ex);
         }
     }
 }
",1
449,19051,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class A {
     static long a[] = new long[13];
 
     public static void main(String zargs[]) throws FileNotFoundException {
 //        Scanner scanner = new Scanner(System.in);
         Scanner scanner = new Scanner(new File(""/Users/vivek/Downloads/A-large.in""));
 
         int t = scanner.nextInt();
         scanner.nextLine();
         long val = 1;
 
         for (int i = 0; i < 13; i++) {
             a[i] = val;
             val = val << 1;
         }
 
 
         for (int iii = 1; iii <= t; iii++) {
             String s = scanner.nextLine();
             String[] ss = s.split(""/"");
             long x = Long.parseLong(ss[0]);
             long y = Long.parseLong(ss[1]);
 
 
             System.out.println(String.format(""Case #%d: %s"", iii, calc(x, y)));
         }
 
     }
 
     private static String calc(long x, long y) {
         long g = gcd(x, y);
         x /= g;
         y /= g;
 
 
         int den = -1;
         for (int i = 0; i < 13; i++)
             if (a[i] == y)
                 den = i;
 
         if (den == -1)
             return ""impossible"";
 
         int ans = 0;
         while (y > x) {
 //            System.out.println(y + "" "" + x);
             ans++;
             y /= 2;
         }
 
         return ans + """";
     }
 
     private static long gcd(long x, long y) {
         if (y == 0)
             return x;
         else
             return gcd(y, x % y);
     }
 }
","
 import java.io.*;
 import java.util.*;
 
 public class FileFixIt
 {
 	public static void main(String[] args) throws Exception
 	{
 		BufferedReader in = new BufferedReader(new FileReader(""A-small-attempt1.in""));
 		BufferedWriter out = new BufferedWriter(new FileWriter(""output.txt"", false));
 
 		String line = in.readLine();
 		int cases = Integer.parseInt(line); // # of test cases
 
 		for (int i = 1; i <= cases; i++)
 		{
 			line = in.readLine();
 			String[] p = line.split("" "");
 			int n = Integer.parseInt(p[0]); // # existing dirs
 			int m = Integer.parseInt(p[1]); // # dirs to create
 
 			Set<String> dirs = new HashSet<String>();
 
 			for (int j = 0; j < n; j++)
 			{
 				line = in.readLine();
 
 				int x = line.indexOf('/', 1);
 				while (x > -1)
 				{
 					String d = line.substring(0, x);
 					dirs.add(d);
 					x = line.indexOf('/', x + 1);
 				}
 
 				dirs.add(line);
 			}
 
 			int c = 0;
 			for (int k = 0; k < m; k++)
 			{
 				line = in.readLine();
 
 				int x = line.indexOf('/', 1);
 				while (x > -1)
 				{
 					String d = line.substring(0, x);
 					if (!dirs.contains(d))
 					{
 						dirs.add(d);
 						c++;
 					}
 					x = line.indexOf('/', x + 1);
 				}
 
 				if (!dirs.contains(line))
 				{
 					dirs.add(line);
 					c++;
 				}
 
 			}
 
 			out.write(""Case #"" + i + "": "" + c);
 			out.newLine();
 		}
 
 		in.close();
 		out.close();
 
 	}
 
 	private static void prt(String m)
 	{
 		System.out.println(m);
 	}
 }
 
 
 
",0
450,9741,"package round1;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Scanner;
 
 public class DeceitfulWar {
 	
 	public DeceitfulWar(String filename){
 		Scanner s=null;
 		try {
 			s = new Scanner(new File(filename));
 		} catch (FileNotFoundException e){
 			e.printStackTrace();
 		}
 
 		String output = """";
 		int testCases = s.nextInt();
 		
 		for (int t = 1; t <= testCases; t++){
 			
 			// reading blocks in
 			int N = s.nextInt();
 			List<Double> naomiBlocks = new ArrayList<Double>();
 			List<Double> kenBlocks = new ArrayList<Double>();
 			
 			for(int b = 0; b < N; b++){
 				naomiBlocks.add(s.nextDouble());
 			}
 			for(int b = 0; b < N; b++){
 				kenBlocks.add(s.nextDouble());
 			}
 			
 			// Play 'War'
 			int warScore = playWar(naomiBlocks, kenBlocks);
 			int deceitfulWarScore = playDeceitfulWar(naomiBlocks, kenBlocks);
 			
 			output += ""Case #""+t+"": ""+deceitfulWarScore+"" ""+warScore+""\n"";
 		}
 		
 		System.out.println(output);
 		
 	}
 	
 	/**
 	 * @param n - naomi blocks
 	 * @param k - ken blocks
 	 * @return
 	 */
 	private int playDeceitfulWar(List<Double> n, List<Double> k) {
 		
 		List<Double> naomiBlocks = new ArrayList<Double>(n);
 		List<Double> kenBlocks = new ArrayList<Double>(k);
 		
 		int naomiScore = 0;
 		
 		for (int b = 0; b < n.size(); b++){ // loop N (number of blocks) times
 			Collections.sort(naomiBlocks);
 			Collections.sort(kenBlocks);
 			double nextNBlock = naomiBlocks.get(0); // if there are none higher than min kenBlock, use min naomiBlock
 			double lowestKenBlock = kenBlocks.get(0);
 			double highestKenBlock = kenBlocks.get(kenBlocks.size()-1);
 			
 			for (double nBlock : naomiBlocks){
 				if(nBlock > lowestKenBlock){
 					nextNBlock = nBlock; // use the next highest naomi block
 					break;
 				}
 			}
 			double chosenNaomi = nextNBlock;
 			double toldNaomi = chosenNaomi;
 			
 			if(chosenNaomi > lowestKenBlock){
 				// there should always be room for this before number => 1
 				// also, this shouldn't have a collision with an already-existing value because it's 7dp
 				toldNaomi = highestKenBlock + 0.0000001; 
 			}
 			double chosenKen = kenChoose(toldNaomi, kenBlocks);
 			kenBlocks.remove(chosenKen);
 			naomiBlocks.remove(chosenNaomi);
 			if (chosenNaomi > chosenKen)
 				naomiScore++;
 		}
 		return naomiScore;
 	}
 
 	private int playWar(List<Double> naomiBlocks, List<Double> kenBlocks) {
 		List<Double> n = new ArrayList<Double>(naomiBlocks);
 		List<Double> k = new ArrayList<Double>(kenBlocks);
 		
 		Collections.sort(n);
 		int naomiScore = 0;
 		
 		for (int b = 0; b < n.size(); b++){
 			double chosenNaomi = n.get(b);
 			double chosenKen = kenChoose(chosenNaomi, k);
 			k.remove(chosenKen);
 			if (chosenNaomi > chosenKen)
 				naomiScore++;
 		}
 		return naomiScore;
 	}
 
 	private double kenChoose(double naomiBlock, List<Double> kenBlocks) {
 		Collections.sort(kenBlocks);
 	//	System.out.println(""kenblocks:\n""+Arrays.toString(kenBlocks.toArray()));
 		for(double kenBlock : kenBlocks){
 			if(kenBlock > naomiBlock)
 				// return next highest block (if there is one).
 				return kenBlock;
 		}
 		// else return lowest block
 		return kenBlocks.get(0);
 	}
 
 	public static void main(String[] args){
 		String path = ""res/war/"";
 		String filename = path+""D-large.in"";
 		new DeceitfulWar(filename);
 	}
 	
 	
 }","package round1;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 public class CookieClicker {
 
 	public CookieClicker(String filename){
 		Scanner s=null;
 		try {
 			s = new Scanner(new File(filename));
 		} catch (FileNotFoundException e){
 			e.printStackTrace();
 		}
 
 		String output = """";
 		
 		int testCases = s.nextInt();
 		for (int t = 1; t <= testCases; t++){
 			
 			double cookieRate = 2;
 			double farmCost = s.nextDouble();
 			double farmRate = s.nextDouble();
 			double goalCookies = s.nextDouble();
 			
 			double timeLeftNoFarms;
 			double timeNextFarm;
 			double timeLeftExtraFarm;
 			
 			double timeTaken = 0;
 			
 			do {
 				
 				timeLeftNoFarms = goalCookies / cookieRate;
 				timeNextFarm = farmCost / cookieRate;
 				timeLeftExtraFarm = timeNextFarm + (goalCookies / (cookieRate + farmRate));
 				
 				if (timeLeftExtraFarm < timeLeftNoFarms){
 					cookieRate += farmRate;
 					timeTaken += timeNextFarm;
 				}
 				else {
 					timeTaken += timeLeftNoFarms;
 				}
 				
 			} while (timeLeftExtraFarm < timeLeftNoFarms);
 			
 			output += String.format(""Case #%d: %.7f\n"", t, timeTaken);
 		}
 		
 		System.out.println(output);
 	}
 	
 	public static void main(String[] args){
 		String path = ""res/cookie/"";
 		String filename = path+""B-large.in"";
 		new CookieClicker(filename);
 	}
 	
 }
",1
451,6489,"import java.util.Scanner;
 import java.math.BigInteger;
 
 
 public class Snapper
 {
   public static void main(String[] args)
   {
     Scanner s = new Scanner(System.in);
     int t = s.nextInt();
 
     for (int i = 1; i <= t; i++)
     {
       int n = s.nextInt();
       int k = s.nextInt();
 
       BigInteger pow = BigInteger.valueOf(2).pow(n);
       boolean on = BigInteger.valueOf(k).mod(pow).equals(pow.subtract(BigInteger.ONE));
       System.out.println(""Case #"" + i + "": "" + (on ? ""ON"" : ""OFF""));
     }
   }
 }
 
","import java.util.Scanner;
 import java.util.LinkedList;
 import java.util.Deque;
 
 public class ThemePark
 {
   public static void main(String[] args)
   {
     Scanner s = new Scanner(System.in);
     int t = s.nextInt();
 
     for (int i = 1; i <= t; i++)
     {
       int r = s.nextInt();
       int k = s.nextInt();
       int n = s.nextInt();
 
       Deque<Integer> groups = new LinkedList<Integer>();
       for (int j = 0; j < n; j++)
       {
         groups.offerLast(s.nextInt());
       }
 
       long euros = calculate(r, k, groups);
       System.out.println(""Case #"" + i + "": "" + euros);
     }
 
   }
 
   public static long calculate(int runs, int capacity, Deque<Integer> groups)
   {
     long euros = 0;
     for (int i = 0; i < runs; i++)
     {
       int passengers = 0;
       int numGroups = 0;
       while (passengers + groups.peekFirst() <= capacity &&
              numGroups < groups.size())
       {
         int g = groups.removeFirst();
         passengers += g;
         groups.offerLast(g);
         numGroups++;
       }
       euros += passengers;
     }
     return euros;
   }
 }
 
",1
452,6688,"package gcj;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class NewLotteryGame {
 
 	public static void main(String[] args) throws Exception {
 		String name = ""B-large"";
 		Scanner scanner = new Scanner(new File(""C:\\Users\\m\\Desktop\\training\\""+name+"".in""));
 		final int len = scanner.nextInt() + 1;
 		FileWriter fw = new FileWriter(""C:\\Users\\m\\Desktop\\training\\""+name+"".out"");
 		BufferedWriter out = new BufferedWriter(fw);
 		for (int i = 1; i < len; i++) {
 			long A = scanner.nextLong();
 			long B = scanner.nextLong();
 			long K = scanner.nextLong();
 			String str = ""Case #"" + i + "": "" + solve(new RangeLess(A), new RangeLess(B), new RangeLess(K));
 			System.out.println(str);
 			out.write(str);
 			out.newLine();
 		}
 		out.flush();
 		out.close();
 	}
 	
 	private static int solve(RangeLess A, RangeLess B, RangeLess K) {
 		//System.out.println(A + "" "" + B + "" "" + K);
 		int r = 0;
 		for (int i = 0; i < A.howManyOne; i ++) {
 			for (int j = 0; j < B.howManyOne; j++) {
 				for (int k = 0; k < K.howManyOne; k++) {
 					final int d = matchClasses(A.classes[i], B.classes[j], K.classes[k]);
 					//System.out.println(""r+="" + d);
 					r += d;
 				}
 			}
 		}
 		return r;
 	}
 	
 	private static final int matchClasses(NumberClass A, NumberClass B, NumberClass K) {
 		int bitA = A.nbBits;
 		int bitB = B.nbBits;
 		int bitK = K.nbBits;
 		int maxBit = Math.max(Math.max(bitA, bitB), bitK);
 		int r = 1;
 		for (int i = 0; i < maxBit; i++) {
 			char a = A.charAt(i);
 			char b = B.charAt(i);
 			char k = K.charAt(i);
 			int ri = match(a, b, k);
 			//System.out.println(ri);
 			if (ri == 0) {
 				return 0;
 			}
 			r *= ri;
 		}
 		return r;
 	}
 	
 	private static int match(char a, char b, char k) {
 		//System.out.println(a + "" "" + b + "" "" + k);
 		if (a == '?' && b == '?') {
 			if (k == '?') {
 				return 4;
 			}
 			if (k == '0') {
 				return 3;
 			}
 			return 1;
 		}
 		if (a == '0' && b == '0') {
 			if (k == '1') {
 				return 0;
 			}
 			return 1;
 		}
 		if (a == '1' && b == '1') {
 			if (k == '0') {
 				return 0;
 			}
 			return 1;
 		}
 		if ((a == '?' && b == '0') || (a == '0' && b == '?')) {
 			if (k == '1') {
 				return 0;
 			}
 			return 2;
 		}
 		if ((a == '?' && b == '1') || (a == '1' && b == '?')) {
 			if (k == '?') {
 				return 2;
 			}
 			return 1;
 		}
 		if ((a == '0' && b == '1') || (a == '1' && b == '0')) {
 			if (k == '1') {
 				return 0;
 			}
 			return 1;
 		}
 		return 0;
 	}
 
 	private static final class RangeLess {
 		private final long max;
 		private final String binary;
 		private final int howManyOne;
 		private final int nbBits;
 		private final NumberClass[] classes;
 		RangeLess(long max) {
 			this.max = max;
 			binary = Long.toBinaryString(max);
 			nbBits = binary.length();
 			int howManyOneTmp = 0;
 			for (int i = 0; i < nbBits; i++) {
 				if (binary.charAt(i) == '1') {
 					howManyOneTmp++;
 				}
 			}
 			howManyOne = howManyOneTmp;
 			classes = new NumberClass[howManyOne];
 			int currentBit = 0;
 			int i = 0;
 			while (currentBit != -1) {
 				classes[i] = new NumberClass(binary, currentBit, nbBits);
 				currentBit = binary.indexOf('1', currentBit + 1);
 				i++;
 			}
 		}
 		@Override
 		public String toString() {
 			StringBuffer buff = new StringBuffer(""RangeLess "");
 			buff.append(max);
 			buff.append("":\n"");
 			for (int i = 0; i < howManyOne; i++) {
 				buff.append(classes[i]);
 				buff.append('\n');
 			}
 			buff.append('\n');
 			return buff.toString();
 		}
 	}
 	
 	private static final class NumberClass {
 		private final int nbBits;
 		private final char[] bits;
 		char charAt(int i) {
 			int idx = nbBits - i - 1;
 			if (idx < 0) {
 				return '0';
 			}
 			return bits[idx];
 		}
 		NumberClass(String binary, int bitPos, int nbBits) {
 			this.nbBits = nbBits;
 			bits = new char[nbBits];
 			for(int i = 0; i < nbBits; i++) {
 				if (i < bitPos) {
 					bits[i] = binary.charAt(i);
 				} else if (i == bitPos) {
 					bits[i] = '0';
 				} else {
 					bits[i] = '?';
 				}
 			}
 		}
 		@Override
 		public String toString() {
 			return new String(bits);
 		}
 	}
 	
 }
","package gcj;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.Scanner;
 
 public class Bullseye {
 
 	public static void main(String[] args) throws Exception {
 		String name = ""A-small"";
 		Scanner scanner = new Scanner(new File(""C:\\Users\\m\\Desktop\\training\\""+name+"".in""));
 		final int len = scanner.nextInt() + 1;
 		FileWriter fw = new FileWriter(""C:\\Users\\m\\Desktop\\training\\""+name+"".out"");
 		BufferedWriter out = new BufferedWriter(fw);
 		for (int i = 1; i < len; i++) {
 			long r = scanner.nextLong();
 			long t = scanner.nextLong();
 			String str = ""Case #"" + i + "": "" + solve(r, t);
 			System.out.println(str);
 			out.write(str);
 			
 			out.newLine();
 		}
 		out.flush();
 		out.close();
 	}
 
 	private static long solve(long r, long t) {
 		long count = 1;
 		long currentRadiusDelta =  2 * r + 1;
 		long remainQ = t;
 		remainQ -= currentRadiusDelta;
 		currentRadiusDelta += 4;
 		long nextRemainQ = remainQ;
 		nextRemainQ -= currentRadiusDelta;
 		while (nextRemainQ >= 0) {
 			count++;
 			remainQ = nextRemainQ;
 			currentRadiusDelta += 4;
 			nextRemainQ -= currentRadiusDelta;
 		} 
 		return count;
 	}
 }
",1
453,8213,"package qualification;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class CookieMiner {
 	static final String inFile = ""B-large.in"";
 	static final String outFile = ""B-largeOUT.txt"";
 	static Scanner scanner;
 	static PrintWriter writer;
 	
 	public static void main(String[] args) throws IOException{
 		scanner = new Scanner(new File(inFile));
 		writer = new PrintWriter(new File(outFile));
 		int numOfTests = scanner.nextInt();
 		for(int i = 0; i < numOfTests; i++){
 			solve(i+1);
 		}
 		writer.flush();
 		scanner.close();
 		writer.close();
 		
 	}
 	public static void solve(int caseNum){
 		double speed = 2.0;
 		double cost = scanner.nextDouble();
 		double extra = scanner.nextDouble();
 		double goal = scanner.nextDouble();
 		
 		double totalTime = 0;
 		
 		if (goal < cost) totalTime = goal / speed;
 		else {
 			
 			while(true){
 				double timeToBonus = cost / speed;
 				double timeNoBonus = goal/speed;
 				double timeWithBonus = timeToBonus + goal/(speed + extra);
 				
 				if (timeWithBonus > timeNoBonus){
 					totalTime += timeNoBonus;
 					break;
 				}
 				else{
 					speed += extra;
 					totalTime += timeToBonus;
 				}
 			}
 		}
 		String s =""Case #""+caseNum + "": "" + totalTime;
 		writer.println(s);
 		System.out.println(s);
 	}
 }
","import java.io.*;
 public class LawnMower
 {
     public static int numberOfCases;
     public static int[][] pattern;
     public static void main() {
         try{
             BufferedReader reader = new BufferedReader(new FileReader(""B-small-attempt0.in""));
             PrintWriter writer = new PrintWriter(""answer.in"");
             String s = reader.readLine();
             numberOfCases = Integer.parseInt(s);
             for (int i = 0; i < numberOfCases; i++) {
                 initializeArray(reader);
                 printArray();
                 if (patternIsValid()) writer.print(""Case #"" + (i + 1) + "": YES"");
                 else writer.print(""Case #"" + (i + 1) + "": NO"");
                 if (i != numberOfCases - 1) writer.println("""");
             }
             writer.flush();
         }catch(Exception e){e.printStackTrace();}
         System.out.println(""CHA!"");
     }
     
     public static boolean patternIsValid() {
         for (int i = 0; i < pattern.length; i++) {
             int max = maxInRow(i);
             for (int j = 0; j < pattern[i].length; j++){
                 if (pattern[i][j] < max) 
                     if (!checkColumn(j, pattern[i][j])) return false;
             }
         }
         return true;
     }
     
     public static int maxInRow(int row)
     {
         int max = pattern[row][0];
         for (int i = 1; i < pattern[row].length; i++)
             if (pattern[row][i] > max) max = pattern[row][i];
         return max;
     }
     
     public static boolean checkColumn(int col, int max)
     {
         for (int i = 0; i < pattern.length; i++)
             if (pattern[i][col] > max) return false;
         return true;
     }
     
     public static void initializeArray(BufferedReader reader) {
         try{
             String[] data = reader.readLine().split("" "");
             int rows = Integer.parseInt(data[0]);
             int cols = Integer.parseInt(data[1]);
             pattern = new int[rows][cols];
             for (int i = 0; i < rows; i++) {
                 data = reader.readLine().split("" "");
                 for (int j = 0; j < cols; j++) {
                     pattern[i][j] = Integer.parseInt(data[j]);
                 }
             }        
         }catch(Exception e) {e.printStackTrace();}
     }
     
     public static void printArray() {
         for(int i = 0; i < pattern.length; i++) {
             for (int j = 0; j < pattern[i].length; j++)
                 System.out.print(pattern[i][j] + "" "");
             System.out.println();
         }
         System.out.println();
     }
     
     
 
 }
",1
454,2440,"import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 public class A {
   public static void main(String[] args) throws Exception {
     if (args.length != 2) {
       System.err.println(""Usage: java "" + A.class.getName()
           + "" [input] [output]"");
       System.exit(1);
     }
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     BufferedWriter bw = new BufferedWriter(new FileWriter(args[1]));
     int testCases = Integer.parseInt(br.readLine());
     for (int testCase = 1; testCase <= testCases; testCase++) {
       bw.write(""Case #"" + testCase + "": "");
       boolean feglaWon = false;
       int n = Integer.parseInt(br.readLine());
       String pattern = null;
       List<List<Integer>> allCounts = new ArrayList<List<Integer>>();
       for (int i = 0; i < n; i++) {
         String line = br.readLine();
         char lastChar = '*';
         List<Integer> counts = new ArrayList<Integer>();
         int count = 0;
         StringBuilder sb = new StringBuilder();
         for (char c : line.toCharArray()) {
           if (lastChar == '*') {
             lastChar = c;
             sb.append(c);
             count = 1;
           } else if (lastChar == c) {
             count++;
           } else {
             counts.add(count);
             sb.append(c);
             lastChar = c;
             count = 1;
           }
         }
         counts.add(count);
         allCounts.add(counts);
         if (pattern == null) {
           pattern = sb.toString();
         } else if (!pattern.equals(sb.toString())) {
           feglaWon = true;
         }
       }
       if (feglaWon) {
         bw.write(""Fegla Won\n"");
       } else {
         int result = 0;
         for (int i = 0; i < pattern.length(); i++) {
           List<Integer> current = new ArrayList<Integer>();
           int min = 100, max = 1;
           for (List<Integer> counts : allCounts) {
             int next = counts.get(i);
             current.add(next);
             min = Math.min(min, next);
             max = Math.max(max, next);
           }
           int minTotal = Integer.MAX_VALUE;
           for (int j = min; j <= max; j++) {
             int total = 0;
             for (int c : current) {
               total += Math.abs(c - j);
             }
             minTotal = Math.min(minTotal, total);
           }
           result += minTotal;
         }
         bw.write(result + ""\n"");
       }
     }
     br.close();
     bw.close();
   }
 }
","package codejam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class B {
   public static void main(String[] args) throws Exception {
     BufferedReader br = new BufferedReader(new FileReader(
         ""B-large.in""));
     BufferedWriter bw = new BufferedWriter(new FileWriter(
         ""B-large.out""));
     String line = br.readLine(); /* Skip number of test cases. */
     int testCase = 1;
     while ((line = br.readLine()) != null) {
       if (line.length() == 0) {
         continue;
       }
       String[] parts = line.split("" "");
       double c = Double.parseDouble(parts[0]);
       double f = Double.parseDouble(parts[1]);
       double x = Double.parseDouble(parts[2]);
       int factories = 0;
       double best = x / 2.0, factoryTime = 0.0;
       while (true) {
         factoryTime += c / (2.0 + factories++ * f);
         double newTime = factoryTime + x / (2.0 + factories * f);
         if (newTime > best) {
           break;
         }
         best = newTime;
       }
       bw.write(String.format(""Case #%d: %.7f%n"", testCase++, best));
     }
     br.close();
     bw.close();
   }
 }
",1
455,3927,"package gcj;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.Scanner;
 
 public class GCJ2013r1CqC {
 	private static final int MAX_EAST = 1000000;
 	private static final int MAX_WEST = -1000000;
 
 	public static void main(String[] args) throws Exception {
 		final String FILE_DIR = ""/Users/jhorwitz/Downloads/"";
 		File inFile = new File(FILE_DIR + ""C-small-attempt0.in"");
 		File outFile = new File(FILE_DIR + ""gcj2013R1C-qC-s.txt"");
 		Writer writer = new FileWriter(outFile);
 		Scanner scanner = new Scanner(inFile);
 
 		int T = scanner.nextInt();
 		for (int t = 1; t <= T; ++t) {
 			int N = scanner.nextInt();
 
 			long[] d = new long[N];
 			long[] n = new long[N];
 			long[] w = new long[N];
 			long[] e = new long[N];
 			long[] s = new long[N];
 			long[] deltaD = new long[N];
 			long[] deltaP = new long[N];
 			long[] deltaS = new long[N];
 
 			// initialize values to store boundaries
 			long lastDayAllTribes = -1;
 			long westernLimitAllTribes = MAX_EAST+1;
 			long easternLimitAllTribes = MAX_WEST-1;
 
 			for (int tribe = 0; tribe < N; ++tribe) {
 				d[tribe] = scanner.nextLong();
 				n[tribe] = scanner.nextLong();
 				w[tribe] = scanner.nextLong();
 				e[tribe] = scanner.nextLong();
 				s[tribe] = scanner.nextLong();
 				deltaD[tribe] = scanner.nextLong();
 				deltaP[tribe] = scanner.nextLong();
 				deltaS[tribe] = scanner.nextLong();
 
 				long lastDayThisTribe = d[tribe] + n[tribe]*deltaD[tribe];
 				lastDayAllTribes = Math.max(lastDayAllTribes, lastDayThisTribe);
 				long westernLimitThisTribe;
 				long easternLimitThisTribe;
 				if (deltaP[tribe] > 0) { // tribe goes east
 					westernLimitThisTribe = w[tribe];
 					easternLimitThisTribe = e[tribe] + (n[tribe] - 1)*deltaP[tribe];
 				} else { // tribe goes west
 					westernLimitThisTribe = w[tribe] + (n[tribe] - 1)*deltaP[tribe];
 					easternLimitThisTribe = e[tribe];
 				}
 				westernLimitAllTribes = Math.min(westernLimitAllTribes, westernLimitThisTribe);
 				easternLimitAllTribes = Math.max(easternLimitAllTribes, easternLimitThisTribe);
 			}
 
 			long[] wallHeightWhereZeroMeansFarthestWest = new long[(int)(easternLimitAllTribes - westernLimitAllTribes)];
 			long numSuccessfulAttacks = 0;
 			for (int day = 0; day <= lastDayAllTribes; ++day) {
 				long[] nextWallHeight = wallHeightWhereZeroMeansFarthestWest.clone();
 				for (int tribe = 0; tribe < N; ++tribe) {
 					boolean attackSucceeds = false;
 					if (day < d[tribe] || day > d[tribe] + (n[tribe] - 1)*deltaD[tribe] || (day - d[tribe]) % deltaD[tribe] != 0) continue; // this tribe doesn't attack today
 
 					long numAttacksSoFarFromThisTribe = (day - d[tribe]) / deltaD[tribe];
 
 					long wForToday = w[tribe] + (numAttacksSoFarFromThisTribe)*deltaP[tribe];
 					long eForToday = e[tribe] + (numAttacksSoFarFromThisTribe)*deltaP[tribe];
 					long sForToday = s[tribe] + (numAttacksSoFarFromThisTribe)*deltaS[tribe];
 					for (long posFromFarthestWest = wForToday-westernLimitAllTribes; posFromFarthestWest < eForToday-westernLimitAllTribes; ++posFromFarthestWest) {
 						if (wallHeightWhereZeroMeansFarthestWest[(int)posFromFarthestWest] < sForToday) {
 							attackSucceeds = true;
 							nextWallHeight[(int)posFromFarthestWest] = sForToday;
 						}
 					}
 
 					if(attackSucceeds) ++numSuccessfulAttacks;
 				}
 				wallHeightWhereZeroMeansFarthestWest = nextWallHeight;
 			}
 
 			output(writer, t, String.valueOf(numSuccessfulAttacks));
 		}
 		scanner.close();
 		writer.close();
 	}
 
 	public static void output(Writer w, int t, String s) throws IOException {
 		w.write(""Case #"" + t + "": "" + s + ""\n"");
 		System.out.println(""Case #"" + t + "": "" + s);
 	}
 }","package gcj;
 
 /*
  * Problem D. Treasure
 Confused? Read the quick-start guide.
 Small input
 20 points 
 Solve D-small
 You may try multiple times, with penalties for wrong submissions.
 Large input
 60 points 
 You must solve the small input first.
 You will have 8 minutes to solve 1 input file. (Judged after contest.)
 Problem
 
 Following an old map, you have stumbled upon the Dread Pirate Larry's secret treasure trove!
 
 The treasure trove consists of N locked chests, each of which can only be opened by a key of a specific type. Furthermore, once a key is used to open a chest, it can never be used again. Inside every chest, you will of course find lots of treasure, and you might also find one or more keys that you can use to open other chests. A chest may contain multiple keys of the same type, and you may hold any number of keys.
 
 You already have at least one key and your map says what other keys can be found inside the various chests. With all this information, can you figure out how to unlock all the chests?
 
 For example, suppose the treasure trove consists of four chests as described below, and you began with exactly one key of type 1:
 
 Chest Number  |  Key Type To Open Chest  |  Key Types Inside
 --------------+--------------------------+------------------
 1             |  1                       |  None
 2             |  1                       |  1, 3
 3             |  2                       |  None
 4             |  3                       |  2
 You can open all the chests in this example if you do them in the order 2, 1, 4, 3. If you start by opening chest #1 first, then you will have used up your only key, and you will be stuck.
 Input
 
 The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing two positive integers K and N, representing the number of keys you start with and the number of chests you need to open.
 
 This is followed by a line containing K integers, representing the types of the keys that you start with.
 
 After that, there will be N lines, each representing a single chest. Each line will begin with integers Ti and Ki, indicating the key type needed to open the chest and the number of keys inside the chest. These two integers will be followed by Ki more integers, indicating the types of the keys contained within the chest.
 
 Output
 
 For each test case, output one line containing ""Case #x: C1 C2 ... CN"", where x is the case number (starting from 1), and where Ci represents the index (starting from 1) of the ith chest that you should open.
 
 If there are multiple ways of opening all the chests, choose the ""lexicographically smallest"" way. In order words, you should choose to make C1 as small as possible, and if there are multiple ways of making C1 as small as possible, choose the one that makes C2 as small as possible, and so on.
 
 If there is no way to open all the chests, you should instead output one line containing ""Case #x: IMPOSSIBLE"".
 
 Limits
 
 1  T  25.
 1  K.
 All chest types and key types will be integers between 1 and 200 inclusive.
 Small dataset
 
 1  N  20.
 In each test case, there will be at most 40 keys altogether.
 Large dataset
 
 1  N  200.
 In each test case, there will be at most 400 keys altogether.
 Sample
 
 
 Input 
   
 Output 
  
 3
 1 4
 1
 1 0
 1 2 1 3
 2 0
 3 1 2
 3 3
 1 1 1
 1 0
 1 0
 1 0
 1 1
 2
 1 1 1
 Case #1: 2 1 4 3
 Case #2: 1 2 3
 Case #3: IMPOSSIBLE
 
  */
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.Scanner;
 
 public class GCJ2013RQD {
   public static void main(String[] args) throws Exception {
     final String FILE_DIR = ""/Users/jhorwitz/Downloads/"";
     File inFile = new File(FILE_DIR + ""D-small-attempt0.in"");
     File outFile = new File(FILE_DIR + ""gcj2013-rq-D-s.txt"");
     Writer w = new FileWriter(outFile);
     Scanner s = new Scanner(inFile);
 
     int T = s.nextInt();
     for (int t = 1; t <= T; ++t) {
       int currentKeys[] = new int[201]; // one-based ... ignore currentKeys[0]
       // init (to 0) current keyring
       for (int key = 1; key <= 200; ++key) {
         currentKeys[key] = 0;
       }
 
       int K = s.nextInt();
       int N = s.nextInt();
 
       // read in initial keyring
       for (int i = 1; i <= K; ++i) {
         (currentKeys[s.nextInt()])++;
       }
 
       int keyToOpen[] = new int[N+1]; // keyToOpen[i] == type of key that opens chest i
 
       int keysInChest[][] = new int[N+1][200+1]; // keysInChest[2][3] == how many keys of type 3 are in chest 2 (e.g.)
       int numKeysInChest[] = new int[N+1];
       for (int chest = 1; chest <= N; ++chest) {
         // init (to 0) keysInChest[chest]
         for (int key = 1; key <= 200; ++key) {
           keysInChest[chest][key] = 0;
         }
 
         keyToOpen[chest] = s.nextInt();
 
         numKeysInChest[chest] = s.nextInt();
         for (int i = 1; i <= numKeysInChest[chest]; ++i) {
           (keysInChest[chest][s.nextInt()])++;
         }
       }
       // now input is (finally!) read in
 
       boolean solutionFound = false;
       int potentialSolution[] = new int[N+1];
       potentialSolution[1] = 0;
       int firstPositionToIncrement = 1; // so first call to nextOrdering will set potentialSolution to (1,2,...,N)
       while (nextOrdering(firstPositionToIncrement, potentialSolution, N)) {
         firstPositionToIncrement = checkForSolution(potentialSolution, N, currentKeys, keyToOpen, numKeysInChest, keysInChest);
         if (firstPositionToIncrement == 0) {
           solutionFound = true;
           break;
         }
       }
       if (solutionFound) {
         output(w, t, makeStringOfSolution(potentialSolution, N));
       } else {
         output(w, t, ""IMPOSSIBLE"");
       }
     }
     s.close();
     w.close();
   }
 
   /*
    * @returns first position to increment when going to next potential solution (i.e., where things first broke); returns 0 if we found a solution! 
    */
   private static int checkForSolution(int[] potentialSolution, int N, int[] initialKeys, int[] keyToOpen, int[] numKeysInChest, int[][] keysInChest) {
     int[] currentKeys = new int[201];
     System.arraycopy(initialKeys, 0, currentKeys, 0, N+1);
     for (int i = 1; i <= N; ++i) {
       // try opening chest potentialSolution[i]
       int chestToOpenNow = potentialSolution[i];
       if ( --(currentKeys[keyToOpen[chestToOpenNow]]) < 0 ) return i; // we don't have the right key to open chestToOpenNow;
 
       // add newfound keys to currentKeys
       for (int key = 1; key <= 200; ++key) {
         currentKeys[key] += keysInChest[chestToOpenNow][key];
       }
     }
     return 0; // success!
   }
 
   private static String makeStringOfSolution(int[] potentialSolution, int N) {
     StringBuilder sb = new StringBuilder();
 
     for (int i = 1; i < N; ++i) {
       sb.append(potentialSolution[i] + "" "");
     }
     sb.append(potentialSolution[N]);
 
     return sb.toString();
   }
 
   /*
    *  changes potentialsSolution to next permutation on (1,2,...,N) after
    *  potentialSolution where value at firstPositionToIncrement is
    *  incrementing--carrying forward as necessary, and resetting later
    *  positions to lexicographically first possible sequence
    *
    * @returns false is there were no more orderings (true otherwise)
    */
   private static boolean nextOrdering(int firstPositionToIncrement, int[] potentialSolution, int N) {
     // figure out what values from 1 to N have been used in positions 1 to firstPositionToIncrement
     boolean[] alreadyUsed = new boolean[N+1]; // init to false
     for (int pos = 1; pos < firstPositionToIncrement; ++pos) {
       alreadyUsed[potentialSolution[pos]] = true;
     }
 
     // increment at firstPositionToIncrement ... and if it goes over max possible value, increment the value to the left (repeating as necessary)
     ++firstPositionToIncrement; // a cheat so we can decrement immediately in the loop and end with the right value (and have a ""meaningful"" value (for debugging) while in the loop
     do {
       --firstPositionToIncrement;
       if (firstPositionToIncrement == 0) return false;
       while ( ++(potentialSolution[firstPositionToIncrement]) <= N && alreadyUsed[potentialSolution[firstPositionToIncrement]] ) {
       }
     } while ( potentialSolution[firstPositionToIncrement] > N );
 
     // now set everything after firstPositionToIncrement to lexicographically first ordering of remaining numbers
 
     // figure out what values from 1 to N have been used
     alreadyUsed = new boolean[N+1]; // init to false
     for (int pos = 1; pos <= firstPositionToIncrement; ++pos) {
       alreadyUsed[potentialSolution[pos]] = true;
     }
 
     // now fill in positions firstPositionToIncrement+1 to N
     int possiblyAvailablePosition = 1;
     for (int pos = firstPositionToIncrement+1; pos <= N; ++pos) {
       while (alreadyUsed[possiblyAvailablePosition]) ++possiblyAvailablePosition;
       potentialSolution[pos] = possiblyAvailablePosition;
       ++possiblyAvailablePosition;
     }
 
     return true;
   }
 
   public static void output(Writer w, int t, String s) throws IOException {
     w.write(""Case #"" + t + "": "" + s + ""\n"");
     System.out.println(""Case #"" + t + "": "" + s);
   }
 }",1
456,8370,"package y2011.candySplitting;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.ArrayList;
 
 
 //n!*(n-1)/2で総当たり。。
 public class CandySplitting {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		String file = args[0];
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(file));
 			int times = Integer.valueOf(br.readLine());
 			int i,count;
 			String str;
 			for(i=0;i<times;i++){
 				count = Integer.valueOf(br.readLine());
 				str = br.readLine();
 				if(str==null){
 					System.out.println(""few input"");
 					break;
 				}
 				String[] datas = str.split("" "");
 				test(datas, count, i+1);
 			}
 			br.close();
 		} catch (Exception e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 	public static void test(String[] datas,int count, int num){
 		ArrayList<Integer> left = new ArrayList<Integer>(1000);
 		ArrayList<Integer> right = new ArrayList<Integer>(1000);
 		int sel,i,r;
 		for(String str : datas){
 			left.add(Integer.valueOf(str));
 		}
 		r = sumPatrick(left);
 		//Debug.print(""sum all by patrick: ""+r);
 		if(r!=0){
 			System.out.println(""Case #""+num+"": NO"");
 			return;
 		}
 		int min=left.get(0),minIndex=0;
 		for(i=1; i<left.size(); i++){
 			int v = left.get(i);
 			if(v<min){
 				minIndex = i;
 				min = v; 
 			}
 		}
 		left.remove(minIndex);
 		System.out.println(""Case #""+num+"": ""+sumSean(left));
 	}
 	
 	public static long sumSean(ArrayList<Integer> list){
 		long r=0;
 		for(int i=0;i<list.size();i++){
 			r += list.get(i);
 		}
 		return r;
 	}
 	public static int sumPatrick(ArrayList<Integer> list){
 		int r = list.get(0);
 		for(int i=1;i<list.size();i++){
 			r = r ^ list.get(i);
 		}
 		return r;
 	}
 }
","package y2011.freecell;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.util.ArrayList;
 
 import y2011.Debug;
 
 public class FreeCell {
 	public static void main(String[] args) {
 		// TODO Auto-generated method stub
 		String file = args[0];
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(file));
 			int times = Integer.valueOf(br.readLine());
 			int i,count;
 			String str;
 			for(i=0;i<times;i++){
 				count = 3;
 				str = br.readLine();
 				if(str==null){
 					System.out.println(""few input"");
 					break;
 				}
 				String[] datas = str.split("" "");
 				test(datas, count, i+1);
 			}
 			br.close();
 		} catch (Exception e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	}
 	public static void test(String[] datas,int count, int num){
 		int n,pd,pg;
 		n = Integer.valueOf(datas[0]);
 		pd = Integer.valueOf(datas[1]);
 		pg = Integer.valueOf(datas[2]);
 		int w=0,l=0;
 		cal_d:
 		for(w=0;w<=n;w++){
 			for(l=0;l<=(n-w);l++){
 				if(w==0 && l==0)
 					continue;
 				if(((double)(w*100))/(w+l) == (double)pd)
 					break cal_d;
 			}
 		}
 		if(w>n || l> n){
 			Debug.print(""error break;"");
 			System.out.println(""Case #""+num+"": Broken"");
 			return;
 		}
 		
 		Debug.print(""w:""+w+ ""  l:"" + l + ""  pd""+pd);
 		int dw=w, dl = l;
 		int s;
 		int limit=30000;
 		cal_is_possible:
 		for(s=0;s<limit;s++){
 			for(w=0;w<=s;w++){
 				l = s-w;
 				if(dw+dl+w+l==0)
 					continue;
 				if(((double)(dw+w))*100/((double)(dw+w+dl+l)) == (double)pg)
 					break cal_is_possible;
 			}
 		}
 		Debug.print(""w:""+(w+dw)+ ""  l:"" + (l+dl) + ""  s""+s);
 		if(s>=limit){
 			System.out.println(""Case #""+num+"": Broken"");
 		}else{
 			System.out.println(""Case #""+num+"": Possible"");
 		}
 		
 		
 	}
 }
 
 
 
 
 
 
 
 
 
 
",1
457,16472,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class Palindrome {
 
 	public static void main(String[] args){
 		Palindrome p = new Palindrome();
 		p.find();
 	}
 	
 	public void find(){
 		Scanner scan;
 		try {
 			scan = new Scanner(new File(""input.txt""));
 			PrintStream p = new PrintStream(""output.txt"");
 			long num = scan.nextInt();
 			//while(scan.hasNextLine()){p.prlongln(scan.nextLine());}
 			for(long i = 1; i <= num; i++){
 				int count = 0;
 				long start = scan.nextInt();
 				long end = scan.nextInt();
 				long sqStart = (long)Math.ceil(Math.pow(start, 0.5));
 				long sqEnd = (long)Math.floor(Math.pow(end, 0.5));
 				//System.out.println(start + "" "" + end + "" "" + sqStart + "" "" +sqEnd);
 				for(long x = sqStart; x <= sqEnd; x++){
 					if(isPalindrome(x) && isPalindrome(x*x)){
 						count++;
 					}
 				}
 				p.println(""Case #"" + i +"": "" + count);
 				System.out.println(""Case #"" + i +"": "" + count);
 
 			}
 			p.close();
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
 	}
 	
 	public boolean isPalindrome(long number) {
 		long x = number;
 		long reverse = 0;
 		while (x > 0) {
 			long dig = (x % 10);
 			reverse = reverse * 10 + dig;
 			x /= 10;
 		}
 		return reverse == number;
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Scanner;
 
 
 public class TicTacToe {
 	public static void main(String[] args){
 		TicTacToe t = new TicTacToe();
 		t.readInput();
 	}
 	
 	public void readInput(){
 		Scanner scan;
 		try {
 			scan = new Scanner(new File(""input.txt""));
 			int num = scan.nextInt();
 			int[][] matrix = new int[4][4];
 			//while(scan.hasNextLine()){System.out.println(scan.nextLine());}
 			for(int i = 1; i <= num; i++){
 				scan.nextLine();
 				for(int y = 0; y < 4; y++){
 					String line = scan.nextLine();
 					for(int x = 0; x < 4; x++){
 						matrix[y][x] = line.charAt(x);
 					}
 				}
 				//process array
 				//try each row
 				Boolean isWon = false;
 				Boolean empty = false;
 				for(int y = 0; y < 4; y++){
 					int sum = 0;
 					for(int x = 0; x < 4; x++){
 						if(matrix[y][x] == '.'){
 							empty = true;
 						}
 						sum += matrix[y][x];
 					}
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						System.out.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						System.out.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				//column
 				for(int x = 0; x < 4; x++){
 					int sum = 0;
 					for(int y = 0; y < 4; y++){
 						sum += matrix[y][x];
 					}
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						System.out.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						System.out.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				//Diagonal
 				int sum = 0;
 				for(int x = 0; x < 4; x++){
 					sum += matrix[x][x];
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						System.out.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						System.out.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				sum = 0;
 				for(int x = 0; x < 4; x++){
 					int y = 3 - x;
 					sum += matrix[y][x];
 					
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						System.out.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						System.out.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				if(!isWon){
 					if(empty){
 						System.out.println(""Case #"" + i + "": Game has not completed"");
 					}else {
 						System.out.println(""Case #"" + i + "": Draw"");
 					}
 				}
 			}
 			
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 	}
 }
 
",1
458,6023,"import java.util.*;
 import java.io.*;
 
 class MakeSmooth
 {
 	public static void main(String[] args) throws IOException
 	{
 		BufferedReader fin = new BufferedReader(new FileReader(""A-large.in""));
 		PrintWriter fout = new PrintWriter(new FileWriter(""A-large.out""));
 		int T;
 		T = Integer.parseInt(fin.readLine());
 		for (int t = 1; t <= T; t++) {
 			String[] sp = fin.readLine().split("" "");
 			int N = Integer.parseInt(sp[0]);
 			int K = Integer.parseInt(sp[1]);
 			String[] board = new String[N];
 			for (int i = 0; i < N; ++i)
 				board[i] = fin.readLine();
 			try {
 				String ans = new MakeSmooth().solve(N, K, board);
 				fout.print(""Case #""+t+"": "");
 				System.out.print(""Case #""+t+"": "");
 				fout.println(ans);
 				System.out.println(ans);
 			} catch (Exception e) {
 				System.err.println(e);
 			}
 		}
 		fout.flush();
 		fout.close();
 	}
 	public String solve(int N, int K, String[] board)
 	{
 		char[][] b = new char[N][N];
 		for (int i = N-1; i > -1; --i) {
 			for (int j = 0; j < N; ++j) {
 				b[j][N-1-i] = board[i].charAt(j);
 			}
 		}
 		for (int i = 0; i < N; ++i) {
 			for (int j = N-1; j > -1; --j) {
 				if (b[j][i] != '.')
 					continue;
 				for (int k = j-1; k > -1; --k) {
 					if (b[k][i] == '.')
 						continue;
 					b[j][i] = b[k][i];
 					b[k][i] = '.';
 					break;
 				}
 			}
 		}
 		boolean red = false, blue = false;
 		for (int i = 0; i < N; ++i) {
 			for (int j = 0; j < N; ++j) {
 				if (b[i][j] == 'R') {
 					int cnt = 1;
 					for (int k = j+1; k < N; ++k) {
 						if (b[i][k] == 'R') {
 							cnt++;
 						} else {
 							break;
 						}
 					}
 					if (cnt >= K) {
 						red = true;
 						break;
 					}
 				}
 			}
 			if (red)
 				break;
 		}
 		for (int i = 0; i < N; ++i) {
 			for (int j = 0; j < N; ++j) {
 				if (b[i][j] == 'B') {
 					int cnt = 1;
 					for (int k = j+1; k < N; ++k) {
 						if (b[i][k] == 'B') {
 							cnt++;
 						} else {
 							break;
 						}
 					}
 					if (cnt >= K) {
 						blue = true;
 						break;
 					}
 				}
 			}
 			if (blue)
 				break;
 		}
 		if (!red) {
 			for (int i = 0; i < N; ++i) {
 				for (int j = 0; j < N; ++j) {
 					if (b[j][i] == 'R') {
 						int cnt = 1;
 						for (int k = j+1; k < N; ++k) {
 							if (b[k][i] == 'R') {
 								cnt++;
 							} else {
 								break;
 							}
 						}
 						if (cnt >= K) {
 							red = true;
 							break;
 						}
 					}
 				}
 				if (red)
 					break;
 			}
 		}
 		if (!blue) {
 			for (int i = 0; i < N; ++i) {
 				for (int j = 0; j < N; ++j) {
 					if (b[j][i] == 'B') {
 						int cnt = 1;
 						for (int k = j+1; k < N; ++k) {
 							if (b[k][i] == 'B') {
 								cnt++;
 							} else {
 								break;
 							}
 						}
 						if (cnt >= K) {
 							blue = true;
 							break;
 						}
 					}
 				}
 				if (blue)
 					break;
 			}
 		}
 		if (!red) {
 			for (int i = 0; i < N; ++i) {
 				int k = -1;
 				for (int j = 0; j < N; ++j) {
 					if (b[i][j] == 'R') {
 						k = j;
 						break;
 					}
 				}
 				if (k == -1)
 					continue;
 				int cnt = 1;
 				for (int x = i-1, y = k+1; x > -1 && y < N && b[x][y] == 'R'; x--, y++)
 					cnt++;
 				for (int x = i+1, y = k-1; x < N && y > -1 && b[x][y] == 'R'; x++, y--)
 					cnt++;
 				if (cnt >= K) {
 					red = true;
 					break;
 				}
 				cnt = 1;
 				for (int x = i-1, y = k-1; x > -1 && y > -1 && b[x][y] == 'R'; x--, y--)
 					cnt++;
 				for (int x = i+1, y = k+1; x < N && y < N && b[x][y] == 'R'; x++, y++)
 					cnt++;
 				if (cnt >= K) {
 					red = true;
 					break;
 				}
 				if (red)
 					break;
 			}
 		}
 		if (!blue) {
 			for (int i = 0; i < N; ++i) {
 				int k = -1;
 				for (int j = 0; j < N; ++j) {
 					if (b[i][j] == 'B') {
 						k = j;
 						break;
 					}
 				}
 				if (k == -1)
 					continue;
 				int cnt = 1;
 				for (int x = i-1, y = k+1; x > -1 && y < N && b[x][y] == 'B'; x--, y++)
 					cnt++;
 				for (int x = i+1, y = k-1; x < N && y > -1 && b[x][y] == 'B'; x++, y--)
 					cnt++;
 				if (cnt >= K) {
 					blue = true;
 					break;
 				}
 				cnt = 1;
 				for (int x = i-1, y = k-1; x > -1 && y > -1 && b[x][y] == 'B'; x--, y--)
 					cnt++;
 				for (int x = i+1, y = k+1; x < N && y < N && b[x][y] == 'B'; x++, y++)
 					cnt++;
 				if (cnt >= K) {
 					blue = true;
 					break;
 				}
 				if (blue)
 					break;
 			}
 		}
 
 		if (red && blue)
 			return ""Both"";
 		else if (blue)
 			return ""Blue"";
 		else if (red)
 			return ""Red"";
 		else
 			return ""Neither"";
 	}
 }
","import java.util.*;
 import java.io.*;
 import java.math.BigInteger;
 
 public class Main
 {
 	public static void main(String[] args)
 	{
 		InputStream inputStream = System.in;
 		OutputStream outputStream = System.out;
 		InputReader in = new InputReader(inputStream);
 		PrintWriter out = new PrintWriter(outputStream);
 		TaskC solver = new TaskC();
 		solver.solve(1, in, out);
 		out.close();
 	}
 }
 
 class TaskC
 {
 	public void solve(int testNumber, InputReader in, PrintWriter out)
 	{
 		pre();
 		//for (int i = 0; i < ans.size(); ++i) out.write(ans.get(i).toString()+""\n"");
 		int T = in.nextInt();
 		for (int t = 1; t <= T; ++t) {
 			BigInteger A = new BigInteger(in.next());
 			BigInteger B = new BigInteger(in.next());
 			int i = binSearchUpper(A);
 			int j = binSearchLower(B);
 			out.write(""Case #""+t+"": ""+(j-i+1)+""\n"");
 		}
 	}
 	private int binSearchUpper(BigInteger x)
 	{
 		int lo = 0, hi = ans.size()-1;
 		while (lo < hi) {
 			int mi = (lo+hi)/2;
 			int cmp = ans.get(mi).compareTo(x);
 			if (cmp == 0) return mi;
 			else if (cmp < 0) lo = mi+1;
 			else hi = mi;
 		}
 		return lo;
 	}
 	private int binSearchLower(BigInteger x)
 	{
 		int lo = 0, hi = ans.size()-1;
 		while (lo < hi) {
 			int mi = (lo+hi)/2;
 			int cmp = ans.get(mi).compareTo(x);
 			if (cmp == 0) return mi;
 			else if (cmp < 0) lo = mi+1;
 			else hi = mi;
 		}
 		return hi-1;
 	}
 	private BigInteger MX;
 	private ArrayList<BigInteger> AL;
 	private ArrayList<BigInteger> ans;
 	private void pre()
 	{
 		String x = ""1"";
 		for (int i = 0; i < 100; ++i) x += '0';
 		MX = new BigInteger(x);
 		AL = new ArrayList<BigInteger>();
 		AL.add(new BigInteger(""1""));
 		AL.add(new BigInteger(""4""));
 		AL.add(new BigInteger(""9""));
 		generatePalindromeSquare();
 		Collections.sort(AL);
 		ans = new ArrayList<BigInteger>();
 		BigInteger cur = AL.get(0);
 		int n = AL.size();
 		ans.add(cur);
 		for (int i = 1; i < n; ++i) {
 			while (i < n && AL.get(i).compareTo(cur) == 0) ++i;
 			if (i == n) break;
 			cur = AL.get(i);
 			ans.add(cur);
 		}
 	}
 	private void generatePalindromeSquare()
 	{
 		// odd-length palindromes
 		doIt(""1"");
 		doIt(""2"");
 		doIt(""3"");
 		doIt(""101"");
 		doIt(""202"");
 		doIt(""303"");
 		// even-length palindromes
 		doIt(""11"");
 		doIt(""22"");
 		doIt(""33"");
 		doIt(""1001"");
 		doIt(""2002"");
 		doIt(""3003"");
 	}
 	private boolean isPalindromic(String s)
 	{
 		for (int i = 0, j = s.length()-1; i < j; ++i, --j) if (s.charAt(i) != s.charAt(j)) return false;
 		return true;
 	}
 	private void doIt(String s)
 	{
 		BigInteger x = new BigInteger(s);
 		BigInteger xx = x.pow(2);
 		if (xx.compareTo(MX) <= 0) {
 			if (isPalindromic(xx.toString())) { AL.add(xx);
 			doIt('1'+s+'1');
 			doIt('2'+s+'2');
 			doIt('3'+s+'3');
 			doIt(""10""+s+""01"");
 			doIt(""20""+s+""02"");
 			doIt(""30""+s+""03"");
 			}
 		}
 	}
 }
 
 class InputReader
 {
 	public BufferedReader reader;
 	public StringTokenizer tokenizer;
 	public InputReader(InputStream stream)
 	{
 		reader = new BufferedReader(new InputStreamReader(stream));
 		tokenizer = null;
 	}
 	public String next()
 	{
 		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
 			try {
 				tokenizer = new StringTokenizer(reader.readLine());
 			} catch (IOException e) {
 				throw new RuntimeException(e);
 			}
 		}
 		return tokenizer.nextToken();
 	}
 	public int nextInt()
 	{
 		return Integer.parseInt(next());
 	}
 }
",1
459,2949,"import static java.lang.Double.parseDouble;
 import static java.lang.Integer.parseInt;
 import static java.lang.Long.parseLong;
 import static java.lang.System.exit;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.StringTokenizer;
 
 
 public class DeceitfulWar {
     
 	static BufferedReader in;
 	static PrintWriter out;
 	static StringTokenizer tok;
 	static int test;
 	
 	static int n;
 	static double[] naomi, ken;
 
 
     static void solve() throws IOException {
     	n = nextInt();
     	Assert.check(n > 0);
     	naomi = new double[n];
     	ken = new double[n];
     	read(naomi);
     	read(ken);
     	
     	printCase();
     	out.printf(""%d %d"", getScore2(), getScore1());
     	out.println();
     }
   
     static void read(double[] A) throws IOException {
     	for (int i = 0; i < n; i++) A[i] = nextDouble();
     	Arrays.sort(A);
     }
     
     // score when both are playing War
     static int getScore1() {
     	int i = n - 1, j = n - 1;
     	while(i >= 0) {
     		if (ken[j] > naomi[i]) j--;
     		i--;
     	}
     	return j + 1;
     }
     
     // socre for deceitful War
     static int getScore2() {
     	int i = 0, j = 0, s = 0;
     	while (i < n) {
     		if (naomi[i] > ken[j]) {
     			s++;
     			j++;
     		}
     		i++;
     	}
     	return s;
     }
     
     static class Assert{
     	static void check(boolean e){
     		if(!e) throw new Error();
     	}
     }
 
 	
 	static void printCase() {
 		out.print(""Case #"" + test + "": "");
 	}
 	
 	static void printlnCase() {
 		out.println(""Case #"" + test + "":"");
 	}
 	
 	static int nextInt() throws IOException {
 		return parseInt(next());
 	}
 
 	static long nextLong() throws IOException {
 		return parseLong(next());
 	}
 
 	static double nextDouble() throws IOException {
 		return parseDouble(next());
 	}
 
 	static String next() throws IOException {
 		while (tok == null || !tok.hasMoreTokens()) {
 			tok = new StringTokenizer(in.readLine());
 		}
 		return tok.nextToken();
 	}
 
 	public static void main(String[] args) {
 		try {
 			in = new BufferedReader(new FileReader(""D-small-attempt0.in""));
 			out = new PrintWriter(""D-small-attempt0.out"");
 			//in = new BufferedReader(new InputStreamReader(System.in));
 			//out = new PrintWriter(new OutputStreamWriter(System.out));
 			int tests = nextInt();
 			for (test = 1; test <= tests; test++) {
 				solve();
 			}
 			in.close();
 			out.close();
 		} catch (Throwable e) {
 			e.printStackTrace();
 			exit(1);
 		}
 	}
 }
","import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 
 public class FreeCellStatsFinder {
 
 	public static void main(String[] args) throws Exception {
 
 		BufferedReader br = new BufferedReader(new InputStreamReader(
 				new FileInputStream(args[0])));
 		String nextLine = br.readLine();
 		int testNumber = 1;
 		while ((nextLine = br.readLine()) != null) {
 			String[] splitParams = nextLine.split("" "");
 			if (findIfStatsPossible(Integer.parseInt(splitParams[0]),
 					Integer.parseInt(splitParams[1]),
 					Integer.parseInt(splitParams[2]))) {
 				System.out.println(""Case #"" + testNumber + "": Possible"");
 			} else {
 				System.out.println(""Case #"" + testNumber + "": Broken"");
 			}
 			testNumber++;
 		}
 	}
 
 	public static boolean findIfStatsPossible(int numGamesPlayedToday,
 			int winPercentToday, int winPercentEver) {
 		if (winPercentEver == 100 && winPercentToday != 100)
 			return false;
 		if (winPercentEver == 0 && winPercentToday != 0)
 			return false;
 		if (winPercentToday == 0 || winPercentEver == 100)
 			return true;
 		for (int i = 1; i <= numGamesPlayedToday; i++) {
 			for (int j = 0; j <= i; j++) {
 				if ((100 * j) / i == winPercentToday && (100 * j) % i == 0) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 }
",0
460,18667,"package round1.a;
 
 
 import java.io.*;
 import java.util.*;
 import java.math.*;
 
 public class A {
 	static final String inFile = ""src/round1/a/A-small-attempt0.in"";
 	static final String outFile = ""src/round1/a/A.out"";
 	static final int selectedTest = -1;
 
 	int A, B;
 	int[] M, N;
 
 	void solve(Scanner sc, PrintWriter pw) {
 		M = new int[4];
 		A = (sc.nextInt()-1)*4;
 		
 		for(int i=-A; i<16-A; i++)
 			if(i>=0&&i<4)
 				M[i] = sc.nextInt();
 			else
 				sc.next();
 		
 		B = sc.nextInt()-1;
 		int[] r = new int[4];
 		int p = 0;
 		for(int j=0; j<16 && (p = sc.nextInt()) != 0; j++)
 			for(int i=0; i<4; i++)
 				if(M[i] == p)
 					if(r[j / 4] > 0)
 						r[j / 4] = -1;
 					else if(r[j / 4] > -1)
 						r[j / 4] = p;
 
 		if(r[B] == -1)
 			pw.println(""Bad magician!"");
 		else if(r[B] == 0)
 			pw.println(""Volunteer cheated!"");
 		else
 			pw.println(r[B]);
 	}
 
 
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new FileReader(inFile));
 		PrintWriter pw = new PrintWriter(new FileWriter(outFile));
 		int caseCnt = sc.nextInt();
 		for (int caseNum=0; caseNum<caseCnt; caseNum++) {
 			System.out.println(""Processing test case "" + (caseNum + 1));
 			pw.print(""Case #"" + (caseNum+1) + "": "");
 			new A().solve(sc, pw);
 		}
 		pw.flush();
 		pw.close();
 		sc.close();
 	}
 }
","import java.util.Scanner;
 
 
 public class Start {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		Scanner in=new Scanner(System.in);
 		int cases=in.nextInt();
 		
 		for (int x=1;x<=cases;x++){
 			int c=0;
 			int num=in.nextInt();
 			int surp=in.nextInt();
 			int best=in.nextInt();
 		//	int[] dancer=new int[num];
 			for (int y=0;y<num;y++){
 				int dummy=in.nextInt();
 				int point=dummy/3;
 				int rest=dummy%3;
 				if(point>=best)c++;
 				else if (point+1>=best &&rest>=1)c++;
 				else if (point+2>=best&&surp>0&&rest==2){
 					c++;
 					surp--;
 				}
 				else if (point+1>=best && surp>0 && point>0){
 					c++;
 					surp--;
 				}
 			}
 			System.out.println(""Case #""+x+"": ""+c);
 		}
 
 	}
 
 }
",0
461,482,"package com.google.codejam.utils.files;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 
 
 public class ManejoArchivos {
     private static String path = ""C:\\Documents and Settings\\Javier\\Mis documentos\\Proyectos Independientes\\Google\\files\\2011\\"";
     
     public static int[][] readFile(String name) throws FileNotFoundException, 
                                                         IOException {
         BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(path + name)));
         
         int arr[][] = new int[Integer.parseInt(br.readLine())][2];
         for(int i=0;i<arr.length;i++) {
             String str[] = br.readLine().split("" "");
             arr[i][0] = Integer.parseInt(str[0]);
             arr[i][1] = Integer.parseInt(str[1]);
         }
         
         return arr;
     }
     
     public static void writeFile(String name, StringBuffer sb) throws FileNotFoundException {
         PrintWriter out = new PrintWriter(new FileOutputStream(path + name));
         out.print(sb.toString());
         out.flush();
         out.close();
     }
     
     
     public static int LOG = 0;
     private static BufferedReader in = null;
     public static void initInput(String name) throws FileNotFoundException {
         in = new BufferedReader(new InputStreamReader(new FileInputStream(path + name + "".in"")));
     }
     public static void closeInput() throws IOException {
         in.close();
     }
     
     private static void logRead(String str) {
         if( LOG == 1 ) {
             System.out.println(str);
         }
     }
     public static String getString() throws IOException {
         String str = in.readLine();
         logRead(str);
         
         return str;
     }    
     public static String[] getStrings() throws IOException {
         String str = in.readLine();
         logRead(str);
         
         return str.split("" "");
     }
     public static int getInt() throws IOException {
         String str = in.readLine();
         logRead(str);
         
         return Integer.parseInt(str);
     }
     public static int[] getInts() throws IOException {
         String str = in.readLine();
         logRead(str);
         
         String arr[] = str.split("" "");
         int ints[] = new int[arr.length];
         for(int i=0;i<arr.length;i++) {
             ints[i] = Integer.parseInt(arr[i]);
         }
         return ints;
     }
     public static long[] getLongs() throws IOException {
         String str = in.readLine();
         logRead(str);
         
         String arr[] = str.split("" "");
         long longs[] = new long[arr.length];
         for(int i=0;i<arr.length;i++) {
             longs[i] = Long.parseLong(arr[i]);
         }
         return longs;
     }
     
     public static int TIPO_WRITE = 0;
     private static PrintWriter out = null;
     private static String strName = null;
     public static void initOutput(String name) throws FileNotFoundException {
         initOutput(name, false);
     }
     public static void initOutput(String name, boolean append) throws FileNotFoundException {
         strName = name;
         out = new PrintWriter(new FileOutputStream(path + name + "".out"", append));
     }
     public static void closeOutput() {
         try {
             out.flush();
             out.close();
         } catch( Exception e ) {
             e.printStackTrace();
         }
     }
 
     private static void openWrite() throws FileNotFoundException {
         if( TIPO_WRITE == 1 ) {
             initOutput(strName, true);
         }
     }
     private static void closeWrite() {
         if( TIPO_WRITE == 1 ) {
             closeOutput();
         }
     }
     public static void writeCase(int i, String str) throws FileNotFoundException {
         openWrite();
         
         out.print(""Case #"");
         out.print(i);
         out.print("": "");
         out.print(str);
         out.print(""\n"");
         
         closeWrite();
     }
 }
","package gcj2014;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Scanner;
 
 public class P1P4v2 {
 
 	public static void main(String[] args) throws FileNotFoundException {
 
 		Scanner in = new Scanner(
 				new File(
 						""/Users/olvitole/Dropbox/workspace/Googe Code/src/gcj2014/files/D-small-attempt1.in""));
 		// Scanner in = new Scanner(System.in);
 		int t = Integer.parseInt(in.nextLine());
 		OutputStream outStr = new FileOutputStream(
 				""/Users/olvitole/Dropbox/workspace/Googe Code/src/gcj2014/files/D1-output.txt"");
 		PrintStream printOut = new PrintStream(outStr);
 
 		for (int zz = 1; zz <= t; zz++) {
 			int n = Integer.parseInt(in.nextLine().trim());
 			String[] naomi = in.nextLine().trim().split("" "");
 			String[] ken = in.nextLine().trim().split("" "");
 
 			ArrayList<BigDecimal> naomiA = new ArrayList<BigDecimal>();
 			ArrayList<BigDecimal> kenA = new ArrayList<BigDecimal>();
 
 			for (String a : naomi) {
 				naomiA.add(new BigDecimal(a));
 			}
 
 			for (String a : ken) {
 				kenA.add(new BigDecimal(a));
 			}
 
 			Collections.sort(naomiA);
 			Collections.sort(kenA);
 
 			ArrayList<BigDecimal> naomiB = new ArrayList<BigDecimal>(naomiA);
 			ArrayList<BigDecimal> kenB = new ArrayList<BigDecimal>(kenA);
 
 			// sort
 			int warVictories = fairgame(kenA, naomiA, n);
 			// reversesort
 			Collections.reverse(naomiB);
 			Collections.reverse(kenB);
 			int decWarVictories = cheating(kenB, naomiB, n);
 
 			String output = decWarVictories + "" "" + warVictories;
 			System.out.println(""Case #"" + zz + "": "" + output);
 
 			printOut.append(""Case #"" + zz + "": "" + output + ""\n"");
 
 		}
 
 		System.setOut(printOut);
 	}
 
 	// private static int swap(ArrayList<BigDecimal> naomiA,
 	// ArrayList<BigDecimal> kenA, int scoreP) {
 	//
 	// BigDecimal first = naomiA.get(0);
 	// int score = scoreP;
 	//
 	// for (int i = 0; i < naomiA.size(); i++) {
 	// if (kenA.get(i).compareTo(first)>0){
 	// score++;
 	// break;
 	// }
 	// kenA.remove(i);
 	// naomiA.remove(0);
 	// System.out.println(naomiA.size());
 	// }
 	// if (naomiA.size() > 0) {
 	// return swap(naomiA, kenA, score);
 	// } else {
 	// return score;
 	// }
 	// }
 
 	private static int fairgame(ArrayList<BigDecimal> kenA,
 			ArrayList<BigDecimal> naomiA, int n) {
 		int count = 0;
 		int index = 0;
 		int kw = 0;
 		int nw = 0;
 		int i, j;
 		for (i = 0; i < n; i++) {
 			for (j = i + index; j < n; j++) {
 				if (kenA.get(j).compareTo(naomiA.get(i)) > 0) {
 					kw++;
 					break;
 				} else {
 					index++;
 				}
 			}
 		}
 		count = n - kw;
 		return count;
 	}
 
 	private static int cheating(ArrayList<BigDecimal> kenB,
 			ArrayList<BigDecimal> naomiB, int n) {
 		int count = 0;
 		int index = 0;
 		int i, j;
 		for (i = 0; i < n; i++) {
 			for (j = i + index; j < n; j++) {
 				if (naomiB.get(i).compareTo(kenB.get(j)) > 0) {
 					count++;
 					break;
 				} else {
 					index++;
 				}
 			}
 		}
 		return count;
 	}
 
 }
",0
462,7150,"import java.io.File;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Scanner;
 
 
 public class EjercicioA {
 	public static boolean prueba = false;
 	public static void main(String args[]){
 		
  		try {
  			FileOutputStream fos = new FileOutputStream(new File(""solucion.txt""));
  			OutputStream os = System.out;
  			if (!prueba)
  				os = fos;
 			Scanner s = new Scanner(new File(""problema.txt""));
 			int a = s.nextInt();
 			for(int i = 0; i < a; i++){
 				int b = s.nextInt();
 				double cantGanados[] = new double[b];
 				double cantJugados[] = new double[b];
 				String string[] = new String[b];
 				for (int j = 0; j<b;j++ ){
 					string[j]  = s.next();
 					for (int k = 0; k<b; k++){
 						if (string[j].charAt(k) == '0')
 							cantJugados[j]++;
 						else if(string[j].charAt(k) == '1'){
 							cantJugados[j]++;
 							cantGanados[j]++;
 						}						
 					}
 				}
 				os.write((""Case #"" + (i+1) + "": "" + ""\n"").getBytes());
 				double owp[] = new double[b];
 				double wp[] = new double[b];
 				double total[] = new double[b];
 				double oponentes[] = new double[b];
 				for (int j = 0; j<b;j++ ){
 					
 					wp[j] = cantGanados[j] / cantJugados[j];
 					owp[j] = 0;
 					oponentes[j] = 0;
 					for (int k = 0; k<b; k++){
 						
 						if (j != k && string[k].charAt(j) != '.'){
 							oponentes[j] ++;
 							double ganados = cantGanados[k];
 							double cantJ = cantJugados[k];
 							if (string[k].charAt(j) == '0')
 								cantJ --;
 							else if (string[k].charAt(j) == '1'){
 								cantJ --;
 								ganados --;
 							}
 							
 							owp[j] += ganados / cantJ;
 						}
 					}	
 					
 					owp[j] = owp[j] /  oponentes[j];
 					
 				}
 				
 				for (int j = 0; j<b;j++ ){
 					for (int k = 0; k<b; k++){
 						
 						if (j != k && string[k].charAt(j) != '.'){					
 							total[j] += owp[k];
 						}
 					}
 					total[j] /= oponentes[j];					
 					double c = wp[j] *0.25 + 0.50 * owp[j] + 0.25 * total[j];
 					os.write((c + ""\n"").getBytes());
 				}
 				
 				
 			}
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		
 	}
 }
","import java.io.File;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Scanner;
 
 
 public class EjercicioA {
 	public static boolean prueba = false;
 	public static void main(String args[]){
 		
  		try {
  			FileOutputStream fos = new FileOutputStream(new File(""1.txt""));
  			OutputStream os = System.out;
  			if (!prueba)
  				os = fos;
 			Scanner s = new Scanner(new File(""a.txt""));
 			int a = s.nextInt();
 			for(int i = 0; i < a; i++){
 				List<Integer> listB = new ArrayList<Integer>();
 				List<Integer> listO = new ArrayList<Integer>();
 				List<String> proximo = new ArrayList<String>();
 				int b = s.nextInt();
 				for (int j = 0; j < b; j++){
 					String p = s.next();
 					proximo.add(p);
 					if (p.equals(""B""))
 						listB.add(s.nextInt());
 					else
 						listO.add(s.nextInt());
 				}
 				listB.add(0);
 				listO.add(0);
 				proximo.add(""d"");
 				int res = ejecutarA(proximo,listB,listO);
 				os.write((""Case #"" + (i+1) + "": "" + res + ""\n"").getBytes());
 			}
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 		
 	}
 
 	private static int ejecutarA(List<String> proximo, List<Integer> listB,
 			List<Integer> listO) {
 		int posB = 1;
 		int posO = 1;
 		int b = 0;
 		int o = 0;
 		int t = 0;
 		Iterator<String> it =proximo.iterator();
 		String pr = it.next();
 		boolean entre = false;
 		do{
 			entre = false;
 			t++;
 			if (listB.get(b) > posB) 
 				posB++;
 			else if (listB.get(b) < posB)
 				posB--;
 			else if (pr.equals(""B"")){
 				pr = it.next();
 				b++;
 				entre = true;
 			}
 			if (listO.get(o) > posO) 
 				posO++;
 			else if (listO.get(o) < posO)
 				posO--;
 			else if (pr.equals(""O"") && !entre){
 				pr = it.next();
 				o++;
 			}
 			
 			
 		}while (it.hasNext());
 		return t;
 	}
 }
",1
463,6645,"import java.io.*;
 import java.math.*;
 import java.util.*;
 
 public class C{
 	public static void main(String[] args) throws Exception{
 		BufferedReader fin = new BufferedReader(new FileReader(""Cin.txt""));
 		PrintWriter fout = new PrintWriter(new FileWriter(""Cout.txt""));
 
 		String in = fin.readLine();
 		int tt = Integer.parseInt(in);
 
 		int t = 1;
 
 		while(t <= tt){
 			//System.out.println(""asdf"");
 			in = fin.readLine();
 			String[] sp = in.split("" "");
 			double d = Double.parseDouble(sp[0]);
 			int n = Integer.parseInt(sp[1]);
 			int A = Integer.parseInt(sp[2]);
 
 			double[] ti = new double[n];
 			double[] xi = new double[n];
 			for(int i = 0; i < n; i++){
 				in = fin.readLine();
 				sp = in.split("" "");
 				ti[i] = Double.parseDouble(sp[0]);
 				xi[i] = Double.parseDouble(sp[1]);
 			}
 			double[] ai = new double[A];
 			in = fin.readLine();
 			sp = in.split("" "");
 			for(int i = 0; i < A; i++){
 				ai[i] = Double.parseDouble(sp[i]);
 			}
 
 			double[] res = new double[A];
 			for(int i = 0; i< A; i++){
 				if(n == 1){
 					res[i] = Math.max(ti[0], Math.pow(2.0 * d / ai[i], .5));
 				} else{
 					double v = (xi[1] - xi[0]) / (ti[1] - ti[0]);
 					double tempt = (d - xi[0]) / v;
 					double tempt2 = Math.pow(2.0 * d / ai[i], .5);
 					res[i] = Math.max(tempt, tempt2);
 				}
 			}
 
 
 
 
 
 			fout.println(""Case #"" + t + "":"");
 			for(int i = 0; i < A; i++){
 				fout.println(res[i]);
 			}
 			fout.flush();
 			t++;
 		}
 	}
 }","package code.jam.y2014.quali;
 
 import java.io.*;
 import java.util.StringTokenizer;
 
 public class ProblemB {
 
     private static String PATH = ""F:\\dev\\projects\\code-jam-2012\\src\\code\\jam\\y2014\\quali"";
     File inputFile = new File(PATH, ""B-large.in"");
     File outputFile = new File(PATH, ""B-large.out"");
     BufferedReader in;
     PrintWriter out;
     StringTokenizer st = new StringTokenizer("""");
 
     public static void main(String[] args) throws Exception {
         new ProblemB().solve();
     }
 
     void solve() throws Exception {
         in = new BufferedReader(new FileReader(inputFile));
         out = new PrintWriter(outputFile);
 
         for (int testCase = 1, testCount = nextInt(); testCase <= testCount; testCase++) {
             print(""Case #"" + testCase + "": "" + solve(testCase));
         }
 
         out.close();
     }
     
     String solve(int testCase) throws IOException {
         final double cookiesToBuyFarm = nextDouble();
         final double cookiesPerSecondForFarm = nextDouble();
         final double targetCookies = nextDouble();
         System.out.println(""trying "" + testCase + "" with "" + targetCookies);
         double bestSecs = Double.MAX_VALUE;
         int farms = 0;
         while(true) {
             double secs = getSecondsForBuyingFarms(farms, 2.0d, cookiesToBuyFarm, cookiesPerSecondForFarm, targetCookies);
             if (secs>bestSecs) return String.valueOf(bestSecs);
             bestSecs = secs;
             farms++;
         }
     }
     
     private double getSecondsForBuyingFarms(int farmsToBeBought, double cookiesPerSecond, final double cookiesToBuyFarm, final double cookiesPerSecondForFarm, final double targetCookies) {
         double time = 0;
         for (int i = 0; i < farmsToBeBought; i++) {
             time+=cookiesToBuyFarm/cookiesPerSecond;
             cookiesPerSecond+=cookiesPerSecondForFarm;
         }
         return time + targetCookies / cookiesPerSecond;
     }
    
     private void print(String text) {
         out.println(text);
         System.out.println(text);
     }
 
     
     /**
      * helpers
      */
     String nextToken() throws IOException {
         while (!st.hasMoreTokens()) {
             st = new StringTokenizer(in.readLine());
         }
         return st.nextToken();
     }
     
     int nextChar() throws IOException {
         return in.read();
     }
 
     int nextInt() throws IOException {
         return Integer.parseInt(nextToken());
     }
 
     long nextLong() throws IOException {
         return Long.parseLong(nextToken());
     }
 
     double nextDouble() throws IOException {
         return Double.parseDouble(nextToken());
     }
 
     String nextLine() throws IOException {
         st = new StringTokenizer("""");
         return in.readLine();
     }
 
     boolean EOF() throws IOException {
         while (!st.hasMoreTokens()) {
             String s = in.readLine();
             if (s == null) {
                 return true;
             }
             st = new StringTokenizer(s);
         }
         return false;
     }
     
 }
",0
464,1552,"import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.math.BigInteger;
 
 
 public class FairWarning {
 	public static void main(String args[]) throws Exception {
 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		
 		int numOfLine = Integer.parseInt(br.readLine());
 		for (int i = 0; i < numOfLine; i++) {
 			String line = br.readLine();
 			String col[] = line.split("" "");
 			int N = Integer.parseInt(col[0]);
 			BigInteger t[] = new BigInteger[N];
 			for (int j = 0; j < N; j++) {
 				t[j] = new BigInteger(col[j + 1]);
 			}
 			System.out.println(""Case #"" + (i + 1) + "": "" + compute(t));
 		}
 	}
 	
 	public static BigInteger compute(BigInteger t[]) {
 		BigInteger gcd = t[0];
 		for (int i = 1; i < t.length; i++)
 			gcd = gcd.gcd(t[i]);
 		BigInteger max = t[0];
 		for (int i = 1; i < t.length; i++) {
 			if (max.compareTo(t[i]) < 0)
 				max = t[i];
 		}
 		BigInteger T = gcd;
 		BigInteger y = BigInteger.ZERO;
 		BigInteger gcd1 = gcd;
 		for (BigInteger bi = BigInteger.ZERO; bi.compareTo(max) <= 0; bi = bi.add(gcd1)) {
 			gcd1 = t[0].add(bi);
 			for (int i = 1; i < t.length; i++)
 				gcd1 = gcd1.gcd(t[i].add(bi));
 			//System.out.println(""   + "" + gcd1 + "" --> "" + bi);
 			if (gcd1.compareTo(T) > 0) {
 				y = bi;
 				T = gcd1;
 			}
 		}
 		return y;
 	}
 	
 }
","package vov.codejam.task_c;
 
 import java.io.*;
 
 public class TaskC {
 
     public static void main(String[] args) throws IOException {
 //        String inputFile = ""C.in"";
         String outputFile = ""C.out"";
 //        String inputFile = ""C-small.in"";
         String inputFile = ""C-large.in"";
         BufferedReader br = new BufferedReader(new FileReader(inputFile));
         String testCaseCountString = br.readLine();
         int testCaseCount = Integer.parseInt(testCaseCountString);
 
         BufferedWriter out = new BufferedWriter(new FileWriter(outputFile));
 
 
         for (int i = 0; i < testCaseCount; i++) {
 
             System.out.print(""Case #"" + (i + 1) + "": "");
             out.write(""Case #"" + (i + 1) + "": "");
 
             String testLine = br.readLine();
             int candles = Integer.parseInt(testLine.trim());
             String testLine2 = br.readLine();
             String[] params = testLine2.split("" "");
 
             int smallestCandle = Integer.MAX_VALUE;
             int total = 0;
             long totalSum = 0;
 
             for (int j =0; j< candles; j++) {
                 int candle = Integer.parseInt(params[j]);
                 smallestCandle = Math.min(candle, smallestCandle);
                 total = total ^ candle;
                 totalSum = totalSum +  candle;
             }
 
             if (total == 0) {
                 System.out.println(totalSum - smallestCandle);
                 out.write("""" + (totalSum - smallestCandle) + ""\n"");
             } else {
                 System.out.println(""NO"");
                 out.write(""NO\n"");
             }
         }
         out.flush();
         out.close();
     }
 }
",0
465,19567,"package y2011.q;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.util.List;
 import java.util.Scanner;
 
 import com.google.common.collect.Lists;
 
 public class BotTrust {
 
 	private static class Button {
 		char color;
 		int pos;
 		
 		@Override
 		public String toString() {
 			return String.format(""Button [color=%s, pos=%s]"", color, pos);
 		}
 	}
 	
 	
 
 	private static int solve(List<Button> buttonSequence) {
 		int posBlue = 1;
 		int posOrange = 1;
 		int stepsBlue = 0;
 		int stepsOrange = 0;
 		
 		for(Button button : buttonSequence) {
 			switch(button.color) {
 			case 'O':
 				stepsOrange += Math.abs(posOrange - button.pos);
 				stepsOrange = Math.max(stepsOrange,stepsBlue);
 				stepsOrange++;
 				posOrange = button.pos;
 				break;
 			case 'B':
 				stepsBlue += Math.abs(posBlue - button.pos);
 				stepsBlue = Math.max(stepsBlue,stepsOrange);
 				stepsBlue++;
 				posBlue = button.pos;
 				break;
 			}
 		}
 
 		
 		return Math.max(stepsOrange,stepsBlue);
 	}
 	
 	
 	
 	public static void main(String[] args) throws Exception {
 		Scanner sc = new Scanner(new File(""A-small-attempt0.in""),""ASCII"");
 		
 		BufferedWriter writer = new BufferedWriter(new FileWriter(""A-small-attempt0.out""));
 		
 		int t = sc.nextInt();
 		List<Button> buttonSequence = Lists.newArrayListWithCapacity(t);
 		for(int i=0;i<t;i++) {
 			buttonSequence.clear();
 			int n = sc.nextInt();
 			for(int j=0;j<n;j++) {
 				Button button = new Button();
 				button.color = sc.next().trim().charAt(0);
 				button.pos = sc.nextInt();
 				buttonSequence.add(button);
 			}
 			int s = solve(buttonSequence);
 			String result = String.format(""Case #%d: %d"",i+1,s);
 			writer.write(result+""\n"");
 			System.out.println(result);
 		}
 		writer.flush();
 		writer.close();
 		
 	}
 
 	
 }
","/*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 import java.text.*;
 
 public class aRepeater {
 
     static BufferedReader br;
     static Scanner sc;
     static PrintWriter out;
 
     public static void initA() {
         try {
             br = new BufferedReader(new InputStreamReader(System.in));
             sc = new Scanner(System.in);
             out = new PrintWriter(System.out);
         } catch (Exception e) {
         }
     }
 
     public static void initB() {
         try {
             String in = ""d:\\MT.in"";
             String of = ""d:\\out.txt"";
             br = new BufferedReader(new FileReader(in));
             sc = new Scanner(new FileReader(in));
             out = new PrintWriter(of);
         } catch (Exception e) {
         }
     }
 
     static boolean next_permutation(Integer[] p) {
         for (int a = p.length - 2; a >= 0; --a) {
             if (p[a] < p[a + 1]) {
                 for (int b = p.length - 1;; --b) {
                     if (p[b] > p[a]) {
                         int t = p[a];
                         p[a] = p[b];
                         p[b] = t;
                         for (++a, b = p.length - 1; a < b; ++a, --b) {
                             t = p[a];
                             p[a] = p[b];
                             p[b] = t;
                         }
                         return true;
                     }
                 }
             }
         }
         return false;
     }
 
     public static String getString() {
         try {
             return br.readLine();
         } catch (Exception e) {
         }
         return """";
     }
 
     public static Integer getInt() {
         try {
             return Integer.parseInt(br.readLine());
         } catch (Exception e) {
         }
         return 0;
     }
 
     public static Integer[] getIntArr() {
         try {
             StringTokenizer temp = new StringTokenizer(br.readLine());
             int n = temp.countTokens();
             Integer temp2[] = new Integer[n];
             for (int i = 0; i < n; i++) {
                 temp2[i] = Integer.parseInt(temp.nextToken());
             }
             return temp2;
         } catch (Exception e) {
         }
         return null;
     }
 
     public static Long[] getLongArr() {
         try {
             StringTokenizer temp = new StringTokenizer(br.readLine());
             int n = temp.countTokens();
             Long temp2[] = new Long[n];
             for (int i = 0; i < n; i++) {
                 temp2[i] = Long.parseLong(temp.nextToken());
             }
             return temp2;
         } catch (Exception e) {
         }
         return null;
     }
 
     public static String[] getStringArr() {
         try {
             StringTokenizer temp = new StringTokenizer(br.readLine());
             int n = temp.countTokens();
             String temp2[] = new String[n];
             for (int i = 0; i < n; i++) {
                 temp2[i] = (temp.nextToken());
             }
             return temp2;
         } catch (Exception e) {
         }
         return null;
     }
 
     public static void print(Object a) {
         out.println(a);
     }
 
     public static void print(String s, Object... a) {
         out.printf(s, a);
     }
 
     public static int nextInt() {
         return sc.nextInt();
     }
 
     public static double nextDouble() {
         return sc.nextDouble();
     }
 
     public static void main(String[] ar) {
         initB();
         aRepeater c = new aRepeater();
         c.solve();
         out.flush();
     }
 
     void solve2() {
 
         String kalah = ""Fegla Won"";
         int n = getInt();
 
         String in[] = new String[n];
 
         for (int i = 0; i < n; i++) {
             in[i] = getString();
         }
 
 
         char arc[][] = new char[n][];
         for (int i = 0; i < n; i++) {
             arc[i] = in[i].toCharArray();
         }
         int total_karakter[] = new int[100];
         int hehe[][] = new int[n][100];
 
         long last_hash = arc[0][0] - 'a' + 1;
 
         int dc;
 
         int pos = 0;
         char lc = arc[0][0];
         total_karakter[0]++;
         hehe[0][0]++;
         for (int i = 1; i < arc[0].length; i++) {
             if (arc[0][i] != lc) {
                 pos++;
                 lc = arc[0][i];
                 last_hash = last_hash * 31 + (lc - 'a' + 1);
             }
             total_karakter[pos]++;
             hehe[0][pos]++;
         }
         dc = pos;
         for (int ul = 1; ul < n; ul++) {
             pos = 0;
             lc = arc[ul][0];
             long next_hash = arc[ul][0] - 'a' + 1;
             total_karakter[pos]++;
             hehe[ul][0]++;
             for (int i = 1; i < arc[ul].length; i++) {
                 if (arc[ul][i] != lc) {
                     pos++;
                     lc = arc[ul][i];
                     next_hash = next_hash * 31 + (lc - 'a' + 1);
                 }
                 total_karakter[pos]++;
                 hehe[ul][pos]++;
             }
             if (next_hash != last_hash) {
                 print(kalah);
                 return;
             }
         }
         int ou = 0;
         //print(""ADA %d KARAKTER\n"", dc + 1);
         for (int i = 0; i <= dc; i++) {
             int sou = (int) (total_karakter[i] / (double) n + 0.5);
             //print(""TOTAL KARAKTER %d \n"",total_karakter[i]);
             //print(""KARAKTER KE %d PIVOTNYA %d\n"", i + 1, sou);
             for (int j = 0; j < n; j++) {
                 ou += Math.abs(sou - hehe[j][i]);
                 //print(""JUMLAH KARAKTER DI STRING KE %d = %d\n"", j, hehe[j][i]);
             }
         }
         print(ou);
     }
 
     void solve() {
         int tc = getInt();
         for (int kasus = 1; kasus <= tc; kasus++) {
             print(""Case #%d: "", kasus);
 
             solve2();
         }
     }
 }
",0
466,20729,"
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 /*
  * To change this license header, choose License Headers in Project Properties.
  * To change this template file, choose Tools | Templates
  * and open the template in the editor.
  */
 
 /**
  *
  * @author nikunj
  */
 public class war {
     public static void main(String args[])
     {
          try
            {
                File f = new File(""D-small-attempt1.in"");
            
         Scanner s = new Scanner(f);
           FileOutputStream out2; // declare a file output object
                 PrintStream p;
                    out2 = new FileOutputStream(""myfile.txt"");
                         // Connect print stream to the output stream
                         p = new PrintStream(out2);
                         int test_case=s.nextInt();
                         
                         
                         for(int i=0;i<test_case;i++)
                         {
                             int n=s.nextInt();
                             float naomi[]=new float[n];
                             float ken[]=new float[n];
                             for(int j=0;j<n;j++)
                             {
                                 naomi[j]=s.nextFloat();
                             }
                             for(int j=0;j<n;j++)
                             {
                                 ken[j]=s.nextFloat();
                             }
                             float min;
                             min = 9999;
                             for(int j=0;j<n;j++)
                             {
                                 if(min>ken[j])
                                 {
                                     min=ken[j];
                                 }
                             }
                             int flag=0;
                             for(int j=0;j<n;j++)
                             {
                                 if(naomi[j]<min)
                                 {
                                     flag++;
                                 }
                             }
                             int d_war=n-flag;
                             int flag2=0;
                             //System.out.println(d_war);
                             for(int j=0;j<n;j++)
                             {
                                 float c=find_next(ken,naomi[j],n);
                                // System.out.println(naomi[j]);
                                // System.out.println(c);
                                if(c<1)
                                {
                                     flag2++;
                                     for(int k=0;k<n;k++)
                                     {
                                         if(c==ken[k])
                                         {
                                             ken[k]=-100;
                                         }
                                     }
                                 
                                }else
                                {
                                    c=c-1;
                                     for(int k=0;k<n;k++)
                                     {
                                         if(c==ken[k])
                                         {
                                             ken[k]=-100;
                                         }
                                     }
                                 
                                }
                             }
                             int war=n-flag2;
                             //System.out.println(war);
                             int l=i+1;
                             p.println(""Case #""+l+"": ""+d_war+"" ""+war);
                         }
            } catch(FileNotFoundException e)
            {}
     }
     public static float find_next(float ken[],float naomi,int n)
     {    float min=9999;
     float val=-1;
         for(int j=0;j<n;j++)
         { 
             if(min>(ken[j]-naomi)&&(ken[j]-naomi)>0)
             {
                 min=ken[j]-naomi;
                 val=ken[j];
             }
         }
         if(val==-1)
         {
             min=999;
             for(int i=0;i<n;i++)
             {
                 if(ken[i]>0&&min>ken[i])
                 {
                     min=ken[i];
                 }
             }
             val=min+1;
         }
             return val;
     }
 }
","package googlecodejam2012_qualification;
 /** 
  * @author neil
  */
 import java.io.*;
 import java.util.*;
 public class NewMain3 {
 
     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) throws IOException
     {        
         //BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   
         BufferedReader in = new BufferedReader(new FileReader(""C:\\Documents and Settings\\neil\\Desktop\\B-small-in.in""));        
         BufferedWriter out = new BufferedWriter(new FileWriter(""C:\\Documents and Settings\\neil\\Desktop\\B-small-output.txt""));
         PrintStream ps = new PrintStream(System.out,true);
         StringTokenizer st;//st = new StringTokenizer(in.readLine(),"" "");
         int count=0;
         int t = Integer.parseInt(in.readLine());
         while(count++<t)
         {
             int score=0;
             
             st = new StringTokenizer(in.readLine(),"" "");
             int n = Integer.parseInt(st.nextToken());
             int s = Integer.parseInt(st.nextToken());
             int p = Integer.parseInt(st.nextToken());
             
             int a[] = new int[n];
             
             for(int i=0;i<n;i++)
             {
                 a[i] = Integer.parseInt(st.nextToken());
             }
             
             boolean selected[] = new boolean[n];
             
             //int b[] = new int[n];
             
             for(int i=0;i<n;i++)
             {
                 if(a[i]>=p)
                 {
                     if(a[i]%3==0)
                     {
                         if(a[i]/3>=p){ score++; selected[i] = true;}
                     }
                     else
                     {
                         if(a[i]/3+1>=p){ score++;selected[i] = true;}
                     }
                 }
                 
             }
             
             for(int i=0;i<n;i++)
             {
                 if(!selected[i]&&a[i]>=p)
                 {
                     if(s==0) break;
                     if(a[i]%3==2)
                     {
                         if(a[i]/3+2>=p){  score++; s--; }
                     }
                     else
                     {
                         if(a[i]/3+1>=p){ score++; s--;  }
                     }
                     
                 }
             }
             
             
             
             
             ps.println(""Case #""+count+"": ""+score);
             out.write(""Case #""+count+"": ""+score+""\n"");
             out.flush();
         }                
     }
 }
",0
467,10333,"package CodeJam2014;
 
 import java.awt.List;
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.LinkedList;
 
 public class A {
 
 	public static void main(String[] args) throws Exception, IOException {
 		BufferedReader in = new BufferedReader(new FileReader(""A-small-attempt0.in""));
 		FileWriter out = new FileWriter(""A-out.txt"");
 		String carriage = System.getProperty(""line.separator"");
 		int t = Integer.parseInt(in.readLine());
 		for (int kase = 0; kase < t; kase++) {
 			int first = Integer.parseInt(in.readLine()) - 1;
 			int[] chosen = new int[16];
 			for (int i = 0; i < 4; i++) {
 				String line = in.readLine();
 				if (i == first) {
 					String[] tokens = line.split("" "");
 					for (int j = 0; j < 4; j++) {
 						chosen[Integer.parseInt(tokens[j]) - 1]++;
 					}
 				}
 			}
 
 			int second = Integer.parseInt(in.readLine()) - 1;
 			for (int i = 0; i < 4; i++) {
 				String line = in.readLine();
 				if (i == second) {
 					String[] tokens = line.split("" "");
 					for (int j = 0; j < 4; j++) {
 						chosen[Integer.parseInt(tokens[j]) - 1]++;
 					}
 				}
 			}
 			LinkedList<Integer> sol = new LinkedList<Integer>();
 			for (int i = 0; i < chosen.length; i++) {
 				System.out.print(chosen[i] + "" "");
 				if (chosen[i] == 2)
 					sol.add(i + 1);
 			}
 			String result;
 			if (sol.size() == 0) {
 				result = ""Case #"" + (kase + 1) + "": Volunteer cheated!"";
 			} else if (sol.size() == 1) {
 				result = ""Case #"" + (kase + 1) + "": "" + sol.poll();
 			} else {
 				result = ""Case #"" + (kase + 1) + "": Bad magician!"";
 			}
 			System.out.println(result);
 			out.append(result);
 			out.append(carriage);
 		}
 		out.close();
 	}
 }
","package CodeJam2013;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Scanner;
 
 public class QB {
 
 	public static void main(String[] args) throws IOException {
 		String carriage = System.getProperty(""line.separator"");
 		Scanner in = new Scanner(new File(""B-small-attempt0.in""));
 		FileWriter out = new FileWriter(""B-smallOut.txt"");
 		int t = in.nextInt();
 		for (int kase = 1; kase <= t; kase++) {
 			int n = in.nextInt(), m = in.nextInt();
 			int original[][] = new int[n][m];
 			int tobe[][] = new int[n][m];
 			for (int i = 0; i < n; i++) {
 				for (int j = 0; j < m; j++) {
 					original[i][j] = 100;
 					tobe[i][j] = in.nextInt();
 				}
 			}
 			for (int i = 0; i < n; i++) {
 				int max = 0;
 				for (int j = 0; j < m; j++) {
 					max = Math.max(max, tobe[i][j]);
 				}
 				for (int j = 0; j < m; j++) {
 					original[i][j] = (original[i][j] > max) ? max
 							: original[i][j];
 				}
 			}
 			for (int j = 0; j < m; j++) {
 				int max = 0;
 				for (int i = 0; i < n; i++) {
 					max = Math.max(max, tobe[i][j]);
 				}
 				for (int i = 0; i < n; i++) {
 					original[i][j] = (original[i][j] > max) ? max
 							: original[i][j];
 				}
 			}
 			boolean sol = true;
 			for (int i = 0; i < n && sol; i++) {
 				for (int j = 0; j < m && sol; j++) {
 					sol = (tobe[i][j] == original[i][j]);
 				}
 			}
 			if (sol) {
 				String str = ""Case #"" + kase + "": YES"";
 				System.out.println(str);
 				out.append(str);
 				out.append(carriage);
 			} else {
 				String str = ""Case #"" + kase + "": NO"";
 				System.out.println(str);
 				out.append(str);
 				out.append(carriage);
 			}
 
 		}
 		out.close();
 		in.close();
 	}
 }
",1
468,1043,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.StringTokenizer;
 
 public class C {
 
     class Building {
         int xFrom, xTo, yFrom, yTo;
 
         Building(int xFrom, int xTo, int yFrom, int yTo) {
             this.xFrom = xFrom;
             this.xTo = xTo;
             this.yFrom = yFrom;
             this.yTo = yTo;
         }
 
         public int distTo(Building other) {
             int distX = Math.max(other.xFrom - xTo, xFrom - other.xTo) - 1;
             int distY = Math.max(other.yFrom - yTo, yFrom - other.yTo) - 1;
             return Math.max(distX, distY);
         }
     }
 
     private void solve() throws Exception {
         int w = nextInt(), h = nextInt(), n = nextInt();
         Building[] b = new Building[n];
         for (int i = 0; i < n; ++i) {
             int xFrom = nextInt(), yFrom = nextInt(), xTo = nextInt(), yTo = nextInt();
             b[i] = new Building(xFrom, xTo, yFrom, yTo);
         }
         boolean[] used = new boolean[n];
         int[] d = new int[n];
         Building leftSide = new Building(-1, -1, 0, h - 1);
         for (int i = 0; i < n; ++i) {
             d[i] = leftSide.distTo(b[i]);
             if (d[i] != b[i].xFrom) {
                 throw new RuntimeException(""Not equal at "" + i + "": "" + d[i] + "" "" + b[i].xFrom);
             }
         }
         for (int i = 0; i < n; ++i) {
             int minVal = Integer.MAX_VALUE, minValInd = -1;
             for (int j = 0; j < n; ++j) {
                 if (!used[j] && d[j] < minVal) {
                     minVal = d[j];
                     minValInd = j;
                 }
             }
             used[minValInd] = true;
             for (int j = 0; j < n; ++j) {
                 if (!used[j]) {
                     d[j] = Math.min(d[j], d[minValInd] + b[minValInd].distTo(b[j]));
                 }
             }
         }
         Building rightSide = new Building(w, w, 0, h - 1);
         int ans = rightSide.distTo(leftSide);
         for (int i = 0; i < n; ++i) {
             ans = Math.min(ans, d[i] + b[i].distTo(rightSide));
         }
         out.println(ans);
     }
 
     public void run() {
         try {
             int tc = nextInt();
             for (int it = 1; it <= tc; ++it) {
                 System.err.println(it);
                 out.print(""Case #"" + it + "": "");
                 solve();
             }
         } catch (Exception e) {
             NOO(e);
         } finally {
             out.close();
         }
     }
 
     PrintWriter out;
     BufferedReader in;
     StringTokenizer St;
 
     void NOO(Exception e) {
         e.printStackTrace();
         System.exit(42);
     }
 
     int nextInt() {
         return Integer.parseInt(nextToken());
     }
 
     long nextLong() {
         return Long.parseLong(nextToken());
     }
 
     double nextDouble() {
         return Double.parseDouble(nextToken());
     }
 
     String nextToken() {
         while (!St.hasMoreTokens()) {
             try {
                 String line = in.readLine();
                 if (line == null)
                     return null;
                 St = new StringTokenizer(line);
             } catch (Exception e) {
                 NOO(e);
             }
         }
         return St.nextToken();
     }
 
     private C(String name) {
         try {
             in = new BufferedReader(new FileReader(""input.txt""));
             St = new StringTokenizer("""");
             out = new PrintWriter(new FileWriter(""output.txt""));
         } catch (Exception e) {
             NOO(e);
         }
     }
 
     public static void main(String[] args) {
         Locale.setDefault(Locale.US);
         new C(""a"").run();
     }
 }
","package qualification.fairnsquare.v1;
 
 import java.math.BigInteger;
 import java.util.Collections;
 import java.util.HashMap;
 
 import utils.IO;
 
 public class FairAndSquare {
     private static HashMap<BigInteger, BigInteger> map = new HashMap<>();
     private static final BigInteger ZERO = BigInteger.ZERO;
     private static final BigInteger ONE = BigInteger.ONE;
     private static final BigInteger TEN = BigInteger.TEN;
 
     public static void reset() {
         map = new HashMap<>();
     }
 
     public static void generate(BigInteger begin, BigInteger end) {
         BigInteger n = begin;
         BigInteger square = begin;
 
         while (square.compareTo(begin) >= 0) {
             square = n.multiply(n);
 
             if (square.compareTo(begin) >= 0 && square.compareTo(end) <= 0) {
                 map.put(n, square);
             }
 
             n = n.subtract(ONE);
         }
 
         n = begin.add(ONE);
 
         while (square.compareTo(end) <= 0) {
             square = n.multiply(n);
 
             if (square.compareTo(end) <= 0) {
                 map.put(n, square);
             }
 
             n = n.add(ONE);
         }
     }
 
     public static long countPalindromes() {
         long count = 0;
 
         for (BigInteger key : map.keySet()) {
             BigInteger val = map.get(key);
             if (isPalindrome(key.toString()) && isPalindrome(val.toString())) {
                 ++count;
             }
         }
 
         return count;
     }
 
     private static boolean isPalindrome(String word) {
         int l = word.length();
         int l1 = l - 1;
 
         for (int i = 0; i < l / 2; i++) {
             if (word.charAt(i) != word.charAt(l1 - i)) {
                 return false;
             }
         }
 
         return true;
     }
 
     public static void main(String[] args) {
         if (args.length != 1) {
             System.out.println(""file name parameter missing"");
         } else {
             start(args[0].trim());
         }
     }
 
     private static void start(String inFileName) {
         StringBuilder output = new StringBuilder();
         String input = IO.readFile(inFileName);
 
         String[] split = input.split(IO.LINE_SEPERATOR, 2);
 
         int num = Integer.parseInt(split[0].trim());
         String[] lines = split[1].split(IO.LINE_SEPERATOR);
 
         if (num != lines.length) {
             System.out.println(""ERROR!!!!!"");
         }
 
         for (int i = 0; i < lines.length; i++) {
             split = lines[i].split("" "");
             BigInteger begin = new BigInteger(split[0]);
             BigInteger end = new BigInteger(split[1]);
 
             generate(begin, end);
 
             long result = countPalindromes();
             output.append(""Case #"" + (i + 1) + "": "" + result);
 
             if (i < lines.length - 1) {
                 output.append(IO.LINE_SEPERATOR);
             }
 
             reset();
         }
 
         System.out.println(output.toString());
     }
 }
",0
469,11338,"import java.io.*;
 import java.util.Scanner;
 
 public class A {
     public static void main(String[] args) throws IOException {
 
         InputStream in = new FileInputStream(""D:\\GCJ\\src\\A-small-attempt0.in"");
         Writer writer = new FileWriter(""D:\\GCJ\\src\\a-out.txt"");
         BufferedWriter bufferedWriter = new BufferedWriter(writer);
 
         Scanner sc = new Scanner(in);
 
         int a[], b[], t, i, j, k;
         a = new int[4];
         b = new int[4];
         int p, q;
         t = sc.nextInt();
 
         for (i = 1; i <= t; i++) {
             p = sc.nextInt();
             for (j = 0; j < 4; j++) {
                 for (k = 0; k < 4; k++)
                     if (j == p - 1)
                         a[k] = sc.nextInt();
                     else
                         q = sc.nextInt();
             }
 
             q = sc.nextInt();
             for (j = 0; j < 4; j++) {
                 for (k = 0; k < 4; k++)
                     if (j == q - 1)
                         b[k] = sc.nextInt();
                     else
                         p = sc.nextInt();
             }
 
             p = 0;
             for (j = 0; j < 4; j++) {
                 for (k = 0; k < 4; k++) {
                     if (a[j] == b[k]) {
                         p++;
                         q = b[k];
                     }
                 }
             }
             if (p == 0) {
                 System.out.println(""Case #"" + i + "": Volunteer cheated!"");
                 bufferedWriter.write(""Case #"" + i + "": Volunteer cheated!"");
                 bufferedWriter.newLine();
 
             } else if (p == 1) {
                 System.out.println(""Case #"" + i + "": "" + q);
                 bufferedWriter.write(""Case #"" + i + "": "" + q);
                 bufferedWriter.newLine();
             } else {
                 System.out.println(""Case #"" + i + "": Bad magician!"");
                 bufferedWriter.write(""Case #"" + i + "": Bad magician!"");
                 bufferedWriter.newLine();
             }
         }
         in.close();
         bufferedWriter.flush();
         bufferedWriter.close();
     }
 }","import java.io.*;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class D {
     public static void main(String[] args) throws IOException {
 
         InputStream in = new FileInputStream(""D:\\GCJ\\src\\D-large.in"");
         Writer writer = new FileWriter(""D:\\GCJ\\src\\d-large.txt"");
         BufferedWriter bufferedWriter = new BufferedWriter(writer);
 
         Scanner sc = new Scanner(in);
 
         int t, i, j, n, k;
         double ken[], naomi[];
         t = sc.nextInt();
         for (k = 1; k <= t; k++) {
             n = sc.nextInt();
             naomi = new double[n];
             ken = new double[n];
 
             for (i = 0; i < n; i++)
                 naomi[i] = sc.nextDouble();
 
             for (i = 0; i < n; i++)
                 ken[i] = sc.nextDouble();
             Arrays.sort(naomi);
             Arrays.sort(ken);
 
             int p = 0, q = 0;
             i = j = 0;
             while (i < n && j < n) {
                 if (naomi[i] > ken[j]) {
                     p++;
                     i++;
                     j++;
                 } else
                     i++;
             }
             i = j = 0;
             while (i < n && j < n) {
                 if (naomi[i] < ken[j]) {
                     q++;
                     i++;
                     j++;
                 } else
                     j++;
             }
 
             System.out.println(""Case #"" + k + "": "" + p + "" "" + (n - q));
             bufferedWriter.write(""Case #"" + k + "": "" + p + "" "" + (n - q));
             bufferedWriter.newLine();
         }
 
         in.close();
         bufferedWriter.flush();
         bufferedWriter.close();
     }
 }",1
470,4430,"import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.Writer;
 import java.util.Scanner;
 
 /**
  * Created by taobo on 14-4-12.
  */
 public class MagicTrick {
     static  String solve(int a1, int[][]c1, int a2, int[][]c2) {
         int selected = -1;
         for(int i=0;i<c1[a1].length;i++)
             for(int j=0;j<c2[a2].length;j++)
                 if(c1[a1][i]==c2[a2][j])
                     if(selected == -1)
                         selected = c1[a1][i];
                     else
                         return ""Bad magician!"";
 
         if(selected == -1)
             return ""Volunteer cheated!"";
 
         return """"+selected;
 
     }
 
     public static void main(String...args) throws Exception {
         String inputFile = ""/Users/taobo/Downloads/A-small-attempt0.in.txt"";
         Scanner input = new Scanner(new File(inputFile));
         Writer output = new BufferedWriter(new FileWriter(inputFile+"".answer""));
 
         int T = input.nextInt();
         for(int i = 1; i<=T; i++)
         {
             int a1 = input.nextInt();
             int[][] c1 = new int[4][4];
             for(int j=0;j<4;j++)
                 for(int k=0;k<4;k++)
                     c1[j][k]=input.nextInt();
 
             int a2 = input.nextInt();
             int[][] c2 = new int[4][4];
             for(int j=0;j<4;j++)
                 for(int k=0;k<4;k++)
                     c2[j][k]=input.nextInt();
 
             output.write(""Case #""+i+"": ""+solve(a1-1, c1, a2-1, c2));
             output.append(""\n"");
         }
 
         input.close();
         output.close();
     }
 
 
 }
","package deceitful_war;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 
 public class DeceitfulWar {
 	
 	static class FileStuff {
 		private String fileInput;
 		private String fileOutput;
 		private String path;
 		
 		public FileStuff(String fileInput, String fileOutput, String path)
 		{
 			this.fileInput = fileInput;
 			this.fileOutput = fileOutput;
 			String pathTemp = System.getProperty(""user.dir"");
 			pathTemp += ""/src/"" + path + ""/"";
 			this.path = pathTemp;
 		}
 		
 		public ArrayList<String> ReadFromFile() throws IOException
 		{
 			InputStream input = new FileInputStream(path + this.fileInput);
 			BufferedReader br = new BufferedReader(new InputStreamReader(input));
 			String strLine;
 			ArrayList<String> arrRes = new ArrayList<String>();
 			while ((strLine = br.readLine()) != null)
 			{
 				arrRes.add(strLine);
 			}
 			br.close();
 			input.close();
 			return arrRes;
 		}
 		
 		public boolean WriteToFile(ArrayList<String> arrOut) throws IOException
 		{
 			OutputStream output = new FileOutputStream(path + this.fileOutput);
 			BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(output));
 			
 			for (int i=0;i<arrOut.size();i++)
 			{
 				bw.write(arrOut.get(i));
 				bw.newLine();
 			}
 			bw.close();
 			output.close();
 			return true;
 		}
 
 	}
 
 	public static void main(String[] args) throws IOException {
 		FileStuff fs = new FileStuff(""input.in"", ""output.out"", ""deceitful_war"");
 		ArrayList<String> input = new ArrayList<String>();
 		input = fs.ReadFromFile();
 		
 		long startTime = System.currentTimeMillis();
 		
 		ArrayList<String> output = new ArrayList<String>();
 		
 		int xCase = Integer.valueOf(input.get(0));
 		int xPointer = 1;
 		
 		for (int i=1;i<=xCase;i++)
 		{
 			String strOut = ""Case #"" + String.valueOf(i) + "":"";
 			xPointer++;
 			String strLine = input.get(xPointer);
 			xPointer++;
 			String[] arrLine = strLine.split("" "");
 			double[] arrNaomi = new double[arrLine.length];
 			for (int a=0;a<arrLine.length;a++) arrNaomi[a] = Double.parseDouble(arrLine[a]);
 			strLine = input.get(xPointer);
 			xPointer++;
 			arrLine = strLine.split("" "");
 			double[] arrKen = new double[arrLine.length];
 			for (int a=0;a<arrLine.length;a++) arrKen[a] = Double.parseDouble(arrLine[a]);
 			Arrays.sort(arrNaomi);
 			Arrays.sort(arrKen);
 			boolean[] flagKen = new boolean[arrKen.length];
 			for (int a=0;a<arrKen.length;a++) flagKen[a] = false;
 			int xPoint = 0;
 			for (int a=0;a<arrNaomi.length;a++) {
 				boolean boolChoose = false;
 				for (int b=0;b<arrKen.length;b++) {
 					if (!flagKen[b]) {
 						if (arrKen[b] > arrNaomi[a]) {
 							flagKen[b] = true;
 							boolChoose = true;
 							break;
 						}
 					}
 				}
 				if (!boolChoose) {
 					xPoint++;
 					for (int b=0;b<arrKen.length;b++) {
 						if (!flagKen[b]) {
 							flagKen[b] = true;
 							break;
 						}
 					}
 				}
 			}
 			boolean[] flagNaomi = new boolean[arrNaomi.length];
 			for (int a=0;a<arrNaomi.length;a++) flagNaomi[a] = false;
 			for (int a=0;a<arrKen.length;a++) flagKen[a] = false;
 			int xFlag = arrKen.length-1;
 			int xDeceive = 0;
 			for (int a=0;a<arrNaomi.length;a++) {
 				if (!flagNaomi[a]) {
 					for (int b=0;b<arrKen.length;b++) {
 						if (!flagKen[b]) {
 							if (arrNaomi[a] < arrKen[b]) {
 								flagNaomi[a] = true;
 								flagKen[xFlag] = true;
 								xFlag--;
 							} else {
 								flagNaomi[a] = true;
 								flagKen[b] = true;
 								xDeceive++;
 							}
 							break;
 						}
 					}
 				}
 			}
 //			for (int a=flagNaomi.length-1;a>=0;a--) {
 //				if (flagNaomi[a]) xDeceive++;
 //			}
 //			for (int a=arrKen.length-1;a>=0;a--) {
 //				if (!flagKen[a]) {
 //					if (arrKen[a] < arrNaomi[arrNaomi.length-1]) break;
 //					xDeceive++;
 //				}
 //			}
 			strOut += "" "" + String.valueOf(xDeceive) + "" "" + String.valueOf(xPoint);
 			output.add(strOut);
 		}
 		fs.WriteToFile(output);
 		
 		long endTime = System.currentTimeMillis();
 		System.out.print(endTime - startTime);
 	}
 
 }
",0
471,12274,"package gt.jl.jam.eleven.qr;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 
 public class BotTrust {
 	static Writer output;
 
 	
 	public static void main(String[] args) {
 		BotTrust app = new BotTrust();
 		String path = """";
 		String name = ""A-small-attempt0"";
 		int cantCasos = 0;
 
 		try {
 			File archivoEntrada = new File(path + name + "".in"");
 			File archivoSalida = new File(path + name + "".out"");
 
 			output = new BufferedWriter(new FileWriter(archivoSalida));
 
 			BufferedReader entrada = new BufferedReader(new FileReader(archivoEntrada));
 			try {
 				String linea = null;
 				int nLinea = 0;
 				int caso = 1;
 
 				while ((linea = entrada.readLine()) != null) {
 					// procesar cada linea y agregarla al Collection
 					Scanner scanner = new Scanner(linea);
 					scanner.useDelimiter("" "");
 					if (scanner.hasNext()) {
 						if (nLinea == 0) {
 							// cantidad de casos
 							cantCasos = scanner.nextInt();
 						} else {
 							String[] datos = linea.split("" "");
 							Long[] orange = new Long[datos.length / 2];
 							Long[] blue = new Long[datos.length / 2];
 							String[] turnos = new String[datos.length / 2];
 							Long botones = new Long(datos[0]);
 							Long botonesPresionados = 0L;
 							int i = 1;
 							int iblue = 0;
 							int iorange = 0;
 							int iturnos = 0;
 							while(i < datos.length) {
 								if(datos[i].equals(""O"")) {
 									turnos[iturnos] = ""O"";
 									iturnos++;
 									i++;
 									orange[iorange] = new Long(datos[i]);
 									iorange++;
 								} else if(datos[i].equals(""B"")) {
 									turnos[iturnos] = ""B"";
 									iturnos++;
 									i++;
 									blue[iblue] = new Long(datos[i]);
 									iblue++;
 								}
 								i++;
 							}
 							
 							long time = 0;
 							int posBlue = 1;
 							int posOrange = 1;
 							int posTurnos = 0;
 							
 							iorange = 0;
 							iblue = 0;
 							boolean presionado = false;
 							boolean continuar = true;
 							//while(botonesPresionados.longValue() < botones.longValue()) {
 							while(continuar) {
 								// casos de orange
 								/*if(posOrange == orange[botonesPresionados.intValue()] && turnos[botonesPresionados.intValue()].equals(""O"")) {
 									botonesPresionados++;
 									presionado = true;
 									System.out.println(""Orange pushed at "" + posOrange);
 								} else if(posOrange == orange[botonesPresionados.intValue()] && !turnos[botonesPresionados.intValue()].equals(""O"")) {
 									System.out.println(""Orange waiting at "" + posOrange);
 									// esperar
 								} else {
 									posOrange++;
 									System.out.println(""Orange moved to "" + posOrange);
 								}
 								
 								// casos de blue
 								if(posBlue == blue[botonesPresionados.intValue()] && turnos[botonesPresionados.intValue()].equals(""B"") && !presionado) {
 									botonesPresionados++;
 									System.out.println(""Blue pushed at "" + posBlue);
 								} else if((posBlue == blue[botonesPresionados.intValue()] && !turnos[botonesPresionados.intValue()].equals(""B"")) || (posBlue == blue[botonesPresionados.intValue()] && turnos[botonesPresionados.intValue()].equals(""B"") && presionado)) {
 									// esperar
 									System.out.println(""Blue waiting at "" + posBlue);
 								} else {
 									posBlue++;
 									System.out.println(""Blue moved to "" + posBlue);
 								}*/
 								
 								if(turnos[botonesPresionados.intValue()].equals(""O"")) {
 									if(posOrange == orange[iorange]) {
 										botonesPresionados++;
 										iorange++;
 										presionado = true;
 										System.out.println(""Orange pushed at "" + posOrange);
 										if(botonesPresionados.longValue() == botones.longValue()) {
 											continuar = false;
 										}
 									} else if(posOrange < orange[iorange]) {
 										posOrange++;
 										System.out.println(""Orange moved to "" + posOrange);
 									} else if(posOrange > orange[iorange]) {
 										posOrange--;
 										System.out.println(""Orange moved to "" + posOrange);
 									}
 									
 									if(continuar) {
 										if(blue[iblue] != null) {
 											if(posBlue == blue[iblue]) {
 												// esperar
 												System.out.println(""Blue waiting at "" + posBlue);
 											} else if(posBlue < blue[iblue]) {
 												posBlue++;
 												System.out.println(""Blue moved to "" + posBlue);
 											} else if(posBlue > blue[iblue]) {
 												posBlue--;
 												System.out.println(""Blue moved to "" + posBlue);
 											}
 										}
 									}
 								} else if(turnos[botonesPresionados.intValue()].equals(""B"")) {
 									if(orange[iorange] != null) {
 										if(posOrange == orange[iorange]) {
 											// esperar
 											System.out.println(""Orange waiting at "" + posOrange);
 										} else if(posOrange < orange[iorange]) {
 											posOrange++;
 											System.out.println(""Orange moved to "" + posOrange);
 										} else if(posOrange > orange[iorange]) {
 											posOrange--;
 											System.out.println(""Orange moved to "" + posOrange);
 										}
 									}
 
 									if(posBlue == blue[iblue]) {
 										botonesPresionados++;
 										iblue++;
 										System.out.println(""Blue pushed at "" + posBlue);
 										if(botonesPresionados.longValue() == botones.longValue()) {
 											continuar = false;
 										}
 
 									/*} else if(presionado) {
 										// esperar
 										presionado = false;
 										System.out.println(""Blue waiting at "" + posBlue);*/
 									} else if(posBlue < blue[iblue]) {
 										posBlue++;
 										System.out.println(""Blue moved to "" + posBlue);
 									} else if(posBlue > blue[iblue]) {
 										posBlue--;
 										System.out.println(""Blue moved to "" + posBlue);
 									}
 								}
 								
 								time++;
 							}
 							System.out.println(botones);
 							
 							output.write(""Case #"" + caso + "": "" + time + ""\n"");
 							caso++;
 						}
 						// int cumplidos = app.encontrarPatron(patron);
 						// cumplidos + ""\n"");
 						nLinea++;
 					} else {
 						System.out.println(""Error al procesar la linea: "" + linea);
 					}
 
 					scanner.close();
 				}
 			} finally {
 				System.out.println(""Finalizado el proceso!!!"");
 				output.close();
 				entrada.close();
 			}
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		}
 	}
 }
","package gt.impower.jam.thirteen.qr;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 
 public class FairSquare {
 	static Writer output;
 
 	public boolean esPalindromo(BigInteger pNumero) {
 		String original = pNumero.toString();
 		StringBuffer modificado = new StringBuffer(original).reverse();
 		
 		if(original.equals(modificado.toString())) {
 			return true;
 		} else {
 			return false;
 		}
 	}
 	
 	public long encontrarFairAndSquare(BigInteger pInferior, BigInteger pSuperior) {
 		// determinar raiz cuadrada mas cercana a limite superior
 		double raizMasGrande = Math.sqrt(pSuperior.doubleValue());
 		double raizMasPequena = Math.sqrt(pInferior.doubleValue());
 		BigInteger fairAndSquare = new BigInteger(""0"");
 		BigInteger raizMasGrandeBI = new BigDecimal(raizMasGrande).toBigInteger();
 		BigInteger raizMasPequenaBI = new BigDecimal(raizMasPequena).toBigInteger();
 		System.out.println(raizMasPequenaBI);
 		BigInteger cuadradoMasPequenoBI = new BigDecimal(Math.pow(raizMasPequenaBI.doubleValue(), new Double(2).doubleValue())).toBigInteger();
 		System.out.println(raizMasPequenaBI + "", "" + cuadradoMasPequenoBI + "", "" + pInferior);
 		if(cuadradoMasPequenoBI.compareTo(pInferior) < 0) {
 			raizMasPequenaBI = raizMasPequenaBI.add(new BigInteger(""1""));
 		}
 		//System.out.println(raizMasGrandeBI);
 		for(BigInteger i = raizMasGrandeBI; i.compareTo(raizMasPequenaBI) >= 0; i = i.subtract(new BigInteger(""1""))) {
 			if(esPalindromo(i)) {
 				BigInteger cuadrado = new BigDecimal(Math.pow(i.doubleValue(), new Double(2).doubleValue())).toBigInteger();
 				if(esPalindromo(cuadrado)) {
 					fairAndSquare = fairAndSquare.add(new BigInteger(""1""));
 				}
 			}
 		}
 		return fairAndSquare.longValue();
 	}
 	
 	public static void main(String[] args) {
 		FairSquare app = new FairSquare();
 		String path = """";
 		String name = ""C-small-attempt1"";
 		int cantCasos = 0;
 
 		SimpleDateFormat sdf = new SimpleDateFormat(""mm.ss.SSS"");
 
 		long inicioProceso = System.currentTimeMillis();
 		try {
 			File archivoEntrada = new File(path + name + "".in"");
 			File archivoSalida = new File(path + name + "".out"");
 
 			output = new BufferedWriter(new FileWriter(archivoSalida));
 
 			BufferedReader entrada = new BufferedReader(new FileReader(
 					archivoEntrada));
 			try {
 				String linea = null;
 				int nLinea = 0;
 				int caso = 1;
 
 				while ((linea = entrada.readLine()) != null) {
 					// procesar cada linea y agregarla al Collection
 					Scanner scanner = new Scanner(linea);
 					scanner.useDelimiter("" "");
 					if (scanner.hasNext()) {
 						if (nLinea == 0) {
 							// cantidad de casos
 							cantCasos = scanner.nextInt();
 						} else {
 							BigInteger limiteInferior = scanner.nextBigInteger();
 							BigInteger limiteSuperior = scanner.nextBigInteger();
 							// procesar limites
 							
 							long inicio = System.currentTimeMillis();
 							long fairAndSquareEncontrados = app.encontrarFairAndSquare(limiteInferior, limiteSuperior);
 							long fin = System.currentTimeMillis();
 							output.write(""Case #"" + caso + "": "" + fairAndSquareEncontrados + ""\n"");
 							System.out.println(""Case #"" + caso + "": "" + fairAndSquareEncontrados + "" en "" + sdf.format(new java.util.Date(fin - inicio)));
 							caso++;
 						}
 						// int cumplidos = app.encontrarPatron(patron);
 						// cumplidos + ""\n"");
 						nLinea++;
 					} else {
 						System.out.println(""Error al procesar la linea: "" + linea);
 					}
 
 					scanner.close();
 				}
 			} finally {
 				long finProceso = System.currentTimeMillis();
 				System.out.println(""Finalizado el proceso!!! en "" + sdf.format(new java.util.Date(finProceso - inicioProceso)));
 				output.close();
 				entrada.close();
 			}
 		} catch (IOException ex) {
 			ex.printStackTrace();
 		}
 	}
 }
",1
472,10385,"import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StreamTokenizer;
 import java.util.ArrayList;
 import java.util.Collections;
 
 
 public class B_qual {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) throws IOException {
 		Lawnmower lawnmower = new Lawnmower();
 		lawnmower.solve();
 	}
 
 }
 
 
 class Lawnmower {
 	
 	Lawnmower() throws IOException {
 		in = new StreamTokenizer(new BufferedReader(new FileReader(""input.txt"")));
 		out = new PrintWriter(""output.txt"");
 		t = nextInt();		
 	}
 	
 	int nextInt() throws IOException {
 		in.nextToken();
 		return (int)in.nval;
 	}
 	
 	
 	class Cell implements Comparable<Cell>{
 		
 		Cell (int r, int c, int h) {
 			this.r = r;
 			this.c = c;
 			this.h = h;
 		}
 		
 		public int compareTo(Cell cell){
 			if (h < cell.h) return -1;
 			if (h > cell.h) return 1;
 			if (r < cell.r) return -1;
 			if (r > cell.r) return 1;
 			if (c < cell.c) return -1;
 			if (c > cell.c) return 1;
 			return 0;
 		}
 		
 		int r;
 		int c;
 		int h;
 	}
 	
 	void readTest() throws IOException {
 		n = nextInt();
 		m = nextInt();
 		
 		lawn = new int[n][m];
 		alawn = new ArrayList<Cell>();
 		
 		int h;
 		for (int i = 0; i < n; i++){
 			for (int j = 0; j < m; j++){
 				h = nextInt();
 				lawn[i][j] = h;
 				alawn.add(new Cell(i, j, h));
 			}
 		}
 		
 		Collections.shuffle(alawn);
 		Collections.sort(alawn);		
 	}
 	
 	
 	String analizeTest() {
 		boolean [] rused = new boolean[n];
 		boolean [] cused = new boolean[m];
 		
 		int checksum;
 		int amount;
 		boolean rr;
 		boolean cc;
 		
 		boolean ans = true;
 		
 		for (Cell cell: alawn) {
 			if (!rused[cell.r] && !cused[cell.c]){
 				checksum = 0;
 				amount = 0;
 				rr = cc = false;
 				
 				for (int j = 0; j < m; j++){
 					if (!cused[j]){
 						checksum += lawn[cell.r][j];
 						amount++;
 					}
 				}
 				
 				if (checksum == cell.h * amount) {
 					rused[cell.r] = true;
 					rr = true;
 				}
 
 				checksum = 0;
 				amount = 0;
 
 				for (int i = 0; i < n; i++){
 					if (!rused[i]) {
 						checksum += lawn[i][cell.c];
 						amount++;
 					}
 				}
 				
 				if (checksum == cell.h * amount) {
 					cused[cell.c] = true;
 					cc = true;
 				}
 				
 				ans = rr || cc;
 				if (!ans) 
 					break;
 			}
 		}
 		
 		return (ans? ""YES"" : ""NO"");
 		
 	}
 	
 	void solve() throws IOException {
 		String res;
 		for (int k = 1; k <= t; k++){
 			readTest();
 			res = analizeTest();
 			out.print(""Case #"");
 			out.print(k);
 			out.print("": "");
 			out.println(res);
 		}
 		
 		out.flush();
 		out.close();
 	}
 	
 	
 	int n;
 	int m;
 	int[][] lawn;
 	ArrayList<Cell> alawn;
 	
 	StreamTokenizer in;
 	PrintWriter out;
 	int t;
 }","import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.math.BigDecimal;
 import java.util.Locale;
 import java.util.Scanner;
 
 
 public class B_large {
 
 	public static void main(String[] args) throws IOException {
 		CookieClickerL ccl = new CookieClickerL();
 		ccl.solve();
 	}
 
 }
 
 class CookieClickerL {
 	
 	CookieClickerL () throws IOException {
 		in = new Scanner(new BufferedReader(new FileReader(""input.txt"")));
 		in.useLocale(Locale.US);
 		t = in.nextInt();
 		out = new PrintWriter(""output.txt"");
 	}
 	
 	void analyzeTest(int tc) {
 		c = in.nextDouble();
 		f = in.nextDouble();
 		x = in.nextDouble();
 		
 //		BigDecimal bc = new BigDecimal(c);
 		BigDecimal bx = new BigDecimal(x);
 		
 		double prod = 2;
 		
 		BigDecimal time = bx.divide(new BigDecimal(prod));
 		BigDecimal ftime = new BigDecimal(""0"");
 		BigDecimal xtime = bx.divide(new BigDecimal(prod));
 		
 		do {
 			time = new BigDecimal(""0"").add(xtime);
 			ftime = ftime.add(new BigDecimal(c/prod));
 			prod = prod + f;
 			xtime = bx.divide(new BigDecimal(prod), 10, BigDecimal.ROUND_HALF_UP).add(ftime);
 		}
 		while (xtime.compareTo(time) < 0);
 		
 		ans = time;
 		out.print(""Case #"");
 		out.print(tc);
 		out.print("": "");
 		out.printf(Locale.US, ""%.7f"", ans);
 		out.println();
 	}
 	
 	void solve() {
 		for (int i = 1; i <= t; i++){
 			analyzeTest(i);
 		}
 		out.flush();
 		out.close();
 	}
 	
 	
 	double c;
 	double f;
 	double x;
 	
 	BigDecimal ans;
 	
 	Scanner in;
 	PrintWriter out;
 	
 	int t;
 	static final double EPS = 1e-7;
 }
",1
473,20246,"import java.io.*;
 import java.util.*;
 
 public class Main {
 
     private long[] other;
     private int n;
     private long A;
     private int curIndex;
     private long curMot;
 
 
 
     private void solve(){
         Scanner scanner;
         PrintStream out;
         try{
             scanner = new Scanner(new File(""A-small-attempt1.in""));
             out = new PrintStream(""outputA-small.txt"");
             try{
                 int numberOfCases = scanner.nextInt();
 
                 inputs:
                 for(int caseNum = 0;caseNum<numberOfCases;caseNum++){
                     //System.out.println(caseNum);
                     String res = ""Case #""+Integer.toString(caseNum+1)+"": "";
                     A = scanner.nextLong();
                     n = scanner.nextInt();
                     other = new long[n];
                     for(int i = 0;i<n;i++) {
                         other[i] = scanner.nextLong();
                     }
                     Arrays.sort(other);
                     long result = Long.MAX_VALUE;
                     if(A == 1){
                         result = n;
                         res+= result;
                     } else{
                         curIndex = 0;
                         curMot = A;
 
 
                         long adds = 0;
                         while(curIndex<n){
 
                             while(curIndex<n){
                                 if(other[curIndex]<curMot){
                                     curMot+=other[curIndex];
                                 } else break;
                                 curIndex++;
                             }
 
                             result = Math.min(result,adds+n-curIndex);
 
                             if(curIndex>=n)
                                 break;
 
                             while(curMot<=other[curIndex]){
                                 curMot+=curMot - 1;
                                 adds++;
                             }
                             //System.out.print(""[""+curIndex+"" ""+curMot+""]"");
                             result = Math.min(result,adds+n-curIndex);
                             if(curIndex==n-1){
                                 break;
                             }
                         }
 
                         res+=result;
                     }
                      //System.out.println();
                     out.println(res);
 
                 }
             } finally{
                 out.close();
                 scanner.close();
             }
 
         } catch (IOException ex){
             System.out.println(ex.getMessage());
         }
 
 
     }
 
     public static void main(String[] args) {
        new Main().solve();
     }
 }
","import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Scanner;
 
 
 public class Main {
 	
 	public static void main(String args[])
 	{
 		Scanner in = new Scanner(System.in);
 		int T = in.nextInt();
 		int i = 1;
 		while( i <= T)
 		{
 			int A = in.nextInt();
 			int B = in.nextInt();
 			int count = 0;
 			
 			
 			if ( 1 >= A && 1 <= B  )
 				count ++;
 			if ( 4 >= A && 4 <= B  )
 				count ++;
 			if ( 9 >= A && 9 <= B  )
 				count ++;
 			if ( 121 >= A && 121 <= B  )
 				count ++;
 			if ( 484 >= A && 484 <= B  )
 				count ++;
 			
 			System.out.println(""Case #"" + i + "": "" + count);
 			
 			i++;
 		}
 		
 	}
 	
 }
 
",0
474,4690,"package com.vovka.gdc2014.r2;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class B {
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner in = new Scanner(new FileInputStream(new File(""/Users/vovka/Documents/workspace/GDC2014/input.txt"")));
 		PrintWriter out = new PrintWriter(new File(""/Users/vovka/Documents/workspace/GDC2014/output.txt""));
 		B worker = new B();
 		int t = in.nextInt();
 		
 		for (int i=0;i<t;i++) {
 			worker.solve(i, in, out);
 		}
 		out.flush();
 		in.close();
 	}
 	
 	public void solve(int caseNum, Scanner in, PrintWriter out) {
 		int n = in.nextInt();
 		int[] data = new int[n];
 		int max = -1;
 		int mi = -1;
 		for (int i=0; i<n; i++) {
 			data[i] = in.nextInt();
 			if (data[i]>max) {
 				max = data[i];
 				mi = i;
 			}
 		}
 		
 		int res = evaluate(data, 0, mi);
 		for (int i=1; i<data.length; i++) {
 			int r = evaluate(data, i, mi);
 			if (r<res) res = r;
 		}
 		
 		out.println(""Case #""+(caseNum+1)+"": ""+res);
 	}
 	
 	private int evaluate(int[] dataSrc, int maxPos, int maxIndex) {
 		int[] data = new int[dataSrc.length];
 		System.arraycopy(dataSrc, 0, data, 0, dataSrc.length);
 		int t;
 		int sum = 0;
 		if (maxIndex>maxPos) {
 			for (int i = maxIndex-1; i>=maxPos; i--) {
 				t = data[i];data[i]=data[i+1];data[i+1]=t;
 				sum++;
 			}
 		} else if (maxIndex < maxPos) {
 			for (int i = maxIndex; i<maxPos; i++) {
 				t = data[i];data[i]=data[i+1];data[i+1]=t;
 				sum++;
 			}
 		}
 		
 		for (int j=0; j<maxPos; j++) {
 			for (int i=0; i<maxPos-j-1; i++) {
 				if (data[i]>data[i+1]) {
 					sum++;
 					t = data[i];data[i]=data[i+1];data[i+1]=t;
 				}
 			}
 		}
 		
 		for (int j=maxPos+1; j<data.length; j++) {
 			for (int i=maxPos+1; i<data.length-1; i++) {
 				if (data[i]<data[i+1]) {
 					sum++;
 					t = data[i];data[i]=data[i+1];data[i+1]=t;
 				}
 			}
 		}
 		return sum;
 	}
 }
","import java.util.*;
 import java.io.*;
 import java.math.*;
 import java.awt.*;
 import static java.lang.Math.*;
 import static java.lang.Integer.parseInt;
 import static java.lang.Double.parseDouble;
 import static java.lang.Long.parseLong;
 import static java.lang.System.*;
 import static java.util.Arrays.*;
 import static java.util.Collection.*;
 public class D
 {
 	static boolean[] visited = new boolean[1000];
 	public static void main(String[] args) throws IOException
 	{
 		BufferedReader br = new BufferedReader(new InputStreamReader(in));
 		int T = parseInt(br.readLine());
 		for(int t = 0; t++ < T; ) {
 			fill(visited, false);
 			int N = parseInt(br.readLine()), sum = 0;
 			String[] line = br.readLine().split("" "");
 			for(int n = 0; n < N; n++)
 				for(int i = parseInt(line[n]) - 1; !visited[i] && i != n; i = parseInt(line[i]) - 1) {
 					visited[i] = true;
 					sum++;
 				}
 			out.println(""Case #"" + t +"": "" + sum + "".000000""); 
 		}
 	}
 }
",0
475,15574,"package nithin.codejam.round.one.b;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.Random;
 import java.util.StringTokenizer;
 class process implements Runnable {
 	Thread t;
 	int print_val;
 	int n;
 	int[] arr;
 	int possible;
 	String res1,res2;
 	Random rd;
 	process(int a,int b,int[] c) {
 		print_val=a+1;
 		n=b;
 		arr=c;
 		possible=0;
 		rd=new Random();
 		t = new Thread(this);
 		t.run();
 	}
 
 	public void run() {
 		int sum1=0,sum2=0;
 		String str1="""";
 		String str2="""";
 		int[] flagarr1=new int[20];
 		int[] flagarr2=new int[20];
 		int a,b,flag=0;
 		for(int m=0;m<100000 && flag!=1;++m)
 		{
 			a=0;
 			b=0;
 			str1="""";
 			str2="""";
 			sum1=0;
 			sum2=0;
 			for(int i=0;i<20;++i)
 			{
 				flagarr1[i]=0;
 				flagarr2[i]=0;
 			}
 			for(int i=0;i<10 && flag!=1;++i)
 			{
 				a=rd.nextInt(20);
 				b=rd.nextInt(20);
 				if(flagarr1[a]!=0 || flagarr2[a]!=0)
 				{
 					while(flagarr1[a]==1 && flagarr2[a]==1)
 						a=rd.nextInt(20);
 						
 				}
 				flagarr1[a]=1;
 				flagarr2[a]=1;
 				if(flagarr2[b]!=0 || flagarr1[b]!=0)
 				{
 					while(flagarr2[b]==1 && flagarr1[b]==1)
 						b=rd.nextInt(20);
 				}
 				
 				flagarr1[b]=1;
 				flagarr2[b]=1;
 				sum1=sum1+arr[a];
 				sum2=sum2+arr[b];
 				str1=str1+arr[a]+"" "";
 				str2=str2+arr[b]+"" "";
 				if(sum1==sum2)
 				{
 					//System.out.println(""successful"");
 					//System.out.println(""str1=""+str1+"" str2=""+str2);
 					res1=str1;
 					res2=str2;
 					flag=1;
 					possible=1;
 				}
 			}
 			
 			//System.out.println(""a=""+a+"" b=""+b);
 		}
 	}
 	public void print()
 	{
 		if(possible==1)
 		{
 		System.out.println(""Case #""+print_val+"":\n""+res1+""\n""+res2);
 		}
 		else
 			System.out.println(""Case #""+print_val+"":\n""+""Impossible"");
 	}
 
 }
 
 public class Main {
 	public static void main(String[] args) throws Exception {
 		StringTokenizer st;
 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 		int t=Integer.parseInt(br.readLine());
 		process[] pr=new process[t];
 		for(int i=0;i<t;++i)
 		{
 			st=new StringTokenizer(br.readLine());
 			int n=Integer.parseInt(st.nextToken());
 			int[] arr=new int[20];
 			for(int j=0;j<n;++j)
 			{
 				arr[j]=Integer.parseInt(st.nextToken());
 			}
 			pr[i]=new process(i,n,arr);
 		}
 
 		for(int i=0;i<t;++i)
 		{
 			pr[i].t.join();
 			pr[i].print();
 		}
 		
 		
 	}
 }
","package eu.grzegorzjankowski;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Locale;
 
 public class CookieClickerAlpha {
 
 	public static void main(String[] args) {
 		BufferedReader br = null;
 		File file;
 
 		Locale.setDefault(Locale.US);
 
 		try {
 
 			String sCurrentLine;
 			file = new File(""c:\\CodeJam\\CookieClickerAlpha\\result.txt"");
 			if (file.exists())
 				file.delete();
 			file.createNewFile();
 
 			FileWriter fw = new FileWriter(file.getAbsoluteFile());
 			BufferedWriter bw = new BufferedWriter(fw);
 
 			br = new BufferedReader(new FileReader(
 					""c:\\CodeJam\\CookieClickerAlpha\\B-large.in""));
 
 			int t = Integer.parseInt(br.readLine());
 			for (int i = 0; i < t; i++) {
 				String[] data = br.readLine().split("" "");
 
 				double result = solveIt(Double.parseDouble(data[0]),
 						Double.parseDouble(data[1]),
 						Double.parseDouble(data[2]));
 				String formatedResult = String.format(""%.7f"", result);
 				bw.write(""Case #"" + (i + 1) + "": "" + formatedResult);
 				bw.newLine();
 				System.out.println(i + 1 + "" -> "" + (i + 1.0) * 100 / t + ""%"");
 
 			}
 			bw.close();
 			System.out.println(""done"");
 
 		} catch (IOException e) {
 			e.printStackTrace();
 		} finally {
 			try {
 				if (br != null)
 					br.close();
 			} catch (IOException ex) {
 				ex.printStackTrace();
 			}
 		}
 
 	}
 
 	private static double solveIt(double c, double f, double x) {
 		System.out.println(c + "" "" + f + "" "" + x);
 		double timeFactory = 0.0;
 		double timeCakes;
 		double min = Double.MAX_VALUE;
 		for (int i = 0;; i++) {
 			if (i > 0)
 				timeFactory += (c / (2 + f * (i - 1)));
 			timeCakes = x / (2 + f * i);
 			double timeTotal = timeCakes + timeFactory;
 
 			if (timeTotal < min)
 				min = timeTotal;
 			if (timeTotal > min)
 				return min;
 		}
 	}
 }
",0
476,2235,"import java.util.Scanner;
 import java.io.*;
 import java.util.HashSet;
 import java.util.LinkedList;
 
 
 public final class problem2 {
 
 	public static HashSet <String> hash;
 	
 	public static String decode(int min, int max){
 		int total = 0;
 		hash = new HashSet <String>();
 		
 		try{
 			//FileWriter fw = new FileWriter(""final1.txt"");
 			
 			for(int i = min ; i <= max ; i++){
 				String n = Integer.toString(i);
 				int len = n.length();
 				n = n.concat(n);
 				
 				int count = 0;
 				for(int j = 0 ; j <= len ; j++){
 					String tmp = n.substring(j, j+len);
 					
 					if(tmp.charAt(0) != '0'){
 						int m = Integer.valueOf(tmp);
 						
 						if(m >= min && m <= max){
 							if(!hash.contains(tmp)){
 								hash.add(tmp);
 								count++;
 								//fw.write(tmp + ""\n"");
 							}
 						}
 					}
 				
 				}
 				
 				if(count > 1)
 					count = count * (count - 1) / 2;
 				else
 					count = 0;
 				
 				total += count;
 			
 			}
 			//fw.write(total);
 			//fw.close();
 			
 			
 		}catch(Exception e){}
 		
 		return Integer.toString(total);
 		
 	}
 
 
 	
 	public static void main(String[] args){
 
 		try{
 			//Scanner sc = new Scanner(new File(""yo.txt""));
 			Scanner sc = new Scanner(new File(""C-large.in""));
 			FileWriter fw = new FileWriter(""Large.txt"");
 		
 		
 			String tmp = sc.nextLine();
 			int step = Integer.valueOf(tmp);
 		
 			int counter = 1;
 			while(sc.hasNextLine()){
 				//System.out.print(""Case #"" + counter + "": ""); 
 				
 				String s = sc.nextLine();
 				Scanner ssc = new Scanner(s);
 				int A = ssc.nextInt();
 				int B = ssc.nextInt();
 				
 				
 				//System.out.println(A + "" "" + B); 
 				String xx = decode(A, B);
 				System.out.println(""Case #"" + counter + "": "" + xx);
 				fw.write(""Case #"" + counter + "": "" + xx);
 				fw.write(""\n"");
 				counter++;
 				if(step < counter)
 					break;
 			}
 			fw.close();
 		}catch(Exception e){}
 		
 	}
 	
 }","// Google Code Jam 2011
 // lid
 
 package Real;
 import java.io.*;
 import java.math.BigInteger;
 import java.util.InputMismatchException;
 import org.apache.commons.lang.ArrayUtils;
 
 @SuppressWarnings(""unused"")
 class R2 implements Runnable {
     // params
 	//static String filePrefix = ""/jam/A-example"";
 
 	//static String filePrefix = ""/jam/A-small-attempt0"";
 	static String filePrefix = ""/jam/A-large"";
 	
 	// I/O
 	private InputReader in;
 	//@SuppressWarnings(""unused"")
 	private PrintWriter out;
 	
     public static void main(String[] args) {
         new Thread(new R2()).start();	// init filestreams then start thread
     }
     
     // Init filestreams
     public R2() {
 		try {
 			System.setIn(new FileInputStream(filePrefix + "".in""));
 			System.setOut(new PrintStream(new FileOutputStream(filePrefix + "".out"")));
 		} catch (FileNotFoundException e) {
 			log(""Tried to open "" + filePrefix + "".in"");
 			throw new RuntimeException();
 		}
 		in = new InputReader(System.in);
 		out = new PrintWriter(System.out);
 
     }
     
     // Start thread
     public void run() {
     	// Keep track of time for efficiency (Zaphod)
 		long startTime = System.currentTimeMillis();
     	
     	logn(""Starting."");
     	int num_cases = in.readInt();
     	logn(""Num_cases: "" + num_cases);
     	
     	for (int case_num = 0; case_num < num_cases; case_num++) {
     		//int L = in.readInt(); // length
     		int R = in.readInt();	// # rows
     		int C = in.readInt(); 	// # cols
     		logn(""Case "" + case_num + "": "" + R + "" "" + C);
     		char[][] grid = new char[R][C];
     		for (int i = 0; i < R; i++) {
     			for (int j = 0; j < C; j++) {
     				grid[i][j] = in.readCharacter();
     			}
     		}
     		
     		Boolean possible = true;
     		for (int i = 0; i < R; i++) {
     			for (int j = 0; j < C; j++) {
     				if (grid[i][j] == '#') {
     					// need to replace this with a red tile, so check next tiles
     					if ((j+1) == C || (i+1) == R) {
     						possible = false;
     						break;
     					} else if (grid[i+1][j] == '#' && grid[i][j+1] == '#' && grid[i+1][j+1] == '#') {
     						grid[i][j] = '/';
     						grid[i][j+1] = '\\';
     						grid[i+1][j+1] = '/';
 							grid[i+1][j] = '\\';
     					} else {
     						possible = false;
     						break;
     					}
     				}
     			}
     			if (!possible)
     				break;
     		}
     		
     		
     		fout(""Case #"" + (case_num + 1) + "": "");
     		
     		fout(""\n"");
     		if (!possible) {
     			fout(""Impossible"");
     		} else {
         		for (int i = 0; i < R; i++) {
         			for (int j = 0; j < C; j++) {
         				fout(""""+grid[i][j]);
         			}
         			fout(""\n"");
         		}
     		}
     		
     		fout (""\n"");
     	}
     	
     	logn(""Done."");
     	
 		long stopTime = System.currentTimeMillis();
 		logn(""Time: "" + (stopTime - startTime) / 1000.0);
     }
     
     private static void fout (String msg) {
     	System.out.print(msg);
     }
     
     private static void log (String msg) {
     	System.err.print(msg);
     }
     
     private static void logn (String msg) {
     	System.err.println(msg);
     }
     
     // readCharacter, readString, readInt, readLong, readLine, readDouble
 	//@SuppressWarnings(""unused"")
 	// from Egor Kulikov
 	private static class InputReader {
 		private InputStream stream;
 		private byte[] buf = new byte[1000];
 		private int curChar, numChars;
 
 		public InputReader(InputStream stream) {
 			this.stream = stream;
 		}
 
 		private int read() {
 			if (numChars == -1)
 				throw new InputMismatchException();
 			if (curChar >= numChars) {
 				curChar = 0;
 				try {
 					numChars = stream.read(buf);
 				} catch (IOException e) {
 					throw new InputMismatchException();
 				}
 				if (numChars <= 0)
 					return -1;
 			}
 			return buf[curChar++];
 		}
 
 		public int readInt() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			int res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public long readLong() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			long res = 0;
 			do {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			} while (!isSpaceChar(c));
 			return res * sgn;
 		}
 
 		public String readString() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			StringBuffer res = new StringBuffer();
 			do {
 				res.appendCodePoint(c);
 				c = read();
 			} while (!isSpaceChar(c));
 			return res.toString();
 		}
 
 		private boolean isSpaceChar(int c) {
 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
 		}
 
 		private String readLine0() {
 			StringBuffer buf = new StringBuffer();
 			int c = read();
 			while (c != '\n' && c != -1) {
 				buf.appendCodePoint(c);
 				c = read();
 			}
 			return buf.toString();
 		}
 
 		public String readLine() {
 			String s = readLine0();
 			while (s.trim().length() == 0)
 				s = readLine0();
 			return s;
 		}
 
 		public String readLine(boolean ignoreEmptyLines) {
 			if (ignoreEmptyLines)
 				return readLine();
 			else
 				return readLine0();
 		}
 
 		public BigInteger readBigInteger() {
 			try {
 				return new BigInteger(readString());
 			} catch (NumberFormatException e) {
 				throw new InputMismatchException();
 			}
 		}
 
 		public char readCharacter() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			return (char) c;
 		}
 
 		public double readDouble() {
 			int c = read();
 			while (isSpaceChar(c))
 				c = read();
 			int sgn = 1;
 			if (c == '-') {
 				sgn = -1;
 				c = read();
 			}
 			double res = 0;
 			while (!isSpaceChar(c) && c != '.') {
 				if (c < '0' || c > '9')
 					throw new InputMismatchException();
 				res *= 10;
 				res += c - '0';
 				c = read();
 			}
 			if (c == '.') {
 				c = read();
 				double m = 1;
 				while (!isSpaceChar(c)) {
 					if (c < '0' || c > '9')
 						throw new InputMismatchException();
 					m /= 10;
 					res += (c - '0') * m;
 					c = read();
 				}
 			}
 			return res * sgn;
 		}
 	}
 	
 	//@SuppressWarnings(""unused"")
 	private static int getBit (int input, int pos) {
     	input >>= pos;
     	return input & 0x0001;
     }
 }
 
",0
477,20271,"package Round1C;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Locale;
 import java.util.Scanner;
 
 
 public class R1C_C {
 
 	/**
 	 * @param args
 	 */
 	public static void main(String[] args) {
 		
 		FileReader fr = null ;
     	Scanner sc = null;
     	int n_cases = 0;
     	Locale.setDefault(Locale.US);
     	
     	try{
     		fr = new FileReader(args[0]);
     		sc = new Scanner(fr);
     		
     		if (sc.hasNextInt()) n_cases = sc.nextInt();
     		
     		sc.nextLine();
     		for (int i=0;i<n_cases;i++){
     			int N = sc.nextInt();
     			int M = sc.nextInt();
     			int K = sc.nextInt();
     			
     			int d = Math.min(N,M);
     			int res = K;
     			
     			if (d>2){
     				for (int x=3;x<=N;x++){
     					for(int y=3;y<=M;y++){
     						int t = x*y-4;
     						int m = (N-x)+(M-y);
     						if(t<=K){
     							int r;
     							if (m==0 || (K-t)>=4){
     								r = (K-t)+2*(x+y-4);
     								}
     							else{
     								r = (K-t)/2+(K-t)%2+2*(x+y-4);
     							}
     							if (res>r){
     								res = r;
     							}
     						}
     					}
     				}
     			}
     			
     			System.out.println(""Case #""+(i+1)+"": ""+res);
     			
     		}
     				
     		
     	} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		}
     	finally{
     		if(sc != null) sc.close();
     		if(fr != null)	try {fr.close();} catch (Exception e) {}
     	}
        	
 
 	}
 
 }
","package main;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.HashMap;
 
 public class Main {
     
     public static final String changeLine = System.getProperty(""line.separator"");
     
     public static void main(String[] args) throws FileNotFoundException, IOException{
         Main main = new Main();
     }
 
     public int n,m,k;
     
     public Main() throws FileNotFoundException, IOException{
         BufferedReader br = new BufferedReader(new FileReader(""D:/C-large.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""D:/result.txt""));
         int cases = Integer.parseInt(br.readLine());
         for (int caseNum = 0; caseNum < cases; caseNum++) {
             String [] split = br.readLine().split("" "");
             n = Integer.parseInt(split[0]);
             m = Integer.parseInt(split[1]);
             k = Integer.parseInt(split[2]);
             // output
             System.out.println(""Case #""+(caseNum+1)+"":"");
             bw.write(""Case #""+(caseNum+1)+"": "");
             bw.write(Integer.toString(cal()));
             bw.write(changeLine);
         }
         br.close();
         bw.close();
     }
 
     public int cal(){
         if (n==1 || n==2 || m==1 || m==2 || k<=4) {
             return k;
         }
         k-=5;
         int result = 4;
         int inner = (n-2)*(m-2)-1;
         if (k<=0) {
             return result;
         }
         if (inner > 0) {
             if (k<=2) {
                 return result + k;
             }
             k-=3;
             result += 2;
             if (k<=0) {
                 return result;
             }
         }
         inner --;
         if (n==3 || m==3){
             while(inner > 0) {
                 inner --;
                 if (k<=2) {
                     return result + k;
                 }
                 k-=3;
                 result += 2;
                 if (k<=0) {
                     return result;
                 }
             }
         } else {
             while(inner > 0) {
                 inner --;
                 k -= 2;
                 result ++;
                 if (k<=0) {
                     return result;
                 }
             }
         }
         if (k>0) {
             return result + k;
         }
         return result;
     }
 }",0
478,1526,"package midnighter.googlejam.y2014;
 
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class QualificationD
 {
 	static final String file = ""D-large"";
 	
     Scanner in;
     PrintWriter out;
    
     public String oneCase()
     {
     	int N = in.nextInt(); 
     	
     	List<Long> all = new ArrayList<Long>();
     	
     	for (int i = 0; i < 2; i++)
     	{
     		in.nextLine();
     		for (int k = 0; k < N; k++)
     		{
     			double val = in.nextDouble();
     			all.add(Math.round(val * 1000000 + i));
     		}
     	}
     	
     	Collections.sort(all);
     	
     	return getPoints(all, 1) + "" "" + (N - getPoints(all, 0));
     }
     
     private int getPoints(List<Long> all, int player) {
     	int points = 0;
     	int cnt = 0;
     	for (int i = 0; i < all.size(); i++)
     		if (all.get(i) % 2 == player)
     			cnt++;
     		else
     			if (cnt > 0)
     			{
     				cnt--;
     				points++;
     			}
     	
     	return points;
     }
     
     public void run() throws Exception
     {
     	in = new Scanner(new FileReader(""inputs/"" + file + "".in"")).useLocale(Locale.ENGLISH);
         out = new PrintWriter(new FileWriter(""outputs/"" + file + "".out""));
         
         int nCases = in.nextInt();
         in.nextLine();
         for (int c = 1; c <= nCases; c++)
         {
             String line = ""Case #"" + c + "": "" + oneCase();
             out.println(line);
             System.out.println(line);
         }
        
         out.flush();
         out.close();
         in.close();
     }
    
     public static void main(String[] args) throws Exception
     {
         new QualificationD().run();
     }
 }
","package midnighter.googlejam.y2014;
 
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class QualificationC
 {
 	static final String file = ""C-small-attempt1"";
 	
     Scanner in;
     PrintWriter out;
    
     public String oneCase()
     {
     	int[] dim = new int[]{in.nextInt(), in.nextInt()};
     	int M = in.nextInt();
     	
     	byte[][] arr = new byte[dim[0]][dim[1]];
     	
     	boolean possible = fill(arr, dim, M);
     	arr[0][0] = 2;
     	
     	if (!possible)
     		return ""\nImpossible"";
     	
     	String res = """";
     	for (int i = 0; i < dim[0]; i++)
     	{
     		res += ""\n"";
     		for (int k = 0; k < dim[1]; k++)
     			if (arr[i][k] == 1)
     				res += ""*"";
     			else if (arr[i][k] == 2)
     				res += ""c"";
     			else
     				res += ""."";
     		
     	}
     	
     	return res;
     }
     
     private boolean fill(byte[][] arr, int[] dim, int M) {
     	if (M == 0)
     		return true;
     	
     	int sh = dim[0] < dim[1] ? 0 : 1;
     	
     	if (M == 1)
     	{
     		if (dim[sh] != 2)
     		{
     			arr[dim[0] - 1][dim[1] - 1] = 1;
     			return true;
     		} else
     			return false;
     	}
       	
     	if (M > dim[sh])
     	{
     		for (int i = 0; i < dim[sh]; i++)
     			if (sh == 0)
     				arr[i][dim[1] - 1] = 1;
     			else
     				arr[dim[0] - 1][i] = 1;
     		
     		int[] nDim = Arrays.copyOf(dim, 2);
     		nDim[1 - sh]--;
     		return fill(arr, nDim, M - dim[sh]);
     	} else {
     		if (dim[sh] == 2)
     			return false;
     		if (M > dim[1 - sh] - 2)
     			return false;
     		
     		for (int i = 0; i < dim[1 - sh] - 2 && i < M; i++)
     			if (sh == 0)
     				arr[dim[0] - 1][dim[1] - i - 1] = 1;
     			else
     				arr[dim[0] - i - 1][dim[1] - 1] = 1;
     		
     		return true;
     	}
     }
     
     public void run() throws Exception
     {
     	in = new Scanner(new FileReader(""inputs/"" + file + "".in"")).useLocale(Locale.ENGLISH);
         out = new PrintWriter(new FileWriter(""outputs/"" + file + "".out""));
         
         int nCases = in.nextInt();
         in.nextLine();
         for (int c = 1; c <= nCases; c++)
         {
             String line = ""Case #"" + c + "": "" + oneCase();
             out.println(line);
             System.out.println(line);
         }
        
         out.flush();
         out.close();
         in.close();
     }
    
     public static void main(String[] args) throws Exception
     {
         new QualificationC().run();
     }
 }
",1
479,20663,"package com.zms.code;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.math.BigInteger;
 import java.util.*;
 
 public class Jam4 {
 
     public static void main1(String[] args) throws Exception {
         Random random=new Random();
         int t=0;
         double d=1.0/6;
         int total=1000000;
         for(int i=0;i<total;i++) {
             do {
                 t++;
             } while(random.nextDouble()>=d);
         }
         System.out.println(t*1.0/total);
     }
 
     public static void main2(String[] args) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
         List<Integer> list=new ArrayList<Integer>();
         String line;
         Jam4 one=new Jam4();
         while ((line = reader.readLine()).length() > 0) {
             list.clear();
             for (String s : line.split("" "")) {
                 s=s.trim();
                 if(s.length()>0) {
                     list.add(Integer.parseInt(s));
                 }
             }
             int size=list.size();
             if(size>0) {
                 int[] cs=new int[size];
                 for(int i=0;i<size;i++) {
                     cs[i]=list.get(i);
                 }
                 System.out.println(one.test(cs));
             } else {
                 break;
             }
         }
     }
 
     public static void main3(String[] args) throws Exception {
         Random random=new Random();
         Set<Integer> set=new HashSet<Integer>();
         while(set.size()<1000) {
             set.add(random.nextInt());
         }
         int[] cs=new int[set.size()];
         int index=0;
         for (Integer n : set) {
             cs[index++]=n;
         }
         System.out.println(new Jam4().test(cs));
     }
 
     public static void main(String[] args) throws Exception {
         int t=0;
         Random random=new Random();
         double a=2.0/3;
         int total=1000000;
         for(int i=0;i<total;i++) {
             while(true) {
                 t++;
                 double d=random.nextDouble();
                 if(d<0.5) {
                     t+=2;
                     break;
                 } else if(d<a) {
                     break;
                 }
             }
         }
         System.out.println(t*1.0/total);
     }
 
     public void test(Scanner scanner,PrintWriter output) throws Exception {
         int count=scanner.nextInt();
         for(int i=1;i<=count;i++) {
             int c=scanner.nextInt();
             int[] cs=new int[c];
             for(int j=0;j<c;j++) {
                 cs[j]=scanner.nextInt();
             }
             BigInteger d=test(cs);
             output.printf(""Case #%d: %d.000000\n"",i,d);
             output.flush();
         }
     }
 
     public BigInteger test(int[] cs) {
         for (int n : cs) {
             System.out.printf(""%d , "", n);
         }
         System.out.println();
         Map<Integer,Integer> map=new TreeMap<Integer, Integer>();
         for (int i : cs) {
             map.put(i,0);
         }
         int index=0;
         for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
             entry.setValue(index++);
         }
         int len=cs.length;
         Set<Integer> set1=new LinkedHashSet<Integer>();
         for(int i=0;i<len;i++) {
             cs[i]=map.get(cs[i]);
             if(cs[i]!=i) {
                 set1.add(cs[i]);
             }
         }
         map=new HashMap<Integer, Integer>();
         for(int i=0;i<len;i++) {
             map.put(cs[i],i);
         }
         List<Set<Integer>> list=new ArrayList<Set<Integer>>();
         while(set1.size()>0) {
             Set<Integer> set2=new LinkedHashSet<Integer>();
             int n1=set1.iterator().next();
             int n2=map.get(n1);
             while(true) {
                 set1.remove(n1);
                 set2.add(n1);
                 if(set2.contains(n2)) {
                     break;
                 } else {
                     n1=n2;
                     n2=map.get(n1);
                 }
             }
             assert(set2.size()>1);
             list.add(set2);
         }
         BigInteger t=BigInteger.ZERO;
         for (Set<Integer> set : list) {
             t=t.add(test(set.size()));
         }
         return t;
     }
 
     public BigInteger test(int n) {
         /*BigInteger t=BigInteger.ONE;
         for(int i=2;i<=n;i++) {
             t=t.multiply(BigInteger.valueOf(i));
         }
         return t;*/
         //return BigInteger.valueOf((n-1)*2);
         return BigInteger.valueOf(n);
     }
 
 }
","import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Scanner;
 
 
 public class GCJB {
 	public static void write(String filename, String content) throws IOException
 	{
 		BufferedWriter out = new BufferedWriter( new FileWriter(filename));
 		out.write( content );
 		out.close();
 	}
 
 	public void solve() throws IOException
 	{
 		Scanner cin = new Scanner( new File(""input/B-small-attempt3.in""));;
 		int T = cin.nextInt();
 		String ans = """";
 		for(int cas=1;cas<=T;cas++)
 		{
 			int r = cin.nextInt();
 			int c = cin.nextInt();
 			int d = cin.nextInt();
 			String [] x = new String[r];
 			int [][] w = new int[r][c];
 			
 			for(int i=0;i<r;i++)
 			{
 				x[i] = cin.next();
 				for(int j=0;j<c;j++)
 				{
 					w[i][j] = x[i].charAt(j)-'0';
 				}			
 			}
 			int maxK = 0;
 			for(int x1=0;x1<r-2;x1++)
 				for(int y1=0;y1<c-2;y1++)
 				{
 					int km = Math.min(r-x1+1,c-y1+1);
 					for(int k=3;k<km;k++)
 					{
 						int x2 = x1 + k -1;
 						int y2 = y1 + k -1;
 						double xw = 0;
 						double xpw = 0;
 						double yw = 0;
 						double ypw = 0;
 						for(int i=x1;i<x1+k;i++)
 							for(int j=y1;j<y1+k;j++)
 							{
 								if( i==x1 && ( j==y1 || j==y2 ) || i==x2 && ( j==y1 || j==y2) )
 									continue;
 								xw += w[i][j] + d;
 								yw += w[i][j] + d;
 								xpw += (i+1)*(w[i][j] + d);
 								ypw += (j+1)*(w[i][j] + d);
 							}
 					//	System.out.println(x1+"" "" + y1 + "" "" + k + "" "" + xw + "" ""+ yw + "" "" +xpw+ "" "" + (xpw/xw) + "" "" + ypw+ "" "" + (ypw/yw) + "" "" + (x1+k/2+1) );
 						xpw /= xw;
 						ypw /= yw;
 						if( xpw <= x1+k/2.0 +0.5+ 1e-6 && xpw >= x1+k/2.0 + 0.5- 1e-6 && ypw <= y1+k/2.0+0.5 + 1e-6 && ypw >= y1+k/2.0+0.5 -1e-6 )
 						{
 							if( k > maxK )
 								maxK = k;
 						}
 					}
 				}
 			if( maxK>=3 )
 				ans += ""Case #"" + cas + "": "" +maxK+ ""\n"";
 			else
 				ans += ""Case #"" + cas + "": IMPOSSIBLE\n"";
 		}
 		System.out.println(ans);
 		GCJB.write(""output/outputB.txt"",ans);
 	}
 	public static void main(String[] arg) throws IOException{
 		GCJB B = new GCJB();
 		B.solve();
 		System.out.println(""Finish."");
 	}
 }
",0
480,12992,"
 import java.io.*;
 
 public class Main {
 	
 	public static void main(String args[]) throws IOException{
 		
 		BufferedReader in = new BufferedReader(new FileReader(""B-small-attempt1.in""));
 		PrintWriter out = new PrintWriter(""E.txt"");
 		
 		int tests = Integer.parseInt(in.readLine());
 		int[] baseCount;
 		String[] adder;
 		String[] oppose;
 		
 		for(int i = 0; i < tests; i++){
 			
 			baseCount = new int[27];
 			adder = new String[27];
 			oppose = new String[27];
 			
 			String input = in.readLine();
 			
 			int spaceIndex = input.indexOf("" "");			
 			int c = Integer.parseInt(input.substring(0,spaceIndex));
 			input = takeInput(input,c,adder,0);
 			
 			spaceIndex = input.indexOf("" "");
 			int d = Integer.parseInt(input.substring(0,spaceIndex));	
 			input = takeInput(input,d,oppose,1);
 			
 			//String ans = new String(); 
 			spaceIndex = input.indexOf("" "");
 			input = input.substring(spaceIndex + 1);
 			String ans = calculateAns(input,adder,oppose,baseCount);
 			
 			out.print(""Case #"" + (i+1) + "": ["");
 			for(int j = 0; j < ans.length(); j++){
 				
 				if(j == 0){
 					
 					out.print(ans.charAt(j));
 					
 				}
 				else{
 					
 					out.print("", "" + ans.charAt(j));
 					
 				}
 				
 			}
 			out.print(""]"");
 			out.println();
 			
 		}
 		out.close();
 		
 	}
 	
 	public static String takeInput(String input,int no,String[] arr,int id){
 		
 		int spaceIndex = input.indexOf("" "");
 		int index = 0;
 		String feed;
 		
 		input = input.substring(spaceIndex + 1);
 		for(int i = 0; i < no; i++){
 			
 			spaceIndex = input.indexOf("" "");			
 			feed = input.substring(0,spaceIndex);
 			if(id == 0){
 			
 				arr[feed.charAt(0) - 64] = feed.substring(1,2) + feed.substring(0,1) + feed.substring(2);
 				arr[feed.charAt(1) - 64] = feed;
 			
 			}
 			else if(id == 1){
 				
 				arr[feed.charAt(0) - 64] = feed.substring(1);
 				arr[feed.charAt(1) - 64] = feed.substring(0,1);
 				
 			}
 			else{
 				
 				arr[index++] = feed;
 				
 			}
 			input = input.substring(spaceIndex + 1);
 			
 		}
 		return input;
 		
 	}
 	
 	public static String calculateAns(String input,String[] add,String[] opp,int[] baseCount){
 		
 		int index;
 		int retLength;
 		String ch;
 		String ret = """";
 		
 		for(int i = 0; i < input.length(); i++){
 			
 			index = input.charAt(i) - 64;
 			
 			if(ret.equals("""")){
 				
 				ret = input.substring(i,i + 1);
 				baseCount[ret.charAt(0) - 64]++;
 				continue;
 				
 			}
 			ch = input.substring(i,i + 1);
 			ret += ch;
 			baseCount[ch.charAt(0) - 64]++;
 			
 			if(add[index] != null){
 				
 				if(ret.endsWith(add[index].substring(0,2))){
 					
 					retLength = ret.length();
 					baseCount[ret.substring(retLength - 1).charAt(0) - 64]--;
 					baseCount[ret.substring(retLength - 2).charAt(0) - 64]--;
 					ret = ret.replace(ret.substring(retLength - 2),add[index].substring(2));
 					continue;
 				}
 				
 			}
 			if(opp[ch.charAt(0) - 64] != null){
 				
 				if(baseCount[opp[ch.charAt(0) - 64].charAt(0) - 64] > 0){
 					
 					ret = """";
 					baseCount = new int[27];
 					
 				}
 				
 			}
 			
 		}
 		return ret;
 		
 	}
 
 }
","package codeJam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Iterator;
 
 /**
  * https://code.google.com/codejam/contest/2270488/dashboard#s=p1
  * 
  * @author Weiwei Cheng
  */
 public class Lawnmower {
 
     private static ArrayList<Integer> getUniqueValues(int[][] array){
         
         ArrayList<Integer> ans = new ArrayList<Integer>();
         
         HashSet<Integer> set = new HashSet<Integer>();
         
         for(int[] a : array){
             for(int i : a){
                 set.add(i);
             }
         }
         
         Iterator<Integer> it = set.iterator();
         
         int[] values = new int[set.size()];
         int idx = 0;
         
         while(it.hasNext()){
             values[idx++] = it.next();
         }
         
         Arrays.sort(values);
         
         for(int i=0; i<values.length; i++){
             if(i==0){
                 ans.add(values[i]);
             }
             else if(values[i] != values[i-1]){
                 ans.add(values[i]);
             }
         }
         
         return ans;
     }
     
     private static boolean valueIsOkay(int value, int[][] array){
         
         for(int i=0; i<array.length; i++){
             for(int j=0; j<array[i].length; j++){
                 if(array[i][j] == value){
                     boolean rowOkay = true;
                     boolean colOkay = true;
                     
                     /* check row */
                     for(int k=0; k<array[i].length; k++){
                         if(array[i][k] != value){
                             rowOkay = false;
                             break;
                         }
                     }
                     /* check column */
                     for(int k=0; k<array.length; k++){
                         if(array[k][j] != value){
                             colOkay = false;
                             break;
                         }
                     }
                     
                     if(! (rowOkay || colOkay)){
                         return false;
                     }
                 }
             }
         }
         
         return true;
     }
     
     public static void main(String[] args) throws Exception {
         
         BufferedReader br = new BufferedReader(new FileReader(""_input.in""));
         BufferedWriter bw = new BufferedWriter(new FileWriter(""_output.in""));
 
         br.readLine();//first line for the case count
 
         String line = null;
         int index = 0;
         
         while((line = br.readLine())!=null){
             
             String[] s_array = line.split(""\\s"");  
             
             int[][] array = new int[Integer.parseInt(s_array[0])][Integer.parseInt(s_array[1])];
             
             for(int i=0; i<array.length; i++){
                 s_array = br.readLine().split(""\\s"");
                 for(int j=0; j<s_array.length; j++){
                     array[i][j] = Integer.parseInt(s_array[j]); 
                 }
             }
             
             ArrayList<Integer> uniqueValues = getUniqueValues(array);
 
             for(int k=0; k<uniqueValues.size(); k++){
                 int value = uniqueValues.get(k);
                 if(valueIsOkay(uniqueValues.get(k), array)){
                     if(k==uniqueValues.size()-1){
                         bw.append(""Case #"" + ++index + "": YES\n"");
                         break;
                     }
                     for(int i=0; i<array.length; i++){
                         for(int j=0; j<array[i].length; j++){
                             if(array[i][j] == value){
                                 array[i][j] = uniqueValues.get(k+1);
                             }
                         }
                     }
                 }
                 else{
                     bw.append(""Case #"" + ++index + "": NO\n"");
                     break;
                 }
             }
         }
         
         br.close();
         bw.close();
         System.out.println(""DONE!"");
     }
 
 }
",0
481,3160,"import java.io.*;
 import java.util.*;
  
 class C
 {
     static int n;
     static boolean[][] buur;
     static boolean[] vis;
     static int[] stack=new int[100];
     
     static boolean[] kanvis;
     
     static void dfs(int cur)
     {
         kanvis[cur]=true;
         for(int i=0;i<n;i++)
             if(buur[cur][i]&&!kanvis[i])
                 dfs(i);
     }
 
     static boolean kan(int index, int to)
     {
         for(int i=0;i<n;i++)
             kanvis[i]=vis[i];
         for(int i=0;i<=index;i++)
             dfs(stack[i]);
         for(int i=0;i<n;i++)
             if(!kanvis[i])
                 return false;
         return true;
     }
 
     public static void main(String[] args) throws IOException
     {
         Scanner sc=new Scanner(System.in);
         int numTests=sc.nextInt();
         for(int test=1;test<=numTests;test++)
         {
             n=sc.nextInt();
             int m=sc.nextInt();
 
             int[] zip=new int[n];
             vis=new boolean[n];
             buur=new boolean[n][n];
             kanvis=new boolean[n];
 
             for(int i=0;i<n;i++)
                 zip[i]=sc.nextInt();
             for(int i=0;i<m;i++)
             {
                 int a=sc.nextInt();
                 int b=sc.nextInt();
                 a--;
                 b--;
                 buur[a][b]=buur[b][a]=true;
             }
 
             int indlo=0;
             for(int i=1;i<n;i++)
                 if(zip[i]<zip[indlo])
                     indlo=i;
 
             String res=""""+zip[indlo];
             vis[indlo]=true;
             int ns=0;
             stack[ns++]=indlo;
 
             for(int rep=1;rep<n;rep++)
             {
                 int best=123456789;
                 int bi=-1, bj=-1;
                 for(int i=ns-1;i>=0;i--)
                     for(int j=0;j<n;j++)
                         if(!vis[j]&&buur[stack[i]][j]&&zip[j]<best&&kan(i,j))
                         {
                             best=zip[j];
                             bi=i;
                             bj=j;
                         }
 
                 res+=best;
                 vis[bj]=true;
                 ns=bi+1;
                 stack[ns++]=bj;
             }
 
             System.out.println(""Case #""+test+"": ""+res);
         }
 
     }
 }","import java.io.*;
 import java.util.*;
  
 class C
 {
     static int n;
     static boolean[][] buur;
     static boolean[] vis;
     static int[] stack=new int[100];
     
     static boolean[] kanvis;
     
     static void dfs(int cur)
     {
         kanvis[cur]=true;
         for(int i=0;i<n;i++)
             if(buur[cur][i]&&!kanvis[i])
                 dfs(i);
     }
 
     static boolean kan(int index, int to)
     {
         for(int i=0;i<n;i++)
             kanvis[i]=vis[i];
         for(int i=0;i<=index;i++)
             dfs(stack[i]);
         for(int i=0;i<n;i++)
             if(!kanvis[i])
                 return false;
         return true;
     }
 
     public static void main(String[] args) throws IOException
     {
         Scanner sc=new Scanner(System.in);
         int numTests=sc.nextInt();
         for(int test=1;test<=numTests;test++)
         {
             n=sc.nextInt();
             int m=sc.nextInt();
 
             int[] zip=new int[n];
             vis=new boolean[n];
             buur=new boolean[n][n];
             kanvis=new boolean[n];
 
             for(int i=0;i<n;i++)
                 zip[i]=sc.nextInt();
             for(int i=0;i<m;i++)
             {
                 int a=sc.nextInt();
                 int b=sc.nextInt();
                 a--;
                 b--;
                 buur[a][b]=buur[b][a]=true;
             }
 
             int indlo=0;
             for(int i=1;i<n;i++)
                 if(zip[i]<zip[indlo])
                     indlo=i;
 
             String res=""""+zip[indlo];
             vis[indlo]=true;
             int ns=0;
             stack[ns++]=indlo;
 
             for(int rep=1;rep<n;rep++)
             {
                 int best=123456789;
                 int bi=-1, bj=-1;
                 for(int i=ns-1;i>=0;i--)
                     for(int j=0;j<n;j++)
                         if(!vis[j]&&buur[stack[i]][j]&&zip[j]<best&&kan(i,j))
                         {
                             best=zip[j];
                             bi=i;
                             bj=j;
                         }
 
                 res+=best;
                 vis[bj]=true;
                 ns=bi+1;
                 stack[ns++]=bj;
             }
 
             System.out.println(""Case #""+test+"": ""+res);
         }
 
     }
 }",1
482,233,"package RoundB2013;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 
 public class C implements Runnable {
 	BufferedReader br;
 
 	public static void main(String[] args) {
 		new Thread(new C()).run();
 	}
 
 	StringTokenizer in;
 	PrintWriter out;
 
 	public String nextToken() throws IOException {
 		while (in == null || !in.hasMoreTokens()) {
 			in = new StringTokenizer(br.readLine());
 		}
 
 		return in.nextToken();
 	}
 
 	public int nextInt() throws IOException {
 		return Integer.parseInt(nextToken());
 	}
 
 	public long nextLong() throws IOException {
 		return Long.parseLong(nextToken());
 	}
 
 	public double nextDouble() throws IOException {
 		return Double.parseDouble(nextToken());
 	}
 
 	int sid = 0;
 	Trie[] tries = new Trie[1125078];
 
 	HashMap<State, Integer> cache = new HashMap<C.State, Integer>();
 
 	public class State {
 		int tid;
 		int l;
 		int le;
 
 		public State(int tid, int l, int le) {
 			this.tid = tid;
 			this.l = l;
 			this.le = le;
 		}
 
 		public boolean equals(Object o) {
 			State s = (State) o;
 			return s.tid == tid && s.l == l && s.le == le;
 		}
 
 		public int hashCode() {
 			return (tid * 41 + l) * 6 + le;
 		}
 	}
 
 	public class Trie {
 		Trie[] next = new Trie[26];
 		boolean end;
 		int id = sid++;
 
 		public Trie() {
 			tries[id] = this;
 		}
 
 		public void add(String word) {
 
 			Trie now = this;
 			for (int i = 0; i < word.length(); i++) {
 				int z = word.charAt(i) - 'a';
 				if (now.next[z] == null)
 					now.next[z] = new Trie();
 				now = now.next[z];
 			}
 
 			now.end = true;
 		}
 	}
 
 	int cnt = 0;
 
 	String s;
 
 	int INF = Integer.MAX_VALUE / 2;
 
 	public int find(Trie t, int l, int le) {
 		State st = new State(t.id, l, le);
 
 		if (cache.containsKey(st))
 			return cache.get(st);
 
 		cnt++;
 
 		int min = INF;
 
 		if (t.end) {
 			if (l < s.length())
 				min = Math.min(find(tries[0], l, le), min);
 			else
 				return 0;
 		}
 
 		if (l == s.length())
 			return INF;
 
 		int z = s.charAt(l) - 'a';
 		for (int i = 0; i < 26; i++) {
 			if (t.next[i] == null)
 				continue;
 
 			if (i == z) {
 				min = Math
 						.min(find(t.next[i], l + 1, Math.min(le + 1, 5)), min);
 			} else {
 				if (le >= 5) {
 					min = Math.min(min, find(t.next[i], l + 1, 1) + 1);
 				}
 			}
 		}
 
 		cache.put(st, min);
 
 		return min;
 	}
 
 	public void solve() throws IOException {
 		s = nextToken();
 
 		cache.clear();
 
 		find(tries[0], 0, 5);
 
 		System.err.println(cnt);
 
 		int min = Integer.MAX_VALUE;
 		for (int i = 0; i < 6; i++) {
 			State st = new State(0, 0, i);
 
 			if (cache.containsKey(st))
 				min = Math.min(min, cache.get(st));
 		}
 		out.println(min);
 	}
 
 	public void run() {
 		try {
 			BufferedReader dic = new BufferedReader(new FileReader(
 					""dictionary.txt""));
 
 			tries[0] = new Trie();
 
 			String line;
 			while ((line = dic.readLine()) != null) {
 				tries[0].add(line);
 			}
 
 			System.err.println(""Build dic "" + sid);
 
 			br = new BufferedReader(new FileReader(""input.txt""));
 			out = new PrintWriter(""output.txt"");
 
 			int t = nextInt();
 			for (int i = 0; i < t; i++) {
 				System.err.println(i);
 				out.print(""Case #"" + (i + 1) + "": "");
 				solve();
 			}
 
 			out.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 }
","package RoundB2013;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.util.*;
 
 public class C implements Runnable {
 	BufferedReader br;
 
 	public static void main(String[] args) {
 		new Thread(new C()).run();
 	}
 
 	StringTokenizer in;
 	PrintWriter out;
 
 	public String nextToken() throws IOException {
 		while (in == null || !in.hasMoreTokens()) {
 			in = new StringTokenizer(br.readLine());
 		}
 
 		return in.nextToken();
 	}
 
 	public int nextInt() throws IOException {
 		return Integer.parseInt(nextToken());
 	}
 
 	public long nextLong() throws IOException {
 		return Long.parseLong(nextToken());
 	}
 
 	public double nextDouble() throws IOException {
 		return Double.parseDouble(nextToken());
 	}
 
 	int sid = 0;
 	Trie[] tries = new Trie[1125078];
 
 	HashMap<State, Integer> cache = new HashMap<C.State, Integer>();
 
 	public class State {
 		int tid;
 		int l;
 		int le;
 
 		public State(int tid, int l, int le) {
 			this.tid = tid;
 			this.l = l;
 			this.le = le;
 		}
 
 		public boolean equals(Object o) {
 			State s = (State) o;
 			return s.tid == tid && s.l == l && s.le == le;
 		}
 
 		public int hashCode() {
 			return (tid * 41 + l) * 6 + le;
 		}
 	}
 
 	public class Trie {
 		Trie[] next = new Trie[26];
 		boolean end;
 		int id = sid++;
 
 		public Trie() {
 			tries[id] = this;
 		}
 
 		public void add(String word) {
 
 			Trie now = this;
 			for (int i = 0; i < word.length(); i++) {
 				int z = word.charAt(i) - 'a';
 				if (now.next[z] == null)
 					now.next[z] = new Trie();
 				now = now.next[z];
 			}
 
 			now.end = true;
 		}
 	}
 
 	int cnt = 0;
 
 	String s;
 
 	int INF = Integer.MAX_VALUE / 2;
 
 	public int find(Trie t, int l, int le) {
 		State st = new State(t.id, l, le);
 
 		if (cache.containsKey(st))
 			return cache.get(st);
 
 		cnt++;
 
 		int min = INF;
 
 		if (t.end) {
 			if (l < s.length())
 				min = Math.min(find(tries[0], l, le), min);
 			else
 				return 0;
 		}
 
 		if (l == s.length())
 			return INF;
 
 		int z = s.charAt(l) - 'a';
 		for (int i = 0; i < 26; i++) {
 			if (t.next[i] == null)
 				continue;
 
 			if (i == z) {
 				min = Math
 						.min(find(t.next[i], l + 1, Math.min(le + 1, 5)), min);
 			} else {
 				if (le >= 5) {
 					min = Math.min(min, find(t.next[i], l + 1, 1) + 1);
 				}
 			}
 		}
 
 		cache.put(st, min);
 
 		return min;
 	}
 
 	public void solve() throws IOException {
 		s = nextToken();
 
 		cache.clear();
 
 		find(tries[0], 0, 5);
 
 		System.err.println(cnt);
 
 		int min = Integer.MAX_VALUE;
 		for (int i = 0; i < 6; i++) {
 			State st = new State(0, 0, i);
 
 			if (cache.containsKey(st))
 				min = Math.min(min, cache.get(st));
 		}
 		out.println(min);
 	}
 
 	public void run() {
 		try {
 			BufferedReader dic = new BufferedReader(new FileReader(
 					""dictionary.txt""));
 
 			tries[0] = new Trie();
 
 			String line;
 			while ((line = dic.readLine()) != null) {
 				tries[0].add(line);
 			}
 
 			System.err.println(""Build dic "" + sid);
 
 			br = new BufferedReader(new FileReader(""input.txt""));
 			out = new PrintWriter(""output.txt"");
 
 			int t = nextInt();
 			for (int i = 0; i < t; i++) {
 				System.err.println(i);
 				out.print(""Case #"" + (i + 1) + "": "");
 				solve();
 			}
 
 			out.close();
 		} catch (IOException e) {
 			e.printStackTrace();
 			System.exit(1);
 		}
 	}
 }
",1
483,5158,"package com.jam.qualify;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.Date;
 import java.util.Scanner;
 
 public class BotTrust2
 {
 	public static void main(String[] args)
 	{
 		try
 		{
 			System.out.println(""Start Time :: "" + new Date());
 			BufferedWriter bw;
 			Scanner in = new Scanner(new BufferedReader(new FileReader(new File(""IN\\A-large.in""))));
 			bw = new BufferedWriter(new FileWriter(new File(""OUT\\A-large.out"")));
 
 			int nTestCase = in.nextInt();
 			for (int i = 0; i < nTestCase; i++)
 			{
 				int t = 0;
 				int nButtons = in.nextInt();
 				int op = 1, ot = 0, bp = 1, bt = 0, tdiff, pdiff;
 				for (int j = 0; j < nButtons; j++)
 				{
 					String r = in.next();
 					int p = in.nextInt();
 
 					switch (r.charAt(0))
 					{
 						case 'O':
 							tdiff = t - ot;
 							pdiff = p - op;
 							if (pdiff != 0)
 							{
 								if (tdiff > 0)
 								{
 									if (tdiff <= Math.abs(pdiff))
 									{
 										if (pdiff < 0)
 										{
 											op = op - tdiff;
 										}
 										else
 										{
 											op = op + tdiff;
 										}
 										ot = ot + tdiff;
 									}
 									else
 									{
 										op = op + pdiff;
 										ot = ot + Math.abs(pdiff);
 									}
 								}
 							}
 							pdiff = p - op;
 							if (pdiff != 0)
 							{
 								op = op + pdiff;
 								ot = ot + Math.abs(pdiff);
 								t = t + Math.abs(pdiff);
 							}
 							// push button;
 							t++;
 							ot = t;
 							break;
 						case 'B':
 							tdiff = t - bt;
 							pdiff = p - bp;
 							if (pdiff != 0)
 							{
 								if (tdiff > 0)
 								{
 									if (tdiff <= Math.abs(pdiff))
 									{
 										if (pdiff < 0)
 										{
 											bp = bp - tdiff;
 										}
 										else
 										{
 											bp = bp + tdiff;
 										}
 										bt = bt + tdiff;
 									}
 									else
 									{
 										bp = bp + pdiff;
 										bt = bt + Math.abs(pdiff);
 									}
 								}
 							}
 							pdiff = p - bp;
 							if (pdiff != 0)
 							{
 								bp = bp + pdiff;
 								bt = bt + Math.abs(pdiff);
 								t = t + Math.abs(pdiff);
 							}
 							// push button;
 							t++;
 							bt = t;
 							break;
 					}
 
 				}
 				bw.write(""Case #"" + (i + 1) + "":"" + "" "" + t + ""\n"");
 			}
 			bw.close();
 			System.out.println(""End Time :: "" + new Date());
 		}
 		catch (Exception e)
 		{
 			e.printStackTrace();
 		}
 	}
 }
","package com.jam.qualify;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.Date;
 import java.util.Scanner;
 
 public class FairSquareSmall
 {
 	static int[]			fairSquares	= { 1, 4, 9, 121, 484 };
 	static int				rangeMin	= 0;
 	static int				rangeMax	= 0;
 	static int				count		= 0;
 	static BufferedWriter	bw;
 
 	public static void main(String[] args)
 	{
 		try
 		{
 			System.out.println(""Start Time :: "" + new Date());
 
 			Scanner in = new Scanner(new BufferedReader(new FileReader(new File(""IN\\sample.in""))));
 			bw = new BufferedWriter(new FileWriter(new File(""OUT\\sample.out"")));
 			int nTestCase = in.nextInt();
 			for (int i = 0; i < nTestCase; i++)
 			{
 				count = 0;
 				rangeMin = in.nextInt();
 				rangeMax = in.nextInt();
 
 				for (int j = 0; j < 5; j++)
 				{
 					if (fairSquares[j] >= rangeMin && fairSquares[j] <= rangeMax)
 					{
 						count++;
 					}
 				}
 
 				bw.write(""Case #"" + (i + 1) + "": "" + count + ""\n"");
 			}
 		}
 		catch (Exception ex)
 		{
 			ex.printStackTrace();
 		}
 		finally
 		{
 			try
 			{
 				bw.close();
 			}
 			catch (IOException e)
 			{
 				e.printStackTrace();
 			}
 			System.out.println(""End Time :: "" + new Date());
 		}
 	}
 }
",1
484,13463,"import java.io.*;
 import java.util.*;
 
 public class RPI {
     public static void main(String[] args)throws IOException{
         System.setOut(new PrintStream(new File(""RPI.out"")));
         new SolveRPI();
     }
 }
 class SolveRPI{
     public SolveRPI()throws IOException
     {
         Scanner sc, oScan,scan;
         sc=oScan=scan=new Scanner(new File(""RPI.dat""));
         int runs = Integer.parseInt(sc.nextLine());
         int cse=1;
         while(runs-->0)
         {
             System.out.println(""Case #""+(cse++)+"":"");
             int numteams = Integer.parseInt(sc.nextLine());
             ArrayList<team> teams = new ArrayList<team>();
             int name =0;
             for(int i=0; i<numteams;i++)
             {
                 teams.add(new team(i));
             }
 
             while(numteams-->0)
             {
                 String line = sc.nextLine();
                 teams.set(name, new team(name,line));
                 name++;
             }
             team.list=teams;
             for(team t: teams)
             {
                 System.out.println(t.getWinPercent());
             }
         }
     }
 
 }
 class team{
     int name;
     static ArrayList<team> list;
     int[] wins;
     int wincount;
     int games;
     public team(int n)
     {
         name=n;
     }
     public String toString()
     {
         return name+"""";
     }
     public team(int n, String sched)
     {
         wins=new int[sched.length()];
         name=n;
         for(int i=0; i<sched.length();i++)
         {
             if(sched.charAt(i)=='.')
                 wins[i]=-1;
             else if(sched.charAt(i)=='1')
             {
                 wins[i] = 1;
                 games++;
                 wincount++;
 
             }
             else
             {
                 wins[i] = 0;
                 games++;
             }
         }
        
     }
     public double getWinPercent()
     {
         return .25*wp()+.5*owp()+.25*oowp();
     }
     public double wp()
     {
         return (double)wincount/games;
     }
     public double owp()
     {
         double sum = 0;
         for(int i=0; i<wins.length; i++)
         {
             if(wins[i]!=-1)
             {
                 sum+=list.get(i).wp(this);
             }
         }
         return sum/games;
 
     }
     public double owp(team remove)
     {
         double sum = 0;
         for(int i=0; i<wins.length; i++)
         {
             if(i==remove.name)
                 continue;
             if(wins[i]!=-1)
             {
                 sum+=list.get(i).wp(this);
             }
         }
         return sum/games;
     }
     public double oowp()
     {
         double sum =0;
         for(int i=0; i<wins.length;i++)
         {
             if(wins[i]!=-1)
             {
                 sum+=list.get(i).owp();
             }
         }
         return sum/games;
     }
     public double wp(team remove)
     {
         int tempwin = wincount;
         int tempgames=games;
         if(wins[remove.name]==1)
              tempwin--;
         tempgames--;
         return (double)tempwin/tempgames;
     }
 }
 //QED
 //What now?
 //Huh?
 //Yeah, thats right. We got it....
","import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class Snapper implements Solver
 {
 
   @Override
   public void solve(Scanner scanner, PrintStream output) throws Exception
   {
     int n = scanner.nextInt();
     int k = scanner.nextInt();
     if(k % (1<<n) == (1 << n) - 1)
     {
       output.print(""ON"");
     }
     else
     {
       output.print(""OFF"");
     }
   }
 
   public static void main(String[] args) throws Exception
   {
     CodeJamHelper.solve(""A-large"", new Snapper());
   }
 
 }
",0
485,19714,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.Scanner;
 
 
 public class TicTacToe {
 	public static void main(String[] args){
 		TicTacToe t = new TicTacToe();
 		t.readInput();
 	}
 	
 	public void readInput(){
 		Scanner scan;
 		try {
 			scan = new Scanner(new File(""input.txt""));
 			PrintStream p = new PrintStream(""output.txt"");
 			int num = scan.nextInt();
 			int[][] matrix = new int[4][4];
 			//while(scan.hasNextLine()){p.println(scan.nextLine());}
 			for(int i = 1; i <= num; i++){
 				scan.nextLine();
 				for(int y = 0; y < 4; y++){
 					String line = scan.nextLine();
 					for(int x = 0; x < 4; x++){
 						matrix[y][x] = line.charAt(x);
 					}
 				}
 				//process array
 				//try each row
 				Boolean isWon = false;
 				Boolean empty = false;
 				for(int y = 0; y < 4; y++){
 					int sum = 0;
 					for(int x = 0; x < 4; x++){
 						if(matrix[y][x] == '.'){
 							empty = true;
 						}
 						sum += matrix[y][x];
 					}
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						p.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						p.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				//column
 				for(int x = 0; x < 4; x++){
 					int sum = 0;
 					for(int y = 0; y < 4; y++){
 						sum += matrix[y][x];
 					}
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						p.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						p.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				//Diagonal
 				int sum = 0;
 				for(int x = 0; x < 4; x++){
 					sum += matrix[x][x];
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						p.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						p.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				sum = 0;
 				for(int x = 0; x < 4; x++){
 					int y = 3 - x;
 					sum += matrix[y][x];
 					
 					if(!isWon && (sum == 'X' + 'X' + 'X' + 'X' || sum == 'X' + 'X' + 'X' + 'T')){
 						p.println(""Case #"" + i + "": X won"");
 						isWon = true;
 					} else if(!isWon && (sum == 'O' + 'O' + 'O' + 'O' || sum == 'T' + 'O' + 'O' + 'O')){
 						p.println(""Case #"" + i + "": O won"");
 						isWon = true;
 					}
 				}
 				if(!isWon){
 					if(empty){
 						p.println(""Case #"" + i + "": Game has not completed"");
 					}else {
 						p.println(""Case #"" + i + "": Draw"");
 					}
 				}
 			}
 			p.close();
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
 	}
 }
 
","package qualification;
 
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Scanner;
 
 public class FairAndSquare {
 
 	private static final File input = new File(""qualification/C-large-2.in"");
 	private static final File output = new File(""qualification/C-large-2.out"");
 	
 	private static List<String> palindromes = new ArrayList<String>();
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner scan = new Scanner(input);
 		PrintStream out = new PrintStream(output);
 		
 		Comparator<String> comp = new Comparator<String>() {
 
 			@Override
 			public int compare(String o1, String o2) {
 				if(o1.length() == o2.length())
 					return o1.compareTo(o2);
 				else
 					return o1.length() - o2.length();
 			}
 		};
 
 		generatePalindromes();
 		Collections.sort(palindromes, comp);
 		
 		//now start solving
 		int cases = scan.nextInt();
 		for(int cs=1; cs<=cases; cs++){
 			String min = scan.next();
 			String max = scan.next();
 			
 			int count = 0;
 			for(String num : palindromes){
 				if(comp.compare(num, min) < 0)
 					continue;
 				else if(comp.compare(num, max) > 0)
 					break;
 				count++;
 			}
 			
 			out.println(""Case #"" + cs + "": "" + count);
 		}
 		
 		scan.close();
 		out.close();
 	}
 
 	public static void generatePalindromes(){
 		generateCase1();
 		generateCase2();
 		generateCase3();
 		generateCase4();
 		palindromes.add(""44944"");
 	}
 	
 	public static void generateCase1(){
 		palindromes.add(""1"");
 		palindromes.add(""4"");
 		palindromes.add(""9"");
 	}
 	
 	public static void generateCase2(){
 		for(int i=1; i<=2; i++){
 			for(int b=0; b<=48; b++){
 				StringBuilder sb = new StringBuilder();
 				sb.append(i*i);
 				for(int z=0; z<b; z++)
 					sb.append(0);
 				sb.append(i*i*2);
 				for(int z=0; z<b; z++)
 					sb.append(0);
 				sb.append(i*i);
 				
 				palindromes.add(sb.toString());
 			}
 		}
 	}
 	
 	public static void generateCase3(){
 		for(int l=3; l<10; l++){
 			StringBuilder sb = new StringBuilder();
 			for(int n=1; n<=l; n++)
 				sb.append(n);
 			for(int n=l-1; n>=1; n--)
 				sb.append(n);
 			palindromes.add(sb.toString());
 		}
 	}
 	
 	public static void generateCase4(){
 		for(int i=2; i<=4; i++){
 			for(int b=0; 3*(i*2-1) + 2*b < 100; b++){
 				StringBuilder sb = new StringBuilder();
 				for(int n=1; n<=i; n++)
 					sb.append(n);
 				for(int n=i-1; n>=1; n--)
 					sb.append(n);
 				
 				for(int z=0; z<b; z++)
 					sb.append(0);
 				
 				for(int n=1; n<=i; n++)
 					sb.append(n*2);
 				for(int n=i-1; n>=1; n--)
 					sb.append(n*2);
 				
 				for(int z=0; z<b; z++)
 					sb.append(0);
 				
 				for(int n=1; n<=i; n++)
 					sb.append(n);
 				for(int n=i-1; n>=1; n--)
 					sb.append(n);
 				
 				palindromes.add(sb.toString());
 			}
 		}
 	}
 }
",0
486,16488,"
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.StringTokenizer;
 
 /**
  *
  * @author igor_kz
  */
 public class PerfectHarmony {
     static int[] a;
     static int n;
     public static void main(String[] args) throws Exception {
         Scanner in = new Scanner(new File(""input.txt""));
         PrintWriter out = new PrintWriter(""output.txt"");
         int test = Integer.parseInt(in.nextLine());
         for (int t = 1; t <= test; t++) {
             String nums = in.nextLine();
             StringTokenizer st = new StringTokenizer(nums);
             n = Integer.parseInt(st.nextToken());
             int l = Integer.parseInt(st.nextToken());
             int h = Integer.parseInt(st.nextToken());
             a = new int[n];
             nums = in.nextLine();
             st = new StringTokenizer(nums);
             for (int i = 0 ; i < n ; i++)
                 a[i] = Integer.parseInt(st.nextToken());
             boolean ok = false;
             while (l <= h) {
                 if (canBe(l)) {
                     ok = true;
                     break;
                 }
                 l++;
             }
             out.print(""Case #"" + t + "": "");
             if (ok) out.println(l); else out.println(""NO"");
         }
         out.close();
     }
 
     private static boolean canBe(int l) {
         for (int i = 0 ; i < n ; i++)
             if (l % a[i] == 0 || a[i] % l == 0) ; else return false;
         return true;
     }
 }
","import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 public class TheKillerWord {
 
 	
 	public static void main(String[] args) throws IOException {
 		setStandardIO();
 		setFileIO(""thekillerword"");
 
 		readLine();
 		int T = nextInt();
 		for (int t = 1; t <= T; ++t) {
 			readLine();
 			int N = nextInt();
 			int M = nextInt();
 			
 			List<String> words = new ArrayList<String>(N);
 			for (int i = 0; i < N; ++i) {
 				readLine();
 				words.add(nextString());
 			}
 			
 			List<String> sequences = new ArrayList<String>(M);
 			for (int i = 0; i < M; ++i) {
 				readLine();
 				sequences.add(nextString());			
 			}
 			
 			print(""Case #"" + t + "": "");
 			for (String sequence : sequences) {
 				String s = value(divide(words), sequence);
 				print(s + "" "");
 			}
 			println("""");
 		}			
 		
 		flush();
 	}
 
 	public static String value(Map<Integer, List<String>> map, String sequence) 
 	{
 		int max = -1;
 		List<String> list = new ArrayList<String>();
 		
 		for (Collection<String> col : map.values()) {
 			RS rs = value(col, sequence);
 			int res = rs.res;
 			if (res > max) {
 				max = res; 
 				list = new ArrayList<String>();
 				list.add(rs.s);
 			}
 			else if (res > max) {
 				list.add(rs.s);
 			}
 		}
 
 		Collections.sort(list);
 		return list.get(0);	
 	}
 	
 	public static RS value(Collection<String> words, String sequence) 
 	{
 		Collection<CS> wordz = new ArrayList<CS>();
 		for (String string : words)
 			wordz.add(new CS(string));			
 		
 		return value(wordz, sequence, 0);
 	}
 	
 	public static RS value(Collection<CS> words, String sequence, int idx) 
 	{
 		char c = sequence.charAt(idx);
 		
 		for (CS word : words) {
 			for (int i = 0; i < word.s.length(); ++i) {
 				if (word.s.charAt(i) == c) 
 					word.list.add(i);
 			}
 		}		
 		
 		Map<List<Integer>, List<CS>> map = new HashMap<List<Integer>, List<CS>>();
 		for (CS word : words) {
 			if (null == map.get(word.list))
 				map.put(word.list, new ArrayList<CS>());
 			
 			map.get(word.list).add(word);
 		}
 		
 		boolean togo = false;
 		for (Collection<CS> wordz : map.values()) {
 			if (wordz.size() > 1)
 				togo = true;
 		}
 		
 		if (!togo) {
 			List<String> result01 = new ArrayList<String>();
 			List<String> result02 = new ArrayList<String>();
 			for (CS word : words) {
 				if (-1 == word.s.indexOf(c)) result01.add(word.s);					
 				else result02.add(word.s);
 			}
 			
 			Collections.sort(result01);
 			Collections.sort(result02);
 			if (result01.isEmpty())			
 				return new RS(0, result02.get(0));
 			
 			return new RS(0, result01.get(0));
 		}
 		
 		
 		int max = 0;
 		List<String> result = new ArrayList<String>();
 		
 		for (Collection<CS> wordz : map.values()) {
 			if (wordz.size() > 1) {
 				RS rs = value(wordz, sequence, idx + 1);
 				int newmax = 1 + rs.res;
 				if (newmax > max) {
 					max = newmax;
 					result = new ArrayList<String>();
 					result.add(rs.s);
 				}
 				else 
 				if (newmax >= max) {
 					result.add(rs.s);
 				}
 			}
 		}
 		
 		Collections.sort(result);
 		return new RS(max, result.get(0));
 	}
 
 	public static Map<Integer, List<String>> divide(List<String> words) 
 	{
 		Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();
 		for (String word : words) {
 			int length = word.length();
 			if (null == map.get(length))
 				map.put(length, new ArrayList<String>());
 			
 			map.get(length).add(word);
 		}
 		
 		return map;
 	}
 	
 	public static class RS {
 		public int res;
 		public String s;
 		public RS(int res, String s) {
 			this.res = res;
 			this.s = s;
 		}
 		@Override
 		public String toString() {
 			return ""RS [res="" + res + "", s="" + s + ""]"";
 		}
 	}
 	
 	public static class CS {
 		public String s;
 		public List<Integer> list = new ArrayList<Integer>();
 		public CS(String s) {
 			this.s = s;
 		}
 		@Override
 		public String toString() {
 			return ""CS [list="" + list + "", s="" + s + ""]"";
 		}
 	}
 	
 	//~ ----------------------------------------------------------------------------------------------------------------
 	//~ - Auxiliary code -----------------------------------------------------------------------------------------------	
 	//~ ----------------------------------------------------------------------------------------------------------------
 	static BufferedReader in;
 	static PrintWriter out;
 	static StringTokenizer st;
 
 	private static void setStandardIO() {
 		in = new BufferedReader(new InputStreamReader(System.in));
 		out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 	}
 
 	private static void setFileIO(String fileName) throws FileNotFoundException, IOException {
 		in = new BufferedReader(new FileReader(fileName + "".in""));
 		out = new PrintWriter(new BufferedWriter(new FileWriter(fileName + "".out"")));
 	}
 
 	public static void readLine() throws IOException {
 		st = new StringTokenizer(in.readLine());
 	}
 
 	public static int nextInt() {
 		return Integer.parseInt(st.nextToken());
 	}
 
 	public static long nextLong() {
 		return Long.parseLong(st.nextToken());
 	}
 	
 	public static String nextString() {
 		return st.nextToken();
 	}
 
 	public static List<String> nextStrings() {
 		List<String> strings = new ArrayList<String>();
 		while (st.hasMoreTokens())
 			strings.add(st.nextToken());		
 		
 		return strings;
 	}
 	
 	public static void flush() {
 		out.flush();
 	}
 	
 	public static void println(Object object) {
 		out.println(object);
 	}
 	
 	public static void print(Object object) {
 		out.print(object);
 	}
 
 	public static long gcd(long a, long b) {
 		if (b == 0) return a;
 		return gcd(b, a % b);
 	}
 	
 	public static class Pair {
 		public long x, y;
 		public Pair(long x, long y) {
 			this.x = x;
 			this.y = y;
 		}
 		@Override
 		public String toString() {
 			return ""Pair [x="" + x + "", y="" + y + ""]"";
 		}
 		@Override
 		public int hashCode() {
 			final int prime = 31;
 			int result = 1;
 			result = prime * result + (int) (x ^ (x >>> 32));
 			result = prime * result + (int) (y ^ (y >>> 32));
 			return result;
 		}
 		@Override
 		public boolean equals(Object obj) {
 			if (this == obj)
 				return true;
 			if (obj == null)
 				return false;
 			if (getClass() != obj.getClass())
 				return false;
 			Pair other = (Pair) obj;
 			if (x != other.x)
 				return false;
 			if (y != other.y)
 				return false;
 			return true;
 		}		
 	}
 }
",0
487,7425,"package ramanvesh.codejam.reorderingTrainCars;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
 public class Main {
 	
 	public static void main(String[] args) {
 		String path = System.getProperty(""user.dir"");
 		try{
 			@SuppressWarnings(""resource"")
 			BufferedReader fileReader = new BufferedReader(new FileReader(new File(path + ""/input"" )));
 			int noOfCases = Integer.parseInt(fileReader.readLine().trim());
 			for(int caseNum =1; caseNum<=noOfCases; caseNum++){
 				int count = 1;
 				String answer = """";
 				solution:{
 					Integer.parseInt(fileReader.readLine().trim());
 					Map<Character, CharState> map = new HashMap<Character, CharState>();
 					//					Map<String, Node> nodes = new HashMap<String, Node>();
 					LinkedList<String> strings = new LinkedList<String>(Arrays.asList(fileReader.readLine().trim().split("" "")));
 					for (String string : strings) {
 						//						Node node = new Node(string);
 						//						nodes.put(string, node);
 						char starts = string.charAt(0);
 						int length = string.length();
 						boolean sameChar = true;
 						for (char character : string.toCharArray()) {
 							if(character != starts){
 								sameChar = false;
 								break;
 							}
 						}
 						for (char character : getUniqueSubString(string).toCharArray()) {
 							getCharState(map, character).containedWithin = true;
 						}
 						CharState beginsCharState = getCharState(map, starts);
 						if(sameChar){
 							beginsCharState.all++;
 							beginsCharState.allStrings.add(string);
 							continue;
 						}
 						char ends = string.charAt(length-1);
 						CharState endsCharState = getCharState(map, ends);
 						if(starts == ends){
 							answer = ""0"";
 							break solution;
 						} else {
 							beginsCharState.starts++;
 							beginsCharState.startsString = string;
 							endsCharState.ends++;
 							endsCharState.endsString = string;
 						}
 					}
 					for (Entry<Character, CharState> entry : map.entrySet()) {
 						CharState charState = entry.getValue();
 						if(charState.starts > 1 || charState.ends>1){
 							answer = ""0"";
 							break solution;
 						}
 						if(charState.all > 0){
 							count = count* fact(charState.all);
 							String allString = """";
 							for (String string : charState.allStrings) {
 								allString += string;
 								strings.remove(string);
 							}
 							charState.allStrings = Arrays.asList(new String[]{allString});
 							strings.add(allString);
 							charState.all = 1;
 						}
 						if(charState.starts + charState.ends + charState.all == 1){
 							 if(!charState.containedWithin){
 								 continue;
 							 } else {
 								 answer = ""0"";
 								 break solution;
 							 }
 						}
 						if(charState.starts ==1 || charState.ends == 1){
 							String endsString = charState.endsString;
 							String startsString = charState.startsString;
 
 							String finalString = endsString;
 							for (String string : charState.allStrings) {
 								finalString+=string;
 								strings.remove(string);
 							}
 							finalString += startsString;
 							if(!startsString.isEmpty()){
 								char otherEnds = startsString.charAt(startsString.length()-1);
 								map.get(otherEnds).endsString = finalString;
 							}
 							if(!endsString.isEmpty()){
 								char otherStarts = endsString.charAt(0);
 								map.get(otherStarts).startsString =finalString;
 							}
 							strings.remove(startsString);
 							strings.remove(endsString);
 							strings.add(finalString);
 						}
 					}
 					answer = String.valueOf(count*fact(strings.size()));
 				}
 				System.out.println(""Case #""+caseNum+"": ""+answer);
 			}
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 	
 	private static String getUniqueSubString(String string) {
 		char start = string.charAt(0);
 		char end = string.charAt(string.length()-1);
 		string = string.replaceAll(""^""+start+""*"", """");
 		string = string.replaceAll(end+""*$"", """");
 		return string;
 	}
 
 	private static int fact(int n){
 		int result = 1;
 		for (int i = 1; i <= n; i++) {
 			result = result * i;
 		}
 		return result;
 	}
 	
 	private static CharState getCharState(Map<Character, CharState> map, char character) {
 		CharState charState = map.get(character);
 		if(charState == null){
 			charState = new CharState();
 			map.put(character, charState);
 		}
 		return charState;
 	}
 
 	private static class CharState{
 		public boolean containedWithin;
 		private int ends;
 		private int starts;
 		private int all;
 		private String endsString ="""";
 		private String startsString = """";
 		private List<String> allStrings = new LinkedList<String>();
 
 	}
 }","package ramanvesh.codejam.theRepeater;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.util.ArrayList;
 import java.util.List;
 
 public class Main {
 	
 	public static void main(String[] args) {
 		String path = System.getProperty(""user.dir"");
 		try{
 			@SuppressWarnings(""resource"")
 			BufferedReader fileReader = new BufferedReader(new FileReader(new File(path + ""/input"" )));
 			int noOfCases = Integer.parseInt(fileReader.readLine().trim());
 			for(int caseNum =1; caseNum<=noOfCases; caseNum++){
 				int numOfStrings = Integer.parseInt(fileReader.readLine().trim());
 				List<String> strings = new ArrayList<String>(numOfStrings);
 				for(int stringNum = 0; stringNum< numOfStrings; stringNum++){
 					strings.add(fileReader.readLine());
 				}
 				int[] markers = new int[numOfStrings];
 				boolean impossible = false;
 				int minSteps = 0;
 				while(!impossible){
 					boolean[] broken = new boolean[numOfStrings];
 					int[] length = new int[numOfStrings];
 					char currentChar = (char)0;
 					for (int i = 0; !checkIfAllTrue(broken) && checkIfMarkersInLimit(markers,strings); i = (i+1)%numOfStrings) {
 						if(broken[i]){
 							continue;
 						}
 						String string = strings.get(i);
 						if(markers[i] >=  string.length()){
 							broken[i]=true;
 							continue;
 						}
 						char thisChar = string.charAt(markers[i]);
 						if(currentChar == (char)0){
 							currentChar = thisChar;
 						} 
 						if(currentChar != thisChar){
 							broken[i] = true;
 						} else {
 							length[i]++;
 							markers[i]++;
 						}
 					}
 					int minStepsToReachCommonNumber = getMinStepsToReachCommonNumber(length);
 					if(minStepsToReachCommonNumber < 0){
 						impossible = true;
 					} else{
 						minSteps += minStepsToReachCommonNumber;
 					}
 					if(!checkIfMarkersInLimit(markers, strings)){
 						break;
 					}
 				}
 				System.out.println(""Case #""+caseNum+"": ""+(impossible? ""Fegla Won"" : minSteps));
 			}
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	private static boolean checkIfMarkersInLimit(int[] markers,List<String> strings) {
 		for(int i =0; i< strings.size(); i++){
 			if(markers[i] < strings.get(i).length()){
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private static int getMinStepsToReachCommonNumber(int[] length) {
 		int minSteps = Integer.MAX_VALUE;
 		for(int i = 0; i < length.length; i++){
 			int thisSteps = 0;
 			if(length[i] == 0){
 				return -1;
 			}
 			for(int j =0; j< length.length; j++){
 				thisSteps += Math.abs(length[i] - length[j]);
 			}
 			minSteps = Math.min(minSteps, thisSteps);
 		}
 		return minSteps;
 	}
 
 	private static boolean checkIfAllTrue(boolean[] broken) {
 		for (boolean b : broken) {
 			if(!b){
 				return false;
 			}
 		}
 		return true;
 	}
 }",1
488,18,"package com.tomasz.codejam;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 import org.apache.log4j.Logger;
 
 public class MineSweeper {
 	private static Logger log = Logger.getLogger(MineSweeper.class);
 
 	public static void main(String[] args) throws IOException {
 		// A-small-attempt0.in
 		Scanner sc = new Scanner(new File(""data/input.txt""));
 		PrintWriter out = new PrintWriter(new File(""data/output.txt""));
 
 		Integer count = sc.nextInt();
 		log.info(count + "" cases"");
 
 		for (int i = 1; i <= count; i++) {
 			log.info(i);
 
 			out.println(""Case #"" + i + "": ""
 					+ solve(sc.nextInt(), sc.nextInt(), sc.nextInt()));
 		}
 
 		out.close();
 	}
 
 	private static String solve(Integer R, Integer C, Integer M) {
 
 		char[][] board = new char[R][C];
 		Integer mines = M;
 
 		for (int r = 0; r < R; r++) {
 			for (int c = 0; c < C; c++) {
 				if (r == R - 2 && c > C - 3) {
 					board[r][c] = '.';
 				} else {
 					if (mines != 0) {
 						board[r][c] = '*';
 						mines--;
 					} else {
 						board[r][c] = '.';
 					}
 				}
 			}
 		}
 		board[R - 1][C - 1] = 'c';
 
 		String output = ""\nImpossible"";
 		if ((R == 1 && C > 2 && M == 1) || //
 				(R > 2 && C == 1 && M == 1) || //
 				(M <= R * C - 4)) {
 			output = """";
 			for (int r = 0; r < R; r++) {
 				output += ""\n"";
 				for (int c = 0; c < C; c++) {
 					output += board[r][c];
 				}
 			}
 		}
 
 		return output;
 	}
 
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class R1CA {
 
     /**
      * Google Code Jam Round 1C 2011 Problem A. Square Tiles
      * 
      * @author dkorduban
      */
     public static void main(String[] args) {
         try {
             new R1CA().solve();
         } catch (Exception e) {
             e.printStackTrace();
             throw new IllegalStateException();
         }
 
     }
 
     private void solve() throws FileNotFoundException {
         // Scanner in = new Scanner(System.in);
         Scanner in = new Scanner(new File(""A-large.in""));
         // PrintWriter out = new PrintWriter(System.out);
         PrintWriter out = new PrintWriter(""A-large.out"");
         int testCount = in.nextInt();
         for (int test = 1; test <= testCount; ++test) {
             int n = in.nextInt();
             int m = in.nextInt();
             char[][] a = new char[n][];
             for (int i = 0; i < n; ++i) {
                 a[i] = in.next().toCharArray();
             }
             for (int i = 0; i < n - 1; ++i) {
                 for (int j = 0; j < m - 1; ++j) {
                     if (a[i][j] == '#' && a[i + 1][j] == '#'
                             && a[i][j + 1] == '#' && a[i + 1][j + 1] == '#') {
                         for (int di = 0; di < 2; ++di) {
                             for (int dj = 0; dj < 2; ++dj) {
                                 a[i + di][j + dj] = ((di + dj) % 2 == 0) ? '/'
                                         : '\\';
                             }
                         }
                     }
                 }
             }
             boolean bad = false;
             for (int i = 0; i < n; ++i) {
                 for (int j = 0; j < m; ++j) {
                     if (a[i][j] == '#') {
                         bad = true;
                     }
                 }
 
             }
             out.printf(""Case #%d:\n"", test);
             if (bad) {
                 out.printf(""Impossible\n"");
             } else {
                 for (int i = 0; i < n; ++i) {
                     out.println(a[i]);
                 }
             }
         }
         out.flush();
     }
 
 }
",0
489,19353,"import java.awt.Point;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
 import java.util.ArrayList;
 
 public class Lawnmower {
 
 	// split de array
 	public static int[] atoi(String cad) {
 		String read[] = cad.split("" "");
 		int res[] = new int[read.length];
 		for (int i = 0; i < read.length; i++) {
 			res[i] = Integer.parseInt(read[i]);
 		}
 		return res;
 	}
 
 	// split de String
 	public static String[] atos(String cad) {
 		return cad.split("" "");
 	}
 
 	// parsing de String a int
 	public static int parseo(String cad, int index) {
 		return Integer.parseInt(cad.split("" "")[index]);
 	}
 
 	// memory status
 	static String memoryStatus() {
 		return (Runtime.getRuntime().totalMemory()
 				- Runtime.getRuntime().freeMemory() >> 20)
 				+ ""/"" + (Runtime.getRuntime().totalMemory() >> 20) + "" MB"";
 	}
 
 	// imprimir array
 	static void printArrayInt(int[] array) {
 		if (array == null || array.length == 0)
 			return;
 		for (int i = 0; i < array.length; i++) {
 			if (i > 0)
 				System.out.print("" "");
 			System.out.print(array[i]);
 		}
 		System.out.println();
 	}
 
 	// impresion de datos
 	static void print(Object... obj) {
 		for (int i = 0; i < obj.length; i++) {
 			if (i != 0)
 				System.out.print("" "");
 			System.out.print(obj[i]);
 		}
 		System.out.println();
 	}
 
 	public static void main(String[] args) throws IOException {
 		//BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 		BufferedReader in= new BufferedReader(new FileReader(""B-small-attempt0 (1).in""));
 		System.setOut(new PrintStream(""out15.txt""));
 		int n = Integer.parseInt(in.readLine());
 		int time=1;
 		for (int i = 0; i < n; i++) {
 			int arr[] = atoi(in.readLine());
 			int cad[][] = new int[arr[0]][arr[1]];
 			boolean marcados[] = new boolean[arr[0]];
 			boolean marcadosy[] = new boolean[arr[1]];
 			ArrayList<Point> puntos[] = new ArrayList[arr[0]];
 
 			int minFila[] = new int[arr[0]];
 
 			int maxFila[] = new int[arr[0]];
 			int maxCol[] = new int[arr[1]];
 
 			for (int j = 0; j < arr[0]; j++) {
 				String read[] = in.readLine().split("" "");
 				int max = Integer.MAX_VALUE;
 				int minF = -1;
 
 				for (int k = 0; k < arr[1]; k++) {
 					cad[j][k] = Integer.parseInt(read[k]);
 					if (cad[j][k] < max) {
 						max = cad[j][k];
 						minFila[j] = cad[j][k];
 					}
 					if (cad[j][k] > minF) {
 						minF = cad[j][k];
 						maxFila[j] = minF;
 					}
 				}
 			}
 			for (int j = 0; j < maxCol.length; j++) {
 				int minC = -1;
 				for (int k = 0; k < maxFila.length; k++) {
 					if (cad[k][j] > minC) {
 						minC = cad[k][j];
 						maxCol[j] = minC;
 					}
 				}
 			}
 
 			for (int j = 0; j < cad.length; j++) {
 				puntos[j] = new ArrayList<Point>();
 				for (int k = 0; k < cad[0].length; k++) {
 					if (cad[j][k] == minFila[j]) {
 						puntos[j].add(new Point(j, k));
 					}
 				}
 			}
 
 			boolean res = true;
 			ciclo2: for (int j = 0; j < cad.length; j++) {
 				if (marcados[j] == false) {
 					ciclo1: for (int k = 0; k < puntos[j].size(); k++) {
 						Point p = puntos[j].get(k);
 						if (marcadosy[p.y] == false) {
 							if (minFila[p.x] == maxFila[p.x]) {
 								marcados[p.x] = true;
 								;
 								break ciclo1;
 							} else if (minFila[p.x] == maxCol[p.y]) {
 								marcadosy[p.y] = true;
 							} else {
 								res = false;
 								break ciclo2;
 							}
 
 						}
 					}
 				}
 			}
 			System.out.print(""Case #""+time+"": "");
 			time++;
 			System.out.println(res ? ""YES"" : ""NO"");
 		}
 	}
 }
","
 import java.io.*;
 import java.util.ArrayList;
 import java.util.StringTokenizer;
 
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
 
 /**
  *
  * @author doda
  */
 public class RecycledNumbers {
 
     /**
      * @param args the command line arguments
      */
      public static void main(String[] args) throws FileNotFoundException, IOException {
         // TODO code application logic here
         BufferedReader R=new BufferedReader(new FileReader(""C:\\Users\\doda\\Desktop\\C-small.in""));
         PrintWriter P=new PrintWriter(new FileWriter(""C:\\Users\\doda\\Desktop\\small.txt""));
         while(R.ready()){
             int t=Integer.parseInt(R.readLine());
             for(int i=0;i<t;++i){
                StringTokenizer s=new StringTokenizer(R.readLine());
                int n=Integer.parseInt(s.nextToken());
                int m= Integer.parseInt(s.nextToken());
                int out=0;String O=""Case #""+(i+1)+"":"";
                for(int j=n;j<m;++j){
                    int numbers[]=diffOrder(j);
                    for(int k=0;k<numbers.length;++k){
                        if(numbers[k]>j && numbers[k]<=m)++out;
                    }
                }
                O+="" ""+out;
                P.println(O);
             }
         }
         P.close();
     }
     public static int [] diffOrder(int num){
         String s=""""+num;
         ArrayList<Integer> in=new ArrayList<Integer>();
         int re[];
         for(int i=0;i<s.length()-1;++i){
             s=s.charAt(s.length()-1)+""""+s.substring(0,s.length()-1);
             int y=Integer.parseInt(s);
             String h=""""+y;
             if(h.length()<s.length())y=0;
             if(!in.contains(y))in.add(y);
         }
         re=new int[in.size()];
         for(int i=0;i<in.size();++i){
             re[i]=in.get(i);
         }
         return re;
     }
 }
",0
490,13036,"import java.util.*;
 import java.io.*;
 
 public class codejam1B2{
 	public static void main(String[] args) throws IOException{
 		Scanner sc = new Scanner(new FileReader(""B-small-attempt0.in""));
 		BufferedWriter write = new BufferedWriter(new FileWriter(""output.txt""));
 
 		int caseN = sc.nextInt();
 		sc.nextLine();
 		String[] allCase = new String[caseN];
 		long a,b,k;
 
 		long num;
 
 		for(int icase = 0;icase<caseN;icase++){
 			System.out.println(""case""+(icase+1));
 			a = sc.nextLong();
 			b = sc.nextLong();
 			k = sc.nextLong();
 			num = 0;
 			for(int na=0;na<a;na++){
 				for(int nb=0;nb<b;nb++){
 					if((na&nb) < k) num++;
 				}
 			}
 			allCase[icase] = ""Case #""+(icase+1)+"": ""+num;
 		}
 
 		for(int icase = 0;icase<caseN;icase++){
 			write.append(allCase[icase]+""\n"");
 			//System.out.println(allCase[icase]);
 		}
 		write.close();
 	}
 }","package code;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 
 public class problemB {
 
 
 	public static void main(String[] args) throws Exception {
 		
 		int row,col;
 		
 		BufferedReader br = new BufferedReader(new FileReader(""C:/Users/LXZE/Desktop/B-large.in""));
 		FileWriter fstream = new FileWriter(""C:/Users/LXZE/Desktop/out.txt"");
 		BufferedWriter write = new BufferedWriter(fstream);
 		
 		int casenum = Integer.parseInt(br.readLine());
 		for(int i = 0; i < casenum; i++){
 			String[] s = br.readLine().split("" "");
 			row = Integer.parseInt(s[0]);
 			col = Integer.parseInt(s[1]);
 			
 			ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
 			for(int i_row=0;i_row<row;i_row++){
         		al.add(new ArrayList<Integer>());
         		
         		String[] line = br.readLine().split("" "");
         		for(int i_col=0;i_col<col;i_col++){
         			al.get(i_row).add(Integer.parseInt(line[i_col]));
         		}
         	}
 			if(check(al))
 			{
 				System.out.println(""Case #""+(i+1)+"": YES"");
 				write.write(""Case #""+(i+1)+"": YES\n"");
 			}
 			else
 			{
 				System.out.println(""Case #""+(i+1)+"": NO"");
 				write.write(""Case #""+(i+1)+"": NO\n"");
 			}
 			
 		}	//end case
 			write.close();
 	}
 	
 	static boolean check(ArrayList<ArrayList<Integer>> al)
 	{
 		
 		while(true){
     		int k = 0;
     		while(k<al.size()){
     			if (al.get(k).isEmpty()){
     				al.remove(k);
     				continue;
     			}
     			k++;
     		}
     		if(al.isEmpty())
     			break;        	
     		int min = 1000;
     		int min_row = 0;
     		int min_col = 0;
     		
         	for(int r=0;r<al.size();r++){
         		for(int c=0;c<al.get(0).size();c++){
         			if (min>al.get(r).get(c)){
         				min_row = r;
         				min_col = c;
         				min = al.get(r).get(c);
         			}
         		}
         	}
 
         	int number_row = 0,number_col = 0;
         	boolean b_row = true,b_col = true;
         	
         	// row		        	
         	for(int i_row=0;i_row<al.get(min_row).size();i_row++)
         		if(al.get(min_row).get(i_row) == min)
         			number_row++;
         	if(number_row!=al.get(min_row).size())
         		b_row = false;
 
         	// column
         	for(int i_col=0;i_col<al.size();i_col++)
         		if (al.get(i_col).get(min_col) == min)
         			number_col++;
         	if (number_col!=al.size())
         		b_col = false;
         	// NO case
         	if(!b_col&&!b_row)
         		return false;
         	
         	// remove col
         	if (b_col){
         		for(int i2_col=0;i2_col<al.size();i2_col++)
 	        		al.get(i2_col).remove(min_col);
         	}
         	// remove row
         	else if(b_row){
 	        	al.remove(min_row);
         	}
     	} // end while true
 		
     	return true;
 	}
 	
 }
",1
491,11197,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.LinkedList;
 
 
 public class Problem {
 	
 	public static final String NAME = ""A-small-attempt0"";
 	
 	public static void main(String args[]) throws FileNotFoundException{
 		Scanner in = new Scanner(new File(NAME + "".in""));
 		PrintWriter out = new PrintWriter(new File(NAME + "".out""));
 		writeSolution(in, out);
 		out.close();
 	}
 	
 	private static void writeSolution(Scanner in, PrintWriter out){
 		int cases = in.nextInt();
 		for (int cas = 0; cas<cases ; cas++){
 			String answer = ""Case #"" + (cas + 1) + "": "" + compute(in);
 			out.println(answer);
 			System.out.println(answer);
 		}
 	}
 	
 	private static int compute(Scanner in){
 		int commands = in.nextInt();
 		int opos = 1;
 		int bpos = 1;
 		int turn = 0;
 		LinkedList<Integer> bcommands = new LinkedList<Integer>();
 		LinkedList<Integer> ocommands = new LinkedList<Integer>();
 		LinkedList<Boolean> bturn = new LinkedList<Boolean>();
 		//read in commands
 		for (int com = 0; com<commands; com++){
 			if (in.next().equals(""B"")){
 				bturn.offer(true);
 				bcommands.offer(in.nextInt());
 			} else {
 				bturn.offer(false);
 				ocommands.offer(in.nextInt());
 			}
 		}
 		while(!bturn.isEmpty()){
 			if (bcommands.peek() != null && bpos == bcommands.peek()){
 				if (bturn.peek()){
 					bcommands.poll();
 					bturn.poll();
 					if (ocommands.peek() != null){
 						if (ocommands.peek() > opos){
 							opos++;
 						} else if (ocommands.peek() < opos){
 							opos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			if (ocommands.peek() != null && opos == ocommands.peek()){
 				if (!bturn.peek()){
 					ocommands.poll();
 					bturn.poll();
 					if (bcommands.peek() != null){
 						if (bcommands.peek() > bpos){
 							bpos++;
 						} else if (bcommands.peek() < bpos){
 							bpos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			int bdistance = Math.abs((bcommands.peek() == null ? bpos : bcommands.peek()) - bpos);
 			int odistance = Math.abs((ocommands.peek() == null ? opos : ocommands.peek()) - opos);
 			
 			if (bdistance == 0 || odistance == 0){
 				if (bdistance > 0){
 					bpos = bcommands.peek();
 					turn = turn + bdistance; 
 				} else {
 					opos = ocommands.peek();
 					turn = turn + odistance;
 				}
 			} else
 			//if both are not 0
 			if (bdistance > odistance){
 				if (bcommands.peek() > bpos){
 					bpos = bpos + odistance;
 				} else {
 					bpos = bpos - odistance;
 				}
 				opos = ocommands.peek();
 				turn = turn + odistance;
 			} else {
 				if (ocommands.peek() > opos){
 					opos = opos + bdistance;
 				} else {
 					opos = opos - bdistance;
 				}
 				bpos = bcommands.peek();
 				turn = turn + bdistance;
 			}
 		}
 		
 		return turn;
 	}
 }
","import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 import java.util.LinkedList;
 
 
 public class Problem {
 	
 	public static final String NAME = ""A-large"";
 	
 	public static void main(String args[]) throws FileNotFoundException{
 		Scanner in = new Scanner(new File(NAME + "".in""));
 		PrintWriter out = new PrintWriter(new File(NAME + "".out""));
 		writeSolution(in, out);
 		out.close();
 	}
 	
 	private static void writeSolution(Scanner in, PrintWriter out){
 		int cases = in.nextInt();
 		for (int cas = 0; cas<cases ; cas++){
 			String answer = ""Case #"" + (cas + 1) + "": "" + compute(in);
 			out.println(answer);
 			System.out.println(answer);
 		}
 	}
 	
 	private static int compute(Scanner in){
 		int commands = in.nextInt();
 		int opos = 1;
 		int bpos = 1;
 		int turn = 0;
 		LinkedList<Integer> bcommands = new LinkedList<Integer>();
 		LinkedList<Integer> ocommands = new LinkedList<Integer>();
 		LinkedList<Boolean> bturn = new LinkedList<Boolean>();
 		//read in commands
 		for (int com = 0; com<commands; com++){
 			if (in.next().equals(""B"")){
 				bturn.offer(true);
 				bcommands.offer(in.nextInt());
 			} else {
 				bturn.offer(false);
 				ocommands.offer(in.nextInt());
 			}
 		}
 		while(!bturn.isEmpty()){
 			if (bcommands.peek() != null && bpos == bcommands.peek()){
 				if (bturn.peek()){
 					bcommands.poll();
 					bturn.poll();
 					if (ocommands.peek() != null){
 						if (ocommands.peek() > opos){
 							opos++;
 						} else if (ocommands.peek() < opos){
 							opos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			if (ocommands.peek() != null && opos == ocommands.peek()){
 				if (!bturn.peek()){
 					ocommands.poll();
 					bturn.poll();
 					if (bcommands.peek() != null){
 						if (bcommands.peek() > bpos){
 							bpos++;
 						} else if (bcommands.peek() < bpos){
 							bpos--;
 						}
 					}
 					turn++;
 					continue;
 				}
 			}
 			int bdistance = Math.abs((bcommands.peek() == null ? bpos : bcommands.peek()) - bpos);
 			int odistance = Math.abs((ocommands.peek() == null ? opos : ocommands.peek()) - opos);
 			
 			if (bdistance == 0 || odistance == 0){
 				if (bdistance > 0){
 					bpos = bcommands.peek();
 					turn = turn + bdistance; 
 				} else {
 					opos = ocommands.peek();
 					turn = turn + odistance;
 				}
 			} else
 			//if both are not 0
 			if (bdistance > odistance){
 				if (bcommands.peek() > bpos){
 					bpos = bpos + odistance;
 				} else {
 					bpos = bpos - odistance;
 				}
 				opos = ocommands.peek();
 				turn = turn + odistance;
 			} else {
 				if (ocommands.peek() > opos){
 					opos = opos + bdistance;
 				} else {
 					opos = opos - bdistance;
 				}
 				bpos = bcommands.peek();
 				turn = turn + bdistance;
 			}
 		}
 		
 		return turn;
 	}
 }
",1
492,5992,"package com.nitin.ofss.codejam;
 
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Vector;
 
 public class Problem4 {
 	static FileReader fr;
 	static Scanner scan;
 	static PrintWriter out;
 	static Vector<Double> Nao = new Vector<Double>();
 	static Vector<Double> Ken = new Vector<Double>();
 	static Vector<Double> KenB = new Vector<Double>();
 	public static void main(String[] args) throws IOException {
 		initialize();
 		int T = scan.nextInt();
 		
 		for (int i10 = 1; i10 <= T; i10++) {
 			int ans=0;	
 			int ans1=0;
 			int N = scan.nextInt();
 			Nao.clear();Ken.clear();KenB.clear();
 			for(int i=0;i<N;i++) {double x=scan.nextDouble();Nao.add(x);}
 			for(int i=0;i<N;i++) {double x=scan.nextDouble();Ken.add(x);}
 			Collections.sort(Ken);Collections.sort(Nao);
 			KenB.addAll(Ken);
 			
 			for(int i=0;i<N;i++){
 				double bet1 = Nao.get(i);
 				Iterator<Double> it = KenB.iterator();
 				while(it.hasNext()){
 					if(it.next()>bet1) {it.remove();
 					ans1++;
 					break;
 					}
 				}
 			}
 			rec();
 			
 			List<Double> Nao1 =  Nao.subList(0, Nao.size());
 			List<Double> Ken1 =  Ken.subList(0, Ken.size());
 			Iterator<Double> it = Nao1.iterator();Iterator<Double> it1 = Ken1.iterator();
 			boolean flag1=false;
 			double y=0;
 			while(it.hasNext() && it1.hasNext()){
 				double x=it.next();
 				if(!flag1) y=it1.next();
 				else flag1=false;
 					if(x>y) {
 						ans++;
 					it.remove();it1.remove();
 					}
 					else{
 						it.remove();//Ken1.remove(Ken1.size()-1);
 						flag1=true;
 					}
 			}
 
 			
 			System.out.printf(""Case #%d: %d %d\n"", i10,ans,N-ans1);
 			out.printf(""Case #%d: %d %d\n"", i10,ans,N-ans1);
 		}
 		close();
 	}
 
 	
 private static void rec() {
 	double firstK = Ken.get(0);
 	Iterator<Double> it1 = Nao.iterator();
 	while(it1.hasNext()){
 		if(it1.next()<firstK) {
 			
 			Ken.remove(Ken.size()-1);
 			it1.remove();
 		}
 	}
 	}
 
 
 public static void initialize() throws FileNotFoundException{
 	fr = new FileReader(""in.txt"");
 	scan = new Scanner(fr);
 	out = new PrintWriter(""out1.txt"");
 }
 public static void close() throws IOException{
 	fr.close();
 	out.close();
 	
 }
 }
","package com.nitin.ofss.codejam;
 
 import java.io.BufferedWriter;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Scanner;
 import java.util.Vector;
 
 public class Problem4 {
 	static FileReader fr;
 	static Scanner scan;
 	static PrintWriter out;
 	static Vector<Double> Nao = new Vector<Double>();
 	static Vector<Double> Ken = new Vector<Double>();
 	static Vector<Double> KenB = new Vector<Double>();
 	public static void main(String[] args) throws IOException {
 		initialize();
 		int T = scan.nextInt();
 		
 		for (int i10 = 1; i10 <= T; i10++) {
 			int ans=0;	
 			int ans1=0;
 			int N = scan.nextInt();
 			Nao.clear();Ken.clear();KenB.clear();
 			for(int i=0;i<N;i++) {double x=scan.nextDouble();Nao.add(x);}
 			for(int i=0;i<N;i++) {double x=scan.nextDouble();Ken.add(x);}
 			Collections.sort(Ken);Collections.sort(Nao);
 			KenB.addAll(Ken);
 			
 			for(int i=0;i<N;i++){
 				double bet1 = Nao.get(i);
 				Iterator<Double> it = KenB.iterator();
 				while(it.hasNext()){
 					if(it.next()>bet1) {it.remove();
 					ans1++;
 					break;
 					}
 				}
 			}
 			rec();
 			
 			List<Double> Nao1 =  Nao.subList(0, Nao.size());
 			List<Double> Ken1 =  Ken.subList(0, Ken.size());
 			Iterator<Double> it = Nao1.iterator();Iterator<Double> it1 = Ken1.iterator();
 			boolean flag1=false;
 			double y=0;
 			while(it.hasNext() && it1.hasNext()){
 				double x=it.next();
 				if(!flag1) y=it1.next();
 				else flag1=false;
 					if(x>y) {
 						ans++;
 					it.remove();it1.remove();
 					}
 					else{
 						it.remove();//Ken1.remove(Ken1.size()-1);
 						flag1=true;
 					}
 			}
 
 			
 			System.out.printf(""Case #%d: %d %d\n"", i10,ans,N-ans1);
 			out.printf(""Case #%d: %d %d\n"", i10,ans,N-ans1);
 		}
 		close();
 	}
 
 	
 private static void rec() {
 	double firstK = Ken.get(0);
 	Iterator<Double> it1 = Nao.iterator();
 	while(it1.hasNext()){
 		if(it1.next()<firstK) {
 			
 			Ken.remove(Ken.size()-1);
 			it1.remove();
 		}
 	}
 	}
 
 
 public static void initialize() throws FileNotFoundException{
 	fr = new FileReader(""in.txt"");
 	scan = new Scanner(fr);
 	out = new PrintWriter(""out1.txt"");
 }
 public static void close() throws IOException{
 	fr.close();
 	out.close();
 	
 }
 }
",1
493,14275,"package acmicpc.contest.codejam10.qual;
 
 import java.io.File;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class SnapperChain {
 	public static void redirect(PrintWriter p, String s) {
 		p.println(s);
 		System.out.println(s);
 	}
 	
 	public static void main(String[] args) throws Exception {
 		Scanner in = new Scanner(new File(""A-small-attempt1.in""));
 		PrintWriter p = new PrintWriter(""a.out"");
 		int ncase = in.nextInt();
 		for (int cs = 0; cs < ncase; ++cs) {
 			long n = in.nextInt(), k = in.nextInt();
 			redirect(p, String.format(
 					""Case #%d: %s"", cs+1, (k % (1L << n)) == (1L << n)-1 ? ""ON"" : ""OFF""));
 		}
 		p.close();
 		in.close();
 	}
 }
","import java.io.File;
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class ElegantDiamond {
 	private final static int getLeft(int n, int x) {
 		if (x < n)
 			return 0;
 		else
 			return x - n + 1;
 	}
 
 	private final static int getRight(int n, int x) {
 		return getLeft(n, x) + getLen(n, x) - 1;
 	}
 
 	private final static int getLen(int n, int x) {
 		if (x < n)
 			return x + 1;
 		else
 			return 2 * n - 1 - x;
 	}
 	
 	static void print(int m, int[][] td) {
 		for (int x = 0; x < 2 * m - 1; ++x, System.out.println()) {
 			int k = x;
 			if (k >= m)
 				k -= (m - 1);
 			else
 				k = m - k - 1;
 			while (k-- > 0)
 				System.out.print("" "");
 
 			for (int y = 0; y < getLen(m, x); ++y) {
 				if (td[x][getLeft(m, x) + y] == -1)
 					System.out.print("" ?"");
 				else
 					System.out.print("" "" + td[x][getLeft(m, x) + y]);
 			}
 		}
 	}
 
 	static boolean check(int n, int[][] d, int m) {
 		int[][] td = new int[2 * m - 1][];
 		for (int i = 0; i < 2 * m - 1; ++i)
 			td[i] = new int[getRight(m, i) + 1];
 		for (int i = 0; i < 2 * m - 1; ++i) {
 			int l = getLen(m, i);
 			for (int j = 0; j < l; ++j) {
 				for (int x = 0; x < 2 * m - 1; ++x)
 					Arrays.fill(td[x], -1);
 				boolean canPut = true;
 				for (int x = 0; x < 2 * n - 1 && canPut; ++x)
 					for (int y = 0; y < getLen(n, x) && canPut; ++y) {
 						int tx = i + x;
 						int ty = j + getLeft(n, x) + y;
 						if (tx >= 2 * m - 1 || ty < getLeft(m, i + x) || ty > getRight(m, i + x))
 							canPut = false;
 						else 
 							td[tx][ty] = d[x][getLeft(n, x) + y];
 					}
 				if (!canPut) continue;
 				
 				boolean canSym = true;
 				for (int x = 0; x < 2 * m - 1 && canSym; ++x) {
 					int l1 = getLen(m, x);
 					for (int y = 0; y < l1 && canSym; ++y)
 						if (td[x][getLeft(m, x) + y] != -1) {
 							int tx, ty, tt = td[x][getLeft(m, x) + y];
 							tx = 2 * m - 2 - x;
 							ty = getLeft(m, tx) + y;
 							if (td[tx][ty] != -1) {
 								if (td[tx][ty] != tt) 
 									canSym = false;
 							} else
 								td[tx][ty] = tt;
 
 							tx = 2 * m - 2 - x;
 							ty = getLeft(m, tx) + l1 - 1 - y;
 							if (td[tx][ty] != -1) {
 								if (td[tx][ty] != tt)
 									canSym = false;
 							} else
 								td[tx][ty] = tt;
 
 							tx = x;
 							ty = getLeft(m, tx) + l1 - 1 - y;
 							if (td[tx][ty] != -1) {
 								if (td[tx][ty] != tt)
 									canSym = false;
 							} else
 								td[tx][ty] = tt;
 						}
 				}
 				if (canSym) 
 					return true;
 			}
 		}
 		return false;
 	}
 
 	static int solve(int n, int[][] d) {
 		for (int i = n;; ++i) {
 			if (check(n, d, i))
 				return i * i - n * n;
 		}
 	}
 
 	public static void main(String[] args) throws Exception {
 		Scanner in = new Scanner(new File(""A-small-attempt2.in""));
 		int c = in.nextInt();
 		for (int i = 0; i < c; ++i) {
 			int n = in.nextInt();
 			int[][] d = new int[2 * n - 1][];
 			for (int k = 0; k < 2 * n - 1; ++k) {
 				d[k] = new int[getRight(n, k) + 1];
 				int left = getLeft(n, k);
 				for (int l = 0; l < getLen(n, k); ++l)
 					d[k][left + l] = in.nextInt();
 			}
 
 			System.out.println(""Case #"" + (i + 1) + "": "" + solve(n, d));
 		}
 	}
 }
",1
494,11243,"import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
 import java.util.Scanner;
 
 public class Q1 {
 
 	static char isWin(String str) {
 		if (str.equals(""XXXX"") || str.equals(""TXXX"") || str.equals(""XTXX"")
 				|| str.equals(""XXTX"") || str.equals(""XXXT"")) {
 			return 'X';
 		} else if (str.equals(""OOOO"") || str.equals(""TOOO"")
 				|| str.equals(""OTOO"") || str.equals(""OOTO"")
 				|| str.equals(""OOOT"")) {
 			return 'O';
 		} else {
 			return 0;
 		}
 	}
 
 	public static void main(String[] args) throws FileNotFoundException {
 		Scanner sc = new Scanner(new File(""A-large.in""));
 		PrintWriter out = new PrintWriter(new File(""ansQ1.txt""));
 		int T = sc.nextInt();
 		for (int i = 0; i < T; i++) {
 			char[][] board = new char[4][4];
 			char isWin = 0;
 			boolean gameFin = true;
 			for (int j = 0; j < 4; j++) {
 				String str = sc.next();
 				System.arraycopy(str.toCharArray(), 0, board[j], 0, 4);
 				if (isWin == 0)
 					isWin = isWin(str);
 				if (str.indexOf(""."") != -1) {
 					gameFin = false;
 				}
 			}
 			if (isWin == 0) {
 				char[] strArray = new char[4];
 				for (int j = 0; j < 4; j++) {
 					for (int k = 0; k < 4; k++) {
 						strArray[k] = board[k][j];
 					}
 					if (isWin == 0)
 						isWin = isWin(String.copyValueOf(strArray));
 				}
 				if (isWin == 0) {
 					for (int j = 0; j < 4; j++) {
 						strArray[j] = board[j][j];
 					}
 					isWin = isWin(String.copyValueOf(strArray));
 					if (isWin == 0) {
 						for (int j = 0; j < 4; j++) {
 							strArray[j] = board[j][3 - j];
 						}
 						isWin = isWin(String.copyValueOf(strArray));
 					}
 				}
 			}
 			if (isWin != 0) {
 				out.printf(""Case #%d: %c won\n"", i + 1, isWin);
 			} else if (gameFin == false) {
 				out.printf(""Case #%d: Game has not completed\n"", i + 1);
 			} else {
 				out.printf(""Case #%d: Draw\n"", i + 1);
 			}
 			sc.nextLine();
 		}
 		sc.close();
 		out.close();
 	}
 }
","package in.co.google.jam;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 
 public class MineSweeper {
 	public MineSweeper(String fileName) {
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(fileName));
 			BufferedWriter bw = new BufferedWriter(new FileWriter(
 					""C:/eclipse/jam.out""));
 			int numTests = Integer.parseInt(br.readLine());
 			for (int i = 1; i <= numTests; i++) {
 				String config = br.readLine();
 				String[] parts = config.split("" "");
 				int rows = Integer.parseInt(parts[0]);
 				int cols = Integer.parseInt(parts[1]);
 				int numMines = Integer.parseInt(parts[2]);
 				int minNumberOfEdges = 1;
 				if (cols > 1) {
 					minNumberOfEdges = 3;
 				}
 				if ((rows * cols) - numMines < (minNumberOfEdges + 1)) {
 					bw.write(""Case #"" + i + "":"");
 					bw.newLine();
 					bw.write(""Impossible"");
 					bw.newLine();
 				} else {
 					// find min number of edges/corners shared
 					// determine if rows*cols - numMines > min number - if yes -
 					// done else impossible
 					bw.write(""Case #"" + i + "":"");
 					bw.newLine();
 					int minesSet = 0;
 					for (int k = 0; k < rows; k++) {
 						StringBuilder b = new StringBuilder();
 						for (int j = 0; j < cols; j++) {
 							if (minesSet < numMines) {
 								b.append(""*"");
 								minesSet++;
 							} else {
 								b.append(""."");
 							}
 						}
 						if (k == (rows - 1)) {
 							b.setCharAt(cols - 1, 'c');
 						}
 						bw.write(b.toString());
 						bw.newLine();
 					}
 				}
 			}
 			bw.close();
 			br.close();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}
 
 	public static void main(String[] args) {
 		new MineSweeper(args[0]);
 	}
 
 }
",0
495,823,"package round1C;
 
 import java.io.*;
 import java.util.*;
 
 public class TaskA {
 	static class InputReader {
 		BufferedReader bin;
 		StringTokenizer tokenizer;
 		
 		public InputReader(InputStream in) {
 			bin = new BufferedReader(new InputStreamReader(in));
 			tokenizer = null;
 		}
 		
 		public InputReader(String fname) {
 			try {
 				bin = new BufferedReader(new FileReader(fname));
 				tokenizer = null;
 			} catch (Exception e) {
 				throw new RuntimeException(e);
 			}
 		}
 		
 		public String next() {
 			
 			while( tokenizer == null || !tokenizer.hasMoreTokens())  {
 				try {
 					tokenizer = new StringTokenizer(bin.readLine());
 				} catch(IOException e) {
 					throw new RuntimeException(e);
 				}
 			}
 			return tokenizer.nextToken();
 		}
 		
 		public String readLine() {
 			try {
 				return bin.readLine();
 			} catch (IOException e) {
 				throw new RuntimeException(e);
 			}
 		}
 		
 		public int nextInt() {
 			return Integer.parseInt(next());
 		}
 		
 		public long nextLong() {
 			return Long.parseLong(next());
 		}
 		
 		public double nextDouble() {
 			return Double.parseDouble(next());
 		}
 		
 		public float nextFloat() {
 			return Float.parseFloat(next());
 		}
 		
 		public void close() {
 			try {
 				bin.close();
 				tokenizer = null;
 			} catch ( IOException e) {
 				throw new RuntimeException(e);
 			}
 		}
 	}
 	
 	public static void main ( String[] args ) throws IOException {
 		//InputReader in = new InputReader(System.in);
 		InputReader in = new InputReader(""A-small-attempt0.in"");
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""A-small-attempt0.out"")));
 		//PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 		int numTc, n, soln;
 		String name;
 		
 		numTc = in.nextInt();
 		
 		for (int i = 0; i < numTc; i++) {
 			name = in.next();
 			n = in.nextInt();
 			soln = solve(name, n);
 			out.println(""Case #"" + (i+1) + "": "" + soln);
 		}
 		
 		in.close();
 		out.close();
 	}
 	
 	public static int solve(String name, int n) {
 		int len = name.length(), ans = 0;
 		
 		for (int i = 0; i < len; i++) {
 			for (int j = i + 1; j <= len; j++) {
 				if(check(name.substring(i, j), n)) {
 					ans++;
 				}
 			}
 		}
 		return ans;
 	}
 	
 	public static boolean check(String name, int n) {
 		int cnt = 0, len = name.length();
 		for (int i = 0; i < len; i++) {
 			if (isvowel(name.charAt(i))) {
 				cnt = 0;
 			}
 			else
 				cnt++;
 			if (cnt == n) {
 				return true;
 			}
 		}
 		return false;
 	}
 	
 	public static boolean isvowel(char ch) {
 		return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'u' || ch == 'o';
 	}
 }
 
 
","
 import java.io.*;
 import java.util.*;
 
 public class Googlerase {
 	
 	static class InputReader {
 		BufferedReader bin;
 		StringTokenizer tokenizer;
 		
 		public InputReader(InputStream in) {
 			bin = new BufferedReader(new InputStreamReader(in));
 			tokenizer = null;
 		}
 		
 		public InputReader(String fname) {
 			try {
 				bin = new BufferedReader(new FileReader(fname));
 				tokenizer = null;
 			} catch (Exception e) {
 				throw new RuntimeException(e);
 			}
 		}
 		
 		public String next() {
 			
 			while( tokenizer == null || !tokenizer.hasMoreTokens())  {
 				try {
 					tokenizer = new StringTokenizer(bin.readLine());
 				} catch(IOException e) {
 					throw new RuntimeException(e);
 				}
 			}
 			return tokenizer.nextToken();
 		}
 		
 		public String readLine() {
 			try {
 				return bin.readLine();
 			} catch (IOException e) {
 				throw new RuntimeException(e);
 			}
 		}
 		
 		public int nextInt() {
 			return Integer.parseInt(next());
 		}
 		
 		public long nextLong() {
 			return Long.parseLong(next());
 		}
 		
 		public double nextDouble() {
 			return Double.parseDouble(next());
 		}
 		
 		public float nextFloat() {
 			return Float.parseFloat(next());
 		}
 		
 		public void close() {
 			try {
 				bin.close();
 				tokenizer = null;
 			} catch ( IOException e) {
 				throw new RuntimeException(e);
 			}
 		}
 	}
 	static char[] mapping = {'y','h','e','s','o','c','v','x','d','u','i','g','l','b','k','r','z','t','n','w','j','p','f','m','a','q'};
 	public static void main(String[] args) throws IOException {
 		//InputReader in = new InputReader(System.in);
 		InputReader in = new InputReader(""A-small-attempt0.in"");
 		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""A-small.out"")));
 		//PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 		int numTc = in.nextInt(),len;
 		String input;
 		StringBuilder soln;
 		
 		for ( int i = 0; i < numTc; i++ ) {
 			input = in.readLine();
 			len = input.length();
 			soln = new StringBuilder();
 			for ( int k = 0; k < len; k++ ) 
 				if(!Character.isWhitespace(input.charAt(k)))
 					soln.append(mapping[input.charAt(k)-'a']);
 				else
 					soln.append("" "");
 			out.println(""Case #""+(i+1)+"": ""+soln.toString());
 		}
 		
 		out.close();
 		in.close();
 	}
 }
 
",1
496,251,"import java.io.File;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class C {
 
     final static String PREFIX = "".\\src\\C"";
 //    final static String FILE_NAME = PREFIX + ""-test"";
         final static String FILE_NAME = PREFIX + ""-small-attempt2"";
     //    final static String FILE_NAME = PREFIX + ""-large"";
 
     private Scanner in;
     private PrintWriter out;
 
     public static void main(String[] args) throws Exception {
         Locale.setDefault(Locale.US);
         new C().solveAll();
     }
 
     private void solveAll() throws Exception {
         in = new Scanner(new File(FILE_NAME + "".in""));
         out = new PrintWriter(new File(FILE_NAME + "".out""));
         int tcn = in.nextInt();
         for (int tc = 1; tc <= tcn; tc++) {
             solve(tc);
         }
         out.close();
     }
 
 	interface BinaryFunction {
 		boolean f(long x);
 	}
 	
     private void solve(int tc) {
         int N = in.nextInt();
         long L = in.nextLong();
         long H = in.nextLong();
         
         final long[] freq = new long[N];
         for(int i = 0; i<N; i++) {
         	freq[i] = in.nextLong();
         }
 		BinaryFunction f = new BinaryFunction() {
 			@Override
 			public boolean f(long x) {
 		        for(long fr : freq) {
 		        	if(fr%x != 0 && x%fr != 0) return false;
 		        }
 		        return true;
 			}
 		};
 		long res = -1;
 		for(long i = L; i <= H; i++) {
 			if(f.f(i) == true) {
 				res = i;
 				break;
 			}
 		}
 		String text = """";
 		if(res < 0) {
 			text = String.format(""Case #%d: NO\n"", tc);
 		} else {
 			text = String.format(""Case #%d: %d\n"", tc, res);
 		}
         out.print(text);
         System.out.print(text);
     }
 
 }
","import java.io.File;
 import java.io.PrintWriter;
 import java.util.Locale;
 import java.util.Scanner;
 
 public class A {
 
     final static String PREFIX = "".\\src\\A"";
 //    final static String FILE_NAME = PREFIX + ""-test"";
         final static String FILE_NAME = PREFIX + ""-small-attempt0"";
     //    final static String FILE_NAME = PREFIX + ""-large"";
 
     private Scanner in;
     private PrintWriter out;
 
     public static void main(String[] args) throws Exception {
         Locale.setDefault(Locale.US);
         new A().solveAll();
     }
 
     private void solveAll() throws Exception {
         in = new Scanner(new File(FILE_NAME + "".in""));
         out = new PrintWriter(new File(FILE_NAME + "".out""));
         int tcn = in.nextInt();
         for (int tc = 1; tc <= tcn; tc++) {
             solve(tc);
         }
         out.close();
     }
 
     private void solve(int tc) {
         int R = in.nextInt();
         int C = in.nextInt();
         char t[][] = new char[R][C];
         for(int i = 0; i < R; i++) {
         	String s = in.next();
         	for(int j = 0; j<C; j++) {
         		t[i][j] = s.charAt(j);
         	}
         }
         for(int i = 0; i < R-1; i++) {
         	for(int j = 0; j < C-1; j++) {
         		if(t[i][j] == '#' && t[i+1][j] == '#' && t[i][j+1] == '#' && t[i+1][j+1] == '#') {
         			t[i][j] = '/';
         			t[i][j+1] = '\\';
         			t[i+1][j] = '\\';
         			t[i+1][j+1] = '/';
         		}
         		if(t[i][j] == '#') {
         	        String text = String.format(""Case #%d:\n%s\n"", tc, ""Impossible"");
 //        	        String text = String.format(""Case #%d: %.7f\n"", tc , res);
         	        
         	        out.print(text);
         	        System.out.print(text);
         	        return;
         		}
         	}
         }
         for(int i = 0; i<R; i++) {
     		if(t[i][C-1] == '#') {
     	        String text = String.format(""Case #%d:\n%s\n"", tc, ""Impossible"");
 //    	        String text = String.format(""Case #%d: %.7f\n"", tc , res);
     	        
     	        out.print(text);
     	        System.out.print(text);
     	        return;
     		}
         }
         for(int i = 0; i<C; i++) {
     		if(t[R-1][i] == '#') {
     	        String text = String.format(""Case #%d:\n%s\n"", tc, ""Impossible"");
 //    	        String text = String.format(""Case #%d: %.7f\n"", tc , res);
     	        
     	        out.print(text);
     	        System.out.print(text);
     	        return;
     		}
         }
 
 
 //      String res = """";
 //		double res = 0;
         int res = 0;
         String text = String.format(""Case #%d:\n"", tc);
         out.print(text);
         System.out.print(text);
         for(int i = 0; i < R; i++) {
         	for(int j = 0; j < C; j++) {
         		char o = t[i][j];
                 out.print(o);
                 System.out.print(o);
         	}
     		char o = '\n';
             out.print(o);
             System.out.print(o);
         }
 //        String text = String.format(""Case #%d: %.7f\n"", tc , res);
         
     }
 
 }
",1
497,2739,"import java.util.*;
 
 class C{
 	public static void main(String[] args){
 		try{
 			Scanner sc = new Scanner(System.in);
 			int kase = sc.nextInt();
 			for(int k = 1; k<=kase; k++){
 				int R = sc.nextInt();
 				int C = sc.nextInt();
 				int M = sc.nextInt();
 				StringBuffer ans;
 				int space = R*C-M;
 				if(R>1 && C>1 && space<4 && space > 1) ans = new StringBuffer(""Impossible"");
 				else if(R==1){
 					ans = new StringBuffer(""c"");
 					for(int i = 1; i<space; i++)
 						ans.append(""."");
 					for(int i = 0; i<M; i++)
 						ans.append(""*"");
 				}
 				else if(C==1){
 					ans = new StringBuffer(""c"");
 					for(int i = 1; i<space; i++)
 						ans.append(""\n."");
 					for(int i = 0; i<M; i++)
 						ans.append(""\n*"");
 				}
 				else if (space==1){
 					ans = new StringBuffer(""c"");
 					int c = 1; int r = 0;
 					while(r<R){
 						while(c<C){
 							ans.append(""*"");
 							c++;
 						}
 						c = 0;
 						r++;
 						if(r<R) ans.append(""\n"");
 					}
 				}
 				else if (space>=4 && space >= 2*C){
 					ans = new StringBuffer(""c"");
 					space--;
 					int c = 1; int r = 0;
 					while(space > 0){
 						while(c<C && space >0){
 							ans.append(""."");
 							space--;
 							c++;
 						}
 						while(c<C){
 							ans.append(""*"");
 							c++;
 						}
 						c = 0;
 						r++;
 						if(r<R) ans.append(""\n"");
 					}
 					while(r<R){		
 						while(c<C){
 							ans.append(""*"");
 							c++;
 						}
 						c = 0;
 						r++;
 						if(r<R) ans.append(""\n"");
 					}
 				}
 				else{
 					int div = 2;
 					while(space % div !=0)div++;
 					if(div == space) ans = new StringBuffer(""Impossible"");
 					else if(div>R) ans = new StringBuffer(""Impossible"");
 					else{
 						div = space/div;
 						ans = new StringBuffer(""c"");
 						space--;
 						int c = 1; int r = 0;
 						while(space > 0){
 							while(c<div){
 								ans.append(""."");
 								space--;
 								c++;
 							}
 							while(c<C){
 								ans.append(""*"");
 								c++;
 							}
 							c = 0;
 							r++;
 							if(r<R) ans.append(""\n"");
 						}
 						while(r<R){		
 							while(c<C){
 								ans.append(""*"");
 								c++;
 							}
 							c = 0;
 							r++;
 							if(r<R) ans.append(""\n"");
 						}
 					}
 				}	
 				System.out.println(""Case #""+k+"":\n""+ans);
 			}
 		}
 		catch(Exception e){e.printStackTrace();}
 	}
 }
","package qual;
 
 
 import java.io.*;
 import java.util.*;
 
 // n < (FX - 2C)/FC
 
 public class CookieClicker {
     public static final PrintStream out = System.out;
     public static final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
     public int numCases;
     
     public void doCase(int caseNumber) throws Exception {
         String line = in.readLine();
         Scanner scan = new Scanner(line);
         double C = scan.nextDouble();
         double F = scan.nextDouble();
         double X = scan.nextDouble();
         int n = (int)((F*X - 2*C)/(F*C));
         if (n < 0) n = 0;
         double s = 0;
         for (int i = 0; i < n; i++) {
             s += C / (2.0 + i * F);
         }
         s += X / (2.0 + n * F);
         System.out.println(s);
     }
     
     public void run() throws Exception {
         numCases = Integer.parseInt(in.readLine().trim());
         for (int i = 1; i <= numCases; i++) {
             out.print(""Case #"" + i + "": "");
             doCase(i);
         }
     }
     
     public static void main(String[] args) throws Exception {
         new CookieClicker().run();
     }
 
 }
",0
498,13949,"import java.io.*;
 import java.math.*;
 
 
 public class inputFormat {
 	public static void main(String[] args) {
 		BufferedReader reader = null;
 		FileWriter fileWriter = null;
 		try {
 		 File file = new File(""H:\\C-small-attempt2.in"");
 		 fileWriter = new FileWriter(""H:\\Result"");
 	            reader = new BufferedReader(new FileReader(file));
 	            int intCasesNumber = Integer.parseInt(reader.readLine());
 	            intCases[] cs = new intCases[intCasesNumber];
 	            for(int j = 0; j < cs.length; j++){
 	            	String[] temp = reader.readLine().split("" "");
 		            cs[j] = new intCases(Integer.parseInt(temp[0]),Integer.parseInt(temp[1]));
 		            
 		            fileWriter.write(""Case #"" + (j+1) + "": "" + cs[j].calculateFairAndSquareNumber() + ""\r\n"");
 	            }
 	            fileWriter.flush();
 				fileWriter.close();
 	            reader.close();
 	        } catch (IOException e) {
 	            e.printStackTrace();
 	        } finally {
 	            if (reader != null) {
 	                try {
 	                    reader.close();
 	                } catch (IOException e1) {
 	                }
 	            }
 	            if (fileWriter != null) {
 	                try {
 	                	fileWriter.flush();
 	     				fileWriter.close();
 	                } catch (IOException e1) {
 	                }
 	            }
 	        }
 	}
 }
","import java.io.*;
 
 
 public class inputFormat {
 	public static void main(String[] args) {
 		BufferedReader reader = null;
 		FileWriter fileWriter = null;
 		try {
 		 File file = new File(""H:\\B-large.in"");
 		 fileWriter = new FileWriter(""H:\\Result"");
 	            reader = new BufferedReader(new FileReader(file));
 	            int casesNumber = Integer.parseInt(reader.readLine());
 	            cases[] cs = new cases[casesNumber];
 	            for(int j = 0; j < cs.length; j++){
 	            	String[] temp = reader.readLine().split("" "");
 		            cs[j] = new cases(Integer.parseInt(temp[0]),Integer.parseInt(temp[1]));
 		            for(int i = 0; i < cs[j].getLength(); i++){
 		            	 cs[j].setLawnHeight(reader.readLine(), i);
 		            }
 		            fileWriter.write(""Case #"" + (j+1) + "": "" + judge.judgeFeasibility(cs[j]) + ""\r\n"");
 	            }
 	            fileWriter.flush();
 				fileWriter.close();
 	            reader.close();
 	        } catch (IOException e) {
 	            e.printStackTrace();
 	        } finally {
 	            if (reader != null) {
 	                try {
 	                    reader.close();
 	                } catch (IOException e1) {
 	                }
 	            }
 	            if (fileWriter != null) {
 	                try {
 	                	fileWriter.flush();
 	     				fileWriter.close();
 	                } catch (IOException e1) {
 	                }
 	            }
 	        }
 	}
 }
",1
499,17377,"
 
 import java.util.ArrayList;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 public class TicTacToeTomek {
 	ArrayList<String> rows; 
 	ArrayList<String> columns;
 	ArrayList<String> diagonals;
 	private int rowNum;
 	private int colNum;
 
 	public TicTacToeTomek(int rows, int cols) {
 		this.rowNum = rows;
 		this.colNum = cols;
 		initialize();
 	}
 	
 	private void initialize() {
 		rows = new ArrayList<String>();
 		columns = new ArrayList<String>();
 		for(int i=0;i<colNum;i++){
 			columns.add("""");
 		}
 		diagonals= new ArrayList<String>();
 		for(int i=0;i<2;i++){
 			diagonals.add("""");
 		}
 	}
 
 	private String winner;
 	private boolean hasEmptySquares;
 
 	public void addLine(String line) {
 		checkWinner(line);
 		rows.add(line);
 		addColumn(line);
 		addDiagonal(line);
 		checkWinnerColumn();
 		checkWinnerDiagonal();
 	}
 
 	private void addDiagonal(String line) {
 		char[] charArray = line.toCharArray();
 		diagonals.set(0, diagonals.get(0)+charArray[rows.size()-1]);
 		diagonals.set(1, diagonals.get(1)+charArray[colNum - rows.size()]);
 		
 	}
 
 	private void checkWinnerDiagonal() {
 		if(hasWinner()){return;}
 		if(rows.size()==rowNum){
 			for(String diagonal : diagonals){
 				checkWinner(diagonal);
 				if(hasWinner()){
 					return;
 				}
 			}
 		}
 	}
 
 	private void checkWinnerColumn() {
 		if(hasWinner()){return;}
 		if(rows.size()==rowNum){
 			for(String column : columns){
 				checkWinner(column);
 				if(hasWinner()){
 					return;
 				}
 			}
 		}
 	}
 	
 	private void addColumn(String line) {
 		char[] charArray = line.toCharArray();
 		for(int i=0; i < colNum;i++){
 			String column = columns.get(i)+""""+charArray[i];
 			columns.set(i, column);
 		}
 		
 	}
 
 	private void checkWinner(String line){
 		isPlayerWinner(""X"", line);
 		isPlayerWinner(""O"", line);
 		if(!hasWinner()){
 			checkFull(line);
 		}
 	}
 	
 	public boolean isCompleted(){
 		return !hasEmptySquares;
 	}
 	private void checkFull(String line) {
 		hasEmptySquares |= line.contains(""."");
 	}
 
 	private void isPlayerWinner(String player, String line) {
 		if(hasWinner()){
 			return;
 		}
 		Pattern patternWin = Pattern.compile(""^[""+player+""*T?""+player+""*]{4}$"");
 		Matcher matcher = patternWin.matcher(line);
 		if(matcher.find()){
 			winner = player;
 		}
 	}
 
 	public boolean hasWinner() {
 		return winner != null;
 	}
 	
 	public String getWinner(){
 		return winner;
 	}
 
 }
","
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 
 public class TicTacToeTomekProcessor {
 	private int ROWS=4;
 	private int COLS=4;
 	private FileReader reader;
 	private FileWriter writer;
 	private int cases;
 
 	public TicTacToeTomekProcessor(String filename) {
 		reader = new FileReader(""resources/tictactoetomek/""+filename+"".in"");
 		writer = new FileWriter(""resources/tictactoetomek/""+filename+"".out"");
 		initialize();
 	}
 	
 	private void initialize() {
 		cases = Integer.parseInt(consumeNext());
 		
 	}
 
 	public void processAll(){
 		int currentCase=1;
 		while(currentCase<=cases){
 			writer.writeLine(String.format(""Case #%s: %s"", currentCase, processNext()));
 			currentCase++;
 		}
 		writer.close();
 		reader.close();
 	}
 
 	private String processNext() {
 		TicTacToeTomek match = new TicTacToeTomek(ROWS, COLS);
 		for(int r=0; r<ROWS;r++){
 			String readLine = consumeNext();
 			if(!match.hasWinner()){
 				match.addLine(readLine);
 			}
 		}
 		consumeNext();
 		if(match.hasWinner()){
 			return match.getWinner()+ "" won"";
 		}
 		return match.isCompleted() ? ""Draw"" : ""Game has not completed"";
 	}
 
 	private String consumeNext() {
 		String readLine = reader.readLine();
 		return readLine;
 	}
 
 	public static void main(String[] args){
 		TicTacToeTomekProcessor processor = new TicTacToeTomekProcessor(""A-large"");
 		processor.processAll();
 	}
 	
 }
",1
